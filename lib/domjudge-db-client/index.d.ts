
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model auditlog
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type auditlog = $Result.DefaultSelection<Prisma.$auditlogPayload>
/**
 * Model balloon
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type balloon = $Result.DefaultSelection<Prisma.$balloonPayload>
/**
 * Model clarification
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type clarification = $Result.DefaultSelection<Prisma.$clarificationPayload>
/**
 * Model configuration
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type configuration = $Result.DefaultSelection<Prisma.$configurationPayload>
/**
 * Model contest
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type contest = $Result.DefaultSelection<Prisma.$contestPayload>
/**
 * Model contestproblem
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type contestproblem = $Result.DefaultSelection<Prisma.$contestproblemPayload>
/**
 * Model contestteam
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type contestteam = $Result.DefaultSelection<Prisma.$contestteamPayload>
/**
 * Model contestteamcategory
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type contestteamcategory = $Result.DefaultSelection<Prisma.$contestteamcategoryPayload>
/**
 * Model contestteamcategoryformedals
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type contestteamcategoryformedals = $Result.DefaultSelection<Prisma.$contestteamcategoryformedalsPayload>
/**
 * Model debug_package
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type debug_package = $Result.DefaultSelection<Prisma.$debug_packagePayload>
/**
 * Model doctrine_migration_versions
 * 
 */
export type doctrine_migration_versions = $Result.DefaultSelection<Prisma.$doctrine_migration_versionsPayload>
/**
 * Model event
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type event = $Result.DefaultSelection<Prisma.$eventPayload>
/**
 * Model executable
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type executable = $Result.DefaultSelection<Prisma.$executablePayload>
/**
 * Model executable_file
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type executable_file = $Result.DefaultSelection<Prisma.$executable_filePayload>
/**
 * Model external_contest_source
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type external_contest_source = $Result.DefaultSelection<Prisma.$external_contest_sourcePayload>
/**
 * Model external_judgement
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type external_judgement = $Result.DefaultSelection<Prisma.$external_judgementPayload>
/**
 * Model external_run
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type external_run = $Result.DefaultSelection<Prisma.$external_runPayload>
/**
 * Model external_source_warning
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type external_source_warning = $Result.DefaultSelection<Prisma.$external_source_warningPayload>
/**
 * Model immutable_executable
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type immutable_executable = $Result.DefaultSelection<Prisma.$immutable_executablePayload>
/**
 * Model internal_error
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type internal_error = $Result.DefaultSelection<Prisma.$internal_errorPayload>
/**
 * Model judgehost
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type judgehost = $Result.DefaultSelection<Prisma.$judgehostPayload>
/**
 * Model judgetask
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type judgetask = $Result.DefaultSelection<Prisma.$judgetaskPayload>
/**
 * Model judging
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type judging = $Result.DefaultSelection<Prisma.$judgingPayload>
/**
 * Model judging_run
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type judging_run = $Result.DefaultSelection<Prisma.$judging_runPayload>
/**
 * Model judging_run_output
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type judging_run_output = $Result.DefaultSelection<Prisma.$judging_run_outputPayload>
/**
 * Model language
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type language = $Result.DefaultSelection<Prisma.$languagePayload>
/**
 * Model problem
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type problem = $Result.DefaultSelection<Prisma.$problemPayload>
/**
 * Model problem_attachment
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type problem_attachment = $Result.DefaultSelection<Prisma.$problem_attachmentPayload>
/**
 * Model problem_attachment_content
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type problem_attachment_content = $Result.DefaultSelection<Prisma.$problem_attachment_contentPayload>
/**
 * Model queuetask
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type queuetask = $Result.DefaultSelection<Prisma.$queuetaskPayload>
/**
 * Model rankcache
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type rankcache = $Result.DefaultSelection<Prisma.$rankcachePayload>
/**
 * Model rejudging
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type rejudging = $Result.DefaultSelection<Prisma.$rejudgingPayload>
/**
 * Model removed_interval
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type removed_interval = $Result.DefaultSelection<Prisma.$removed_intervalPayload>
/**
 * Model role
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type role = $Result.DefaultSelection<Prisma.$rolePayload>
/**
 * Model scorecache
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type scorecache = $Result.DefaultSelection<Prisma.$scorecachePayload>
/**
 * Model sessions
 * 
 */
export type sessions = $Result.DefaultSelection<Prisma.$sessionsPayload>
/**
 * Model submission
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type submission = $Result.DefaultSelection<Prisma.$submissionPayload>
/**
 * Model submission_file
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type submission_file = $Result.DefaultSelection<Prisma.$submission_filePayload>
/**
 * Model team
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type team = $Result.DefaultSelection<Prisma.$teamPayload>
/**
 * Model team_affiliation
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type team_affiliation = $Result.DefaultSelection<Prisma.$team_affiliationPayload>
/**
 * Model team_category
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type team_category = $Result.DefaultSelection<Prisma.$team_categoryPayload>
/**
 * Model team_unread
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type team_unread = $Result.DefaultSelection<Prisma.$team_unreadPayload>
/**
 * Model testcase
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type testcase = $Result.DefaultSelection<Prisma.$testcasePayload>
/**
 * Model testcase_content
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type testcase_content = $Result.DefaultSelection<Prisma.$testcase_contentPayload>
/**
 * Model user
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model userrole
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type userrole = $Result.DefaultSelection<Prisma.$userrolePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const internal_error_status: {
  open: 'open',
  resolved: 'resolved',
  ignored: 'ignored'
};

export type internal_error_status = (typeof internal_error_status)[keyof typeof internal_error_status]


export const judgetask_type: {
  judging_run: 'judging_run',
  generic_task: 'generic_task',
  config_check: 'config_check',
  debug_info: 'debug_info',
  prefetch: 'prefetch'
};

export type judgetask_type = (typeof judgetask_type)[keyof typeof judgetask_type]

}

export type internal_error_status = $Enums.internal_error_status

export const internal_error_status: typeof $Enums.internal_error_status

export type judgetask_type = $Enums.judgetask_type

export const judgetask_type: typeof $Enums.judgetask_type

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Auditlogs
 * const auditlogs = await prisma.auditlog.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Auditlogs
   * const auditlogs = await prisma.auditlog.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.auditlog`: Exposes CRUD operations for the **auditlog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auditlogs
    * const auditlogs = await prisma.auditlog.findMany()
    * ```
    */
  get auditlog(): Prisma.auditlogDelegate<ExtArgs>;

  /**
   * `prisma.balloon`: Exposes CRUD operations for the **balloon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Balloons
    * const balloons = await prisma.balloon.findMany()
    * ```
    */
  get balloon(): Prisma.balloonDelegate<ExtArgs>;

  /**
   * `prisma.clarification`: Exposes CRUD operations for the **clarification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clarifications
    * const clarifications = await prisma.clarification.findMany()
    * ```
    */
  get clarification(): Prisma.clarificationDelegate<ExtArgs>;

  /**
   * `prisma.configuration`: Exposes CRUD operations for the **configuration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configurations
    * const configurations = await prisma.configuration.findMany()
    * ```
    */
  get configuration(): Prisma.configurationDelegate<ExtArgs>;

  /**
   * `prisma.contest`: Exposes CRUD operations for the **contest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contests
    * const contests = await prisma.contest.findMany()
    * ```
    */
  get contest(): Prisma.contestDelegate<ExtArgs>;

  /**
   * `prisma.contestproblem`: Exposes CRUD operations for the **contestproblem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contestproblems
    * const contestproblems = await prisma.contestproblem.findMany()
    * ```
    */
  get contestproblem(): Prisma.contestproblemDelegate<ExtArgs>;

  /**
   * `prisma.contestteam`: Exposes CRUD operations for the **contestteam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contestteams
    * const contestteams = await prisma.contestteam.findMany()
    * ```
    */
  get contestteam(): Prisma.contestteamDelegate<ExtArgs>;

  /**
   * `prisma.contestteamcategory`: Exposes CRUD operations for the **contestteamcategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contestteamcategories
    * const contestteamcategories = await prisma.contestteamcategory.findMany()
    * ```
    */
  get contestteamcategory(): Prisma.contestteamcategoryDelegate<ExtArgs>;

  /**
   * `prisma.contestteamcategoryformedals`: Exposes CRUD operations for the **contestteamcategoryformedals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contestteamcategoryformedals
    * const contestteamcategoryformedals = await prisma.contestteamcategoryformedals.findMany()
    * ```
    */
  get contestteamcategoryformedals(): Prisma.contestteamcategoryformedalsDelegate<ExtArgs>;

  /**
   * `prisma.debug_package`: Exposes CRUD operations for the **debug_package** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Debug_packages
    * const debug_packages = await prisma.debug_package.findMany()
    * ```
    */
  get debug_package(): Prisma.debug_packageDelegate<ExtArgs>;

  /**
   * `prisma.doctrine_migration_versions`: Exposes CRUD operations for the **doctrine_migration_versions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Doctrine_migration_versions
    * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findMany()
    * ```
    */
  get doctrine_migration_versions(): Prisma.doctrine_migration_versionsDelegate<ExtArgs>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.eventDelegate<ExtArgs>;

  /**
   * `prisma.executable`: Exposes CRUD operations for the **executable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Executables
    * const executables = await prisma.executable.findMany()
    * ```
    */
  get executable(): Prisma.executableDelegate<ExtArgs>;

  /**
   * `prisma.executable_file`: Exposes CRUD operations for the **executable_file** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Executable_files
    * const executable_files = await prisma.executable_file.findMany()
    * ```
    */
  get executable_file(): Prisma.executable_fileDelegate<ExtArgs>;

  /**
   * `prisma.external_contest_source`: Exposes CRUD operations for the **external_contest_source** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more External_contest_sources
    * const external_contest_sources = await prisma.external_contest_source.findMany()
    * ```
    */
  get external_contest_source(): Prisma.external_contest_sourceDelegate<ExtArgs>;

  /**
   * `prisma.external_judgement`: Exposes CRUD operations for the **external_judgement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more External_judgements
    * const external_judgements = await prisma.external_judgement.findMany()
    * ```
    */
  get external_judgement(): Prisma.external_judgementDelegate<ExtArgs>;

  /**
   * `prisma.external_run`: Exposes CRUD operations for the **external_run** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more External_runs
    * const external_runs = await prisma.external_run.findMany()
    * ```
    */
  get external_run(): Prisma.external_runDelegate<ExtArgs>;

  /**
   * `prisma.external_source_warning`: Exposes CRUD operations for the **external_source_warning** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more External_source_warnings
    * const external_source_warnings = await prisma.external_source_warning.findMany()
    * ```
    */
  get external_source_warning(): Prisma.external_source_warningDelegate<ExtArgs>;

  /**
   * `prisma.immutable_executable`: Exposes CRUD operations for the **immutable_executable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Immutable_executables
    * const immutable_executables = await prisma.immutable_executable.findMany()
    * ```
    */
  get immutable_executable(): Prisma.immutable_executableDelegate<ExtArgs>;

  /**
   * `prisma.internal_error`: Exposes CRUD operations for the **internal_error** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Internal_errors
    * const internal_errors = await prisma.internal_error.findMany()
    * ```
    */
  get internal_error(): Prisma.internal_errorDelegate<ExtArgs>;

  /**
   * `prisma.judgehost`: Exposes CRUD operations for the **judgehost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Judgehosts
    * const judgehosts = await prisma.judgehost.findMany()
    * ```
    */
  get judgehost(): Prisma.judgehostDelegate<ExtArgs>;

  /**
   * `prisma.judgetask`: Exposes CRUD operations for the **judgetask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Judgetasks
    * const judgetasks = await prisma.judgetask.findMany()
    * ```
    */
  get judgetask(): Prisma.judgetaskDelegate<ExtArgs>;

  /**
   * `prisma.judging`: Exposes CRUD operations for the **judging** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Judgings
    * const judgings = await prisma.judging.findMany()
    * ```
    */
  get judging(): Prisma.judgingDelegate<ExtArgs>;

  /**
   * `prisma.judging_run`: Exposes CRUD operations for the **judging_run** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Judging_runs
    * const judging_runs = await prisma.judging_run.findMany()
    * ```
    */
  get judging_run(): Prisma.judging_runDelegate<ExtArgs>;

  /**
   * `prisma.judging_run_output`: Exposes CRUD operations for the **judging_run_output** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Judging_run_outputs
    * const judging_run_outputs = await prisma.judging_run_output.findMany()
    * ```
    */
  get judging_run_output(): Prisma.judging_run_outputDelegate<ExtArgs>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.languageDelegate<ExtArgs>;

  /**
   * `prisma.problem`: Exposes CRUD operations for the **problem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Problems
    * const problems = await prisma.problem.findMany()
    * ```
    */
  get problem(): Prisma.problemDelegate<ExtArgs>;

  /**
   * `prisma.problem_attachment`: Exposes CRUD operations for the **problem_attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Problem_attachments
    * const problem_attachments = await prisma.problem_attachment.findMany()
    * ```
    */
  get problem_attachment(): Prisma.problem_attachmentDelegate<ExtArgs>;

  /**
   * `prisma.problem_attachment_content`: Exposes CRUD operations for the **problem_attachment_content** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Problem_attachment_contents
    * const problem_attachment_contents = await prisma.problem_attachment_content.findMany()
    * ```
    */
  get problem_attachment_content(): Prisma.problem_attachment_contentDelegate<ExtArgs>;

  /**
   * `prisma.queuetask`: Exposes CRUD operations for the **queuetask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Queuetasks
    * const queuetasks = await prisma.queuetask.findMany()
    * ```
    */
  get queuetask(): Prisma.queuetaskDelegate<ExtArgs>;

  /**
   * `prisma.rankcache`: Exposes CRUD operations for the **rankcache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rankcaches
    * const rankcaches = await prisma.rankcache.findMany()
    * ```
    */
  get rankcache(): Prisma.rankcacheDelegate<ExtArgs>;

  /**
   * `prisma.rejudging`: Exposes CRUD operations for the **rejudging** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rejudgings
    * const rejudgings = await prisma.rejudging.findMany()
    * ```
    */
  get rejudging(): Prisma.rejudgingDelegate<ExtArgs>;

  /**
   * `prisma.removed_interval`: Exposes CRUD operations for the **removed_interval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Removed_intervals
    * const removed_intervals = await prisma.removed_interval.findMany()
    * ```
    */
  get removed_interval(): Prisma.removed_intervalDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.roleDelegate<ExtArgs>;

  /**
   * `prisma.scorecache`: Exposes CRUD operations for the **scorecache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Scorecaches
    * const scorecaches = await prisma.scorecache.findMany()
    * ```
    */
  get scorecache(): Prisma.scorecacheDelegate<ExtArgs>;

  /**
   * `prisma.sessions`: Exposes CRUD operations for the **sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.sessions.findMany()
    * ```
    */
  get sessions(): Prisma.sessionsDelegate<ExtArgs>;

  /**
   * `prisma.submission`: Exposes CRUD operations for the **submission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Submissions
    * const submissions = await prisma.submission.findMany()
    * ```
    */
  get submission(): Prisma.submissionDelegate<ExtArgs>;

  /**
   * `prisma.submission_file`: Exposes CRUD operations for the **submission_file** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Submission_files
    * const submission_files = await prisma.submission_file.findMany()
    * ```
    */
  get submission_file(): Prisma.submission_fileDelegate<ExtArgs>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.teamDelegate<ExtArgs>;

  /**
   * `prisma.team_affiliation`: Exposes CRUD operations for the **team_affiliation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Team_affiliations
    * const team_affiliations = await prisma.team_affiliation.findMany()
    * ```
    */
  get team_affiliation(): Prisma.team_affiliationDelegate<ExtArgs>;

  /**
   * `prisma.team_category`: Exposes CRUD operations for the **team_category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Team_categories
    * const team_categories = await prisma.team_category.findMany()
    * ```
    */
  get team_category(): Prisma.team_categoryDelegate<ExtArgs>;

  /**
   * `prisma.team_unread`: Exposes CRUD operations for the **team_unread** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Team_unreads
    * const team_unreads = await prisma.team_unread.findMany()
    * ```
    */
  get team_unread(): Prisma.team_unreadDelegate<ExtArgs>;

  /**
   * `prisma.testcase`: Exposes CRUD operations for the **testcase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testcases
    * const testcases = await prisma.testcase.findMany()
    * ```
    */
  get testcase(): Prisma.testcaseDelegate<ExtArgs>;

  /**
   * `prisma.testcase_content`: Exposes CRUD operations for the **testcase_content** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testcase_contents
    * const testcase_contents = await prisma.testcase_content.findMany()
    * ```
    */
  get testcase_content(): Prisma.testcase_contentDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs>;

  /**
   * `prisma.userrole`: Exposes CRUD operations for the **userrole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userroles
    * const userroles = await prisma.userrole.findMany()
    * ```
    */
  get userrole(): Prisma.userroleDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.11.0
   * Query Engine version: efd2449663b3d73d637ea1fd226bafbcf45b3102
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    auditlog: 'auditlog',
    balloon: 'balloon',
    clarification: 'clarification',
    configuration: 'configuration',
    contest: 'contest',
    contestproblem: 'contestproblem',
    contestteam: 'contestteam',
    contestteamcategory: 'contestteamcategory',
    contestteamcategoryformedals: 'contestteamcategoryformedals',
    debug_package: 'debug_package',
    doctrine_migration_versions: 'doctrine_migration_versions',
    event: 'event',
    executable: 'executable',
    executable_file: 'executable_file',
    external_contest_source: 'external_contest_source',
    external_judgement: 'external_judgement',
    external_run: 'external_run',
    external_source_warning: 'external_source_warning',
    immutable_executable: 'immutable_executable',
    internal_error: 'internal_error',
    judgehost: 'judgehost',
    judgetask: 'judgetask',
    judging: 'judging',
    judging_run: 'judging_run',
    judging_run_output: 'judging_run_output',
    language: 'language',
    problem: 'problem',
    problem_attachment: 'problem_attachment',
    problem_attachment_content: 'problem_attachment_content',
    queuetask: 'queuetask',
    rankcache: 'rankcache',
    rejudging: 'rejudging',
    removed_interval: 'removed_interval',
    role: 'role',
    scorecache: 'scorecache',
    sessions: 'sessions',
    submission: 'submission',
    submission_file: 'submission_file',
    team: 'team',
    team_affiliation: 'team_affiliation',
    team_category: 'team_category',
    team_unread: 'team_unread',
    testcase: 'testcase',
    testcase_content: 'testcase_content',
    user: 'user',
    userrole: 'userrole'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'auditlog' | 'balloon' | 'clarification' | 'configuration' | 'contest' | 'contestproblem' | 'contestteam' | 'contestteamcategory' | 'contestteamcategoryformedals' | 'debug_package' | 'doctrine_migration_versions' | 'event' | 'executable' | 'executable_file' | 'external_contest_source' | 'external_judgement' | 'external_run' | 'external_source_warning' | 'immutable_executable' | 'internal_error' | 'judgehost' | 'judgetask' | 'judging' | 'judging_run' | 'judging_run_output' | 'language' | 'problem' | 'problem_attachment' | 'problem_attachment_content' | 'queuetask' | 'rankcache' | 'rejudging' | 'removed_interval' | 'role' | 'scorecache' | 'sessions' | 'submission' | 'submission_file' | 'team' | 'team_affiliation' | 'team_category' | 'team_unread' | 'testcase' | 'testcase_content' | 'user' | 'userrole'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      auditlog: {
        payload: Prisma.$auditlogPayload<ExtArgs>
        fields: Prisma.auditlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auditlogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auditlogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          findFirst: {
            args: Prisma.auditlogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auditlogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          findMany: {
            args: Prisma.auditlogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>[]
          }
          create: {
            args: Prisma.auditlogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          createMany: {
            args: Prisma.auditlogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.auditlogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          update: {
            args: Prisma.auditlogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          deleteMany: {
            args: Prisma.auditlogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.auditlogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.auditlogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          aggregate: {
            args: Prisma.AuditlogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAuditlog>
          }
          groupBy: {
            args: Prisma.auditlogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AuditlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.auditlogCountArgs<ExtArgs>,
            result: $Utils.Optional<AuditlogCountAggregateOutputType> | number
          }
        }
      }
      balloon: {
        payload: Prisma.$balloonPayload<ExtArgs>
        fields: Prisma.balloonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.balloonFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$balloonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.balloonFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$balloonPayload>
          }
          findFirst: {
            args: Prisma.balloonFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$balloonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.balloonFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$balloonPayload>
          }
          findMany: {
            args: Prisma.balloonFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$balloonPayload>[]
          }
          create: {
            args: Prisma.balloonCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$balloonPayload>
          }
          createMany: {
            args: Prisma.balloonCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.balloonDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$balloonPayload>
          }
          update: {
            args: Prisma.balloonUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$balloonPayload>
          }
          deleteMany: {
            args: Prisma.balloonDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.balloonUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.balloonUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$balloonPayload>
          }
          aggregate: {
            args: Prisma.BalloonAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBalloon>
          }
          groupBy: {
            args: Prisma.balloonGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BalloonGroupByOutputType>[]
          }
          count: {
            args: Prisma.balloonCountArgs<ExtArgs>,
            result: $Utils.Optional<BalloonCountAggregateOutputType> | number
          }
        }
      }
      clarification: {
        payload: Prisma.$clarificationPayload<ExtArgs>
        fields: Prisma.clarificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clarificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clarificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clarificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clarificationPayload>
          }
          findFirst: {
            args: Prisma.clarificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clarificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clarificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clarificationPayload>
          }
          findMany: {
            args: Prisma.clarificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clarificationPayload>[]
          }
          create: {
            args: Prisma.clarificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clarificationPayload>
          }
          createMany: {
            args: Prisma.clarificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.clarificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clarificationPayload>
          }
          update: {
            args: Prisma.clarificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clarificationPayload>
          }
          deleteMany: {
            args: Prisma.clarificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.clarificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.clarificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clarificationPayload>
          }
          aggregate: {
            args: Prisma.ClarificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClarification>
          }
          groupBy: {
            args: Prisma.clarificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClarificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.clarificationCountArgs<ExtArgs>,
            result: $Utils.Optional<ClarificationCountAggregateOutputType> | number
          }
        }
      }
      configuration: {
        payload: Prisma.$configurationPayload<ExtArgs>
        fields: Prisma.configurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.configurationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.configurationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configurationPayload>
          }
          findFirst: {
            args: Prisma.configurationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.configurationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configurationPayload>
          }
          findMany: {
            args: Prisma.configurationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configurationPayload>[]
          }
          create: {
            args: Prisma.configurationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configurationPayload>
          }
          createMany: {
            args: Prisma.configurationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.configurationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configurationPayload>
          }
          update: {
            args: Prisma.configurationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configurationPayload>
          }
          deleteMany: {
            args: Prisma.configurationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.configurationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.configurationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$configurationPayload>
          }
          aggregate: {
            args: Prisma.ConfigurationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConfiguration>
          }
          groupBy: {
            args: Prisma.configurationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConfigurationGroupByOutputType>[]
          }
          count: {
            args: Prisma.configurationCountArgs<ExtArgs>,
            result: $Utils.Optional<ConfigurationCountAggregateOutputType> | number
          }
        }
      }
      contest: {
        payload: Prisma.$contestPayload<ExtArgs>
        fields: Prisma.contestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestPayload>
          }
          findFirst: {
            args: Prisma.contestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestPayload>
          }
          findMany: {
            args: Prisma.contestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestPayload>[]
          }
          create: {
            args: Prisma.contestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestPayload>
          }
          createMany: {
            args: Prisma.contestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.contestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestPayload>
          }
          update: {
            args: Prisma.contestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestPayload>
          }
          deleteMany: {
            args: Prisma.contestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.contestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.contestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestPayload>
          }
          aggregate: {
            args: Prisma.ContestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContest>
          }
          groupBy: {
            args: Prisma.contestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContestGroupByOutputType>[]
          }
          count: {
            args: Prisma.contestCountArgs<ExtArgs>,
            result: $Utils.Optional<ContestCountAggregateOutputType> | number
          }
        }
      }
      contestproblem: {
        payload: Prisma.$contestproblemPayload<ExtArgs>
        fields: Prisma.contestproblemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contestproblemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestproblemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contestproblemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestproblemPayload>
          }
          findFirst: {
            args: Prisma.contestproblemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestproblemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contestproblemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestproblemPayload>
          }
          findMany: {
            args: Prisma.contestproblemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestproblemPayload>[]
          }
          create: {
            args: Prisma.contestproblemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestproblemPayload>
          }
          createMany: {
            args: Prisma.contestproblemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.contestproblemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestproblemPayload>
          }
          update: {
            args: Prisma.contestproblemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestproblemPayload>
          }
          deleteMany: {
            args: Prisma.contestproblemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.contestproblemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.contestproblemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestproblemPayload>
          }
          aggregate: {
            args: Prisma.ContestproblemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContestproblem>
          }
          groupBy: {
            args: Prisma.contestproblemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContestproblemGroupByOutputType>[]
          }
          count: {
            args: Prisma.contestproblemCountArgs<ExtArgs>,
            result: $Utils.Optional<ContestproblemCountAggregateOutputType> | number
          }
        }
      }
      contestteam: {
        payload: Prisma.$contestteamPayload<ExtArgs>
        fields: Prisma.contestteamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contestteamFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contestteamFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamPayload>
          }
          findFirst: {
            args: Prisma.contestteamFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contestteamFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamPayload>
          }
          findMany: {
            args: Prisma.contestteamFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamPayload>[]
          }
          create: {
            args: Prisma.contestteamCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamPayload>
          }
          createMany: {
            args: Prisma.contestteamCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.contestteamDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamPayload>
          }
          update: {
            args: Prisma.contestteamUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamPayload>
          }
          deleteMany: {
            args: Prisma.contestteamDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.contestteamUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.contestteamUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamPayload>
          }
          aggregate: {
            args: Prisma.ContestteamAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContestteam>
          }
          groupBy: {
            args: Prisma.contestteamGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContestteamGroupByOutputType>[]
          }
          count: {
            args: Prisma.contestteamCountArgs<ExtArgs>,
            result: $Utils.Optional<ContestteamCountAggregateOutputType> | number
          }
        }
      }
      contestteamcategory: {
        payload: Prisma.$contestteamcategoryPayload<ExtArgs>
        fields: Prisma.contestteamcategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contestteamcategoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamcategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contestteamcategoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamcategoryPayload>
          }
          findFirst: {
            args: Prisma.contestteamcategoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamcategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contestteamcategoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamcategoryPayload>
          }
          findMany: {
            args: Prisma.contestteamcategoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamcategoryPayload>[]
          }
          create: {
            args: Prisma.contestteamcategoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamcategoryPayload>
          }
          createMany: {
            args: Prisma.contestteamcategoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.contestteamcategoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamcategoryPayload>
          }
          update: {
            args: Prisma.contestteamcategoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamcategoryPayload>
          }
          deleteMany: {
            args: Prisma.contestteamcategoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.contestteamcategoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.contestteamcategoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamcategoryPayload>
          }
          aggregate: {
            args: Prisma.ContestteamcategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContestteamcategory>
          }
          groupBy: {
            args: Prisma.contestteamcategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContestteamcategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.contestteamcategoryCountArgs<ExtArgs>,
            result: $Utils.Optional<ContestteamcategoryCountAggregateOutputType> | number
          }
        }
      }
      contestteamcategoryformedals: {
        payload: Prisma.$contestteamcategoryformedalsPayload<ExtArgs>
        fields: Prisma.contestteamcategoryformedalsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contestteamcategoryformedalsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamcategoryformedalsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contestteamcategoryformedalsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamcategoryformedalsPayload>
          }
          findFirst: {
            args: Prisma.contestteamcategoryformedalsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamcategoryformedalsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contestteamcategoryformedalsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamcategoryformedalsPayload>
          }
          findMany: {
            args: Prisma.contestteamcategoryformedalsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamcategoryformedalsPayload>[]
          }
          create: {
            args: Prisma.contestteamcategoryformedalsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamcategoryformedalsPayload>
          }
          createMany: {
            args: Prisma.contestteamcategoryformedalsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.contestteamcategoryformedalsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamcategoryformedalsPayload>
          }
          update: {
            args: Prisma.contestteamcategoryformedalsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamcategoryformedalsPayload>
          }
          deleteMany: {
            args: Prisma.contestteamcategoryformedalsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.contestteamcategoryformedalsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.contestteamcategoryformedalsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$contestteamcategoryformedalsPayload>
          }
          aggregate: {
            args: Prisma.ContestteamcategoryformedalsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContestteamcategoryformedals>
          }
          groupBy: {
            args: Prisma.contestteamcategoryformedalsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContestteamcategoryformedalsGroupByOutputType>[]
          }
          count: {
            args: Prisma.contestteamcategoryformedalsCountArgs<ExtArgs>,
            result: $Utils.Optional<ContestteamcategoryformedalsCountAggregateOutputType> | number
          }
        }
      }
      debug_package: {
        payload: Prisma.$debug_packagePayload<ExtArgs>
        fields: Prisma.debug_packageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.debug_packageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$debug_packagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.debug_packageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$debug_packagePayload>
          }
          findFirst: {
            args: Prisma.debug_packageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$debug_packagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.debug_packageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$debug_packagePayload>
          }
          findMany: {
            args: Prisma.debug_packageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$debug_packagePayload>[]
          }
          create: {
            args: Prisma.debug_packageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$debug_packagePayload>
          }
          createMany: {
            args: Prisma.debug_packageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.debug_packageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$debug_packagePayload>
          }
          update: {
            args: Prisma.debug_packageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$debug_packagePayload>
          }
          deleteMany: {
            args: Prisma.debug_packageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.debug_packageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.debug_packageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$debug_packagePayload>
          }
          aggregate: {
            args: Prisma.Debug_packageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDebug_package>
          }
          groupBy: {
            args: Prisma.debug_packageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Debug_packageGroupByOutputType>[]
          }
          count: {
            args: Prisma.debug_packageCountArgs<ExtArgs>,
            result: $Utils.Optional<Debug_packageCountAggregateOutputType> | number
          }
        }
      }
      doctrine_migration_versions: {
        payload: Prisma.$doctrine_migration_versionsPayload<ExtArgs>
        fields: Prisma.doctrine_migration_versionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.doctrine_migration_versionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$doctrine_migration_versionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.doctrine_migration_versionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$doctrine_migration_versionsPayload>
          }
          findFirst: {
            args: Prisma.doctrine_migration_versionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$doctrine_migration_versionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.doctrine_migration_versionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$doctrine_migration_versionsPayload>
          }
          findMany: {
            args: Prisma.doctrine_migration_versionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$doctrine_migration_versionsPayload>[]
          }
          create: {
            args: Prisma.doctrine_migration_versionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$doctrine_migration_versionsPayload>
          }
          createMany: {
            args: Prisma.doctrine_migration_versionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.doctrine_migration_versionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$doctrine_migration_versionsPayload>
          }
          update: {
            args: Prisma.doctrine_migration_versionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$doctrine_migration_versionsPayload>
          }
          deleteMany: {
            args: Prisma.doctrine_migration_versionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.doctrine_migration_versionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.doctrine_migration_versionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$doctrine_migration_versionsPayload>
          }
          aggregate: {
            args: Prisma.Doctrine_migration_versionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDoctrine_migration_versions>
          }
          groupBy: {
            args: Prisma.doctrine_migration_versionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Doctrine_migration_versionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.doctrine_migration_versionsCountArgs<ExtArgs>,
            result: $Utils.Optional<Doctrine_migration_versionsCountAggregateOutputType> | number
          }
        }
      }
      event: {
        payload: Prisma.$eventPayload<ExtArgs>
        fields: Prisma.eventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.eventFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.eventFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          findFirst: {
            args: Prisma.eventFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.eventFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          findMany: {
            args: Prisma.eventFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eventPayload>[]
          }
          create: {
            args: Prisma.eventCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          createMany: {
            args: Prisma.eventCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.eventDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          update: {
            args: Prisma.eventUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          deleteMany: {
            args: Prisma.eventDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.eventUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.eventUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.eventGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.eventCountArgs<ExtArgs>,
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      executable: {
        payload: Prisma.$executablePayload<ExtArgs>
        fields: Prisma.executableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.executableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$executablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.executableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$executablePayload>
          }
          findFirst: {
            args: Prisma.executableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$executablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.executableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$executablePayload>
          }
          findMany: {
            args: Prisma.executableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$executablePayload>[]
          }
          create: {
            args: Prisma.executableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$executablePayload>
          }
          createMany: {
            args: Prisma.executableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.executableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$executablePayload>
          }
          update: {
            args: Prisma.executableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$executablePayload>
          }
          deleteMany: {
            args: Prisma.executableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.executableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.executableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$executablePayload>
          }
          aggregate: {
            args: Prisma.ExecutableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateExecutable>
          }
          groupBy: {
            args: Prisma.executableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ExecutableGroupByOutputType>[]
          }
          count: {
            args: Prisma.executableCountArgs<ExtArgs>,
            result: $Utils.Optional<ExecutableCountAggregateOutputType> | number
          }
        }
      }
      executable_file: {
        payload: Prisma.$executable_filePayload<ExtArgs>
        fields: Prisma.executable_fileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.executable_fileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$executable_filePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.executable_fileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$executable_filePayload>
          }
          findFirst: {
            args: Prisma.executable_fileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$executable_filePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.executable_fileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$executable_filePayload>
          }
          findMany: {
            args: Prisma.executable_fileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$executable_filePayload>[]
          }
          create: {
            args: Prisma.executable_fileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$executable_filePayload>
          }
          createMany: {
            args: Prisma.executable_fileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.executable_fileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$executable_filePayload>
          }
          update: {
            args: Prisma.executable_fileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$executable_filePayload>
          }
          deleteMany: {
            args: Prisma.executable_fileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.executable_fileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.executable_fileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$executable_filePayload>
          }
          aggregate: {
            args: Prisma.Executable_fileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateExecutable_file>
          }
          groupBy: {
            args: Prisma.executable_fileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Executable_fileGroupByOutputType>[]
          }
          count: {
            args: Prisma.executable_fileCountArgs<ExtArgs>,
            result: $Utils.Optional<Executable_fileCountAggregateOutputType> | number
          }
        }
      }
      external_contest_source: {
        payload: Prisma.$external_contest_sourcePayload<ExtArgs>
        fields: Prisma.external_contest_sourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.external_contest_sourceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_contest_sourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.external_contest_sourceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_contest_sourcePayload>
          }
          findFirst: {
            args: Prisma.external_contest_sourceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_contest_sourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.external_contest_sourceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_contest_sourcePayload>
          }
          findMany: {
            args: Prisma.external_contest_sourceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_contest_sourcePayload>[]
          }
          create: {
            args: Prisma.external_contest_sourceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_contest_sourcePayload>
          }
          createMany: {
            args: Prisma.external_contest_sourceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.external_contest_sourceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_contest_sourcePayload>
          }
          update: {
            args: Prisma.external_contest_sourceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_contest_sourcePayload>
          }
          deleteMany: {
            args: Prisma.external_contest_sourceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.external_contest_sourceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.external_contest_sourceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_contest_sourcePayload>
          }
          aggregate: {
            args: Prisma.External_contest_sourceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateExternal_contest_source>
          }
          groupBy: {
            args: Prisma.external_contest_sourceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<External_contest_sourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.external_contest_sourceCountArgs<ExtArgs>,
            result: $Utils.Optional<External_contest_sourceCountAggregateOutputType> | number
          }
        }
      }
      external_judgement: {
        payload: Prisma.$external_judgementPayload<ExtArgs>
        fields: Prisma.external_judgementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.external_judgementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_judgementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.external_judgementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_judgementPayload>
          }
          findFirst: {
            args: Prisma.external_judgementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_judgementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.external_judgementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_judgementPayload>
          }
          findMany: {
            args: Prisma.external_judgementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_judgementPayload>[]
          }
          create: {
            args: Prisma.external_judgementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_judgementPayload>
          }
          createMany: {
            args: Prisma.external_judgementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.external_judgementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_judgementPayload>
          }
          update: {
            args: Prisma.external_judgementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_judgementPayload>
          }
          deleteMany: {
            args: Prisma.external_judgementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.external_judgementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.external_judgementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_judgementPayload>
          }
          aggregate: {
            args: Prisma.External_judgementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateExternal_judgement>
          }
          groupBy: {
            args: Prisma.external_judgementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<External_judgementGroupByOutputType>[]
          }
          count: {
            args: Prisma.external_judgementCountArgs<ExtArgs>,
            result: $Utils.Optional<External_judgementCountAggregateOutputType> | number
          }
        }
      }
      external_run: {
        payload: Prisma.$external_runPayload<ExtArgs>
        fields: Prisma.external_runFieldRefs
        operations: {
          findUnique: {
            args: Prisma.external_runFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_runPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.external_runFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_runPayload>
          }
          findFirst: {
            args: Prisma.external_runFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_runPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.external_runFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_runPayload>
          }
          findMany: {
            args: Prisma.external_runFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_runPayload>[]
          }
          create: {
            args: Prisma.external_runCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_runPayload>
          }
          createMany: {
            args: Prisma.external_runCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.external_runDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_runPayload>
          }
          update: {
            args: Prisma.external_runUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_runPayload>
          }
          deleteMany: {
            args: Prisma.external_runDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.external_runUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.external_runUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_runPayload>
          }
          aggregate: {
            args: Prisma.External_runAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateExternal_run>
          }
          groupBy: {
            args: Prisma.external_runGroupByArgs<ExtArgs>,
            result: $Utils.Optional<External_runGroupByOutputType>[]
          }
          count: {
            args: Prisma.external_runCountArgs<ExtArgs>,
            result: $Utils.Optional<External_runCountAggregateOutputType> | number
          }
        }
      }
      external_source_warning: {
        payload: Prisma.$external_source_warningPayload<ExtArgs>
        fields: Prisma.external_source_warningFieldRefs
        operations: {
          findUnique: {
            args: Prisma.external_source_warningFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_source_warningPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.external_source_warningFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_source_warningPayload>
          }
          findFirst: {
            args: Prisma.external_source_warningFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_source_warningPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.external_source_warningFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_source_warningPayload>
          }
          findMany: {
            args: Prisma.external_source_warningFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_source_warningPayload>[]
          }
          create: {
            args: Prisma.external_source_warningCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_source_warningPayload>
          }
          createMany: {
            args: Prisma.external_source_warningCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.external_source_warningDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_source_warningPayload>
          }
          update: {
            args: Prisma.external_source_warningUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_source_warningPayload>
          }
          deleteMany: {
            args: Prisma.external_source_warningDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.external_source_warningUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.external_source_warningUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$external_source_warningPayload>
          }
          aggregate: {
            args: Prisma.External_source_warningAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateExternal_source_warning>
          }
          groupBy: {
            args: Prisma.external_source_warningGroupByArgs<ExtArgs>,
            result: $Utils.Optional<External_source_warningGroupByOutputType>[]
          }
          count: {
            args: Prisma.external_source_warningCountArgs<ExtArgs>,
            result: $Utils.Optional<External_source_warningCountAggregateOutputType> | number
          }
        }
      }
      immutable_executable: {
        payload: Prisma.$immutable_executablePayload<ExtArgs>
        fields: Prisma.immutable_executableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.immutable_executableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$immutable_executablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.immutable_executableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$immutable_executablePayload>
          }
          findFirst: {
            args: Prisma.immutable_executableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$immutable_executablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.immutable_executableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$immutable_executablePayload>
          }
          findMany: {
            args: Prisma.immutable_executableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$immutable_executablePayload>[]
          }
          create: {
            args: Prisma.immutable_executableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$immutable_executablePayload>
          }
          createMany: {
            args: Prisma.immutable_executableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.immutable_executableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$immutable_executablePayload>
          }
          update: {
            args: Prisma.immutable_executableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$immutable_executablePayload>
          }
          deleteMany: {
            args: Prisma.immutable_executableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.immutable_executableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.immutable_executableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$immutable_executablePayload>
          }
          aggregate: {
            args: Prisma.Immutable_executableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateImmutable_executable>
          }
          groupBy: {
            args: Prisma.immutable_executableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Immutable_executableGroupByOutputType>[]
          }
          count: {
            args: Prisma.immutable_executableCountArgs<ExtArgs>,
            result: $Utils.Optional<Immutable_executableCountAggregateOutputType> | number
          }
        }
      }
      internal_error: {
        payload: Prisma.$internal_errorPayload<ExtArgs>
        fields: Prisma.internal_errorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.internal_errorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$internal_errorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.internal_errorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$internal_errorPayload>
          }
          findFirst: {
            args: Prisma.internal_errorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$internal_errorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.internal_errorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$internal_errorPayload>
          }
          findMany: {
            args: Prisma.internal_errorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$internal_errorPayload>[]
          }
          create: {
            args: Prisma.internal_errorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$internal_errorPayload>
          }
          createMany: {
            args: Prisma.internal_errorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.internal_errorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$internal_errorPayload>
          }
          update: {
            args: Prisma.internal_errorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$internal_errorPayload>
          }
          deleteMany: {
            args: Prisma.internal_errorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.internal_errorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.internal_errorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$internal_errorPayload>
          }
          aggregate: {
            args: Prisma.Internal_errorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInternal_error>
          }
          groupBy: {
            args: Prisma.internal_errorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Internal_errorGroupByOutputType>[]
          }
          count: {
            args: Prisma.internal_errorCountArgs<ExtArgs>,
            result: $Utils.Optional<Internal_errorCountAggregateOutputType> | number
          }
        }
      }
      judgehost: {
        payload: Prisma.$judgehostPayload<ExtArgs>
        fields: Prisma.judgehostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.judgehostFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgehostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.judgehostFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgehostPayload>
          }
          findFirst: {
            args: Prisma.judgehostFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgehostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.judgehostFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgehostPayload>
          }
          findMany: {
            args: Prisma.judgehostFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgehostPayload>[]
          }
          create: {
            args: Prisma.judgehostCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgehostPayload>
          }
          createMany: {
            args: Prisma.judgehostCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.judgehostDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgehostPayload>
          }
          update: {
            args: Prisma.judgehostUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgehostPayload>
          }
          deleteMany: {
            args: Prisma.judgehostDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.judgehostUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.judgehostUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgehostPayload>
          }
          aggregate: {
            args: Prisma.JudgehostAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJudgehost>
          }
          groupBy: {
            args: Prisma.judgehostGroupByArgs<ExtArgs>,
            result: $Utils.Optional<JudgehostGroupByOutputType>[]
          }
          count: {
            args: Prisma.judgehostCountArgs<ExtArgs>,
            result: $Utils.Optional<JudgehostCountAggregateOutputType> | number
          }
        }
      }
      judgetask: {
        payload: Prisma.$judgetaskPayload<ExtArgs>
        fields: Prisma.judgetaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.judgetaskFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgetaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.judgetaskFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgetaskPayload>
          }
          findFirst: {
            args: Prisma.judgetaskFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgetaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.judgetaskFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgetaskPayload>
          }
          findMany: {
            args: Prisma.judgetaskFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgetaskPayload>[]
          }
          create: {
            args: Prisma.judgetaskCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgetaskPayload>
          }
          createMany: {
            args: Prisma.judgetaskCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.judgetaskDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgetaskPayload>
          }
          update: {
            args: Prisma.judgetaskUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgetaskPayload>
          }
          deleteMany: {
            args: Prisma.judgetaskDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.judgetaskUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.judgetaskUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgetaskPayload>
          }
          aggregate: {
            args: Prisma.JudgetaskAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJudgetask>
          }
          groupBy: {
            args: Prisma.judgetaskGroupByArgs<ExtArgs>,
            result: $Utils.Optional<JudgetaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.judgetaskCountArgs<ExtArgs>,
            result: $Utils.Optional<JudgetaskCountAggregateOutputType> | number
          }
        }
      }
      judging: {
        payload: Prisma.$judgingPayload<ExtArgs>
        fields: Prisma.judgingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.judgingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.judgingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgingPayload>
          }
          findFirst: {
            args: Prisma.judgingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.judgingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgingPayload>
          }
          findMany: {
            args: Prisma.judgingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgingPayload>[]
          }
          create: {
            args: Prisma.judgingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgingPayload>
          }
          createMany: {
            args: Prisma.judgingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.judgingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgingPayload>
          }
          update: {
            args: Prisma.judgingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgingPayload>
          }
          deleteMany: {
            args: Prisma.judgingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.judgingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.judgingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judgingPayload>
          }
          aggregate: {
            args: Prisma.JudgingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJudging>
          }
          groupBy: {
            args: Prisma.judgingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<JudgingGroupByOutputType>[]
          }
          count: {
            args: Prisma.judgingCountArgs<ExtArgs>,
            result: $Utils.Optional<JudgingCountAggregateOutputType> | number
          }
        }
      }
      judging_run: {
        payload: Prisma.$judging_runPayload<ExtArgs>
        fields: Prisma.judging_runFieldRefs
        operations: {
          findUnique: {
            args: Prisma.judging_runFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judging_runPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.judging_runFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judging_runPayload>
          }
          findFirst: {
            args: Prisma.judging_runFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judging_runPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.judging_runFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judging_runPayload>
          }
          findMany: {
            args: Prisma.judging_runFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judging_runPayload>[]
          }
          create: {
            args: Prisma.judging_runCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judging_runPayload>
          }
          createMany: {
            args: Prisma.judging_runCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.judging_runDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judging_runPayload>
          }
          update: {
            args: Prisma.judging_runUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judging_runPayload>
          }
          deleteMany: {
            args: Prisma.judging_runDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.judging_runUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.judging_runUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judging_runPayload>
          }
          aggregate: {
            args: Prisma.Judging_runAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJudging_run>
          }
          groupBy: {
            args: Prisma.judging_runGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Judging_runGroupByOutputType>[]
          }
          count: {
            args: Prisma.judging_runCountArgs<ExtArgs>,
            result: $Utils.Optional<Judging_runCountAggregateOutputType> | number
          }
        }
      }
      judging_run_output: {
        payload: Prisma.$judging_run_outputPayload<ExtArgs>
        fields: Prisma.judging_run_outputFieldRefs
        operations: {
          findUnique: {
            args: Prisma.judging_run_outputFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judging_run_outputPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.judging_run_outputFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judging_run_outputPayload>
          }
          findFirst: {
            args: Prisma.judging_run_outputFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judging_run_outputPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.judging_run_outputFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judging_run_outputPayload>
          }
          findMany: {
            args: Prisma.judging_run_outputFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judging_run_outputPayload>[]
          }
          create: {
            args: Prisma.judging_run_outputCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judging_run_outputPayload>
          }
          createMany: {
            args: Prisma.judging_run_outputCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.judging_run_outputDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judging_run_outputPayload>
          }
          update: {
            args: Prisma.judging_run_outputUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judging_run_outputPayload>
          }
          deleteMany: {
            args: Prisma.judging_run_outputDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.judging_run_outputUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.judging_run_outputUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$judging_run_outputPayload>
          }
          aggregate: {
            args: Prisma.Judging_run_outputAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJudging_run_output>
          }
          groupBy: {
            args: Prisma.judging_run_outputGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Judging_run_outputGroupByOutputType>[]
          }
          count: {
            args: Prisma.judging_run_outputCountArgs<ExtArgs>,
            result: $Utils.Optional<Judging_run_outputCountAggregateOutputType> | number
          }
        }
      }
      language: {
        payload: Prisma.$languagePayload<ExtArgs>
        fields: Prisma.languageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.languageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$languagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.languageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$languagePayload>
          }
          findFirst: {
            args: Prisma.languageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$languagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.languageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$languagePayload>
          }
          findMany: {
            args: Prisma.languageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$languagePayload>[]
          }
          create: {
            args: Prisma.languageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$languagePayload>
          }
          createMany: {
            args: Prisma.languageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.languageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$languagePayload>
          }
          update: {
            args: Prisma.languageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$languagePayload>
          }
          deleteMany: {
            args: Prisma.languageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.languageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.languageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$languagePayload>
          }
          aggregate: {
            args: Prisma.LanguageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLanguage>
          }
          groupBy: {
            args: Prisma.languageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.languageCountArgs<ExtArgs>,
            result: $Utils.Optional<LanguageCountAggregateOutputType> | number
          }
        }
      }
      problem: {
        payload: Prisma.$problemPayload<ExtArgs>
        fields: Prisma.problemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.problemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.problemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problemPayload>
          }
          findFirst: {
            args: Prisma.problemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.problemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problemPayload>
          }
          findMany: {
            args: Prisma.problemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problemPayload>[]
          }
          create: {
            args: Prisma.problemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problemPayload>
          }
          createMany: {
            args: Prisma.problemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.problemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problemPayload>
          }
          update: {
            args: Prisma.problemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problemPayload>
          }
          deleteMany: {
            args: Prisma.problemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.problemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.problemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problemPayload>
          }
          aggregate: {
            args: Prisma.ProblemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProblem>
          }
          groupBy: {
            args: Prisma.problemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProblemGroupByOutputType>[]
          }
          count: {
            args: Prisma.problemCountArgs<ExtArgs>,
            result: $Utils.Optional<ProblemCountAggregateOutputType> | number
          }
        }
      }
      problem_attachment: {
        payload: Prisma.$problem_attachmentPayload<ExtArgs>
        fields: Prisma.problem_attachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.problem_attachmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problem_attachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.problem_attachmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problem_attachmentPayload>
          }
          findFirst: {
            args: Prisma.problem_attachmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problem_attachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.problem_attachmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problem_attachmentPayload>
          }
          findMany: {
            args: Prisma.problem_attachmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problem_attachmentPayload>[]
          }
          create: {
            args: Prisma.problem_attachmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problem_attachmentPayload>
          }
          createMany: {
            args: Prisma.problem_attachmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.problem_attachmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problem_attachmentPayload>
          }
          update: {
            args: Prisma.problem_attachmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problem_attachmentPayload>
          }
          deleteMany: {
            args: Prisma.problem_attachmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.problem_attachmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.problem_attachmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problem_attachmentPayload>
          }
          aggregate: {
            args: Prisma.Problem_attachmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProblem_attachment>
          }
          groupBy: {
            args: Prisma.problem_attachmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Problem_attachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.problem_attachmentCountArgs<ExtArgs>,
            result: $Utils.Optional<Problem_attachmentCountAggregateOutputType> | number
          }
        }
      }
      problem_attachment_content: {
        payload: Prisma.$problem_attachment_contentPayload<ExtArgs>
        fields: Prisma.problem_attachment_contentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.problem_attachment_contentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problem_attachment_contentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.problem_attachment_contentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problem_attachment_contentPayload>
          }
          findFirst: {
            args: Prisma.problem_attachment_contentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problem_attachment_contentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.problem_attachment_contentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problem_attachment_contentPayload>
          }
          findMany: {
            args: Prisma.problem_attachment_contentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problem_attachment_contentPayload>[]
          }
          create: {
            args: Prisma.problem_attachment_contentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problem_attachment_contentPayload>
          }
          createMany: {
            args: Prisma.problem_attachment_contentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.problem_attachment_contentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problem_attachment_contentPayload>
          }
          update: {
            args: Prisma.problem_attachment_contentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problem_attachment_contentPayload>
          }
          deleteMany: {
            args: Prisma.problem_attachment_contentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.problem_attachment_contentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.problem_attachment_contentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$problem_attachment_contentPayload>
          }
          aggregate: {
            args: Prisma.Problem_attachment_contentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProblem_attachment_content>
          }
          groupBy: {
            args: Prisma.problem_attachment_contentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Problem_attachment_contentGroupByOutputType>[]
          }
          count: {
            args: Prisma.problem_attachment_contentCountArgs<ExtArgs>,
            result: $Utils.Optional<Problem_attachment_contentCountAggregateOutputType> | number
          }
        }
      }
      queuetask: {
        payload: Prisma.$queuetaskPayload<ExtArgs>
        fields: Prisma.queuetaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.queuetaskFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$queuetaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.queuetaskFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$queuetaskPayload>
          }
          findFirst: {
            args: Prisma.queuetaskFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$queuetaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.queuetaskFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$queuetaskPayload>
          }
          findMany: {
            args: Prisma.queuetaskFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$queuetaskPayload>[]
          }
          create: {
            args: Prisma.queuetaskCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$queuetaskPayload>
          }
          createMany: {
            args: Prisma.queuetaskCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.queuetaskDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$queuetaskPayload>
          }
          update: {
            args: Prisma.queuetaskUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$queuetaskPayload>
          }
          deleteMany: {
            args: Prisma.queuetaskDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.queuetaskUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.queuetaskUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$queuetaskPayload>
          }
          aggregate: {
            args: Prisma.QueuetaskAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateQueuetask>
          }
          groupBy: {
            args: Prisma.queuetaskGroupByArgs<ExtArgs>,
            result: $Utils.Optional<QueuetaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.queuetaskCountArgs<ExtArgs>,
            result: $Utils.Optional<QueuetaskCountAggregateOutputType> | number
          }
        }
      }
      rankcache: {
        payload: Prisma.$rankcachePayload<ExtArgs>
        fields: Prisma.rankcacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rankcacheFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rankcachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rankcacheFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rankcachePayload>
          }
          findFirst: {
            args: Prisma.rankcacheFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rankcachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rankcacheFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rankcachePayload>
          }
          findMany: {
            args: Prisma.rankcacheFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rankcachePayload>[]
          }
          create: {
            args: Prisma.rankcacheCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rankcachePayload>
          }
          createMany: {
            args: Prisma.rankcacheCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.rankcacheDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rankcachePayload>
          }
          update: {
            args: Prisma.rankcacheUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rankcachePayload>
          }
          deleteMany: {
            args: Prisma.rankcacheDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.rankcacheUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.rankcacheUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rankcachePayload>
          }
          aggregate: {
            args: Prisma.RankcacheAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRankcache>
          }
          groupBy: {
            args: Prisma.rankcacheGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RankcacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.rankcacheCountArgs<ExtArgs>,
            result: $Utils.Optional<RankcacheCountAggregateOutputType> | number
          }
        }
      }
      rejudging: {
        payload: Prisma.$rejudgingPayload<ExtArgs>
        fields: Prisma.rejudgingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rejudgingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rejudgingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rejudgingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rejudgingPayload>
          }
          findFirst: {
            args: Prisma.rejudgingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rejudgingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rejudgingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rejudgingPayload>
          }
          findMany: {
            args: Prisma.rejudgingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rejudgingPayload>[]
          }
          create: {
            args: Prisma.rejudgingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rejudgingPayload>
          }
          createMany: {
            args: Prisma.rejudgingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.rejudgingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rejudgingPayload>
          }
          update: {
            args: Prisma.rejudgingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rejudgingPayload>
          }
          deleteMany: {
            args: Prisma.rejudgingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.rejudgingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.rejudgingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rejudgingPayload>
          }
          aggregate: {
            args: Prisma.RejudgingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRejudging>
          }
          groupBy: {
            args: Prisma.rejudgingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RejudgingGroupByOutputType>[]
          }
          count: {
            args: Prisma.rejudgingCountArgs<ExtArgs>,
            result: $Utils.Optional<RejudgingCountAggregateOutputType> | number
          }
        }
      }
      removed_interval: {
        payload: Prisma.$removed_intervalPayload<ExtArgs>
        fields: Prisma.removed_intervalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.removed_intervalFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$removed_intervalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.removed_intervalFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$removed_intervalPayload>
          }
          findFirst: {
            args: Prisma.removed_intervalFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$removed_intervalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.removed_intervalFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$removed_intervalPayload>
          }
          findMany: {
            args: Prisma.removed_intervalFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$removed_intervalPayload>[]
          }
          create: {
            args: Prisma.removed_intervalCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$removed_intervalPayload>
          }
          createMany: {
            args: Prisma.removed_intervalCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.removed_intervalDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$removed_intervalPayload>
          }
          update: {
            args: Prisma.removed_intervalUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$removed_intervalPayload>
          }
          deleteMany: {
            args: Prisma.removed_intervalDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.removed_intervalUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.removed_intervalUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$removed_intervalPayload>
          }
          aggregate: {
            args: Prisma.Removed_intervalAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRemoved_interval>
          }
          groupBy: {
            args: Prisma.removed_intervalGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Removed_intervalGroupByOutputType>[]
          }
          count: {
            args: Prisma.removed_intervalCountArgs<ExtArgs>,
            result: $Utils.Optional<Removed_intervalCountAggregateOutputType> | number
          }
        }
      }
      role: {
        payload: Prisma.$rolePayload<ExtArgs>
        fields: Prisma.roleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.roleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.roleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findFirst: {
            args: Prisma.roleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.roleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findMany: {
            args: Prisma.roleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          create: {
            args: Prisma.roleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          createMany: {
            args: Prisma.roleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.roleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          update: {
            args: Prisma.roleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          deleteMany: {
            args: Prisma.roleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.roleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.roleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.roleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.roleCountArgs<ExtArgs>,
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      scorecache: {
        payload: Prisma.$scorecachePayload<ExtArgs>
        fields: Prisma.scorecacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.scorecacheFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$scorecachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.scorecacheFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$scorecachePayload>
          }
          findFirst: {
            args: Prisma.scorecacheFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$scorecachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.scorecacheFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$scorecachePayload>
          }
          findMany: {
            args: Prisma.scorecacheFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$scorecachePayload>[]
          }
          create: {
            args: Prisma.scorecacheCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$scorecachePayload>
          }
          createMany: {
            args: Prisma.scorecacheCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.scorecacheDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$scorecachePayload>
          }
          update: {
            args: Prisma.scorecacheUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$scorecachePayload>
          }
          deleteMany: {
            args: Prisma.scorecacheDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.scorecacheUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.scorecacheUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$scorecachePayload>
          }
          aggregate: {
            args: Prisma.ScorecacheAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateScorecache>
          }
          groupBy: {
            args: Prisma.scorecacheGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ScorecacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.scorecacheCountArgs<ExtArgs>,
            result: $Utils.Optional<ScorecacheCountAggregateOutputType> | number
          }
        }
      }
      sessions: {
        payload: Prisma.$sessionsPayload<ExtArgs>
        fields: Prisma.sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findFirst: {
            args: Prisma.sessionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findMany: {
            args: Prisma.sessionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          create: {
            args: Prisma.sessionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          createMany: {
            args: Prisma.sessionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.sessionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          update: {
            args: Prisma.sessionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          deleteMany: {
            args: Prisma.sessionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.sessionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.sessionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          aggregate: {
            args: Prisma.SessionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSessions>
          }
          groupBy: {
            args: Prisma.sessionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionsCountArgs<ExtArgs>,
            result: $Utils.Optional<SessionsCountAggregateOutputType> | number
          }
        }
      }
      submission: {
        payload: Prisma.$submissionPayload<ExtArgs>
        fields: Prisma.submissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.submissionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$submissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.submissionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$submissionPayload>
          }
          findFirst: {
            args: Prisma.submissionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$submissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.submissionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$submissionPayload>
          }
          findMany: {
            args: Prisma.submissionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$submissionPayload>[]
          }
          create: {
            args: Prisma.submissionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$submissionPayload>
          }
          createMany: {
            args: Prisma.submissionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.submissionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$submissionPayload>
          }
          update: {
            args: Prisma.submissionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$submissionPayload>
          }
          deleteMany: {
            args: Prisma.submissionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.submissionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.submissionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$submissionPayload>
          }
          aggregate: {
            args: Prisma.SubmissionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSubmission>
          }
          groupBy: {
            args: Prisma.submissionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.submissionCountArgs<ExtArgs>,
            result: $Utils.Optional<SubmissionCountAggregateOutputType> | number
          }
        }
      }
      submission_file: {
        payload: Prisma.$submission_filePayload<ExtArgs>
        fields: Prisma.submission_fileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.submission_fileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$submission_filePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.submission_fileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$submission_filePayload>
          }
          findFirst: {
            args: Prisma.submission_fileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$submission_filePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.submission_fileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$submission_filePayload>
          }
          findMany: {
            args: Prisma.submission_fileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$submission_filePayload>[]
          }
          create: {
            args: Prisma.submission_fileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$submission_filePayload>
          }
          createMany: {
            args: Prisma.submission_fileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.submission_fileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$submission_filePayload>
          }
          update: {
            args: Prisma.submission_fileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$submission_filePayload>
          }
          deleteMany: {
            args: Prisma.submission_fileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.submission_fileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.submission_fileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$submission_filePayload>
          }
          aggregate: {
            args: Prisma.Submission_fileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSubmission_file>
          }
          groupBy: {
            args: Prisma.submission_fileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Submission_fileGroupByOutputType>[]
          }
          count: {
            args: Prisma.submission_fileCountArgs<ExtArgs>,
            result: $Utils.Optional<Submission_fileCountAggregateOutputType> | number
          }
        }
      }
      team: {
        payload: Prisma.$teamPayload<ExtArgs>
        fields: Prisma.teamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teamFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$teamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teamFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          findFirst: {
            args: Prisma.teamFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$teamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teamFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          findMany: {
            args: Prisma.teamFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$teamPayload>[]
          }
          create: {
            args: Prisma.teamCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          createMany: {
            args: Prisma.teamCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.teamDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          update: {
            args: Prisma.teamUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          deleteMany: {
            args: Prisma.teamDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.teamUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.teamUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.teamGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.teamCountArgs<ExtArgs>,
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      team_affiliation: {
        payload: Prisma.$team_affiliationPayload<ExtArgs>
        fields: Prisma.team_affiliationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.team_affiliationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_affiliationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.team_affiliationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_affiliationPayload>
          }
          findFirst: {
            args: Prisma.team_affiliationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_affiliationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.team_affiliationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_affiliationPayload>
          }
          findMany: {
            args: Prisma.team_affiliationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_affiliationPayload>[]
          }
          create: {
            args: Prisma.team_affiliationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_affiliationPayload>
          }
          createMany: {
            args: Prisma.team_affiliationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.team_affiliationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_affiliationPayload>
          }
          update: {
            args: Prisma.team_affiliationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_affiliationPayload>
          }
          deleteMany: {
            args: Prisma.team_affiliationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.team_affiliationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.team_affiliationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_affiliationPayload>
          }
          aggregate: {
            args: Prisma.Team_affiliationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTeam_affiliation>
          }
          groupBy: {
            args: Prisma.team_affiliationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Team_affiliationGroupByOutputType>[]
          }
          count: {
            args: Prisma.team_affiliationCountArgs<ExtArgs>,
            result: $Utils.Optional<Team_affiliationCountAggregateOutputType> | number
          }
        }
      }
      team_category: {
        payload: Prisma.$team_categoryPayload<ExtArgs>
        fields: Prisma.team_categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.team_categoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.team_categoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_categoryPayload>
          }
          findFirst: {
            args: Prisma.team_categoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.team_categoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_categoryPayload>
          }
          findMany: {
            args: Prisma.team_categoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_categoryPayload>[]
          }
          create: {
            args: Prisma.team_categoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_categoryPayload>
          }
          createMany: {
            args: Prisma.team_categoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.team_categoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_categoryPayload>
          }
          update: {
            args: Prisma.team_categoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_categoryPayload>
          }
          deleteMany: {
            args: Prisma.team_categoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.team_categoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.team_categoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_categoryPayload>
          }
          aggregate: {
            args: Prisma.Team_categoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTeam_category>
          }
          groupBy: {
            args: Prisma.team_categoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Team_categoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.team_categoryCountArgs<ExtArgs>,
            result: $Utils.Optional<Team_categoryCountAggregateOutputType> | number
          }
        }
      }
      team_unread: {
        payload: Prisma.$team_unreadPayload<ExtArgs>
        fields: Prisma.team_unreadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.team_unreadFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_unreadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.team_unreadFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_unreadPayload>
          }
          findFirst: {
            args: Prisma.team_unreadFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_unreadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.team_unreadFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_unreadPayload>
          }
          findMany: {
            args: Prisma.team_unreadFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_unreadPayload>[]
          }
          create: {
            args: Prisma.team_unreadCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_unreadPayload>
          }
          createMany: {
            args: Prisma.team_unreadCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.team_unreadDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_unreadPayload>
          }
          update: {
            args: Prisma.team_unreadUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_unreadPayload>
          }
          deleteMany: {
            args: Prisma.team_unreadDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.team_unreadUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.team_unreadUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$team_unreadPayload>
          }
          aggregate: {
            args: Prisma.Team_unreadAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTeam_unread>
          }
          groupBy: {
            args: Prisma.team_unreadGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Team_unreadGroupByOutputType>[]
          }
          count: {
            args: Prisma.team_unreadCountArgs<ExtArgs>,
            result: $Utils.Optional<Team_unreadCountAggregateOutputType> | number
          }
        }
      }
      testcase: {
        payload: Prisma.$testcasePayload<ExtArgs>
        fields: Prisma.testcaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.testcaseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$testcasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.testcaseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$testcasePayload>
          }
          findFirst: {
            args: Prisma.testcaseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$testcasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.testcaseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$testcasePayload>
          }
          findMany: {
            args: Prisma.testcaseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$testcasePayload>[]
          }
          create: {
            args: Prisma.testcaseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$testcasePayload>
          }
          createMany: {
            args: Prisma.testcaseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.testcaseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$testcasePayload>
          }
          update: {
            args: Prisma.testcaseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$testcasePayload>
          }
          deleteMany: {
            args: Prisma.testcaseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.testcaseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.testcaseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$testcasePayload>
          }
          aggregate: {
            args: Prisma.TestcaseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTestcase>
          }
          groupBy: {
            args: Prisma.testcaseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TestcaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.testcaseCountArgs<ExtArgs>,
            result: $Utils.Optional<TestcaseCountAggregateOutputType> | number
          }
        }
      }
      testcase_content: {
        payload: Prisma.$testcase_contentPayload<ExtArgs>
        fields: Prisma.testcase_contentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.testcase_contentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$testcase_contentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.testcase_contentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$testcase_contentPayload>
          }
          findFirst: {
            args: Prisma.testcase_contentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$testcase_contentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.testcase_contentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$testcase_contentPayload>
          }
          findMany: {
            args: Prisma.testcase_contentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$testcase_contentPayload>[]
          }
          create: {
            args: Prisma.testcase_contentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$testcase_contentPayload>
          }
          createMany: {
            args: Prisma.testcase_contentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.testcase_contentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$testcase_contentPayload>
          }
          update: {
            args: Prisma.testcase_contentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$testcase_contentPayload>
          }
          deleteMany: {
            args: Prisma.testcase_contentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.testcase_contentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.testcase_contentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$testcase_contentPayload>
          }
          aggregate: {
            args: Prisma.Testcase_contentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTestcase_content>
          }
          groupBy: {
            args: Prisma.testcase_contentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Testcase_contentGroupByOutputType>[]
          }
          count: {
            args: Prisma.testcase_contentCountArgs<ExtArgs>,
            result: $Utils.Optional<Testcase_contentCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      userrole: {
        payload: Prisma.$userrolePayload<ExtArgs>
        fields: Prisma.userroleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userroleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userrolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userroleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          findFirst: {
            args: Prisma.userroleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userrolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userroleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          findMany: {
            args: Prisma.userroleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>[]
          }
          create: {
            args: Prisma.userroleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          createMany: {
            args: Prisma.userroleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userroleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          update: {
            args: Prisma.userroleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          deleteMany: {
            args: Prisma.userroleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userroleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userroleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          aggregate: {
            args: Prisma.UserroleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserrole>
          }
          groupBy: {
            args: Prisma.userroleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserroleGroupByOutputType>[]
          }
          count: {
            args: Prisma.userroleCountArgs<ExtArgs>,
            result: $Utils.Optional<UserroleCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClarificationCountOutputType
   */

  export type ClarificationCountOutputType = {
    other_clarification: number
    team_unread: number
  }

  export type ClarificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_clarification?: boolean | ClarificationCountOutputTypeCountOther_clarificationArgs
    team_unread?: boolean | ClarificationCountOutputTypeCountTeam_unreadArgs
  }

  // Custom InputTypes

  /**
   * ClarificationCountOutputType without action
   */
  export type ClarificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClarificationCountOutputType
     */
    select?: ClarificationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ClarificationCountOutputType without action
   */
  export type ClarificationCountOutputTypeCountOther_clarificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clarificationWhereInput
  }


  /**
   * ClarificationCountOutputType without action
   */
  export type ClarificationCountOutputTypeCountTeam_unreadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: team_unreadWhereInput
  }



  /**
   * Count Type ContestCountOutputType
   */

  export type ContestCountOutputType = {
    clarification: number
    contestproblem: number
    contestteam: number
    contestteamcategory: number
    contestteamcategoryformedals: number
    event: number
    external_judgement: number
    external_run: number
    internal_error: number
    judging: number
    rankcache: number
    removed_interval: number
    scorecache: number
    submission: number
  }

  export type ContestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clarification?: boolean | ContestCountOutputTypeCountClarificationArgs
    contestproblem?: boolean | ContestCountOutputTypeCountContestproblemArgs
    contestteam?: boolean | ContestCountOutputTypeCountContestteamArgs
    contestteamcategory?: boolean | ContestCountOutputTypeCountContestteamcategoryArgs
    contestteamcategoryformedals?: boolean | ContestCountOutputTypeCountContestteamcategoryformedalsArgs
    event?: boolean | ContestCountOutputTypeCountEventArgs
    external_judgement?: boolean | ContestCountOutputTypeCountExternal_judgementArgs
    external_run?: boolean | ContestCountOutputTypeCountExternal_runArgs
    internal_error?: boolean | ContestCountOutputTypeCountInternal_errorArgs
    judging?: boolean | ContestCountOutputTypeCountJudgingArgs
    rankcache?: boolean | ContestCountOutputTypeCountRankcacheArgs
    removed_interval?: boolean | ContestCountOutputTypeCountRemoved_intervalArgs
    scorecache?: boolean | ContestCountOutputTypeCountScorecacheArgs
    submission?: boolean | ContestCountOutputTypeCountSubmissionArgs
  }

  // Custom InputTypes

  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestCountOutputType
     */
    select?: ContestCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountClarificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clarificationWhereInput
  }


  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountContestproblemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contestproblemWhereInput
  }


  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountContestteamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contestteamWhereInput
  }


  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountContestteamcategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contestteamcategoryWhereInput
  }


  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountContestteamcategoryformedalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contestteamcategoryformedalsWhereInput
  }


  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: eventWhereInput
  }


  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountExternal_judgementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: external_judgementWhereInput
  }


  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountExternal_runArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: external_runWhereInput
  }


  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountInternal_errorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: internal_errorWhereInput
  }


  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountJudgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: judgingWhereInput
  }


  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountRankcacheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rankcacheWhereInput
  }


  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountRemoved_intervalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: removed_intervalWhereInput
  }


  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountScorecacheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: scorecacheWhereInput
  }


  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: submissionWhereInput
  }



  /**
   * Count Type ContestproblemCountOutputType
   */

  export type ContestproblemCountOutputType = {
    submission: number
  }

  export type ContestproblemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submission?: boolean | ContestproblemCountOutputTypeCountSubmissionArgs
  }

  // Custom InputTypes

  /**
   * ContestproblemCountOutputType without action
   */
  export type ContestproblemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestproblemCountOutputType
     */
    select?: ContestproblemCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ContestproblemCountOutputType without action
   */
  export type ContestproblemCountOutputTypeCountSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: submissionWhereInput
  }



  /**
   * Count Type ExecutableCountOutputType
   */

  export type ExecutableCountOutputType = {
    language: number
    problem_problem_special_runToexecutable: number
    problem_problem_special_compareToexecutable: number
  }

  export type ExecutableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    language?: boolean | ExecutableCountOutputTypeCountLanguageArgs
    problem_problem_special_runToexecutable?: boolean | ExecutableCountOutputTypeCountProblem_problem_special_runToexecutableArgs
    problem_problem_special_compareToexecutable?: boolean | ExecutableCountOutputTypeCountProblem_problem_special_compareToexecutableArgs
  }

  // Custom InputTypes

  /**
   * ExecutableCountOutputType without action
   */
  export type ExecutableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutableCountOutputType
     */
    select?: ExecutableCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ExecutableCountOutputType without action
   */
  export type ExecutableCountOutputTypeCountLanguageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: languageWhereInput
  }


  /**
   * ExecutableCountOutputType without action
   */
  export type ExecutableCountOutputTypeCountProblem_problem_special_runToexecutableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: problemWhereInput
  }


  /**
   * ExecutableCountOutputType without action
   */
  export type ExecutableCountOutputTypeCountProblem_problem_special_compareToexecutableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: problemWhereInput
  }



  /**
   * Count Type External_contest_sourceCountOutputType
   */

  export type External_contest_sourceCountOutputType = {
    external_source_warning: number
  }

  export type External_contest_sourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    external_source_warning?: boolean | External_contest_sourceCountOutputTypeCountExternal_source_warningArgs
  }

  // Custom InputTypes

  /**
   * External_contest_sourceCountOutputType without action
   */
  export type External_contest_sourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the External_contest_sourceCountOutputType
     */
    select?: External_contest_sourceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * External_contest_sourceCountOutputType without action
   */
  export type External_contest_sourceCountOutputTypeCountExternal_source_warningArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: external_source_warningWhereInput
  }



  /**
   * Count Type External_judgementCountOutputType
   */

  export type External_judgementCountOutputType = {
    external_run: number
  }

  export type External_judgementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    external_run?: boolean | External_judgementCountOutputTypeCountExternal_runArgs
  }

  // Custom InputTypes

  /**
   * External_judgementCountOutputType without action
   */
  export type External_judgementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the External_judgementCountOutputType
     */
    select?: External_judgementCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * External_judgementCountOutputType without action
   */
  export type External_judgementCountOutputTypeCountExternal_runArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: external_runWhereInput
  }



  /**
   * Count Type Immutable_executableCountOutputType
   */

  export type Immutable_executableCountOutputType = {
    executable_file: number
  }

  export type Immutable_executableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executable_file?: boolean | Immutable_executableCountOutputTypeCountExecutable_fileArgs
  }

  // Custom InputTypes

  /**
   * Immutable_executableCountOutputType without action
   */
  export type Immutable_executableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Immutable_executableCountOutputType
     */
    select?: Immutable_executableCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Immutable_executableCountOutputType without action
   */
  export type Immutable_executableCountOutputTypeCountExecutable_fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: executable_fileWhereInput
  }



  /**
   * Count Type Internal_errorCountOutputType
   */

  export type Internal_errorCountOutputType = {
    judging_judging_erroridTointernal_error: number
  }

  export type Internal_errorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    judging_judging_erroridTointernal_error?: boolean | Internal_errorCountOutputTypeCountJudging_judging_erroridTointernal_errorArgs
  }

  // Custom InputTypes

  /**
   * Internal_errorCountOutputType without action
   */
  export type Internal_errorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internal_errorCountOutputType
     */
    select?: Internal_errorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Internal_errorCountOutputType without action
   */
  export type Internal_errorCountOutputTypeCountJudging_judging_erroridTointernal_errorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: judgingWhereInput
  }



  /**
   * Count Type JudgehostCountOutputType
   */

  export type JudgehostCountOutputType = {
    debug_package: number
    judgetask: number
  }

  export type JudgehostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debug_package?: boolean | JudgehostCountOutputTypeCountDebug_packageArgs
    judgetask?: boolean | JudgehostCountOutputTypeCountJudgetaskArgs
  }

  // Custom InputTypes

  /**
   * JudgehostCountOutputType without action
   */
  export type JudgehostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JudgehostCountOutputType
     */
    select?: JudgehostCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * JudgehostCountOutputType without action
   */
  export type JudgehostCountOutputTypeCountDebug_packageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: debug_packageWhereInput
  }


  /**
   * JudgehostCountOutputType without action
   */
  export type JudgehostCountOutputTypeCountJudgetaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: judgetaskWhereInput
  }



  /**
   * Count Type JudgetaskCountOutputType
   */

  export type JudgetaskCountOutputType = {
    judging_run: number
  }

  export type JudgetaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    judging_run?: boolean | JudgetaskCountOutputTypeCountJudging_runArgs
  }

  // Custom InputTypes

  /**
   * JudgetaskCountOutputType without action
   */
  export type JudgetaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JudgetaskCountOutputType
     */
    select?: JudgetaskCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * JudgetaskCountOutputType without action
   */
  export type JudgetaskCountOutputTypeCountJudging_runArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: judging_runWhereInput
  }



  /**
   * Count Type JudgingCountOutputType
   */

  export type JudgingCountOutputType = {
    debug_package: number
    internal_error_internal_error_judgingidTojudging: number
    other_judging: number
    judging_run: number
  }

  export type JudgingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debug_package?: boolean | JudgingCountOutputTypeCountDebug_packageArgs
    internal_error_internal_error_judgingidTojudging?: boolean | JudgingCountOutputTypeCountInternal_error_internal_error_judgingidTojudgingArgs
    other_judging?: boolean | JudgingCountOutputTypeCountOther_judgingArgs
    judging_run?: boolean | JudgingCountOutputTypeCountJudging_runArgs
  }

  // Custom InputTypes

  /**
   * JudgingCountOutputType without action
   */
  export type JudgingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JudgingCountOutputType
     */
    select?: JudgingCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * JudgingCountOutputType without action
   */
  export type JudgingCountOutputTypeCountDebug_packageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: debug_packageWhereInput
  }


  /**
   * JudgingCountOutputType without action
   */
  export type JudgingCountOutputTypeCountInternal_error_internal_error_judgingidTojudgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: internal_errorWhereInput
  }


  /**
   * JudgingCountOutputType without action
   */
  export type JudgingCountOutputTypeCountOther_judgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: judgingWhereInput
  }


  /**
   * JudgingCountOutputType without action
   */
  export type JudgingCountOutputTypeCountJudging_runArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: judging_runWhereInput
  }



  /**
   * Count Type LanguageCountOutputType
   */

  export type LanguageCountOutputType = {
    submission: number
  }

  export type LanguageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submission?: boolean | LanguageCountOutputTypeCountSubmissionArgs
  }

  // Custom InputTypes

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageCountOutputType
     */
    select?: LanguageCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: submissionWhereInput
  }



  /**
   * Count Type ProblemCountOutputType
   */

  export type ProblemCountOutputType = {
    clarification: number
    contestproblem: number
    problem_attachment: number
    scorecache: number
    submission: number
    testcase: number
  }

  export type ProblemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clarification?: boolean | ProblemCountOutputTypeCountClarificationArgs
    contestproblem?: boolean | ProblemCountOutputTypeCountContestproblemArgs
    problem_attachment?: boolean | ProblemCountOutputTypeCountProblem_attachmentArgs
    scorecache?: boolean | ProblemCountOutputTypeCountScorecacheArgs
    submission?: boolean | ProblemCountOutputTypeCountSubmissionArgs
    testcase?: boolean | ProblemCountOutputTypeCountTestcaseArgs
  }

  // Custom InputTypes

  /**
   * ProblemCountOutputType without action
   */
  export type ProblemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProblemCountOutputType
     */
    select?: ProblemCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProblemCountOutputType without action
   */
  export type ProblemCountOutputTypeCountClarificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clarificationWhereInput
  }


  /**
   * ProblemCountOutputType without action
   */
  export type ProblemCountOutputTypeCountContestproblemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contestproblemWhereInput
  }


  /**
   * ProblemCountOutputType without action
   */
  export type ProblemCountOutputTypeCountProblem_attachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: problem_attachmentWhereInput
  }


  /**
   * ProblemCountOutputType without action
   */
  export type ProblemCountOutputTypeCountScorecacheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: scorecacheWhereInput
  }


  /**
   * ProblemCountOutputType without action
   */
  export type ProblemCountOutputTypeCountSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: submissionWhereInput
  }


  /**
   * ProblemCountOutputType without action
   */
  export type ProblemCountOutputTypeCountTestcaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: testcaseWhereInput
  }



  /**
   * Count Type RejudgingCountOutputType
   */

  export type RejudgingCountOutputType = {
    judging: number
    other_rejudging: number
    submission: number
  }

  export type RejudgingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    judging?: boolean | RejudgingCountOutputTypeCountJudgingArgs
    other_rejudging?: boolean | RejudgingCountOutputTypeCountOther_rejudgingArgs
    submission?: boolean | RejudgingCountOutputTypeCountSubmissionArgs
  }

  // Custom InputTypes

  /**
   * RejudgingCountOutputType without action
   */
  export type RejudgingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RejudgingCountOutputType
     */
    select?: RejudgingCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RejudgingCountOutputType without action
   */
  export type RejudgingCountOutputTypeCountJudgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: judgingWhereInput
  }


  /**
   * RejudgingCountOutputType without action
   */
  export type RejudgingCountOutputTypeCountOther_rejudgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rejudgingWhereInput
  }


  /**
   * RejudgingCountOutputType without action
   */
  export type RejudgingCountOutputTypeCountSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: submissionWhereInput
  }



  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    userrole: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userrole?: boolean | RoleCountOutputTypeCountUserroleArgs
  }

  // Custom InputTypes

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserroleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
  }



  /**
   * Count Type SubmissionCountOutputType
   */

  export type SubmissionCountOutputType = {
    balloon: number
    external_judgement: number
    judging: number
    other_submission: number
    submission_file: number
  }

  export type SubmissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    balloon?: boolean | SubmissionCountOutputTypeCountBalloonArgs
    external_judgement?: boolean | SubmissionCountOutputTypeCountExternal_judgementArgs
    judging?: boolean | SubmissionCountOutputTypeCountJudgingArgs
    other_submission?: boolean | SubmissionCountOutputTypeCountOther_submissionArgs
    submission_file?: boolean | SubmissionCountOutputTypeCountSubmission_fileArgs
  }

  // Custom InputTypes

  /**
   * SubmissionCountOutputType without action
   */
  export type SubmissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionCountOutputType
     */
    select?: SubmissionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SubmissionCountOutputType without action
   */
  export type SubmissionCountOutputTypeCountBalloonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: balloonWhereInput
  }


  /**
   * SubmissionCountOutputType without action
   */
  export type SubmissionCountOutputTypeCountExternal_judgementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: external_judgementWhereInput
  }


  /**
   * SubmissionCountOutputType without action
   */
  export type SubmissionCountOutputTypeCountJudgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: judgingWhereInput
  }


  /**
   * SubmissionCountOutputType without action
   */
  export type SubmissionCountOutputTypeCountOther_submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: submissionWhereInput
  }


  /**
   * SubmissionCountOutputType without action
   */
  export type SubmissionCountOutputTypeCountSubmission_fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: submission_fileWhereInput
  }



  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    clarification_clarification_senderToteam: number
    clarification_clarification_recipientToteam: number
    contestteam: number
    queuetask: number
    rankcache: number
    scorecache: number
    submission: number
    team_unread: number
    user: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clarification_clarification_senderToteam?: boolean | TeamCountOutputTypeCountClarification_clarification_senderToteamArgs
    clarification_clarification_recipientToteam?: boolean | TeamCountOutputTypeCountClarification_clarification_recipientToteamArgs
    contestteam?: boolean | TeamCountOutputTypeCountContestteamArgs
    queuetask?: boolean | TeamCountOutputTypeCountQueuetaskArgs
    rankcache?: boolean | TeamCountOutputTypeCountRankcacheArgs
    scorecache?: boolean | TeamCountOutputTypeCountScorecacheArgs
    submission?: boolean | TeamCountOutputTypeCountSubmissionArgs
    team_unread?: boolean | TeamCountOutputTypeCountTeam_unreadArgs
    user?: boolean | TeamCountOutputTypeCountUserArgs
  }

  // Custom InputTypes

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountClarification_clarification_senderToteamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clarificationWhereInput
  }


  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountClarification_clarification_recipientToteamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clarificationWhereInput
  }


  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountContestteamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contestteamWhereInput
  }


  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountQueuetaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: queuetaskWhereInput
  }


  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountRankcacheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rankcacheWhereInput
  }


  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountScorecacheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: scorecacheWhereInput
  }


  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: submissionWhereInput
  }


  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTeam_unreadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: team_unreadWhereInput
  }


  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }



  /**
   * Count Type Team_affiliationCountOutputType
   */

  export type Team_affiliationCountOutputType = {
    team: number
  }

  export type Team_affiliationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | Team_affiliationCountOutputTypeCountTeamArgs
  }

  // Custom InputTypes

  /**
   * Team_affiliationCountOutputType without action
   */
  export type Team_affiliationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team_affiliationCountOutputType
     */
    select?: Team_affiliationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Team_affiliationCountOutputType without action
   */
  export type Team_affiliationCountOutputTypeCountTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamWhereInput
  }



  /**
   * Count Type Team_categoryCountOutputType
   */

  export type Team_categoryCountOutputType = {
    contestteamcategory: number
    contestteamcategoryformedals: number
    team: number
  }

  export type Team_categoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contestteamcategory?: boolean | Team_categoryCountOutputTypeCountContestteamcategoryArgs
    contestteamcategoryformedals?: boolean | Team_categoryCountOutputTypeCountContestteamcategoryformedalsArgs
    team?: boolean | Team_categoryCountOutputTypeCountTeamArgs
  }

  // Custom InputTypes

  /**
   * Team_categoryCountOutputType without action
   */
  export type Team_categoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team_categoryCountOutputType
     */
    select?: Team_categoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Team_categoryCountOutputType without action
   */
  export type Team_categoryCountOutputTypeCountContestteamcategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contestteamcategoryWhereInput
  }


  /**
   * Team_categoryCountOutputType without action
   */
  export type Team_categoryCountOutputTypeCountContestteamcategoryformedalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contestteamcategoryformedalsWhereInput
  }


  /**
   * Team_categoryCountOutputType without action
   */
  export type Team_categoryCountOutputTypeCountTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamWhereInput
  }



  /**
   * Count Type TestcaseCountOutputType
   */

  export type TestcaseCountOutputType = {
    external_run: number
    judging_run: number
    testcase_content: number
  }

  export type TestcaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    external_run?: boolean | TestcaseCountOutputTypeCountExternal_runArgs
    judging_run?: boolean | TestcaseCountOutputTypeCountJudging_runArgs
    testcase_content?: boolean | TestcaseCountOutputTypeCountTestcase_contentArgs
  }

  // Custom InputTypes

  /**
   * TestcaseCountOutputType without action
   */
  export type TestcaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestcaseCountOutputType
     */
    select?: TestcaseCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TestcaseCountOutputType without action
   */
  export type TestcaseCountOutputTypeCountExternal_runArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: external_runWhereInput
  }


  /**
   * TestcaseCountOutputType without action
   */
  export type TestcaseCountOutputTypeCountJudging_runArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: judging_runWhereInput
  }


  /**
   * TestcaseCountOutputType without action
   */
  export type TestcaseCountOutputTypeCountTestcase_contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: testcase_contentWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    immutable_executable: number
    rejudging_rejudging_userid_startTouser: number
    rejudging_rejudging_userid_finishTouser: number
    submission: number
    userrole: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    immutable_executable?: boolean | UserCountOutputTypeCountImmutable_executableArgs
    rejudging_rejudging_userid_startTouser?: boolean | UserCountOutputTypeCountRejudging_rejudging_userid_startTouserArgs
    rejudging_rejudging_userid_finishTouser?: boolean | UserCountOutputTypeCountRejudging_rejudging_userid_finishTouserArgs
    submission?: boolean | UserCountOutputTypeCountSubmissionArgs
    userrole?: boolean | UserCountOutputTypeCountUserroleArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountImmutable_executableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: immutable_executableWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRejudging_rejudging_userid_startTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rejudgingWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRejudging_rejudging_userid_finishTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rejudgingWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: submissionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserroleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
  }



  /**
   * Models
   */

  /**
   * Model auditlog
   */

  export type AggregateAuditlog = {
    _count: AuditlogCountAggregateOutputType | null
    _avg: AuditlogAvgAggregateOutputType | null
    _sum: AuditlogSumAggregateOutputType | null
    _min: AuditlogMinAggregateOutputType | null
    _max: AuditlogMaxAggregateOutputType | null
  }

  export type AuditlogAvgAggregateOutputType = {
    logid: number | null
    logtime: Decimal | null
    cid: number | null
  }

  export type AuditlogSumAggregateOutputType = {
    logid: number | null
    logtime: Decimal | null
    cid: number | null
  }

  export type AuditlogMinAggregateOutputType = {
    logid: number | null
    logtime: Decimal | null
    cid: number | null
    user: string | null
    datatype: string | null
    dataid: string | null
    action: string | null
    extrainfo: string | null
  }

  export type AuditlogMaxAggregateOutputType = {
    logid: number | null
    logtime: Decimal | null
    cid: number | null
    user: string | null
    datatype: string | null
    dataid: string | null
    action: string | null
    extrainfo: string | null
  }

  export type AuditlogCountAggregateOutputType = {
    logid: number
    logtime: number
    cid: number
    user: number
    datatype: number
    dataid: number
    action: number
    extrainfo: number
    _all: number
  }


  export type AuditlogAvgAggregateInputType = {
    logid?: true
    logtime?: true
    cid?: true
  }

  export type AuditlogSumAggregateInputType = {
    logid?: true
    logtime?: true
    cid?: true
  }

  export type AuditlogMinAggregateInputType = {
    logid?: true
    logtime?: true
    cid?: true
    user?: true
    datatype?: true
    dataid?: true
    action?: true
    extrainfo?: true
  }

  export type AuditlogMaxAggregateInputType = {
    logid?: true
    logtime?: true
    cid?: true
    user?: true
    datatype?: true
    dataid?: true
    action?: true
    extrainfo?: true
  }

  export type AuditlogCountAggregateInputType = {
    logid?: true
    logtime?: true
    cid?: true
    user?: true
    datatype?: true
    dataid?: true
    action?: true
    extrainfo?: true
    _all?: true
  }

  export type AuditlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auditlog to aggregate.
     */
    where?: auditlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditlogs to fetch.
     */
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auditlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auditlogs
    **/
    _count?: true | AuditlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditlogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditlogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditlogMaxAggregateInputType
  }

  export type GetAuditlogAggregateType<T extends AuditlogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditlog[P]>
      : GetScalarType<T[P], AggregateAuditlog[P]>
  }




  export type auditlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditlogWhereInput
    orderBy?: auditlogOrderByWithAggregationInput | auditlogOrderByWithAggregationInput[]
    by: AuditlogScalarFieldEnum[] | AuditlogScalarFieldEnum
    having?: auditlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditlogCountAggregateInputType | true
    _avg?: AuditlogAvgAggregateInputType
    _sum?: AuditlogSumAggregateInputType
    _min?: AuditlogMinAggregateInputType
    _max?: AuditlogMaxAggregateInputType
  }

  export type AuditlogGroupByOutputType = {
    logid: number
    logtime: Decimal
    cid: number | null
    user: string | null
    datatype: string
    dataid: string | null
    action: string
    extrainfo: string | null
    _count: AuditlogCountAggregateOutputType | null
    _avg: AuditlogAvgAggregateOutputType | null
    _sum: AuditlogSumAggregateOutputType | null
    _min: AuditlogMinAggregateOutputType | null
    _max: AuditlogMaxAggregateOutputType | null
  }

  type GetAuditlogGroupByPayload<T extends auditlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditlogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditlogGroupByOutputType[P]>
        }
      >
    >


  export type auditlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    logid?: boolean
    logtime?: boolean
    cid?: boolean
    user?: boolean
    datatype?: boolean
    dataid?: boolean
    action?: boolean
    extrainfo?: boolean
  }, ExtArgs["result"]["auditlog"]>

  export type auditlogSelectScalar = {
    logid?: boolean
    logtime?: boolean
    cid?: boolean
    user?: boolean
    datatype?: boolean
    dataid?: boolean
    action?: boolean
    extrainfo?: boolean
  }


  export type $auditlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "auditlog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      logid: number
      logtime: Prisma.Decimal
      cid: number | null
      user: string | null
      datatype: string
      dataid: string | null
      action: string
      extrainfo: string | null
    }, ExtArgs["result"]["auditlog"]>
    composites: {}
  }


  type auditlogGetPayload<S extends boolean | null | undefined | auditlogDefaultArgs> = $Result.GetResult<Prisma.$auditlogPayload, S>

  type auditlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<auditlogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditlogCountAggregateInputType | true
    }

  export interface auditlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auditlog'], meta: { name: 'auditlog' } }
    /**
     * Find zero or one Auditlog that matches the filter.
     * @param {auditlogFindUniqueArgs} args - Arguments to find a Auditlog
     * @example
     * // Get one Auditlog
     * const auditlog = await prisma.auditlog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends auditlogFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, auditlogFindUniqueArgs<ExtArgs>>
    ): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Auditlog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {auditlogFindUniqueOrThrowArgs} args - Arguments to find a Auditlog
     * @example
     * // Get one Auditlog
     * const auditlog = await prisma.auditlog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends auditlogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, auditlogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Auditlog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogFindFirstArgs} args - Arguments to find a Auditlog
     * @example
     * // Get one Auditlog
     * const auditlog = await prisma.auditlog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends auditlogFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, auditlogFindFirstArgs<ExtArgs>>
    ): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Auditlog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogFindFirstOrThrowArgs} args - Arguments to find a Auditlog
     * @example
     * // Get one Auditlog
     * const auditlog = await prisma.auditlog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends auditlogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, auditlogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Auditlogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auditlogs
     * const auditlogs = await prisma.auditlog.findMany()
     * 
     * // Get first 10 Auditlogs
     * const auditlogs = await prisma.auditlog.findMany({ take: 10 })
     * 
     * // Only select the `logid`
     * const auditlogWithLogidOnly = await prisma.auditlog.findMany({ select: { logid: true } })
     * 
    **/
    findMany<T extends auditlogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, auditlogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Auditlog.
     * @param {auditlogCreateArgs} args - Arguments to create a Auditlog.
     * @example
     * // Create one Auditlog
     * const Auditlog = await prisma.auditlog.create({
     *   data: {
     *     // ... data to create a Auditlog
     *   }
     * })
     * 
    **/
    create<T extends auditlogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, auditlogCreateArgs<ExtArgs>>
    ): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Auditlogs.
     *     @param {auditlogCreateManyArgs} args - Arguments to create many Auditlogs.
     *     @example
     *     // Create many Auditlogs
     *     const auditlog = await prisma.auditlog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends auditlogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, auditlogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Auditlog.
     * @param {auditlogDeleteArgs} args - Arguments to delete one Auditlog.
     * @example
     * // Delete one Auditlog
     * const Auditlog = await prisma.auditlog.delete({
     *   where: {
     *     // ... filter to delete one Auditlog
     *   }
     * })
     * 
    **/
    delete<T extends auditlogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, auditlogDeleteArgs<ExtArgs>>
    ): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Auditlog.
     * @param {auditlogUpdateArgs} args - Arguments to update one Auditlog.
     * @example
     * // Update one Auditlog
     * const auditlog = await prisma.auditlog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends auditlogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, auditlogUpdateArgs<ExtArgs>>
    ): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Auditlogs.
     * @param {auditlogDeleteManyArgs} args - Arguments to filter Auditlogs to delete.
     * @example
     * // Delete a few Auditlogs
     * const { count } = await prisma.auditlog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends auditlogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, auditlogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auditlogs
     * const auditlog = await prisma.auditlog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends auditlogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, auditlogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Auditlog.
     * @param {auditlogUpsertArgs} args - Arguments to update or create a Auditlog.
     * @example
     * // Update or create a Auditlog
     * const auditlog = await prisma.auditlog.upsert({
     *   create: {
     *     // ... data to create a Auditlog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auditlog we want to update
     *   }
     * })
    **/
    upsert<T extends auditlogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, auditlogUpsertArgs<ExtArgs>>
    ): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Auditlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogCountArgs} args - Arguments to filter Auditlogs to count.
     * @example
     * // Count the number of Auditlogs
     * const count = await prisma.auditlog.count({
     *   where: {
     *     // ... the filter for the Auditlogs we want to count
     *   }
     * })
    **/
    count<T extends auditlogCountArgs>(
      args?: Subset<T, auditlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auditlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditlogAggregateArgs>(args: Subset<T, AuditlogAggregateArgs>): Prisma.PrismaPromise<GetAuditlogAggregateType<T>>

    /**
     * Group by Auditlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auditlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auditlogGroupByArgs['orderBy'] }
        : { orderBy?: auditlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auditlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auditlog model
   */
  readonly fields: auditlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auditlog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auditlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the auditlog model
   */ 
  interface auditlogFieldRefs {
    readonly logid: FieldRef<"auditlog", 'Int'>
    readonly logtime: FieldRef<"auditlog", 'Decimal'>
    readonly cid: FieldRef<"auditlog", 'Int'>
    readonly user: FieldRef<"auditlog", 'String'>
    readonly datatype: FieldRef<"auditlog", 'String'>
    readonly dataid: FieldRef<"auditlog", 'String'>
    readonly action: FieldRef<"auditlog", 'String'>
    readonly extrainfo: FieldRef<"auditlog", 'String'>
  }
    

  // Custom InputTypes

  /**
   * auditlog findUnique
   */
  export type auditlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Filter, which auditlog to fetch.
     */
    where: auditlogWhereUniqueInput
  }


  /**
   * auditlog findUniqueOrThrow
   */
  export type auditlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Filter, which auditlog to fetch.
     */
    where: auditlogWhereUniqueInput
  }


  /**
   * auditlog findFirst
   */
  export type auditlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Filter, which auditlog to fetch.
     */
    where?: auditlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditlogs to fetch.
     */
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditlogs.
     */
    cursor?: auditlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditlogs.
     */
    distinct?: AuditlogScalarFieldEnum | AuditlogScalarFieldEnum[]
  }


  /**
   * auditlog findFirstOrThrow
   */
  export type auditlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Filter, which auditlog to fetch.
     */
    where?: auditlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditlogs to fetch.
     */
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditlogs.
     */
    cursor?: auditlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditlogs.
     */
    distinct?: AuditlogScalarFieldEnum | AuditlogScalarFieldEnum[]
  }


  /**
   * auditlog findMany
   */
  export type auditlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Filter, which auditlogs to fetch.
     */
    where?: auditlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditlogs to fetch.
     */
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auditlogs.
     */
    cursor?: auditlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditlogs.
     */
    skip?: number
    distinct?: AuditlogScalarFieldEnum | AuditlogScalarFieldEnum[]
  }


  /**
   * auditlog create
   */
  export type auditlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * The data needed to create a auditlog.
     */
    data: XOR<auditlogCreateInput, auditlogUncheckedCreateInput>
  }


  /**
   * auditlog createMany
   */
  export type auditlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auditlogs.
     */
    data: auditlogCreateManyInput | auditlogCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * auditlog update
   */
  export type auditlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * The data needed to update a auditlog.
     */
    data: XOR<auditlogUpdateInput, auditlogUncheckedUpdateInput>
    /**
     * Choose, which auditlog to update.
     */
    where: auditlogWhereUniqueInput
  }


  /**
   * auditlog updateMany
   */
  export type auditlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auditlogs.
     */
    data: XOR<auditlogUpdateManyMutationInput, auditlogUncheckedUpdateManyInput>
    /**
     * Filter which auditlogs to update
     */
    where?: auditlogWhereInput
  }


  /**
   * auditlog upsert
   */
  export type auditlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * The filter to search for the auditlog to update in case it exists.
     */
    where: auditlogWhereUniqueInput
    /**
     * In case the auditlog found by the `where` argument doesn't exist, create a new auditlog with this data.
     */
    create: XOR<auditlogCreateInput, auditlogUncheckedCreateInput>
    /**
     * In case the auditlog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auditlogUpdateInput, auditlogUncheckedUpdateInput>
  }


  /**
   * auditlog delete
   */
  export type auditlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Filter which auditlog to delete.
     */
    where: auditlogWhereUniqueInput
  }


  /**
   * auditlog deleteMany
   */
  export type auditlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auditlogs to delete
     */
    where?: auditlogWhereInput
  }


  /**
   * auditlog without action
   */
  export type auditlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
  }



  /**
   * Model balloon
   */

  export type AggregateBalloon = {
    _count: BalloonCountAggregateOutputType | null
    _avg: BalloonAvgAggregateOutputType | null
    _sum: BalloonSumAggregateOutputType | null
    _min: BalloonMinAggregateOutputType | null
    _max: BalloonMaxAggregateOutputType | null
  }

  export type BalloonAvgAggregateOutputType = {
    balloonid: number | null
    submitid: number | null
  }

  export type BalloonSumAggregateOutputType = {
    balloonid: number | null
    submitid: number | null
  }

  export type BalloonMinAggregateOutputType = {
    balloonid: number | null
    submitid: number | null
    done: boolean | null
  }

  export type BalloonMaxAggregateOutputType = {
    balloonid: number | null
    submitid: number | null
    done: boolean | null
  }

  export type BalloonCountAggregateOutputType = {
    balloonid: number
    submitid: number
    done: number
    _all: number
  }


  export type BalloonAvgAggregateInputType = {
    balloonid?: true
    submitid?: true
  }

  export type BalloonSumAggregateInputType = {
    balloonid?: true
    submitid?: true
  }

  export type BalloonMinAggregateInputType = {
    balloonid?: true
    submitid?: true
    done?: true
  }

  export type BalloonMaxAggregateInputType = {
    balloonid?: true
    submitid?: true
    done?: true
  }

  export type BalloonCountAggregateInputType = {
    balloonid?: true
    submitid?: true
    done?: true
    _all?: true
  }

  export type BalloonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which balloon to aggregate.
     */
    where?: balloonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of balloons to fetch.
     */
    orderBy?: balloonOrderByWithRelationInput | balloonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: balloonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` balloons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` balloons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned balloons
    **/
    _count?: true | BalloonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BalloonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BalloonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BalloonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BalloonMaxAggregateInputType
  }

  export type GetBalloonAggregateType<T extends BalloonAggregateArgs> = {
        [P in keyof T & keyof AggregateBalloon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBalloon[P]>
      : GetScalarType<T[P], AggregateBalloon[P]>
  }




  export type balloonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: balloonWhereInput
    orderBy?: balloonOrderByWithAggregationInput | balloonOrderByWithAggregationInput[]
    by: BalloonScalarFieldEnum[] | BalloonScalarFieldEnum
    having?: balloonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BalloonCountAggregateInputType | true
    _avg?: BalloonAvgAggregateInputType
    _sum?: BalloonSumAggregateInputType
    _min?: BalloonMinAggregateInputType
    _max?: BalloonMaxAggregateInputType
  }

  export type BalloonGroupByOutputType = {
    balloonid: number
    submitid: number | null
    done: boolean
    _count: BalloonCountAggregateOutputType | null
    _avg: BalloonAvgAggregateOutputType | null
    _sum: BalloonSumAggregateOutputType | null
    _min: BalloonMinAggregateOutputType | null
    _max: BalloonMaxAggregateOutputType | null
  }

  type GetBalloonGroupByPayload<T extends balloonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BalloonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BalloonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BalloonGroupByOutputType[P]>
            : GetScalarType<T[P], BalloonGroupByOutputType[P]>
        }
      >
    >


  export type balloonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    balloonid?: boolean
    submitid?: boolean
    done?: boolean
    submission?: boolean | balloon$submissionArgs<ExtArgs>
  }, ExtArgs["result"]["balloon"]>

  export type balloonSelectScalar = {
    balloonid?: boolean
    submitid?: boolean
    done?: boolean
  }

  export type balloonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submission?: boolean | balloon$submissionArgs<ExtArgs>
  }


  export type $balloonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "balloon"
    objects: {
      submission: Prisma.$submissionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      balloonid: number
      submitid: number | null
      done: boolean
    }, ExtArgs["result"]["balloon"]>
    composites: {}
  }


  type balloonGetPayload<S extends boolean | null | undefined | balloonDefaultArgs> = $Result.GetResult<Prisma.$balloonPayload, S>

  type balloonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<balloonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BalloonCountAggregateInputType | true
    }

  export interface balloonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['balloon'], meta: { name: 'balloon' } }
    /**
     * Find zero or one Balloon that matches the filter.
     * @param {balloonFindUniqueArgs} args - Arguments to find a Balloon
     * @example
     * // Get one Balloon
     * const balloon = await prisma.balloon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends balloonFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, balloonFindUniqueArgs<ExtArgs>>
    ): Prisma__balloonClient<$Result.GetResult<Prisma.$balloonPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Balloon that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {balloonFindUniqueOrThrowArgs} args - Arguments to find a Balloon
     * @example
     * // Get one Balloon
     * const balloon = await prisma.balloon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends balloonFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, balloonFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__balloonClient<$Result.GetResult<Prisma.$balloonPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Balloon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balloonFindFirstArgs} args - Arguments to find a Balloon
     * @example
     * // Get one Balloon
     * const balloon = await prisma.balloon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends balloonFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, balloonFindFirstArgs<ExtArgs>>
    ): Prisma__balloonClient<$Result.GetResult<Prisma.$balloonPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Balloon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balloonFindFirstOrThrowArgs} args - Arguments to find a Balloon
     * @example
     * // Get one Balloon
     * const balloon = await prisma.balloon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends balloonFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, balloonFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__balloonClient<$Result.GetResult<Prisma.$balloonPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Balloons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balloonFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Balloons
     * const balloons = await prisma.balloon.findMany()
     * 
     * // Get first 10 Balloons
     * const balloons = await prisma.balloon.findMany({ take: 10 })
     * 
     * // Only select the `balloonid`
     * const balloonWithBalloonidOnly = await prisma.balloon.findMany({ select: { balloonid: true } })
     * 
    **/
    findMany<T extends balloonFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, balloonFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$balloonPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Balloon.
     * @param {balloonCreateArgs} args - Arguments to create a Balloon.
     * @example
     * // Create one Balloon
     * const Balloon = await prisma.balloon.create({
     *   data: {
     *     // ... data to create a Balloon
     *   }
     * })
     * 
    **/
    create<T extends balloonCreateArgs<ExtArgs>>(
      args: SelectSubset<T, balloonCreateArgs<ExtArgs>>
    ): Prisma__balloonClient<$Result.GetResult<Prisma.$balloonPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Balloons.
     *     @param {balloonCreateManyArgs} args - Arguments to create many Balloons.
     *     @example
     *     // Create many Balloons
     *     const balloon = await prisma.balloon.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends balloonCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, balloonCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Balloon.
     * @param {balloonDeleteArgs} args - Arguments to delete one Balloon.
     * @example
     * // Delete one Balloon
     * const Balloon = await prisma.balloon.delete({
     *   where: {
     *     // ... filter to delete one Balloon
     *   }
     * })
     * 
    **/
    delete<T extends balloonDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, balloonDeleteArgs<ExtArgs>>
    ): Prisma__balloonClient<$Result.GetResult<Prisma.$balloonPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Balloon.
     * @param {balloonUpdateArgs} args - Arguments to update one Balloon.
     * @example
     * // Update one Balloon
     * const balloon = await prisma.balloon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends balloonUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, balloonUpdateArgs<ExtArgs>>
    ): Prisma__balloonClient<$Result.GetResult<Prisma.$balloonPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Balloons.
     * @param {balloonDeleteManyArgs} args - Arguments to filter Balloons to delete.
     * @example
     * // Delete a few Balloons
     * const { count } = await prisma.balloon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends balloonDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, balloonDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Balloons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balloonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Balloons
     * const balloon = await prisma.balloon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends balloonUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, balloonUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Balloon.
     * @param {balloonUpsertArgs} args - Arguments to update or create a Balloon.
     * @example
     * // Update or create a Balloon
     * const balloon = await prisma.balloon.upsert({
     *   create: {
     *     // ... data to create a Balloon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Balloon we want to update
     *   }
     * })
    **/
    upsert<T extends balloonUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, balloonUpsertArgs<ExtArgs>>
    ): Prisma__balloonClient<$Result.GetResult<Prisma.$balloonPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Balloons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balloonCountArgs} args - Arguments to filter Balloons to count.
     * @example
     * // Count the number of Balloons
     * const count = await prisma.balloon.count({
     *   where: {
     *     // ... the filter for the Balloons we want to count
     *   }
     * })
    **/
    count<T extends balloonCountArgs>(
      args?: Subset<T, balloonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BalloonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Balloon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalloonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BalloonAggregateArgs>(args: Subset<T, BalloonAggregateArgs>): Prisma.PrismaPromise<GetBalloonAggregateType<T>>

    /**
     * Group by Balloon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balloonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends balloonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: balloonGroupByArgs['orderBy'] }
        : { orderBy?: balloonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, balloonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBalloonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the balloon model
   */
  readonly fields: balloonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for balloon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__balloonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    submission<T extends balloon$submissionArgs<ExtArgs> = {}>(args?: Subset<T, balloon$submissionArgs<ExtArgs>>): Prisma__submissionClient<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the balloon model
   */ 
  interface balloonFieldRefs {
    readonly balloonid: FieldRef<"balloon", 'Int'>
    readonly submitid: FieldRef<"balloon", 'Int'>
    readonly done: FieldRef<"balloon", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * balloon findUnique
   */
  export type balloonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balloon
     */
    select?: balloonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: balloonInclude<ExtArgs> | null
    /**
     * Filter, which balloon to fetch.
     */
    where: balloonWhereUniqueInput
  }


  /**
   * balloon findUniqueOrThrow
   */
  export type balloonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balloon
     */
    select?: balloonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: balloonInclude<ExtArgs> | null
    /**
     * Filter, which balloon to fetch.
     */
    where: balloonWhereUniqueInput
  }


  /**
   * balloon findFirst
   */
  export type balloonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balloon
     */
    select?: balloonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: balloonInclude<ExtArgs> | null
    /**
     * Filter, which balloon to fetch.
     */
    where?: balloonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of balloons to fetch.
     */
    orderBy?: balloonOrderByWithRelationInput | balloonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for balloons.
     */
    cursor?: balloonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` balloons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` balloons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of balloons.
     */
    distinct?: BalloonScalarFieldEnum | BalloonScalarFieldEnum[]
  }


  /**
   * balloon findFirstOrThrow
   */
  export type balloonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balloon
     */
    select?: balloonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: balloonInclude<ExtArgs> | null
    /**
     * Filter, which balloon to fetch.
     */
    where?: balloonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of balloons to fetch.
     */
    orderBy?: balloonOrderByWithRelationInput | balloonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for balloons.
     */
    cursor?: balloonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` balloons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` balloons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of balloons.
     */
    distinct?: BalloonScalarFieldEnum | BalloonScalarFieldEnum[]
  }


  /**
   * balloon findMany
   */
  export type balloonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balloon
     */
    select?: balloonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: balloonInclude<ExtArgs> | null
    /**
     * Filter, which balloons to fetch.
     */
    where?: balloonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of balloons to fetch.
     */
    orderBy?: balloonOrderByWithRelationInput | balloonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing balloons.
     */
    cursor?: balloonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` balloons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` balloons.
     */
    skip?: number
    distinct?: BalloonScalarFieldEnum | BalloonScalarFieldEnum[]
  }


  /**
   * balloon create
   */
  export type balloonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balloon
     */
    select?: balloonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: balloonInclude<ExtArgs> | null
    /**
     * The data needed to create a balloon.
     */
    data?: XOR<balloonCreateInput, balloonUncheckedCreateInput>
  }


  /**
   * balloon createMany
   */
  export type balloonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many balloons.
     */
    data: balloonCreateManyInput | balloonCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * balloon update
   */
  export type balloonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balloon
     */
    select?: balloonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: balloonInclude<ExtArgs> | null
    /**
     * The data needed to update a balloon.
     */
    data: XOR<balloonUpdateInput, balloonUncheckedUpdateInput>
    /**
     * Choose, which balloon to update.
     */
    where: balloonWhereUniqueInput
  }


  /**
   * balloon updateMany
   */
  export type balloonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update balloons.
     */
    data: XOR<balloonUpdateManyMutationInput, balloonUncheckedUpdateManyInput>
    /**
     * Filter which balloons to update
     */
    where?: balloonWhereInput
  }


  /**
   * balloon upsert
   */
  export type balloonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balloon
     */
    select?: balloonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: balloonInclude<ExtArgs> | null
    /**
     * The filter to search for the balloon to update in case it exists.
     */
    where: balloonWhereUniqueInput
    /**
     * In case the balloon found by the `where` argument doesn't exist, create a new balloon with this data.
     */
    create: XOR<balloonCreateInput, balloonUncheckedCreateInput>
    /**
     * In case the balloon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<balloonUpdateInput, balloonUncheckedUpdateInput>
  }


  /**
   * balloon delete
   */
  export type balloonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balloon
     */
    select?: balloonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: balloonInclude<ExtArgs> | null
    /**
     * Filter which balloon to delete.
     */
    where: balloonWhereUniqueInput
  }


  /**
   * balloon deleteMany
   */
  export type balloonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which balloons to delete
     */
    where?: balloonWhereInput
  }


  /**
   * balloon.submission
   */
  export type balloon$submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    where?: submissionWhereInput
  }


  /**
   * balloon without action
   */
  export type balloonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balloon
     */
    select?: balloonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: balloonInclude<ExtArgs> | null
  }



  /**
   * Model clarification
   */

  export type AggregateClarification = {
    _count: ClarificationCountAggregateOutputType | null
    _avg: ClarificationAvgAggregateOutputType | null
    _sum: ClarificationSumAggregateOutputType | null
    _min: ClarificationMinAggregateOutputType | null
    _max: ClarificationMaxAggregateOutputType | null
  }

  export type ClarificationAvgAggregateOutputType = {
    clarid: number | null
    cid: number | null
    respid: number | null
    submittime: Decimal | null
    sender: number | null
    recipient: number | null
    probid: number | null
  }

  export type ClarificationSumAggregateOutputType = {
    clarid: number | null
    cid: number | null
    respid: number | null
    submittime: Decimal | null
    sender: number | null
    recipient: number | null
    probid: number | null
  }

  export type ClarificationMinAggregateOutputType = {
    clarid: number | null
    externalid: string | null
    cid: number | null
    respid: number | null
    submittime: Decimal | null
    sender: number | null
    recipient: number | null
    jury_member: string | null
    probid: number | null
    category: string | null
    queue: string | null
    body: string | null
    answered: boolean | null
  }

  export type ClarificationMaxAggregateOutputType = {
    clarid: number | null
    externalid: string | null
    cid: number | null
    respid: number | null
    submittime: Decimal | null
    sender: number | null
    recipient: number | null
    jury_member: string | null
    probid: number | null
    category: string | null
    queue: string | null
    body: string | null
    answered: boolean | null
  }

  export type ClarificationCountAggregateOutputType = {
    clarid: number
    externalid: number
    cid: number
    respid: number
    submittime: number
    sender: number
    recipient: number
    jury_member: number
    probid: number
    category: number
    queue: number
    body: number
    answered: number
    _all: number
  }


  export type ClarificationAvgAggregateInputType = {
    clarid?: true
    cid?: true
    respid?: true
    submittime?: true
    sender?: true
    recipient?: true
    probid?: true
  }

  export type ClarificationSumAggregateInputType = {
    clarid?: true
    cid?: true
    respid?: true
    submittime?: true
    sender?: true
    recipient?: true
    probid?: true
  }

  export type ClarificationMinAggregateInputType = {
    clarid?: true
    externalid?: true
    cid?: true
    respid?: true
    submittime?: true
    sender?: true
    recipient?: true
    jury_member?: true
    probid?: true
    category?: true
    queue?: true
    body?: true
    answered?: true
  }

  export type ClarificationMaxAggregateInputType = {
    clarid?: true
    externalid?: true
    cid?: true
    respid?: true
    submittime?: true
    sender?: true
    recipient?: true
    jury_member?: true
    probid?: true
    category?: true
    queue?: true
    body?: true
    answered?: true
  }

  export type ClarificationCountAggregateInputType = {
    clarid?: true
    externalid?: true
    cid?: true
    respid?: true
    submittime?: true
    sender?: true
    recipient?: true
    jury_member?: true
    probid?: true
    category?: true
    queue?: true
    body?: true
    answered?: true
    _all?: true
  }

  export type ClarificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clarification to aggregate.
     */
    where?: clarificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clarifications to fetch.
     */
    orderBy?: clarificationOrderByWithRelationInput | clarificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clarificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clarifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clarifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clarifications
    **/
    _count?: true | ClarificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClarificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClarificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClarificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClarificationMaxAggregateInputType
  }

  export type GetClarificationAggregateType<T extends ClarificationAggregateArgs> = {
        [P in keyof T & keyof AggregateClarification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClarification[P]>
      : GetScalarType<T[P], AggregateClarification[P]>
  }




  export type clarificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clarificationWhereInput
    orderBy?: clarificationOrderByWithAggregationInput | clarificationOrderByWithAggregationInput[]
    by: ClarificationScalarFieldEnum[] | ClarificationScalarFieldEnum
    having?: clarificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClarificationCountAggregateInputType | true
    _avg?: ClarificationAvgAggregateInputType
    _sum?: ClarificationSumAggregateInputType
    _min?: ClarificationMinAggregateInputType
    _max?: ClarificationMaxAggregateInputType
  }

  export type ClarificationGroupByOutputType = {
    clarid: number
    externalid: string | null
    cid: number | null
    respid: number | null
    submittime: Decimal
    sender: number | null
    recipient: number | null
    jury_member: string | null
    probid: number | null
    category: string | null
    queue: string | null
    body: string
    answered: boolean
    _count: ClarificationCountAggregateOutputType | null
    _avg: ClarificationAvgAggregateOutputType | null
    _sum: ClarificationSumAggregateOutputType | null
    _min: ClarificationMinAggregateOutputType | null
    _max: ClarificationMaxAggregateOutputType | null
  }

  type GetClarificationGroupByPayload<T extends clarificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClarificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClarificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClarificationGroupByOutputType[P]>
            : GetScalarType<T[P], ClarificationGroupByOutputType[P]>
        }
      >
    >


  export type clarificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clarid?: boolean
    externalid?: boolean
    cid?: boolean
    respid?: boolean
    submittime?: boolean
    sender?: boolean
    recipient?: boolean
    jury_member?: boolean
    probid?: boolean
    category?: boolean
    queue?: boolean
    body?: boolean
    answered?: boolean
    contest?: boolean | clarification$contestArgs<ExtArgs>
    clarification?: boolean | clarification$clarificationArgs<ExtArgs>
    other_clarification?: boolean | clarification$other_clarificationArgs<ExtArgs>
    problem?: boolean | clarification$problemArgs<ExtArgs>
    team_clarification_senderToteam?: boolean | clarification$team_clarification_senderToteamArgs<ExtArgs>
    team_clarification_recipientToteam?: boolean | clarification$team_clarification_recipientToteamArgs<ExtArgs>
    team_unread?: boolean | clarification$team_unreadArgs<ExtArgs>
    _count?: boolean | ClarificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clarification"]>

  export type clarificationSelectScalar = {
    clarid?: boolean
    externalid?: boolean
    cid?: boolean
    respid?: boolean
    submittime?: boolean
    sender?: boolean
    recipient?: boolean
    jury_member?: boolean
    probid?: boolean
    category?: boolean
    queue?: boolean
    body?: boolean
    answered?: boolean
  }

  export type clarificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contest?: boolean | clarification$contestArgs<ExtArgs>
    clarification?: boolean | clarification$clarificationArgs<ExtArgs>
    other_clarification?: boolean | clarification$other_clarificationArgs<ExtArgs>
    problem?: boolean | clarification$problemArgs<ExtArgs>
    team_clarification_senderToteam?: boolean | clarification$team_clarification_senderToteamArgs<ExtArgs>
    team_clarification_recipientToteam?: boolean | clarification$team_clarification_recipientToteamArgs<ExtArgs>
    team_unread?: boolean | clarification$team_unreadArgs<ExtArgs>
    _count?: boolean | ClarificationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $clarificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clarification"
    objects: {
      contest: Prisma.$contestPayload<ExtArgs> | null
      clarification: Prisma.$clarificationPayload<ExtArgs> | null
      other_clarification: Prisma.$clarificationPayload<ExtArgs>[]
      problem: Prisma.$problemPayload<ExtArgs> | null
      team_clarification_senderToteam: Prisma.$teamPayload<ExtArgs> | null
      team_clarification_recipientToteam: Prisma.$teamPayload<ExtArgs> | null
      team_unread: Prisma.$team_unreadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      clarid: number
      externalid: string | null
      cid: number | null
      respid: number | null
      submittime: Prisma.Decimal
      sender: number | null
      recipient: number | null
      jury_member: string | null
      probid: number | null
      category: string | null
      queue: string | null
      body: string
      answered: boolean
    }, ExtArgs["result"]["clarification"]>
    composites: {}
  }


  type clarificationGetPayload<S extends boolean | null | undefined | clarificationDefaultArgs> = $Result.GetResult<Prisma.$clarificationPayload, S>

  type clarificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<clarificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClarificationCountAggregateInputType | true
    }

  export interface clarificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clarification'], meta: { name: 'clarification' } }
    /**
     * Find zero or one Clarification that matches the filter.
     * @param {clarificationFindUniqueArgs} args - Arguments to find a Clarification
     * @example
     * // Get one Clarification
     * const clarification = await prisma.clarification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends clarificationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, clarificationFindUniqueArgs<ExtArgs>>
    ): Prisma__clarificationClient<$Result.GetResult<Prisma.$clarificationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Clarification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {clarificationFindUniqueOrThrowArgs} args - Arguments to find a Clarification
     * @example
     * // Get one Clarification
     * const clarification = await prisma.clarification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends clarificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, clarificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__clarificationClient<$Result.GetResult<Prisma.$clarificationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Clarification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clarificationFindFirstArgs} args - Arguments to find a Clarification
     * @example
     * // Get one Clarification
     * const clarification = await prisma.clarification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends clarificationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, clarificationFindFirstArgs<ExtArgs>>
    ): Prisma__clarificationClient<$Result.GetResult<Prisma.$clarificationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Clarification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clarificationFindFirstOrThrowArgs} args - Arguments to find a Clarification
     * @example
     * // Get one Clarification
     * const clarification = await prisma.clarification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends clarificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, clarificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__clarificationClient<$Result.GetResult<Prisma.$clarificationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Clarifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clarificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clarifications
     * const clarifications = await prisma.clarification.findMany()
     * 
     * // Get first 10 Clarifications
     * const clarifications = await prisma.clarification.findMany({ take: 10 })
     * 
     * // Only select the `clarid`
     * const clarificationWithClaridOnly = await prisma.clarification.findMany({ select: { clarid: true } })
     * 
    **/
    findMany<T extends clarificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, clarificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clarificationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Clarification.
     * @param {clarificationCreateArgs} args - Arguments to create a Clarification.
     * @example
     * // Create one Clarification
     * const Clarification = await prisma.clarification.create({
     *   data: {
     *     // ... data to create a Clarification
     *   }
     * })
     * 
    **/
    create<T extends clarificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, clarificationCreateArgs<ExtArgs>>
    ): Prisma__clarificationClient<$Result.GetResult<Prisma.$clarificationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Clarifications.
     *     @param {clarificationCreateManyArgs} args - Arguments to create many Clarifications.
     *     @example
     *     // Create many Clarifications
     *     const clarification = await prisma.clarification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends clarificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, clarificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Clarification.
     * @param {clarificationDeleteArgs} args - Arguments to delete one Clarification.
     * @example
     * // Delete one Clarification
     * const Clarification = await prisma.clarification.delete({
     *   where: {
     *     // ... filter to delete one Clarification
     *   }
     * })
     * 
    **/
    delete<T extends clarificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, clarificationDeleteArgs<ExtArgs>>
    ): Prisma__clarificationClient<$Result.GetResult<Prisma.$clarificationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Clarification.
     * @param {clarificationUpdateArgs} args - Arguments to update one Clarification.
     * @example
     * // Update one Clarification
     * const clarification = await prisma.clarification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends clarificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, clarificationUpdateArgs<ExtArgs>>
    ): Prisma__clarificationClient<$Result.GetResult<Prisma.$clarificationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Clarifications.
     * @param {clarificationDeleteManyArgs} args - Arguments to filter Clarifications to delete.
     * @example
     * // Delete a few Clarifications
     * const { count } = await prisma.clarification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends clarificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, clarificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clarifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clarificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clarifications
     * const clarification = await prisma.clarification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends clarificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, clarificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clarification.
     * @param {clarificationUpsertArgs} args - Arguments to update or create a Clarification.
     * @example
     * // Update or create a Clarification
     * const clarification = await prisma.clarification.upsert({
     *   create: {
     *     // ... data to create a Clarification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clarification we want to update
     *   }
     * })
    **/
    upsert<T extends clarificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, clarificationUpsertArgs<ExtArgs>>
    ): Prisma__clarificationClient<$Result.GetResult<Prisma.$clarificationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Clarifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clarificationCountArgs} args - Arguments to filter Clarifications to count.
     * @example
     * // Count the number of Clarifications
     * const count = await prisma.clarification.count({
     *   where: {
     *     // ... the filter for the Clarifications we want to count
     *   }
     * })
    **/
    count<T extends clarificationCountArgs>(
      args?: Subset<T, clarificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClarificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clarification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClarificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClarificationAggregateArgs>(args: Subset<T, ClarificationAggregateArgs>): Prisma.PrismaPromise<GetClarificationAggregateType<T>>

    /**
     * Group by Clarification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clarificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clarificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clarificationGroupByArgs['orderBy'] }
        : { orderBy?: clarificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clarificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClarificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clarification model
   */
  readonly fields: clarificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clarification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clarificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contest<T extends clarification$contestArgs<ExtArgs> = {}>(args?: Subset<T, clarification$contestArgs<ExtArgs>>): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    clarification<T extends clarification$clarificationArgs<ExtArgs> = {}>(args?: Subset<T, clarification$clarificationArgs<ExtArgs>>): Prisma__clarificationClient<$Result.GetResult<Prisma.$clarificationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    other_clarification<T extends clarification$other_clarificationArgs<ExtArgs> = {}>(args?: Subset<T, clarification$other_clarificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clarificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    problem<T extends clarification$problemArgs<ExtArgs> = {}>(args?: Subset<T, clarification$problemArgs<ExtArgs>>): Prisma__problemClient<$Result.GetResult<Prisma.$problemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    team_clarification_senderToteam<T extends clarification$team_clarification_senderToteamArgs<ExtArgs> = {}>(args?: Subset<T, clarification$team_clarification_senderToteamArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    team_clarification_recipientToteam<T extends clarification$team_clarification_recipientToteamArgs<ExtArgs> = {}>(args?: Subset<T, clarification$team_clarification_recipientToteamArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    team_unread<T extends clarification$team_unreadArgs<ExtArgs> = {}>(args?: Subset<T, clarification$team_unreadArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$team_unreadPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the clarification model
   */ 
  interface clarificationFieldRefs {
    readonly clarid: FieldRef<"clarification", 'Int'>
    readonly externalid: FieldRef<"clarification", 'String'>
    readonly cid: FieldRef<"clarification", 'Int'>
    readonly respid: FieldRef<"clarification", 'Int'>
    readonly submittime: FieldRef<"clarification", 'Decimal'>
    readonly sender: FieldRef<"clarification", 'Int'>
    readonly recipient: FieldRef<"clarification", 'Int'>
    readonly jury_member: FieldRef<"clarification", 'String'>
    readonly probid: FieldRef<"clarification", 'Int'>
    readonly category: FieldRef<"clarification", 'String'>
    readonly queue: FieldRef<"clarification", 'String'>
    readonly body: FieldRef<"clarification", 'String'>
    readonly answered: FieldRef<"clarification", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * clarification findUnique
   */
  export type clarificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clarification
     */
    select?: clarificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clarificationInclude<ExtArgs> | null
    /**
     * Filter, which clarification to fetch.
     */
    where: clarificationWhereUniqueInput
  }


  /**
   * clarification findUniqueOrThrow
   */
  export type clarificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clarification
     */
    select?: clarificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clarificationInclude<ExtArgs> | null
    /**
     * Filter, which clarification to fetch.
     */
    where: clarificationWhereUniqueInput
  }


  /**
   * clarification findFirst
   */
  export type clarificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clarification
     */
    select?: clarificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clarificationInclude<ExtArgs> | null
    /**
     * Filter, which clarification to fetch.
     */
    where?: clarificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clarifications to fetch.
     */
    orderBy?: clarificationOrderByWithRelationInput | clarificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clarifications.
     */
    cursor?: clarificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clarifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clarifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clarifications.
     */
    distinct?: ClarificationScalarFieldEnum | ClarificationScalarFieldEnum[]
  }


  /**
   * clarification findFirstOrThrow
   */
  export type clarificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clarification
     */
    select?: clarificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clarificationInclude<ExtArgs> | null
    /**
     * Filter, which clarification to fetch.
     */
    where?: clarificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clarifications to fetch.
     */
    orderBy?: clarificationOrderByWithRelationInput | clarificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clarifications.
     */
    cursor?: clarificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clarifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clarifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clarifications.
     */
    distinct?: ClarificationScalarFieldEnum | ClarificationScalarFieldEnum[]
  }


  /**
   * clarification findMany
   */
  export type clarificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clarification
     */
    select?: clarificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clarificationInclude<ExtArgs> | null
    /**
     * Filter, which clarifications to fetch.
     */
    where?: clarificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clarifications to fetch.
     */
    orderBy?: clarificationOrderByWithRelationInput | clarificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clarifications.
     */
    cursor?: clarificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clarifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clarifications.
     */
    skip?: number
    distinct?: ClarificationScalarFieldEnum | ClarificationScalarFieldEnum[]
  }


  /**
   * clarification create
   */
  export type clarificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clarification
     */
    select?: clarificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clarificationInclude<ExtArgs> | null
    /**
     * The data needed to create a clarification.
     */
    data: XOR<clarificationCreateInput, clarificationUncheckedCreateInput>
  }


  /**
   * clarification createMany
   */
  export type clarificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clarifications.
     */
    data: clarificationCreateManyInput | clarificationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * clarification update
   */
  export type clarificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clarification
     */
    select?: clarificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clarificationInclude<ExtArgs> | null
    /**
     * The data needed to update a clarification.
     */
    data: XOR<clarificationUpdateInput, clarificationUncheckedUpdateInput>
    /**
     * Choose, which clarification to update.
     */
    where: clarificationWhereUniqueInput
  }


  /**
   * clarification updateMany
   */
  export type clarificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clarifications.
     */
    data: XOR<clarificationUpdateManyMutationInput, clarificationUncheckedUpdateManyInput>
    /**
     * Filter which clarifications to update
     */
    where?: clarificationWhereInput
  }


  /**
   * clarification upsert
   */
  export type clarificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clarification
     */
    select?: clarificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clarificationInclude<ExtArgs> | null
    /**
     * The filter to search for the clarification to update in case it exists.
     */
    where: clarificationWhereUniqueInput
    /**
     * In case the clarification found by the `where` argument doesn't exist, create a new clarification with this data.
     */
    create: XOR<clarificationCreateInput, clarificationUncheckedCreateInput>
    /**
     * In case the clarification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clarificationUpdateInput, clarificationUncheckedUpdateInput>
  }


  /**
   * clarification delete
   */
  export type clarificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clarification
     */
    select?: clarificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clarificationInclude<ExtArgs> | null
    /**
     * Filter which clarification to delete.
     */
    where: clarificationWhereUniqueInput
  }


  /**
   * clarification deleteMany
   */
  export type clarificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clarifications to delete
     */
    where?: clarificationWhereInput
  }


  /**
   * clarification.contest
   */
  export type clarification$contestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contest
     */
    select?: contestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestInclude<ExtArgs> | null
    where?: contestWhereInput
  }


  /**
   * clarification.clarification
   */
  export type clarification$clarificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clarification
     */
    select?: clarificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clarificationInclude<ExtArgs> | null
    where?: clarificationWhereInput
  }


  /**
   * clarification.other_clarification
   */
  export type clarification$other_clarificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clarification
     */
    select?: clarificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clarificationInclude<ExtArgs> | null
    where?: clarificationWhereInput
    orderBy?: clarificationOrderByWithRelationInput | clarificationOrderByWithRelationInput[]
    cursor?: clarificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClarificationScalarFieldEnum | ClarificationScalarFieldEnum[]
  }


  /**
   * clarification.problem
   */
  export type clarification$problemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem
     */
    select?: problemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problemInclude<ExtArgs> | null
    where?: problemWhereInput
  }


  /**
   * clarification.team_clarification_senderToteam
   */
  export type clarification$team_clarification_senderToteamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    where?: teamWhereInput
  }


  /**
   * clarification.team_clarification_recipientToteam
   */
  export type clarification$team_clarification_recipientToteamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    where?: teamWhereInput
  }


  /**
   * clarification.team_unread
   */
  export type clarification$team_unreadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_unread
     */
    select?: team_unreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_unreadInclude<ExtArgs> | null
    where?: team_unreadWhereInput
    orderBy?: team_unreadOrderByWithRelationInput | team_unreadOrderByWithRelationInput[]
    cursor?: team_unreadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Team_unreadScalarFieldEnum | Team_unreadScalarFieldEnum[]
  }


  /**
   * clarification without action
   */
  export type clarificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clarification
     */
    select?: clarificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clarificationInclude<ExtArgs> | null
  }



  /**
   * Model configuration
   */

  export type AggregateConfiguration = {
    _count: ConfigurationCountAggregateOutputType | null
    _avg: ConfigurationAvgAggregateOutputType | null
    _sum: ConfigurationSumAggregateOutputType | null
    _min: ConfigurationMinAggregateOutputType | null
    _max: ConfigurationMaxAggregateOutputType | null
  }

  export type ConfigurationAvgAggregateOutputType = {
    configid: number | null
  }

  export type ConfigurationSumAggregateOutputType = {
    configid: number | null
  }

  export type ConfigurationMinAggregateOutputType = {
    configid: number | null
    name: string | null
    value: string | null
  }

  export type ConfigurationMaxAggregateOutputType = {
    configid: number | null
    name: string | null
    value: string | null
  }

  export type ConfigurationCountAggregateOutputType = {
    configid: number
    name: number
    value: number
    _all: number
  }


  export type ConfigurationAvgAggregateInputType = {
    configid?: true
  }

  export type ConfigurationSumAggregateInputType = {
    configid?: true
  }

  export type ConfigurationMinAggregateInputType = {
    configid?: true
    name?: true
    value?: true
  }

  export type ConfigurationMaxAggregateInputType = {
    configid?: true
    name?: true
    value?: true
  }

  export type ConfigurationCountAggregateInputType = {
    configid?: true
    name?: true
    value?: true
    _all?: true
  }

  export type ConfigurationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which configuration to aggregate.
     */
    where?: configurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configurations to fetch.
     */
    orderBy?: configurationOrderByWithRelationInput | configurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: configurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned configurations
    **/
    _count?: true | ConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfigurationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfigurationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigurationMaxAggregateInputType
  }

  export type GetConfigurationAggregateType<T extends ConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfiguration[P]>
      : GetScalarType<T[P], AggregateConfiguration[P]>
  }




  export type configurationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: configurationWhereInput
    orderBy?: configurationOrderByWithAggregationInput | configurationOrderByWithAggregationInput[]
    by: ConfigurationScalarFieldEnum[] | ConfigurationScalarFieldEnum
    having?: configurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigurationCountAggregateInputType | true
    _avg?: ConfigurationAvgAggregateInputType
    _sum?: ConfigurationSumAggregateInputType
    _min?: ConfigurationMinAggregateInputType
    _max?: ConfigurationMaxAggregateInputType
  }

  export type ConfigurationGroupByOutputType = {
    configid: number
    name: string
    value: string
    _count: ConfigurationCountAggregateOutputType | null
    _avg: ConfigurationAvgAggregateOutputType | null
    _sum: ConfigurationSumAggregateOutputType | null
    _min: ConfigurationMinAggregateOutputType | null
    _max: ConfigurationMaxAggregateOutputType | null
  }

  type GetConfigurationGroupByPayload<T extends configurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type configurationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    configid?: boolean
    name?: boolean
    value?: boolean
  }, ExtArgs["result"]["configuration"]>

  export type configurationSelectScalar = {
    configid?: boolean
    name?: boolean
    value?: boolean
  }


  export type $configurationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "configuration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      configid: number
      name: string
      value: string
    }, ExtArgs["result"]["configuration"]>
    composites: {}
  }


  type configurationGetPayload<S extends boolean | null | undefined | configurationDefaultArgs> = $Result.GetResult<Prisma.$configurationPayload, S>

  type configurationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<configurationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConfigurationCountAggregateInputType | true
    }

  export interface configurationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['configuration'], meta: { name: 'configuration' } }
    /**
     * Find zero or one Configuration that matches the filter.
     * @param {configurationFindUniqueArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends configurationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, configurationFindUniqueArgs<ExtArgs>>
    ): Prisma__configurationClient<$Result.GetResult<Prisma.$configurationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Configuration that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {configurationFindUniqueOrThrowArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends configurationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, configurationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__configurationClient<$Result.GetResult<Prisma.$configurationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Configuration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configurationFindFirstArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends configurationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, configurationFindFirstArgs<ExtArgs>>
    ): Prisma__configurationClient<$Result.GetResult<Prisma.$configurationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Configuration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configurationFindFirstOrThrowArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends configurationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, configurationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__configurationClient<$Result.GetResult<Prisma.$configurationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Configurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configurationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configurations
     * const configurations = await prisma.configuration.findMany()
     * 
     * // Get first 10 Configurations
     * const configurations = await prisma.configuration.findMany({ take: 10 })
     * 
     * // Only select the `configid`
     * const configurationWithConfigidOnly = await prisma.configuration.findMany({ select: { configid: true } })
     * 
    **/
    findMany<T extends configurationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, configurationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$configurationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Configuration.
     * @param {configurationCreateArgs} args - Arguments to create a Configuration.
     * @example
     * // Create one Configuration
     * const Configuration = await prisma.configuration.create({
     *   data: {
     *     // ... data to create a Configuration
     *   }
     * })
     * 
    **/
    create<T extends configurationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, configurationCreateArgs<ExtArgs>>
    ): Prisma__configurationClient<$Result.GetResult<Prisma.$configurationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Configurations.
     *     @param {configurationCreateManyArgs} args - Arguments to create many Configurations.
     *     @example
     *     // Create many Configurations
     *     const configuration = await prisma.configuration.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends configurationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, configurationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Configuration.
     * @param {configurationDeleteArgs} args - Arguments to delete one Configuration.
     * @example
     * // Delete one Configuration
     * const Configuration = await prisma.configuration.delete({
     *   where: {
     *     // ... filter to delete one Configuration
     *   }
     * })
     * 
    **/
    delete<T extends configurationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, configurationDeleteArgs<ExtArgs>>
    ): Prisma__configurationClient<$Result.GetResult<Prisma.$configurationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Configuration.
     * @param {configurationUpdateArgs} args - Arguments to update one Configuration.
     * @example
     * // Update one Configuration
     * const configuration = await prisma.configuration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends configurationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, configurationUpdateArgs<ExtArgs>>
    ): Prisma__configurationClient<$Result.GetResult<Prisma.$configurationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Configurations.
     * @param {configurationDeleteManyArgs} args - Arguments to filter Configurations to delete.
     * @example
     * // Delete a few Configurations
     * const { count } = await prisma.configuration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends configurationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, configurationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configurations
     * const configuration = await prisma.configuration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends configurationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, configurationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Configuration.
     * @param {configurationUpsertArgs} args - Arguments to update or create a Configuration.
     * @example
     * // Update or create a Configuration
     * const configuration = await prisma.configuration.upsert({
     *   create: {
     *     // ... data to create a Configuration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Configuration we want to update
     *   }
     * })
    **/
    upsert<T extends configurationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, configurationUpsertArgs<ExtArgs>>
    ): Prisma__configurationClient<$Result.GetResult<Prisma.$configurationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configurationCountArgs} args - Arguments to filter Configurations to count.
     * @example
     * // Count the number of Configurations
     * const count = await prisma.configuration.count({
     *   where: {
     *     // ... the filter for the Configurations we want to count
     *   }
     * })
    **/
    count<T extends configurationCountArgs>(
      args?: Subset<T, configurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Configuration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigurationAggregateArgs>(args: Subset<T, ConfigurationAggregateArgs>): Prisma.PrismaPromise<GetConfigurationAggregateType<T>>

    /**
     * Group by Configuration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends configurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: configurationGroupByArgs['orderBy'] }
        : { orderBy?: configurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, configurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the configuration model
   */
  readonly fields: configurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for configuration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__configurationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the configuration model
   */ 
  interface configurationFieldRefs {
    readonly configid: FieldRef<"configuration", 'Int'>
    readonly name: FieldRef<"configuration", 'String'>
    readonly value: FieldRef<"configuration", 'String'>
  }
    

  // Custom InputTypes

  /**
   * configuration findUnique
   */
  export type configurationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuration
     */
    select?: configurationSelect<ExtArgs> | null
    /**
     * Filter, which configuration to fetch.
     */
    where: configurationWhereUniqueInput
  }


  /**
   * configuration findUniqueOrThrow
   */
  export type configurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuration
     */
    select?: configurationSelect<ExtArgs> | null
    /**
     * Filter, which configuration to fetch.
     */
    where: configurationWhereUniqueInput
  }


  /**
   * configuration findFirst
   */
  export type configurationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuration
     */
    select?: configurationSelect<ExtArgs> | null
    /**
     * Filter, which configuration to fetch.
     */
    where?: configurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configurations to fetch.
     */
    orderBy?: configurationOrderByWithRelationInput | configurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configurations.
     */
    cursor?: configurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configurations.
     */
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }


  /**
   * configuration findFirstOrThrow
   */
  export type configurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuration
     */
    select?: configurationSelect<ExtArgs> | null
    /**
     * Filter, which configuration to fetch.
     */
    where?: configurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configurations to fetch.
     */
    orderBy?: configurationOrderByWithRelationInput | configurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configurations.
     */
    cursor?: configurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configurations.
     */
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }


  /**
   * configuration findMany
   */
  export type configurationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuration
     */
    select?: configurationSelect<ExtArgs> | null
    /**
     * Filter, which configurations to fetch.
     */
    where?: configurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configurations to fetch.
     */
    orderBy?: configurationOrderByWithRelationInput | configurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing configurations.
     */
    cursor?: configurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configurations.
     */
    skip?: number
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }


  /**
   * configuration create
   */
  export type configurationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuration
     */
    select?: configurationSelect<ExtArgs> | null
    /**
     * The data needed to create a configuration.
     */
    data: XOR<configurationCreateInput, configurationUncheckedCreateInput>
  }


  /**
   * configuration createMany
   */
  export type configurationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many configurations.
     */
    data: configurationCreateManyInput | configurationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * configuration update
   */
  export type configurationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuration
     */
    select?: configurationSelect<ExtArgs> | null
    /**
     * The data needed to update a configuration.
     */
    data: XOR<configurationUpdateInput, configurationUncheckedUpdateInput>
    /**
     * Choose, which configuration to update.
     */
    where: configurationWhereUniqueInput
  }


  /**
   * configuration updateMany
   */
  export type configurationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update configurations.
     */
    data: XOR<configurationUpdateManyMutationInput, configurationUncheckedUpdateManyInput>
    /**
     * Filter which configurations to update
     */
    where?: configurationWhereInput
  }


  /**
   * configuration upsert
   */
  export type configurationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuration
     */
    select?: configurationSelect<ExtArgs> | null
    /**
     * The filter to search for the configuration to update in case it exists.
     */
    where: configurationWhereUniqueInput
    /**
     * In case the configuration found by the `where` argument doesn't exist, create a new configuration with this data.
     */
    create: XOR<configurationCreateInput, configurationUncheckedCreateInput>
    /**
     * In case the configuration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<configurationUpdateInput, configurationUncheckedUpdateInput>
  }


  /**
   * configuration delete
   */
  export type configurationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuration
     */
    select?: configurationSelect<ExtArgs> | null
    /**
     * Filter which configuration to delete.
     */
    where: configurationWhereUniqueInput
  }


  /**
   * configuration deleteMany
   */
  export type configurationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which configurations to delete
     */
    where?: configurationWhereInput
  }


  /**
   * configuration without action
   */
  export type configurationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuration
     */
    select?: configurationSelect<ExtArgs> | null
  }



  /**
   * Model contest
   */

  export type AggregateContest = {
    _count: ContestCountAggregateOutputType | null
    _avg: ContestAvgAggregateOutputType | null
    _sum: ContestSumAggregateOutputType | null
    _min: ContestMinAggregateOutputType | null
    _max: ContestMaxAggregateOutputType | null
  }

  export type ContestAvgAggregateOutputType = {
    cid: number | null
    activatetime: Decimal | null
    starttime: Decimal | null
    freezetime: Decimal | null
    endtime: Decimal | null
    unfreezetime: Decimal | null
    deactivatetime: Decimal | null
    finalizetime: Decimal | null
    b: number | null
    gold_medals: number | null
    silver_medals: number | null
    bronze_medals: number | null
  }

  export type ContestSumAggregateOutputType = {
    cid: number | null
    activatetime: Decimal | null
    starttime: Decimal | null
    freezetime: Decimal | null
    endtime: Decimal | null
    unfreezetime: Decimal | null
    deactivatetime: Decimal | null
    finalizetime: Decimal | null
    b: number | null
    gold_medals: number | null
    silver_medals: number | null
    bronze_medals: number | null
  }

  export type ContestMinAggregateOutputType = {
    cid: number | null
    externalid: string | null
    name: string | null
    shortname: string | null
    activatetime: Decimal | null
    starttime: Decimal | null
    freezetime: Decimal | null
    endtime: Decimal | null
    unfreezetime: Decimal | null
    deactivatetime: Decimal | null
    activatetime_string: string | null
    starttime_string: string | null
    freezetime_string: string | null
    endtime_string: string | null
    unfreezetime_string: string | null
    deactivatetime_string: string | null
    finalizetime: Decimal | null
    finalizecomment: string | null
    b: number | null
    enabled: boolean | null
    starttime_enabled: boolean | null
    process_balloons: boolean | null
    public: boolean | null
    open_to_all_teams: boolean | null
    medals_enabled: boolean | null
    gold_medals: number | null
    silver_medals: number | null
    bronze_medals: number | null
    is_locked: boolean | null
    allow_submit: boolean | null
    warning_message: string | null
  }

  export type ContestMaxAggregateOutputType = {
    cid: number | null
    externalid: string | null
    name: string | null
    shortname: string | null
    activatetime: Decimal | null
    starttime: Decimal | null
    freezetime: Decimal | null
    endtime: Decimal | null
    unfreezetime: Decimal | null
    deactivatetime: Decimal | null
    activatetime_string: string | null
    starttime_string: string | null
    freezetime_string: string | null
    endtime_string: string | null
    unfreezetime_string: string | null
    deactivatetime_string: string | null
    finalizetime: Decimal | null
    finalizecomment: string | null
    b: number | null
    enabled: boolean | null
    starttime_enabled: boolean | null
    process_balloons: boolean | null
    public: boolean | null
    open_to_all_teams: boolean | null
    medals_enabled: boolean | null
    gold_medals: number | null
    silver_medals: number | null
    bronze_medals: number | null
    is_locked: boolean | null
    allow_submit: boolean | null
    warning_message: string | null
  }

  export type ContestCountAggregateOutputType = {
    cid: number
    externalid: number
    name: number
    shortname: number
    activatetime: number
    starttime: number
    freezetime: number
    endtime: number
    unfreezetime: number
    deactivatetime: number
    activatetime_string: number
    starttime_string: number
    freezetime_string: number
    endtime_string: number
    unfreezetime_string: number
    deactivatetime_string: number
    finalizetime: number
    finalizecomment: number
    b: number
    enabled: number
    starttime_enabled: number
    process_balloons: number
    public: number
    open_to_all_teams: number
    medals_enabled: number
    gold_medals: number
    silver_medals: number
    bronze_medals: number
    is_locked: number
    allow_submit: number
    warning_message: number
    _all: number
  }


  export type ContestAvgAggregateInputType = {
    cid?: true
    activatetime?: true
    starttime?: true
    freezetime?: true
    endtime?: true
    unfreezetime?: true
    deactivatetime?: true
    finalizetime?: true
    b?: true
    gold_medals?: true
    silver_medals?: true
    bronze_medals?: true
  }

  export type ContestSumAggregateInputType = {
    cid?: true
    activatetime?: true
    starttime?: true
    freezetime?: true
    endtime?: true
    unfreezetime?: true
    deactivatetime?: true
    finalizetime?: true
    b?: true
    gold_medals?: true
    silver_medals?: true
    bronze_medals?: true
  }

  export type ContestMinAggregateInputType = {
    cid?: true
    externalid?: true
    name?: true
    shortname?: true
    activatetime?: true
    starttime?: true
    freezetime?: true
    endtime?: true
    unfreezetime?: true
    deactivatetime?: true
    activatetime_string?: true
    starttime_string?: true
    freezetime_string?: true
    endtime_string?: true
    unfreezetime_string?: true
    deactivatetime_string?: true
    finalizetime?: true
    finalizecomment?: true
    b?: true
    enabled?: true
    starttime_enabled?: true
    process_balloons?: true
    public?: true
    open_to_all_teams?: true
    medals_enabled?: true
    gold_medals?: true
    silver_medals?: true
    bronze_medals?: true
    is_locked?: true
    allow_submit?: true
    warning_message?: true
  }

  export type ContestMaxAggregateInputType = {
    cid?: true
    externalid?: true
    name?: true
    shortname?: true
    activatetime?: true
    starttime?: true
    freezetime?: true
    endtime?: true
    unfreezetime?: true
    deactivatetime?: true
    activatetime_string?: true
    starttime_string?: true
    freezetime_string?: true
    endtime_string?: true
    unfreezetime_string?: true
    deactivatetime_string?: true
    finalizetime?: true
    finalizecomment?: true
    b?: true
    enabled?: true
    starttime_enabled?: true
    process_balloons?: true
    public?: true
    open_to_all_teams?: true
    medals_enabled?: true
    gold_medals?: true
    silver_medals?: true
    bronze_medals?: true
    is_locked?: true
    allow_submit?: true
    warning_message?: true
  }

  export type ContestCountAggregateInputType = {
    cid?: true
    externalid?: true
    name?: true
    shortname?: true
    activatetime?: true
    starttime?: true
    freezetime?: true
    endtime?: true
    unfreezetime?: true
    deactivatetime?: true
    activatetime_string?: true
    starttime_string?: true
    freezetime_string?: true
    endtime_string?: true
    unfreezetime_string?: true
    deactivatetime_string?: true
    finalizetime?: true
    finalizecomment?: true
    b?: true
    enabled?: true
    starttime_enabled?: true
    process_balloons?: true
    public?: true
    open_to_all_teams?: true
    medals_enabled?: true
    gold_medals?: true
    silver_medals?: true
    bronze_medals?: true
    is_locked?: true
    allow_submit?: true
    warning_message?: true
    _all?: true
  }

  export type ContestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contest to aggregate.
     */
    where?: contestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contests to fetch.
     */
    orderBy?: contestOrderByWithRelationInput | contestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contests
    **/
    _count?: true | ContestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestMaxAggregateInputType
  }

  export type GetContestAggregateType<T extends ContestAggregateArgs> = {
        [P in keyof T & keyof AggregateContest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContest[P]>
      : GetScalarType<T[P], AggregateContest[P]>
  }




  export type contestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contestWhereInput
    orderBy?: contestOrderByWithAggregationInput | contestOrderByWithAggregationInput[]
    by: ContestScalarFieldEnum[] | ContestScalarFieldEnum
    having?: contestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestCountAggregateInputType | true
    _avg?: ContestAvgAggregateInputType
    _sum?: ContestSumAggregateInputType
    _min?: ContestMinAggregateInputType
    _max?: ContestMaxAggregateInputType
  }

  export type ContestGroupByOutputType = {
    cid: number
    externalid: string | null
    name: string
    shortname: string
    activatetime: Decimal
    starttime: Decimal
    freezetime: Decimal | null
    endtime: Decimal
    unfreezetime: Decimal | null
    deactivatetime: Decimal | null
    activatetime_string: string
    starttime_string: string
    freezetime_string: string | null
    endtime_string: string
    unfreezetime_string: string | null
    deactivatetime_string: string | null
    finalizetime: Decimal | null
    finalizecomment: string | null
    b: number
    enabled: boolean
    starttime_enabled: boolean
    process_balloons: boolean
    public: boolean
    open_to_all_teams: boolean
    medals_enabled: boolean
    gold_medals: number
    silver_medals: number
    bronze_medals: number
    is_locked: boolean
    allow_submit: boolean
    warning_message: string | null
    _count: ContestCountAggregateOutputType | null
    _avg: ContestAvgAggregateOutputType | null
    _sum: ContestSumAggregateOutputType | null
    _min: ContestMinAggregateOutputType | null
    _max: ContestMaxAggregateOutputType | null
  }

  type GetContestGroupByPayload<T extends contestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestGroupByOutputType[P]>
            : GetScalarType<T[P], ContestGroupByOutputType[P]>
        }
      >
    >


  export type contestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cid?: boolean
    externalid?: boolean
    name?: boolean
    shortname?: boolean
    activatetime?: boolean
    starttime?: boolean
    freezetime?: boolean
    endtime?: boolean
    unfreezetime?: boolean
    deactivatetime?: boolean
    activatetime_string?: boolean
    starttime_string?: boolean
    freezetime_string?: boolean
    endtime_string?: boolean
    unfreezetime_string?: boolean
    deactivatetime_string?: boolean
    finalizetime?: boolean
    finalizecomment?: boolean
    b?: boolean
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: boolean
    silver_medals?: boolean
    bronze_medals?: boolean
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: boolean
    clarification?: boolean | contest$clarificationArgs<ExtArgs>
    contestproblem?: boolean | contest$contestproblemArgs<ExtArgs>
    contestteam?: boolean | contest$contestteamArgs<ExtArgs>
    contestteamcategory?: boolean | contest$contestteamcategoryArgs<ExtArgs>
    contestteamcategoryformedals?: boolean | contest$contestteamcategoryformedalsArgs<ExtArgs>
    event?: boolean | contest$eventArgs<ExtArgs>
    external_contest_source?: boolean | contest$external_contest_sourceArgs<ExtArgs>
    external_judgement?: boolean | contest$external_judgementArgs<ExtArgs>
    external_run?: boolean | contest$external_runArgs<ExtArgs>
    internal_error?: boolean | contest$internal_errorArgs<ExtArgs>
    judging?: boolean | contest$judgingArgs<ExtArgs>
    rankcache?: boolean | contest$rankcacheArgs<ExtArgs>
    removed_interval?: boolean | contest$removed_intervalArgs<ExtArgs>
    scorecache?: boolean | contest$scorecacheArgs<ExtArgs>
    submission?: boolean | contest$submissionArgs<ExtArgs>
    _count?: boolean | ContestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contest"]>

  export type contestSelectScalar = {
    cid?: boolean
    externalid?: boolean
    name?: boolean
    shortname?: boolean
    activatetime?: boolean
    starttime?: boolean
    freezetime?: boolean
    endtime?: boolean
    unfreezetime?: boolean
    deactivatetime?: boolean
    activatetime_string?: boolean
    starttime_string?: boolean
    freezetime_string?: boolean
    endtime_string?: boolean
    unfreezetime_string?: boolean
    deactivatetime_string?: boolean
    finalizetime?: boolean
    finalizecomment?: boolean
    b?: boolean
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: boolean
    silver_medals?: boolean
    bronze_medals?: boolean
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: boolean
  }

  export type contestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clarification?: boolean | contest$clarificationArgs<ExtArgs>
    contestproblem?: boolean | contest$contestproblemArgs<ExtArgs>
    contestteam?: boolean | contest$contestteamArgs<ExtArgs>
    contestteamcategory?: boolean | contest$contestteamcategoryArgs<ExtArgs>
    contestteamcategoryformedals?: boolean | contest$contestteamcategoryformedalsArgs<ExtArgs>
    event?: boolean | contest$eventArgs<ExtArgs>
    external_contest_source?: boolean | contest$external_contest_sourceArgs<ExtArgs>
    external_judgement?: boolean | contest$external_judgementArgs<ExtArgs>
    external_run?: boolean | contest$external_runArgs<ExtArgs>
    internal_error?: boolean | contest$internal_errorArgs<ExtArgs>
    judging?: boolean | contest$judgingArgs<ExtArgs>
    rankcache?: boolean | contest$rankcacheArgs<ExtArgs>
    removed_interval?: boolean | contest$removed_intervalArgs<ExtArgs>
    scorecache?: boolean | contest$scorecacheArgs<ExtArgs>
    submission?: boolean | contest$submissionArgs<ExtArgs>
    _count?: boolean | ContestCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $contestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contest"
    objects: {
      clarification: Prisma.$clarificationPayload<ExtArgs>[]
      contestproblem: Prisma.$contestproblemPayload<ExtArgs>[]
      contestteam: Prisma.$contestteamPayload<ExtArgs>[]
      contestteamcategory: Prisma.$contestteamcategoryPayload<ExtArgs>[]
      contestteamcategoryformedals: Prisma.$contestteamcategoryformedalsPayload<ExtArgs>[]
      event: Prisma.$eventPayload<ExtArgs>[]
      external_contest_source: Prisma.$external_contest_sourcePayload<ExtArgs> | null
      external_judgement: Prisma.$external_judgementPayload<ExtArgs>[]
      external_run: Prisma.$external_runPayload<ExtArgs>[]
      internal_error: Prisma.$internal_errorPayload<ExtArgs>[]
      judging: Prisma.$judgingPayload<ExtArgs>[]
      rankcache: Prisma.$rankcachePayload<ExtArgs>[]
      removed_interval: Prisma.$removed_intervalPayload<ExtArgs>[]
      scorecache: Prisma.$scorecachePayload<ExtArgs>[]
      submission: Prisma.$submissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      cid: number
      externalid: string | null
      name: string
      shortname: string
      activatetime: Prisma.Decimal
      starttime: Prisma.Decimal
      freezetime: Prisma.Decimal | null
      endtime: Prisma.Decimal
      unfreezetime: Prisma.Decimal | null
      deactivatetime: Prisma.Decimal | null
      activatetime_string: string
      starttime_string: string
      freezetime_string: string | null
      endtime_string: string
      unfreezetime_string: string | null
      deactivatetime_string: string | null
      finalizetime: Prisma.Decimal | null
      finalizecomment: string | null
      b: number
      enabled: boolean
      starttime_enabled: boolean
      process_balloons: boolean
      public: boolean
      open_to_all_teams: boolean
      medals_enabled: boolean
      gold_medals: number
      silver_medals: number
      bronze_medals: number
      is_locked: boolean
      allow_submit: boolean
      warning_message: string | null
    }, ExtArgs["result"]["contest"]>
    composites: {}
  }


  type contestGetPayload<S extends boolean | null | undefined | contestDefaultArgs> = $Result.GetResult<Prisma.$contestPayload, S>

  type contestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<contestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContestCountAggregateInputType | true
    }

  export interface contestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contest'], meta: { name: 'contest' } }
    /**
     * Find zero or one Contest that matches the filter.
     * @param {contestFindUniqueArgs} args - Arguments to find a Contest
     * @example
     * // Get one Contest
     * const contest = await prisma.contest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends contestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, contestFindUniqueArgs<ExtArgs>>
    ): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Contest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {contestFindUniqueOrThrowArgs} args - Arguments to find a Contest
     * @example
     * // Get one Contest
     * const contest = await prisma.contest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends contestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Contest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestFindFirstArgs} args - Arguments to find a Contest
     * @example
     * // Get one Contest
     * const contest = await prisma.contest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends contestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, contestFindFirstArgs<ExtArgs>>
    ): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Contest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestFindFirstOrThrowArgs} args - Arguments to find a Contest
     * @example
     * // Get one Contest
     * const contest = await prisma.contest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends contestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contests
     * const contests = await prisma.contest.findMany()
     * 
     * // Get first 10 Contests
     * const contests = await prisma.contest.findMany({ take: 10 })
     * 
     * // Only select the `cid`
     * const contestWithCidOnly = await prisma.contest.findMany({ select: { cid: true } })
     * 
    **/
    findMany<T extends contestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Contest.
     * @param {contestCreateArgs} args - Arguments to create a Contest.
     * @example
     * // Create one Contest
     * const Contest = await prisma.contest.create({
     *   data: {
     *     // ... data to create a Contest
     *   }
     * })
     * 
    **/
    create<T extends contestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, contestCreateArgs<ExtArgs>>
    ): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contests.
     *     @param {contestCreateManyArgs} args - Arguments to create many Contests.
     *     @example
     *     // Create many Contests
     *     const contest = await prisma.contest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends contestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contest.
     * @param {contestDeleteArgs} args - Arguments to delete one Contest.
     * @example
     * // Delete one Contest
     * const Contest = await prisma.contest.delete({
     *   where: {
     *     // ... filter to delete one Contest
     *   }
     * })
     * 
    **/
    delete<T extends contestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, contestDeleteArgs<ExtArgs>>
    ): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Contest.
     * @param {contestUpdateArgs} args - Arguments to update one Contest.
     * @example
     * // Update one Contest
     * const contest = await prisma.contest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends contestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, contestUpdateArgs<ExtArgs>>
    ): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contests.
     * @param {contestDeleteManyArgs} args - Arguments to filter Contests to delete.
     * @example
     * // Delete a few Contests
     * const { count } = await prisma.contest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends contestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contests
     * const contest = await prisma.contest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends contestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, contestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contest.
     * @param {contestUpsertArgs} args - Arguments to update or create a Contest.
     * @example
     * // Update or create a Contest
     * const contest = await prisma.contest.upsert({
     *   create: {
     *     // ... data to create a Contest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contest we want to update
     *   }
     * })
    **/
    upsert<T extends contestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, contestUpsertArgs<ExtArgs>>
    ): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Contests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestCountArgs} args - Arguments to filter Contests to count.
     * @example
     * // Count the number of Contests
     * const count = await prisma.contest.count({
     *   where: {
     *     // ... the filter for the Contests we want to count
     *   }
     * })
    **/
    count<T extends contestCountArgs>(
      args?: Subset<T, contestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestAggregateArgs>(args: Subset<T, ContestAggregateArgs>): Prisma.PrismaPromise<GetContestAggregateType<T>>

    /**
     * Group by Contest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contestGroupByArgs['orderBy'] }
        : { orderBy?: contestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contest model
   */
  readonly fields: contestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    clarification<T extends contest$clarificationArgs<ExtArgs> = {}>(args?: Subset<T, contest$clarificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clarificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    contestproblem<T extends contest$contestproblemArgs<ExtArgs> = {}>(args?: Subset<T, contest$contestproblemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contestproblemPayload<ExtArgs>, T, 'findMany'> | Null>;

    contestteam<T extends contest$contestteamArgs<ExtArgs> = {}>(args?: Subset<T, contest$contestteamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contestteamPayload<ExtArgs>, T, 'findMany'> | Null>;

    contestteamcategory<T extends contest$contestteamcategoryArgs<ExtArgs> = {}>(args?: Subset<T, contest$contestteamcategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contestteamcategoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    contestteamcategoryformedals<T extends contest$contestteamcategoryformedalsArgs<ExtArgs> = {}>(args?: Subset<T, contest$contestteamcategoryformedalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contestteamcategoryformedalsPayload<ExtArgs>, T, 'findMany'> | Null>;

    event<T extends contest$eventArgs<ExtArgs> = {}>(args?: Subset<T, contest$eventArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, 'findMany'> | Null>;

    external_contest_source<T extends contest$external_contest_sourceArgs<ExtArgs> = {}>(args?: Subset<T, contest$external_contest_sourceArgs<ExtArgs>>): Prisma__external_contest_sourceClient<$Result.GetResult<Prisma.$external_contest_sourcePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    external_judgement<T extends contest$external_judgementArgs<ExtArgs> = {}>(args?: Subset<T, contest$external_judgementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$external_judgementPayload<ExtArgs>, T, 'findMany'> | Null>;

    external_run<T extends contest$external_runArgs<ExtArgs> = {}>(args?: Subset<T, contest$external_runArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$external_runPayload<ExtArgs>, T, 'findMany'> | Null>;

    internal_error<T extends contest$internal_errorArgs<ExtArgs> = {}>(args?: Subset<T, contest$internal_errorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$internal_errorPayload<ExtArgs>, T, 'findMany'> | Null>;

    judging<T extends contest$judgingArgs<ExtArgs> = {}>(args?: Subset<T, contest$judgingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$judgingPayload<ExtArgs>, T, 'findMany'> | Null>;

    rankcache<T extends contest$rankcacheArgs<ExtArgs> = {}>(args?: Subset<T, contest$rankcacheArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rankcachePayload<ExtArgs>, T, 'findMany'> | Null>;

    removed_interval<T extends contest$removed_intervalArgs<ExtArgs> = {}>(args?: Subset<T, contest$removed_intervalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$removed_intervalPayload<ExtArgs>, T, 'findMany'> | Null>;

    scorecache<T extends contest$scorecacheArgs<ExtArgs> = {}>(args?: Subset<T, contest$scorecacheArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$scorecachePayload<ExtArgs>, T, 'findMany'> | Null>;

    submission<T extends contest$submissionArgs<ExtArgs> = {}>(args?: Subset<T, contest$submissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the contest model
   */ 
  interface contestFieldRefs {
    readonly cid: FieldRef<"contest", 'Int'>
    readonly externalid: FieldRef<"contest", 'String'>
    readonly name: FieldRef<"contest", 'String'>
    readonly shortname: FieldRef<"contest", 'String'>
    readonly activatetime: FieldRef<"contest", 'Decimal'>
    readonly starttime: FieldRef<"contest", 'Decimal'>
    readonly freezetime: FieldRef<"contest", 'Decimal'>
    readonly endtime: FieldRef<"contest", 'Decimal'>
    readonly unfreezetime: FieldRef<"contest", 'Decimal'>
    readonly deactivatetime: FieldRef<"contest", 'Decimal'>
    readonly activatetime_string: FieldRef<"contest", 'String'>
    readonly starttime_string: FieldRef<"contest", 'String'>
    readonly freezetime_string: FieldRef<"contest", 'String'>
    readonly endtime_string: FieldRef<"contest", 'String'>
    readonly unfreezetime_string: FieldRef<"contest", 'String'>
    readonly deactivatetime_string: FieldRef<"contest", 'String'>
    readonly finalizetime: FieldRef<"contest", 'Decimal'>
    readonly finalizecomment: FieldRef<"contest", 'String'>
    readonly b: FieldRef<"contest", 'Int'>
    readonly enabled: FieldRef<"contest", 'Boolean'>
    readonly starttime_enabled: FieldRef<"contest", 'Boolean'>
    readonly process_balloons: FieldRef<"contest", 'Boolean'>
    readonly public: FieldRef<"contest", 'Boolean'>
    readonly open_to_all_teams: FieldRef<"contest", 'Boolean'>
    readonly medals_enabled: FieldRef<"contest", 'Boolean'>
    readonly gold_medals: FieldRef<"contest", 'Int'>
    readonly silver_medals: FieldRef<"contest", 'Int'>
    readonly bronze_medals: FieldRef<"contest", 'Int'>
    readonly is_locked: FieldRef<"contest", 'Boolean'>
    readonly allow_submit: FieldRef<"contest", 'Boolean'>
    readonly warning_message: FieldRef<"contest", 'String'>
  }
    

  // Custom InputTypes

  /**
   * contest findUnique
   */
  export type contestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contest
     */
    select?: contestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestInclude<ExtArgs> | null
    /**
     * Filter, which contest to fetch.
     */
    where: contestWhereUniqueInput
  }


  /**
   * contest findUniqueOrThrow
   */
  export type contestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contest
     */
    select?: contestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestInclude<ExtArgs> | null
    /**
     * Filter, which contest to fetch.
     */
    where: contestWhereUniqueInput
  }


  /**
   * contest findFirst
   */
  export type contestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contest
     */
    select?: contestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestInclude<ExtArgs> | null
    /**
     * Filter, which contest to fetch.
     */
    where?: contestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contests to fetch.
     */
    orderBy?: contestOrderByWithRelationInput | contestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contests.
     */
    cursor?: contestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contests.
     */
    distinct?: ContestScalarFieldEnum | ContestScalarFieldEnum[]
  }


  /**
   * contest findFirstOrThrow
   */
  export type contestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contest
     */
    select?: contestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestInclude<ExtArgs> | null
    /**
     * Filter, which contest to fetch.
     */
    where?: contestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contests to fetch.
     */
    orderBy?: contestOrderByWithRelationInput | contestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contests.
     */
    cursor?: contestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contests.
     */
    distinct?: ContestScalarFieldEnum | ContestScalarFieldEnum[]
  }


  /**
   * contest findMany
   */
  export type contestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contest
     */
    select?: contestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestInclude<ExtArgs> | null
    /**
     * Filter, which contests to fetch.
     */
    where?: contestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contests to fetch.
     */
    orderBy?: contestOrderByWithRelationInput | contestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contests.
     */
    cursor?: contestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contests.
     */
    skip?: number
    distinct?: ContestScalarFieldEnum | ContestScalarFieldEnum[]
  }


  /**
   * contest create
   */
  export type contestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contest
     */
    select?: contestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestInclude<ExtArgs> | null
    /**
     * The data needed to create a contest.
     */
    data: XOR<contestCreateInput, contestUncheckedCreateInput>
  }


  /**
   * contest createMany
   */
  export type contestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contests.
     */
    data: contestCreateManyInput | contestCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * contest update
   */
  export type contestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contest
     */
    select?: contestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestInclude<ExtArgs> | null
    /**
     * The data needed to update a contest.
     */
    data: XOR<contestUpdateInput, contestUncheckedUpdateInput>
    /**
     * Choose, which contest to update.
     */
    where: contestWhereUniqueInput
  }


  /**
   * contest updateMany
   */
  export type contestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contests.
     */
    data: XOR<contestUpdateManyMutationInput, contestUncheckedUpdateManyInput>
    /**
     * Filter which contests to update
     */
    where?: contestWhereInput
  }


  /**
   * contest upsert
   */
  export type contestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contest
     */
    select?: contestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestInclude<ExtArgs> | null
    /**
     * The filter to search for the contest to update in case it exists.
     */
    where: contestWhereUniqueInput
    /**
     * In case the contest found by the `where` argument doesn't exist, create a new contest with this data.
     */
    create: XOR<contestCreateInput, contestUncheckedCreateInput>
    /**
     * In case the contest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contestUpdateInput, contestUncheckedUpdateInput>
  }


  /**
   * contest delete
   */
  export type contestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contest
     */
    select?: contestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestInclude<ExtArgs> | null
    /**
     * Filter which contest to delete.
     */
    where: contestWhereUniqueInput
  }


  /**
   * contest deleteMany
   */
  export type contestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contests to delete
     */
    where?: contestWhereInput
  }


  /**
   * contest.clarification
   */
  export type contest$clarificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clarification
     */
    select?: clarificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clarificationInclude<ExtArgs> | null
    where?: clarificationWhereInput
    orderBy?: clarificationOrderByWithRelationInput | clarificationOrderByWithRelationInput[]
    cursor?: clarificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClarificationScalarFieldEnum | ClarificationScalarFieldEnum[]
  }


  /**
   * contest.contestproblem
   */
  export type contest$contestproblemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestproblem
     */
    select?: contestproblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestproblemInclude<ExtArgs> | null
    where?: contestproblemWhereInput
    orderBy?: contestproblemOrderByWithRelationInput | contestproblemOrderByWithRelationInput[]
    cursor?: contestproblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestproblemScalarFieldEnum | ContestproblemScalarFieldEnum[]
  }


  /**
   * contest.contestteam
   */
  export type contest$contestteamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteam
     */
    select?: contestteamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamInclude<ExtArgs> | null
    where?: contestteamWhereInput
    orderBy?: contestteamOrderByWithRelationInput | contestteamOrderByWithRelationInput[]
    cursor?: contestteamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestteamScalarFieldEnum | ContestteamScalarFieldEnum[]
  }


  /**
   * contest.contestteamcategory
   */
  export type contest$contestteamcategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategory
     */
    select?: contestteamcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryInclude<ExtArgs> | null
    where?: contestteamcategoryWhereInput
    orderBy?: contestteamcategoryOrderByWithRelationInput | contestteamcategoryOrderByWithRelationInput[]
    cursor?: contestteamcategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestteamcategoryScalarFieldEnum | ContestteamcategoryScalarFieldEnum[]
  }


  /**
   * contest.contestteamcategoryformedals
   */
  export type contest$contestteamcategoryformedalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategoryformedals
     */
    select?: contestteamcategoryformedalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryformedalsInclude<ExtArgs> | null
    where?: contestteamcategoryformedalsWhereInput
    orderBy?: contestteamcategoryformedalsOrderByWithRelationInput | contestteamcategoryformedalsOrderByWithRelationInput[]
    cursor?: contestteamcategoryformedalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestteamcategoryformedalsScalarFieldEnum | ContestteamcategoryformedalsScalarFieldEnum[]
  }


  /**
   * contest.event
   */
  export type contest$eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventInclude<ExtArgs> | null
    where?: eventWhereInput
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    cursor?: eventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }


  /**
   * contest.external_contest_source
   */
  export type contest$external_contest_sourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_contest_source
     */
    select?: external_contest_sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_contest_sourceInclude<ExtArgs> | null
    where?: external_contest_sourceWhereInput
  }


  /**
   * contest.external_judgement
   */
  export type contest$external_judgementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_judgement
     */
    select?: external_judgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_judgementInclude<ExtArgs> | null
    where?: external_judgementWhereInput
    orderBy?: external_judgementOrderByWithRelationInput | external_judgementOrderByWithRelationInput[]
    cursor?: external_judgementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: External_judgementScalarFieldEnum | External_judgementScalarFieldEnum[]
  }


  /**
   * contest.external_run
   */
  export type contest$external_runArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_run
     */
    select?: external_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_runInclude<ExtArgs> | null
    where?: external_runWhereInput
    orderBy?: external_runOrderByWithRelationInput | external_runOrderByWithRelationInput[]
    cursor?: external_runWhereUniqueInput
    take?: number
    skip?: number
    distinct?: External_runScalarFieldEnum | External_runScalarFieldEnum[]
  }


  /**
   * contest.internal_error
   */
  export type contest$internal_errorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal_error
     */
    select?: internal_errorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: internal_errorInclude<ExtArgs> | null
    where?: internal_errorWhereInput
    orderBy?: internal_errorOrderByWithRelationInput | internal_errorOrderByWithRelationInput[]
    cursor?: internal_errorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Internal_errorScalarFieldEnum | Internal_errorScalarFieldEnum[]
  }


  /**
   * contest.judging
   */
  export type contest$judgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging
     */
    select?: judgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgingInclude<ExtArgs> | null
    where?: judgingWhereInput
    orderBy?: judgingOrderByWithRelationInput | judgingOrderByWithRelationInput[]
    cursor?: judgingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JudgingScalarFieldEnum | JudgingScalarFieldEnum[]
  }


  /**
   * contest.rankcache
   */
  export type contest$rankcacheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rankcache
     */
    select?: rankcacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rankcacheInclude<ExtArgs> | null
    where?: rankcacheWhereInput
    orderBy?: rankcacheOrderByWithRelationInput | rankcacheOrderByWithRelationInput[]
    cursor?: rankcacheWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RankcacheScalarFieldEnum | RankcacheScalarFieldEnum[]
  }


  /**
   * contest.removed_interval
   */
  export type contest$removed_intervalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the removed_interval
     */
    select?: removed_intervalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: removed_intervalInclude<ExtArgs> | null
    where?: removed_intervalWhereInput
    orderBy?: removed_intervalOrderByWithRelationInput | removed_intervalOrderByWithRelationInput[]
    cursor?: removed_intervalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Removed_intervalScalarFieldEnum | Removed_intervalScalarFieldEnum[]
  }


  /**
   * contest.scorecache
   */
  export type contest$scorecacheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scorecache
     */
    select?: scorecacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: scorecacheInclude<ExtArgs> | null
    where?: scorecacheWhereInput
    orderBy?: scorecacheOrderByWithRelationInput | scorecacheOrderByWithRelationInput[]
    cursor?: scorecacheWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScorecacheScalarFieldEnum | ScorecacheScalarFieldEnum[]
  }


  /**
   * contest.submission
   */
  export type contest$submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    where?: submissionWhereInput
    orderBy?: submissionOrderByWithRelationInput | submissionOrderByWithRelationInput[]
    cursor?: submissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }


  /**
   * contest without action
   */
  export type contestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contest
     */
    select?: contestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestInclude<ExtArgs> | null
  }



  /**
   * Model contestproblem
   */

  export type AggregateContestproblem = {
    _count: ContestproblemCountAggregateOutputType | null
    _avg: ContestproblemAvgAggregateOutputType | null
    _sum: ContestproblemSumAggregateOutputType | null
    _min: ContestproblemMinAggregateOutputType | null
    _max: ContestproblemMaxAggregateOutputType | null
  }

  export type ContestproblemAvgAggregateOutputType = {
    cid: number | null
    probid: number | null
    points: number | null
    lazy_eval_results: number | null
  }

  export type ContestproblemSumAggregateOutputType = {
    cid: number | null
    probid: number | null
    points: number | null
    lazy_eval_results: number | null
  }

  export type ContestproblemMinAggregateOutputType = {
    cid: number | null
    probid: number | null
    shortname: string | null
    points: number | null
    allow_submit: boolean | null
    allow_judge: boolean | null
    color: string | null
    lazy_eval_results: number | null
  }

  export type ContestproblemMaxAggregateOutputType = {
    cid: number | null
    probid: number | null
    shortname: string | null
    points: number | null
    allow_submit: boolean | null
    allow_judge: boolean | null
    color: string | null
    lazy_eval_results: number | null
  }

  export type ContestproblemCountAggregateOutputType = {
    cid: number
    probid: number
    shortname: number
    points: number
    allow_submit: number
    allow_judge: number
    color: number
    lazy_eval_results: number
    _all: number
  }


  export type ContestproblemAvgAggregateInputType = {
    cid?: true
    probid?: true
    points?: true
    lazy_eval_results?: true
  }

  export type ContestproblemSumAggregateInputType = {
    cid?: true
    probid?: true
    points?: true
    lazy_eval_results?: true
  }

  export type ContestproblemMinAggregateInputType = {
    cid?: true
    probid?: true
    shortname?: true
    points?: true
    allow_submit?: true
    allow_judge?: true
    color?: true
    lazy_eval_results?: true
  }

  export type ContestproblemMaxAggregateInputType = {
    cid?: true
    probid?: true
    shortname?: true
    points?: true
    allow_submit?: true
    allow_judge?: true
    color?: true
    lazy_eval_results?: true
  }

  export type ContestproblemCountAggregateInputType = {
    cid?: true
    probid?: true
    shortname?: true
    points?: true
    allow_submit?: true
    allow_judge?: true
    color?: true
    lazy_eval_results?: true
    _all?: true
  }

  export type ContestproblemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contestproblem to aggregate.
     */
    where?: contestproblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contestproblems to fetch.
     */
    orderBy?: contestproblemOrderByWithRelationInput | contestproblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contestproblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contestproblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contestproblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contestproblems
    **/
    _count?: true | ContestproblemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContestproblemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContestproblemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestproblemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestproblemMaxAggregateInputType
  }

  export type GetContestproblemAggregateType<T extends ContestproblemAggregateArgs> = {
        [P in keyof T & keyof AggregateContestproblem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContestproblem[P]>
      : GetScalarType<T[P], AggregateContestproblem[P]>
  }




  export type contestproblemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contestproblemWhereInput
    orderBy?: contestproblemOrderByWithAggregationInput | contestproblemOrderByWithAggregationInput[]
    by: ContestproblemScalarFieldEnum[] | ContestproblemScalarFieldEnum
    having?: contestproblemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestproblemCountAggregateInputType | true
    _avg?: ContestproblemAvgAggregateInputType
    _sum?: ContestproblemSumAggregateInputType
    _min?: ContestproblemMinAggregateInputType
    _max?: ContestproblemMaxAggregateInputType
  }

  export type ContestproblemGroupByOutputType = {
    cid: number
    probid: number
    shortname: string
    points: number
    allow_submit: boolean
    allow_judge: boolean
    color: string | null
    lazy_eval_results: number | null
    _count: ContestproblemCountAggregateOutputType | null
    _avg: ContestproblemAvgAggregateOutputType | null
    _sum: ContestproblemSumAggregateOutputType | null
    _min: ContestproblemMinAggregateOutputType | null
    _max: ContestproblemMaxAggregateOutputType | null
  }

  type GetContestproblemGroupByPayload<T extends contestproblemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestproblemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestproblemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestproblemGroupByOutputType[P]>
            : GetScalarType<T[P], ContestproblemGroupByOutputType[P]>
        }
      >
    >


  export type contestproblemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cid?: boolean
    probid?: boolean
    shortname?: boolean
    points?: boolean
    allow_submit?: boolean
    allow_judge?: boolean
    color?: boolean
    lazy_eval_results?: boolean
    contest?: boolean | contestDefaultArgs<ExtArgs>
    problem?: boolean | problemDefaultArgs<ExtArgs>
    submission?: boolean | contestproblem$submissionArgs<ExtArgs>
    _count?: boolean | ContestproblemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contestproblem"]>

  export type contestproblemSelectScalar = {
    cid?: boolean
    probid?: boolean
    shortname?: boolean
    points?: boolean
    allow_submit?: boolean
    allow_judge?: boolean
    color?: boolean
    lazy_eval_results?: boolean
  }

  export type contestproblemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contest?: boolean | contestDefaultArgs<ExtArgs>
    problem?: boolean | problemDefaultArgs<ExtArgs>
    submission?: boolean | contestproblem$submissionArgs<ExtArgs>
    _count?: boolean | ContestproblemCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $contestproblemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contestproblem"
    objects: {
      contest: Prisma.$contestPayload<ExtArgs>
      problem: Prisma.$problemPayload<ExtArgs>
      submission: Prisma.$submissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      cid: number
      probid: number
      shortname: string
      points: number
      allow_submit: boolean
      allow_judge: boolean
      color: string | null
      lazy_eval_results: number | null
    }, ExtArgs["result"]["contestproblem"]>
    composites: {}
  }


  type contestproblemGetPayload<S extends boolean | null | undefined | contestproblemDefaultArgs> = $Result.GetResult<Prisma.$contestproblemPayload, S>

  type contestproblemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<contestproblemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContestproblemCountAggregateInputType | true
    }

  export interface contestproblemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contestproblem'], meta: { name: 'contestproblem' } }
    /**
     * Find zero or one Contestproblem that matches the filter.
     * @param {contestproblemFindUniqueArgs} args - Arguments to find a Contestproblem
     * @example
     * // Get one Contestproblem
     * const contestproblem = await prisma.contestproblem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends contestproblemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, contestproblemFindUniqueArgs<ExtArgs>>
    ): Prisma__contestproblemClient<$Result.GetResult<Prisma.$contestproblemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Contestproblem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {contestproblemFindUniqueOrThrowArgs} args - Arguments to find a Contestproblem
     * @example
     * // Get one Contestproblem
     * const contestproblem = await prisma.contestproblem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends contestproblemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contestproblemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__contestproblemClient<$Result.GetResult<Prisma.$contestproblemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Contestproblem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestproblemFindFirstArgs} args - Arguments to find a Contestproblem
     * @example
     * // Get one Contestproblem
     * const contestproblem = await prisma.contestproblem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends contestproblemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, contestproblemFindFirstArgs<ExtArgs>>
    ): Prisma__contestproblemClient<$Result.GetResult<Prisma.$contestproblemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Contestproblem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestproblemFindFirstOrThrowArgs} args - Arguments to find a Contestproblem
     * @example
     * // Get one Contestproblem
     * const contestproblem = await prisma.contestproblem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends contestproblemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contestproblemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__contestproblemClient<$Result.GetResult<Prisma.$contestproblemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contestproblems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestproblemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contestproblems
     * const contestproblems = await prisma.contestproblem.findMany()
     * 
     * // Get first 10 Contestproblems
     * const contestproblems = await prisma.contestproblem.findMany({ take: 10 })
     * 
     * // Only select the `cid`
     * const contestproblemWithCidOnly = await prisma.contestproblem.findMany({ select: { cid: true } })
     * 
    **/
    findMany<T extends contestproblemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contestproblemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contestproblemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Contestproblem.
     * @param {contestproblemCreateArgs} args - Arguments to create a Contestproblem.
     * @example
     * // Create one Contestproblem
     * const Contestproblem = await prisma.contestproblem.create({
     *   data: {
     *     // ... data to create a Contestproblem
     *   }
     * })
     * 
    **/
    create<T extends contestproblemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, contestproblemCreateArgs<ExtArgs>>
    ): Prisma__contestproblemClient<$Result.GetResult<Prisma.$contestproblemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contestproblems.
     *     @param {contestproblemCreateManyArgs} args - Arguments to create many Contestproblems.
     *     @example
     *     // Create many Contestproblems
     *     const contestproblem = await prisma.contestproblem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends contestproblemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contestproblemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contestproblem.
     * @param {contestproblemDeleteArgs} args - Arguments to delete one Contestproblem.
     * @example
     * // Delete one Contestproblem
     * const Contestproblem = await prisma.contestproblem.delete({
     *   where: {
     *     // ... filter to delete one Contestproblem
     *   }
     * })
     * 
    **/
    delete<T extends contestproblemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, contestproblemDeleteArgs<ExtArgs>>
    ): Prisma__contestproblemClient<$Result.GetResult<Prisma.$contestproblemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Contestproblem.
     * @param {contestproblemUpdateArgs} args - Arguments to update one Contestproblem.
     * @example
     * // Update one Contestproblem
     * const contestproblem = await prisma.contestproblem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends contestproblemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, contestproblemUpdateArgs<ExtArgs>>
    ): Prisma__contestproblemClient<$Result.GetResult<Prisma.$contestproblemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contestproblems.
     * @param {contestproblemDeleteManyArgs} args - Arguments to filter Contestproblems to delete.
     * @example
     * // Delete a few Contestproblems
     * const { count } = await prisma.contestproblem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends contestproblemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contestproblemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contestproblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestproblemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contestproblems
     * const contestproblem = await prisma.contestproblem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends contestproblemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, contestproblemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contestproblem.
     * @param {contestproblemUpsertArgs} args - Arguments to update or create a Contestproblem.
     * @example
     * // Update or create a Contestproblem
     * const contestproblem = await prisma.contestproblem.upsert({
     *   create: {
     *     // ... data to create a Contestproblem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contestproblem we want to update
     *   }
     * })
    **/
    upsert<T extends contestproblemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, contestproblemUpsertArgs<ExtArgs>>
    ): Prisma__contestproblemClient<$Result.GetResult<Prisma.$contestproblemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Contestproblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestproblemCountArgs} args - Arguments to filter Contestproblems to count.
     * @example
     * // Count the number of Contestproblems
     * const count = await prisma.contestproblem.count({
     *   where: {
     *     // ... the filter for the Contestproblems we want to count
     *   }
     * })
    **/
    count<T extends contestproblemCountArgs>(
      args?: Subset<T, contestproblemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestproblemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contestproblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestproblemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestproblemAggregateArgs>(args: Subset<T, ContestproblemAggregateArgs>): Prisma.PrismaPromise<GetContestproblemAggregateType<T>>

    /**
     * Group by Contestproblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestproblemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contestproblemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contestproblemGroupByArgs['orderBy'] }
        : { orderBy?: contestproblemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contestproblemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestproblemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contestproblem model
   */
  readonly fields: contestproblemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contestproblem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contestproblemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contest<T extends contestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, contestDefaultArgs<ExtArgs>>): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    problem<T extends problemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, problemDefaultArgs<ExtArgs>>): Prisma__problemClient<$Result.GetResult<Prisma.$problemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    submission<T extends contestproblem$submissionArgs<ExtArgs> = {}>(args?: Subset<T, contestproblem$submissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the contestproblem model
   */ 
  interface contestproblemFieldRefs {
    readonly cid: FieldRef<"contestproblem", 'Int'>
    readonly probid: FieldRef<"contestproblem", 'Int'>
    readonly shortname: FieldRef<"contestproblem", 'String'>
    readonly points: FieldRef<"contestproblem", 'Int'>
    readonly allow_submit: FieldRef<"contestproblem", 'Boolean'>
    readonly allow_judge: FieldRef<"contestproblem", 'Boolean'>
    readonly color: FieldRef<"contestproblem", 'String'>
    readonly lazy_eval_results: FieldRef<"contestproblem", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * contestproblem findUnique
   */
  export type contestproblemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestproblem
     */
    select?: contestproblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestproblemInclude<ExtArgs> | null
    /**
     * Filter, which contestproblem to fetch.
     */
    where: contestproblemWhereUniqueInput
  }


  /**
   * contestproblem findUniqueOrThrow
   */
  export type contestproblemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestproblem
     */
    select?: contestproblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestproblemInclude<ExtArgs> | null
    /**
     * Filter, which contestproblem to fetch.
     */
    where: contestproblemWhereUniqueInput
  }


  /**
   * contestproblem findFirst
   */
  export type contestproblemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestproblem
     */
    select?: contestproblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestproblemInclude<ExtArgs> | null
    /**
     * Filter, which contestproblem to fetch.
     */
    where?: contestproblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contestproblems to fetch.
     */
    orderBy?: contestproblemOrderByWithRelationInput | contestproblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contestproblems.
     */
    cursor?: contestproblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contestproblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contestproblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contestproblems.
     */
    distinct?: ContestproblemScalarFieldEnum | ContestproblemScalarFieldEnum[]
  }


  /**
   * contestproblem findFirstOrThrow
   */
  export type contestproblemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestproblem
     */
    select?: contestproblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestproblemInclude<ExtArgs> | null
    /**
     * Filter, which contestproblem to fetch.
     */
    where?: contestproblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contestproblems to fetch.
     */
    orderBy?: contestproblemOrderByWithRelationInput | contestproblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contestproblems.
     */
    cursor?: contestproblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contestproblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contestproblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contestproblems.
     */
    distinct?: ContestproblemScalarFieldEnum | ContestproblemScalarFieldEnum[]
  }


  /**
   * contestproblem findMany
   */
  export type contestproblemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestproblem
     */
    select?: contestproblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestproblemInclude<ExtArgs> | null
    /**
     * Filter, which contestproblems to fetch.
     */
    where?: contestproblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contestproblems to fetch.
     */
    orderBy?: contestproblemOrderByWithRelationInput | contestproblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contestproblems.
     */
    cursor?: contestproblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contestproblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contestproblems.
     */
    skip?: number
    distinct?: ContestproblemScalarFieldEnum | ContestproblemScalarFieldEnum[]
  }


  /**
   * contestproblem create
   */
  export type contestproblemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestproblem
     */
    select?: contestproblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestproblemInclude<ExtArgs> | null
    /**
     * The data needed to create a contestproblem.
     */
    data: XOR<contestproblemCreateInput, contestproblemUncheckedCreateInput>
  }


  /**
   * contestproblem createMany
   */
  export type contestproblemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contestproblems.
     */
    data: contestproblemCreateManyInput | contestproblemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * contestproblem update
   */
  export type contestproblemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestproblem
     */
    select?: contestproblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestproblemInclude<ExtArgs> | null
    /**
     * The data needed to update a contestproblem.
     */
    data: XOR<contestproblemUpdateInput, contestproblemUncheckedUpdateInput>
    /**
     * Choose, which contestproblem to update.
     */
    where: contestproblemWhereUniqueInput
  }


  /**
   * contestproblem updateMany
   */
  export type contestproblemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contestproblems.
     */
    data: XOR<contestproblemUpdateManyMutationInput, contestproblemUncheckedUpdateManyInput>
    /**
     * Filter which contestproblems to update
     */
    where?: contestproblemWhereInput
  }


  /**
   * contestproblem upsert
   */
  export type contestproblemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestproblem
     */
    select?: contestproblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestproblemInclude<ExtArgs> | null
    /**
     * The filter to search for the contestproblem to update in case it exists.
     */
    where: contestproblemWhereUniqueInput
    /**
     * In case the contestproblem found by the `where` argument doesn't exist, create a new contestproblem with this data.
     */
    create: XOR<contestproblemCreateInput, contestproblemUncheckedCreateInput>
    /**
     * In case the contestproblem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contestproblemUpdateInput, contestproblemUncheckedUpdateInput>
  }


  /**
   * contestproblem delete
   */
  export type contestproblemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestproblem
     */
    select?: contestproblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestproblemInclude<ExtArgs> | null
    /**
     * Filter which contestproblem to delete.
     */
    where: contestproblemWhereUniqueInput
  }


  /**
   * contestproblem deleteMany
   */
  export type contestproblemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contestproblems to delete
     */
    where?: contestproblemWhereInput
  }


  /**
   * contestproblem.submission
   */
  export type contestproblem$submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    where?: submissionWhereInput
    orderBy?: submissionOrderByWithRelationInput | submissionOrderByWithRelationInput[]
    cursor?: submissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }


  /**
   * contestproblem without action
   */
  export type contestproblemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestproblem
     */
    select?: contestproblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestproblemInclude<ExtArgs> | null
  }



  /**
   * Model contestteam
   */

  export type AggregateContestteam = {
    _count: ContestteamCountAggregateOutputType | null
    _avg: ContestteamAvgAggregateOutputType | null
    _sum: ContestteamSumAggregateOutputType | null
    _min: ContestteamMinAggregateOutputType | null
    _max: ContestteamMaxAggregateOutputType | null
  }

  export type ContestteamAvgAggregateOutputType = {
    cid: number | null
    teamid: number | null
  }

  export type ContestteamSumAggregateOutputType = {
    cid: number | null
    teamid: number | null
  }

  export type ContestteamMinAggregateOutputType = {
    cid: number | null
    teamid: number | null
  }

  export type ContestteamMaxAggregateOutputType = {
    cid: number | null
    teamid: number | null
  }

  export type ContestteamCountAggregateOutputType = {
    cid: number
    teamid: number
    _all: number
  }


  export type ContestteamAvgAggregateInputType = {
    cid?: true
    teamid?: true
  }

  export type ContestteamSumAggregateInputType = {
    cid?: true
    teamid?: true
  }

  export type ContestteamMinAggregateInputType = {
    cid?: true
    teamid?: true
  }

  export type ContestteamMaxAggregateInputType = {
    cid?: true
    teamid?: true
  }

  export type ContestteamCountAggregateInputType = {
    cid?: true
    teamid?: true
    _all?: true
  }

  export type ContestteamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contestteam to aggregate.
     */
    where?: contestteamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contestteams to fetch.
     */
    orderBy?: contestteamOrderByWithRelationInput | contestteamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contestteamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contestteams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contestteams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contestteams
    **/
    _count?: true | ContestteamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContestteamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContestteamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestteamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestteamMaxAggregateInputType
  }

  export type GetContestteamAggregateType<T extends ContestteamAggregateArgs> = {
        [P in keyof T & keyof AggregateContestteam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContestteam[P]>
      : GetScalarType<T[P], AggregateContestteam[P]>
  }




  export type contestteamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contestteamWhereInput
    orderBy?: contestteamOrderByWithAggregationInput | contestteamOrderByWithAggregationInput[]
    by: ContestteamScalarFieldEnum[] | ContestteamScalarFieldEnum
    having?: contestteamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestteamCountAggregateInputType | true
    _avg?: ContestteamAvgAggregateInputType
    _sum?: ContestteamSumAggregateInputType
    _min?: ContestteamMinAggregateInputType
    _max?: ContestteamMaxAggregateInputType
  }

  export type ContestteamGroupByOutputType = {
    cid: number
    teamid: number
    _count: ContestteamCountAggregateOutputType | null
    _avg: ContestteamAvgAggregateOutputType | null
    _sum: ContestteamSumAggregateOutputType | null
    _min: ContestteamMinAggregateOutputType | null
    _max: ContestteamMaxAggregateOutputType | null
  }

  type GetContestteamGroupByPayload<T extends contestteamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestteamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestteamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestteamGroupByOutputType[P]>
            : GetScalarType<T[P], ContestteamGroupByOutputType[P]>
        }
      >
    >


  export type contestteamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cid?: boolean
    teamid?: boolean
    contest?: boolean | contestDefaultArgs<ExtArgs>
    team?: boolean | teamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contestteam"]>

  export type contestteamSelectScalar = {
    cid?: boolean
    teamid?: boolean
  }

  export type contestteamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contest?: boolean | contestDefaultArgs<ExtArgs>
    team?: boolean | teamDefaultArgs<ExtArgs>
  }


  export type $contestteamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contestteam"
    objects: {
      contest: Prisma.$contestPayload<ExtArgs>
      team: Prisma.$teamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cid: number
      teamid: number
    }, ExtArgs["result"]["contestteam"]>
    composites: {}
  }


  type contestteamGetPayload<S extends boolean | null | undefined | contestteamDefaultArgs> = $Result.GetResult<Prisma.$contestteamPayload, S>

  type contestteamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<contestteamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContestteamCountAggregateInputType | true
    }

  export interface contestteamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contestteam'], meta: { name: 'contestteam' } }
    /**
     * Find zero or one Contestteam that matches the filter.
     * @param {contestteamFindUniqueArgs} args - Arguments to find a Contestteam
     * @example
     * // Get one Contestteam
     * const contestteam = await prisma.contestteam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends contestteamFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, contestteamFindUniqueArgs<ExtArgs>>
    ): Prisma__contestteamClient<$Result.GetResult<Prisma.$contestteamPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Contestteam that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {contestteamFindUniqueOrThrowArgs} args - Arguments to find a Contestteam
     * @example
     * // Get one Contestteam
     * const contestteam = await prisma.contestteam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends contestteamFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contestteamFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__contestteamClient<$Result.GetResult<Prisma.$contestteamPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Contestteam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestteamFindFirstArgs} args - Arguments to find a Contestteam
     * @example
     * // Get one Contestteam
     * const contestteam = await prisma.contestteam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends contestteamFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, contestteamFindFirstArgs<ExtArgs>>
    ): Prisma__contestteamClient<$Result.GetResult<Prisma.$contestteamPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Contestteam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestteamFindFirstOrThrowArgs} args - Arguments to find a Contestteam
     * @example
     * // Get one Contestteam
     * const contestteam = await prisma.contestteam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends contestteamFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contestteamFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__contestteamClient<$Result.GetResult<Prisma.$contestteamPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contestteams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestteamFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contestteams
     * const contestteams = await prisma.contestteam.findMany()
     * 
     * // Get first 10 Contestteams
     * const contestteams = await prisma.contestteam.findMany({ take: 10 })
     * 
     * // Only select the `cid`
     * const contestteamWithCidOnly = await prisma.contestteam.findMany({ select: { cid: true } })
     * 
    **/
    findMany<T extends contestteamFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contestteamFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contestteamPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Contestteam.
     * @param {contestteamCreateArgs} args - Arguments to create a Contestteam.
     * @example
     * // Create one Contestteam
     * const Contestteam = await prisma.contestteam.create({
     *   data: {
     *     // ... data to create a Contestteam
     *   }
     * })
     * 
    **/
    create<T extends contestteamCreateArgs<ExtArgs>>(
      args: SelectSubset<T, contestteamCreateArgs<ExtArgs>>
    ): Prisma__contestteamClient<$Result.GetResult<Prisma.$contestteamPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contestteams.
     *     @param {contestteamCreateManyArgs} args - Arguments to create many Contestteams.
     *     @example
     *     // Create many Contestteams
     *     const contestteam = await prisma.contestteam.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends contestteamCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contestteamCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contestteam.
     * @param {contestteamDeleteArgs} args - Arguments to delete one Contestteam.
     * @example
     * // Delete one Contestteam
     * const Contestteam = await prisma.contestteam.delete({
     *   where: {
     *     // ... filter to delete one Contestteam
     *   }
     * })
     * 
    **/
    delete<T extends contestteamDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, contestteamDeleteArgs<ExtArgs>>
    ): Prisma__contestteamClient<$Result.GetResult<Prisma.$contestteamPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Contestteam.
     * @param {contestteamUpdateArgs} args - Arguments to update one Contestteam.
     * @example
     * // Update one Contestteam
     * const contestteam = await prisma.contestteam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends contestteamUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, contestteamUpdateArgs<ExtArgs>>
    ): Prisma__contestteamClient<$Result.GetResult<Prisma.$contestteamPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contestteams.
     * @param {contestteamDeleteManyArgs} args - Arguments to filter Contestteams to delete.
     * @example
     * // Delete a few Contestteams
     * const { count } = await prisma.contestteam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends contestteamDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contestteamDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contestteams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestteamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contestteams
     * const contestteam = await prisma.contestteam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends contestteamUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, contestteamUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contestteam.
     * @param {contestteamUpsertArgs} args - Arguments to update or create a Contestteam.
     * @example
     * // Update or create a Contestteam
     * const contestteam = await prisma.contestteam.upsert({
     *   create: {
     *     // ... data to create a Contestteam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contestteam we want to update
     *   }
     * })
    **/
    upsert<T extends contestteamUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, contestteamUpsertArgs<ExtArgs>>
    ): Prisma__contestteamClient<$Result.GetResult<Prisma.$contestteamPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Contestteams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestteamCountArgs} args - Arguments to filter Contestteams to count.
     * @example
     * // Count the number of Contestteams
     * const count = await prisma.contestteam.count({
     *   where: {
     *     // ... the filter for the Contestteams we want to count
     *   }
     * })
    **/
    count<T extends contestteamCountArgs>(
      args?: Subset<T, contestteamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestteamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contestteam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestteamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestteamAggregateArgs>(args: Subset<T, ContestteamAggregateArgs>): Prisma.PrismaPromise<GetContestteamAggregateType<T>>

    /**
     * Group by Contestteam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestteamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contestteamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contestteamGroupByArgs['orderBy'] }
        : { orderBy?: contestteamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contestteamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestteamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contestteam model
   */
  readonly fields: contestteamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contestteam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contestteamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contest<T extends contestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, contestDefaultArgs<ExtArgs>>): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    team<T extends teamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teamDefaultArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the contestteam model
   */ 
  interface contestteamFieldRefs {
    readonly cid: FieldRef<"contestteam", 'Int'>
    readonly teamid: FieldRef<"contestteam", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * contestteam findUnique
   */
  export type contestteamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteam
     */
    select?: contestteamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamInclude<ExtArgs> | null
    /**
     * Filter, which contestteam to fetch.
     */
    where: contestteamWhereUniqueInput
  }


  /**
   * contestteam findUniqueOrThrow
   */
  export type contestteamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteam
     */
    select?: contestteamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamInclude<ExtArgs> | null
    /**
     * Filter, which contestteam to fetch.
     */
    where: contestteamWhereUniqueInput
  }


  /**
   * contestteam findFirst
   */
  export type contestteamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteam
     */
    select?: contestteamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamInclude<ExtArgs> | null
    /**
     * Filter, which contestteam to fetch.
     */
    where?: contestteamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contestteams to fetch.
     */
    orderBy?: contestteamOrderByWithRelationInput | contestteamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contestteams.
     */
    cursor?: contestteamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contestteams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contestteams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contestteams.
     */
    distinct?: ContestteamScalarFieldEnum | ContestteamScalarFieldEnum[]
  }


  /**
   * contestteam findFirstOrThrow
   */
  export type contestteamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteam
     */
    select?: contestteamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamInclude<ExtArgs> | null
    /**
     * Filter, which contestteam to fetch.
     */
    where?: contestteamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contestteams to fetch.
     */
    orderBy?: contestteamOrderByWithRelationInput | contestteamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contestteams.
     */
    cursor?: contestteamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contestteams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contestteams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contestteams.
     */
    distinct?: ContestteamScalarFieldEnum | ContestteamScalarFieldEnum[]
  }


  /**
   * contestteam findMany
   */
  export type contestteamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteam
     */
    select?: contestteamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamInclude<ExtArgs> | null
    /**
     * Filter, which contestteams to fetch.
     */
    where?: contestteamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contestteams to fetch.
     */
    orderBy?: contestteamOrderByWithRelationInput | contestteamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contestteams.
     */
    cursor?: contestteamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contestteams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contestteams.
     */
    skip?: number
    distinct?: ContestteamScalarFieldEnum | ContestteamScalarFieldEnum[]
  }


  /**
   * contestteam create
   */
  export type contestteamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteam
     */
    select?: contestteamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamInclude<ExtArgs> | null
    /**
     * The data needed to create a contestteam.
     */
    data: XOR<contestteamCreateInput, contestteamUncheckedCreateInput>
  }


  /**
   * contestteam createMany
   */
  export type contestteamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contestteams.
     */
    data: contestteamCreateManyInput | contestteamCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * contestteam update
   */
  export type contestteamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteam
     */
    select?: contestteamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamInclude<ExtArgs> | null
    /**
     * The data needed to update a contestteam.
     */
    data: XOR<contestteamUpdateInput, contestteamUncheckedUpdateInput>
    /**
     * Choose, which contestteam to update.
     */
    where: contestteamWhereUniqueInput
  }


  /**
   * contestteam updateMany
   */
  export type contestteamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contestteams.
     */
    data: XOR<contestteamUpdateManyMutationInput, contestteamUncheckedUpdateManyInput>
    /**
     * Filter which contestteams to update
     */
    where?: contestteamWhereInput
  }


  /**
   * contestteam upsert
   */
  export type contestteamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteam
     */
    select?: contestteamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamInclude<ExtArgs> | null
    /**
     * The filter to search for the contestteam to update in case it exists.
     */
    where: contestteamWhereUniqueInput
    /**
     * In case the contestteam found by the `where` argument doesn't exist, create a new contestteam with this data.
     */
    create: XOR<contestteamCreateInput, contestteamUncheckedCreateInput>
    /**
     * In case the contestteam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contestteamUpdateInput, contestteamUncheckedUpdateInput>
  }


  /**
   * contestteam delete
   */
  export type contestteamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteam
     */
    select?: contestteamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamInclude<ExtArgs> | null
    /**
     * Filter which contestteam to delete.
     */
    where: contestteamWhereUniqueInput
  }


  /**
   * contestteam deleteMany
   */
  export type contestteamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contestteams to delete
     */
    where?: contestteamWhereInput
  }


  /**
   * contestteam without action
   */
  export type contestteamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteam
     */
    select?: contestteamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamInclude<ExtArgs> | null
  }



  /**
   * Model contestteamcategory
   */

  export type AggregateContestteamcategory = {
    _count: ContestteamcategoryCountAggregateOutputType | null
    _avg: ContestteamcategoryAvgAggregateOutputType | null
    _sum: ContestteamcategorySumAggregateOutputType | null
    _min: ContestteamcategoryMinAggregateOutputType | null
    _max: ContestteamcategoryMaxAggregateOutputType | null
  }

  export type ContestteamcategoryAvgAggregateOutputType = {
    cid: number | null
    categoryid: number | null
  }

  export type ContestteamcategorySumAggregateOutputType = {
    cid: number | null
    categoryid: number | null
  }

  export type ContestteamcategoryMinAggregateOutputType = {
    cid: number | null
    categoryid: number | null
  }

  export type ContestteamcategoryMaxAggregateOutputType = {
    cid: number | null
    categoryid: number | null
  }

  export type ContestteamcategoryCountAggregateOutputType = {
    cid: number
    categoryid: number
    _all: number
  }


  export type ContestteamcategoryAvgAggregateInputType = {
    cid?: true
    categoryid?: true
  }

  export type ContestteamcategorySumAggregateInputType = {
    cid?: true
    categoryid?: true
  }

  export type ContestteamcategoryMinAggregateInputType = {
    cid?: true
    categoryid?: true
  }

  export type ContestteamcategoryMaxAggregateInputType = {
    cid?: true
    categoryid?: true
  }

  export type ContestteamcategoryCountAggregateInputType = {
    cid?: true
    categoryid?: true
    _all?: true
  }

  export type ContestteamcategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contestteamcategory to aggregate.
     */
    where?: contestteamcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contestteamcategories to fetch.
     */
    orderBy?: contestteamcategoryOrderByWithRelationInput | contestteamcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contestteamcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contestteamcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contestteamcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contestteamcategories
    **/
    _count?: true | ContestteamcategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContestteamcategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContestteamcategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestteamcategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestteamcategoryMaxAggregateInputType
  }

  export type GetContestteamcategoryAggregateType<T extends ContestteamcategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateContestteamcategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContestteamcategory[P]>
      : GetScalarType<T[P], AggregateContestteamcategory[P]>
  }




  export type contestteamcategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contestteamcategoryWhereInput
    orderBy?: contestteamcategoryOrderByWithAggregationInput | contestteamcategoryOrderByWithAggregationInput[]
    by: ContestteamcategoryScalarFieldEnum[] | ContestteamcategoryScalarFieldEnum
    having?: contestteamcategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestteamcategoryCountAggregateInputType | true
    _avg?: ContestteamcategoryAvgAggregateInputType
    _sum?: ContestteamcategorySumAggregateInputType
    _min?: ContestteamcategoryMinAggregateInputType
    _max?: ContestteamcategoryMaxAggregateInputType
  }

  export type ContestteamcategoryGroupByOutputType = {
    cid: number
    categoryid: number
    _count: ContestteamcategoryCountAggregateOutputType | null
    _avg: ContestteamcategoryAvgAggregateOutputType | null
    _sum: ContestteamcategorySumAggregateOutputType | null
    _min: ContestteamcategoryMinAggregateOutputType | null
    _max: ContestteamcategoryMaxAggregateOutputType | null
  }

  type GetContestteamcategoryGroupByPayload<T extends contestteamcategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestteamcategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestteamcategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestteamcategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ContestteamcategoryGroupByOutputType[P]>
        }
      >
    >


  export type contestteamcategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cid?: boolean
    categoryid?: boolean
    contest?: boolean | contestDefaultArgs<ExtArgs>
    team_category?: boolean | team_categoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contestteamcategory"]>

  export type contestteamcategorySelectScalar = {
    cid?: boolean
    categoryid?: boolean
  }

  export type contestteamcategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contest?: boolean | contestDefaultArgs<ExtArgs>
    team_category?: boolean | team_categoryDefaultArgs<ExtArgs>
  }


  export type $contestteamcategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contestteamcategory"
    objects: {
      contest: Prisma.$contestPayload<ExtArgs>
      team_category: Prisma.$team_categoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cid: number
      categoryid: number
    }, ExtArgs["result"]["contestteamcategory"]>
    composites: {}
  }


  type contestteamcategoryGetPayload<S extends boolean | null | undefined | contestteamcategoryDefaultArgs> = $Result.GetResult<Prisma.$contestteamcategoryPayload, S>

  type contestteamcategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<contestteamcategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContestteamcategoryCountAggregateInputType | true
    }

  export interface contestteamcategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contestteamcategory'], meta: { name: 'contestteamcategory' } }
    /**
     * Find zero or one Contestteamcategory that matches the filter.
     * @param {contestteamcategoryFindUniqueArgs} args - Arguments to find a Contestteamcategory
     * @example
     * // Get one Contestteamcategory
     * const contestteamcategory = await prisma.contestteamcategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends contestteamcategoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, contestteamcategoryFindUniqueArgs<ExtArgs>>
    ): Prisma__contestteamcategoryClient<$Result.GetResult<Prisma.$contestteamcategoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Contestteamcategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {contestteamcategoryFindUniqueOrThrowArgs} args - Arguments to find a Contestteamcategory
     * @example
     * // Get one Contestteamcategory
     * const contestteamcategory = await prisma.contestteamcategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends contestteamcategoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contestteamcategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__contestteamcategoryClient<$Result.GetResult<Prisma.$contestteamcategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Contestteamcategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestteamcategoryFindFirstArgs} args - Arguments to find a Contestteamcategory
     * @example
     * // Get one Contestteamcategory
     * const contestteamcategory = await prisma.contestteamcategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends contestteamcategoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, contestteamcategoryFindFirstArgs<ExtArgs>>
    ): Prisma__contestteamcategoryClient<$Result.GetResult<Prisma.$contestteamcategoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Contestteamcategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestteamcategoryFindFirstOrThrowArgs} args - Arguments to find a Contestteamcategory
     * @example
     * // Get one Contestteamcategory
     * const contestteamcategory = await prisma.contestteamcategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends contestteamcategoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contestteamcategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__contestteamcategoryClient<$Result.GetResult<Prisma.$contestteamcategoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contestteamcategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestteamcategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contestteamcategories
     * const contestteamcategories = await prisma.contestteamcategory.findMany()
     * 
     * // Get first 10 Contestteamcategories
     * const contestteamcategories = await prisma.contestteamcategory.findMany({ take: 10 })
     * 
     * // Only select the `cid`
     * const contestteamcategoryWithCidOnly = await prisma.contestteamcategory.findMany({ select: { cid: true } })
     * 
    **/
    findMany<T extends contestteamcategoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contestteamcategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contestteamcategoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Contestteamcategory.
     * @param {contestteamcategoryCreateArgs} args - Arguments to create a Contestteamcategory.
     * @example
     * // Create one Contestteamcategory
     * const Contestteamcategory = await prisma.contestteamcategory.create({
     *   data: {
     *     // ... data to create a Contestteamcategory
     *   }
     * })
     * 
    **/
    create<T extends contestteamcategoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, contestteamcategoryCreateArgs<ExtArgs>>
    ): Prisma__contestteamcategoryClient<$Result.GetResult<Prisma.$contestteamcategoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contestteamcategories.
     *     @param {contestteamcategoryCreateManyArgs} args - Arguments to create many Contestteamcategories.
     *     @example
     *     // Create many Contestteamcategories
     *     const contestteamcategory = await prisma.contestteamcategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends contestteamcategoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contestteamcategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contestteamcategory.
     * @param {contestteamcategoryDeleteArgs} args - Arguments to delete one Contestteamcategory.
     * @example
     * // Delete one Contestteamcategory
     * const Contestteamcategory = await prisma.contestteamcategory.delete({
     *   where: {
     *     // ... filter to delete one Contestteamcategory
     *   }
     * })
     * 
    **/
    delete<T extends contestteamcategoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, contestteamcategoryDeleteArgs<ExtArgs>>
    ): Prisma__contestteamcategoryClient<$Result.GetResult<Prisma.$contestteamcategoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Contestteamcategory.
     * @param {contestteamcategoryUpdateArgs} args - Arguments to update one Contestteamcategory.
     * @example
     * // Update one Contestteamcategory
     * const contestteamcategory = await prisma.contestteamcategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends contestteamcategoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, contestteamcategoryUpdateArgs<ExtArgs>>
    ): Prisma__contestteamcategoryClient<$Result.GetResult<Prisma.$contestteamcategoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contestteamcategories.
     * @param {contestteamcategoryDeleteManyArgs} args - Arguments to filter Contestteamcategories to delete.
     * @example
     * // Delete a few Contestteamcategories
     * const { count } = await prisma.contestteamcategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends contestteamcategoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contestteamcategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contestteamcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestteamcategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contestteamcategories
     * const contestteamcategory = await prisma.contestteamcategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends contestteamcategoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, contestteamcategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contestteamcategory.
     * @param {contestteamcategoryUpsertArgs} args - Arguments to update or create a Contestteamcategory.
     * @example
     * // Update or create a Contestteamcategory
     * const contestteamcategory = await prisma.contestteamcategory.upsert({
     *   create: {
     *     // ... data to create a Contestteamcategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contestteamcategory we want to update
     *   }
     * })
    **/
    upsert<T extends contestteamcategoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, contestteamcategoryUpsertArgs<ExtArgs>>
    ): Prisma__contestteamcategoryClient<$Result.GetResult<Prisma.$contestteamcategoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Contestteamcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestteamcategoryCountArgs} args - Arguments to filter Contestteamcategories to count.
     * @example
     * // Count the number of Contestteamcategories
     * const count = await prisma.contestteamcategory.count({
     *   where: {
     *     // ... the filter for the Contestteamcategories we want to count
     *   }
     * })
    **/
    count<T extends contestteamcategoryCountArgs>(
      args?: Subset<T, contestteamcategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestteamcategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contestteamcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestteamcategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestteamcategoryAggregateArgs>(args: Subset<T, ContestteamcategoryAggregateArgs>): Prisma.PrismaPromise<GetContestteamcategoryAggregateType<T>>

    /**
     * Group by Contestteamcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestteamcategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contestteamcategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contestteamcategoryGroupByArgs['orderBy'] }
        : { orderBy?: contestteamcategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contestteamcategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestteamcategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contestteamcategory model
   */
  readonly fields: contestteamcategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contestteamcategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contestteamcategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contest<T extends contestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, contestDefaultArgs<ExtArgs>>): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    team_category<T extends team_categoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, team_categoryDefaultArgs<ExtArgs>>): Prisma__team_categoryClient<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the contestteamcategory model
   */ 
  interface contestteamcategoryFieldRefs {
    readonly cid: FieldRef<"contestteamcategory", 'Int'>
    readonly categoryid: FieldRef<"contestteamcategory", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * contestteamcategory findUnique
   */
  export type contestteamcategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategory
     */
    select?: contestteamcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryInclude<ExtArgs> | null
    /**
     * Filter, which contestteamcategory to fetch.
     */
    where: contestteamcategoryWhereUniqueInput
  }


  /**
   * contestteamcategory findUniqueOrThrow
   */
  export type contestteamcategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategory
     */
    select?: contestteamcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryInclude<ExtArgs> | null
    /**
     * Filter, which contestteamcategory to fetch.
     */
    where: contestteamcategoryWhereUniqueInput
  }


  /**
   * contestteamcategory findFirst
   */
  export type contestteamcategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategory
     */
    select?: contestteamcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryInclude<ExtArgs> | null
    /**
     * Filter, which contestteamcategory to fetch.
     */
    where?: contestteamcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contestteamcategories to fetch.
     */
    orderBy?: contestteamcategoryOrderByWithRelationInput | contestteamcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contestteamcategories.
     */
    cursor?: contestteamcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contestteamcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contestteamcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contestteamcategories.
     */
    distinct?: ContestteamcategoryScalarFieldEnum | ContestteamcategoryScalarFieldEnum[]
  }


  /**
   * contestteamcategory findFirstOrThrow
   */
  export type contestteamcategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategory
     */
    select?: contestteamcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryInclude<ExtArgs> | null
    /**
     * Filter, which contestteamcategory to fetch.
     */
    where?: contestteamcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contestteamcategories to fetch.
     */
    orderBy?: contestteamcategoryOrderByWithRelationInput | contestteamcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contestteamcategories.
     */
    cursor?: contestteamcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contestteamcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contestteamcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contestteamcategories.
     */
    distinct?: ContestteamcategoryScalarFieldEnum | ContestteamcategoryScalarFieldEnum[]
  }


  /**
   * contestteamcategory findMany
   */
  export type contestteamcategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategory
     */
    select?: contestteamcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryInclude<ExtArgs> | null
    /**
     * Filter, which contestteamcategories to fetch.
     */
    where?: contestteamcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contestteamcategories to fetch.
     */
    orderBy?: contestteamcategoryOrderByWithRelationInput | contestteamcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contestteamcategories.
     */
    cursor?: contestteamcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contestteamcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contestteamcategories.
     */
    skip?: number
    distinct?: ContestteamcategoryScalarFieldEnum | ContestteamcategoryScalarFieldEnum[]
  }


  /**
   * contestteamcategory create
   */
  export type contestteamcategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategory
     */
    select?: contestteamcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a contestteamcategory.
     */
    data: XOR<contestteamcategoryCreateInput, contestteamcategoryUncheckedCreateInput>
  }


  /**
   * contestteamcategory createMany
   */
  export type contestteamcategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contestteamcategories.
     */
    data: contestteamcategoryCreateManyInput | contestteamcategoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * contestteamcategory update
   */
  export type contestteamcategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategory
     */
    select?: contestteamcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a contestteamcategory.
     */
    data: XOR<contestteamcategoryUpdateInput, contestteamcategoryUncheckedUpdateInput>
    /**
     * Choose, which contestteamcategory to update.
     */
    where: contestteamcategoryWhereUniqueInput
  }


  /**
   * contestteamcategory updateMany
   */
  export type contestteamcategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contestteamcategories.
     */
    data: XOR<contestteamcategoryUpdateManyMutationInput, contestteamcategoryUncheckedUpdateManyInput>
    /**
     * Filter which contestteamcategories to update
     */
    where?: contestteamcategoryWhereInput
  }


  /**
   * contestteamcategory upsert
   */
  export type contestteamcategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategory
     */
    select?: contestteamcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the contestteamcategory to update in case it exists.
     */
    where: contestteamcategoryWhereUniqueInput
    /**
     * In case the contestteamcategory found by the `where` argument doesn't exist, create a new contestteamcategory with this data.
     */
    create: XOR<contestteamcategoryCreateInput, contestteamcategoryUncheckedCreateInput>
    /**
     * In case the contestteamcategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contestteamcategoryUpdateInput, contestteamcategoryUncheckedUpdateInput>
  }


  /**
   * contestteamcategory delete
   */
  export type contestteamcategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategory
     */
    select?: contestteamcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryInclude<ExtArgs> | null
    /**
     * Filter which contestteamcategory to delete.
     */
    where: contestteamcategoryWhereUniqueInput
  }


  /**
   * contestteamcategory deleteMany
   */
  export type contestteamcategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contestteamcategories to delete
     */
    where?: contestteamcategoryWhereInput
  }


  /**
   * contestteamcategory without action
   */
  export type contestteamcategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategory
     */
    select?: contestteamcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryInclude<ExtArgs> | null
  }



  /**
   * Model contestteamcategoryformedals
   */

  export type AggregateContestteamcategoryformedals = {
    _count: ContestteamcategoryformedalsCountAggregateOutputType | null
    _avg: ContestteamcategoryformedalsAvgAggregateOutputType | null
    _sum: ContestteamcategoryformedalsSumAggregateOutputType | null
    _min: ContestteamcategoryformedalsMinAggregateOutputType | null
    _max: ContestteamcategoryformedalsMaxAggregateOutputType | null
  }

  export type ContestteamcategoryformedalsAvgAggregateOutputType = {
    cid: number | null
    categoryid: number | null
  }

  export type ContestteamcategoryformedalsSumAggregateOutputType = {
    cid: number | null
    categoryid: number | null
  }

  export type ContestteamcategoryformedalsMinAggregateOutputType = {
    cid: number | null
    categoryid: number | null
  }

  export type ContestteamcategoryformedalsMaxAggregateOutputType = {
    cid: number | null
    categoryid: number | null
  }

  export type ContestteamcategoryformedalsCountAggregateOutputType = {
    cid: number
    categoryid: number
    _all: number
  }


  export type ContestteamcategoryformedalsAvgAggregateInputType = {
    cid?: true
    categoryid?: true
  }

  export type ContestteamcategoryformedalsSumAggregateInputType = {
    cid?: true
    categoryid?: true
  }

  export type ContestteamcategoryformedalsMinAggregateInputType = {
    cid?: true
    categoryid?: true
  }

  export type ContestteamcategoryformedalsMaxAggregateInputType = {
    cid?: true
    categoryid?: true
  }

  export type ContestteamcategoryformedalsCountAggregateInputType = {
    cid?: true
    categoryid?: true
    _all?: true
  }

  export type ContestteamcategoryformedalsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contestteamcategoryformedals to aggregate.
     */
    where?: contestteamcategoryformedalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contestteamcategoryformedals to fetch.
     */
    orderBy?: contestteamcategoryformedalsOrderByWithRelationInput | contestteamcategoryformedalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contestteamcategoryformedalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contestteamcategoryformedals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contestteamcategoryformedals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contestteamcategoryformedals
    **/
    _count?: true | ContestteamcategoryformedalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContestteamcategoryformedalsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContestteamcategoryformedalsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestteamcategoryformedalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestteamcategoryformedalsMaxAggregateInputType
  }

  export type GetContestteamcategoryformedalsAggregateType<T extends ContestteamcategoryformedalsAggregateArgs> = {
        [P in keyof T & keyof AggregateContestteamcategoryformedals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContestteamcategoryformedals[P]>
      : GetScalarType<T[P], AggregateContestteamcategoryformedals[P]>
  }




  export type contestteamcategoryformedalsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contestteamcategoryformedalsWhereInput
    orderBy?: contestteamcategoryformedalsOrderByWithAggregationInput | contestteamcategoryformedalsOrderByWithAggregationInput[]
    by: ContestteamcategoryformedalsScalarFieldEnum[] | ContestteamcategoryformedalsScalarFieldEnum
    having?: contestteamcategoryformedalsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestteamcategoryformedalsCountAggregateInputType | true
    _avg?: ContestteamcategoryformedalsAvgAggregateInputType
    _sum?: ContestteamcategoryformedalsSumAggregateInputType
    _min?: ContestteamcategoryformedalsMinAggregateInputType
    _max?: ContestteamcategoryformedalsMaxAggregateInputType
  }

  export type ContestteamcategoryformedalsGroupByOutputType = {
    cid: number
    categoryid: number
    _count: ContestteamcategoryformedalsCountAggregateOutputType | null
    _avg: ContestteamcategoryformedalsAvgAggregateOutputType | null
    _sum: ContestteamcategoryformedalsSumAggregateOutputType | null
    _min: ContestteamcategoryformedalsMinAggregateOutputType | null
    _max: ContestteamcategoryformedalsMaxAggregateOutputType | null
  }

  type GetContestteamcategoryformedalsGroupByPayload<T extends contestteamcategoryformedalsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestteamcategoryformedalsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestteamcategoryformedalsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestteamcategoryformedalsGroupByOutputType[P]>
            : GetScalarType<T[P], ContestteamcategoryformedalsGroupByOutputType[P]>
        }
      >
    >


  export type contestteamcategoryformedalsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cid?: boolean
    categoryid?: boolean
    contest?: boolean | contestDefaultArgs<ExtArgs>
    team_category?: boolean | team_categoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contestteamcategoryformedals"]>

  export type contestteamcategoryformedalsSelectScalar = {
    cid?: boolean
    categoryid?: boolean
  }

  export type contestteamcategoryformedalsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contest?: boolean | contestDefaultArgs<ExtArgs>
    team_category?: boolean | team_categoryDefaultArgs<ExtArgs>
  }


  export type $contestteamcategoryformedalsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contestteamcategoryformedals"
    objects: {
      contest: Prisma.$contestPayload<ExtArgs>
      team_category: Prisma.$team_categoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cid: number
      categoryid: number
    }, ExtArgs["result"]["contestteamcategoryformedals"]>
    composites: {}
  }


  type contestteamcategoryformedalsGetPayload<S extends boolean | null | undefined | contestteamcategoryformedalsDefaultArgs> = $Result.GetResult<Prisma.$contestteamcategoryformedalsPayload, S>

  type contestteamcategoryformedalsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<contestteamcategoryformedalsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContestteamcategoryformedalsCountAggregateInputType | true
    }

  export interface contestteamcategoryformedalsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contestteamcategoryformedals'], meta: { name: 'contestteamcategoryformedals' } }
    /**
     * Find zero or one Contestteamcategoryformedals that matches the filter.
     * @param {contestteamcategoryformedalsFindUniqueArgs} args - Arguments to find a Contestteamcategoryformedals
     * @example
     * // Get one Contestteamcategoryformedals
     * const contestteamcategoryformedals = await prisma.contestteamcategoryformedals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends contestteamcategoryformedalsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, contestteamcategoryformedalsFindUniqueArgs<ExtArgs>>
    ): Prisma__contestteamcategoryformedalsClient<$Result.GetResult<Prisma.$contestteamcategoryformedalsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Contestteamcategoryformedals that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {contestteamcategoryformedalsFindUniqueOrThrowArgs} args - Arguments to find a Contestteamcategoryformedals
     * @example
     * // Get one Contestteamcategoryformedals
     * const contestteamcategoryformedals = await prisma.contestteamcategoryformedals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends contestteamcategoryformedalsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contestteamcategoryformedalsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__contestteamcategoryformedalsClient<$Result.GetResult<Prisma.$contestteamcategoryformedalsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Contestteamcategoryformedals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestteamcategoryformedalsFindFirstArgs} args - Arguments to find a Contestteamcategoryformedals
     * @example
     * // Get one Contestteamcategoryformedals
     * const contestteamcategoryformedals = await prisma.contestteamcategoryformedals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends contestteamcategoryformedalsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, contestteamcategoryformedalsFindFirstArgs<ExtArgs>>
    ): Prisma__contestteamcategoryformedalsClient<$Result.GetResult<Prisma.$contestteamcategoryformedalsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Contestteamcategoryformedals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestteamcategoryformedalsFindFirstOrThrowArgs} args - Arguments to find a Contestteamcategoryformedals
     * @example
     * // Get one Contestteamcategoryformedals
     * const contestteamcategoryformedals = await prisma.contestteamcategoryformedals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends contestteamcategoryformedalsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contestteamcategoryformedalsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__contestteamcategoryformedalsClient<$Result.GetResult<Prisma.$contestteamcategoryformedalsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contestteamcategoryformedals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestteamcategoryformedalsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contestteamcategoryformedals
     * const contestteamcategoryformedals = await prisma.contestteamcategoryformedals.findMany()
     * 
     * // Get first 10 Contestteamcategoryformedals
     * const contestteamcategoryformedals = await prisma.contestteamcategoryformedals.findMany({ take: 10 })
     * 
     * // Only select the `cid`
     * const contestteamcategoryformedalsWithCidOnly = await prisma.contestteamcategoryformedals.findMany({ select: { cid: true } })
     * 
    **/
    findMany<T extends contestteamcategoryformedalsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contestteamcategoryformedalsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contestteamcategoryformedalsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Contestteamcategoryformedals.
     * @param {contestteamcategoryformedalsCreateArgs} args - Arguments to create a Contestteamcategoryformedals.
     * @example
     * // Create one Contestteamcategoryformedals
     * const Contestteamcategoryformedals = await prisma.contestteamcategoryformedals.create({
     *   data: {
     *     // ... data to create a Contestteamcategoryformedals
     *   }
     * })
     * 
    **/
    create<T extends contestteamcategoryformedalsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, contestteamcategoryformedalsCreateArgs<ExtArgs>>
    ): Prisma__contestteamcategoryformedalsClient<$Result.GetResult<Prisma.$contestteamcategoryformedalsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contestteamcategoryformedals.
     *     @param {contestteamcategoryformedalsCreateManyArgs} args - Arguments to create many Contestteamcategoryformedals.
     *     @example
     *     // Create many Contestteamcategoryformedals
     *     const contestteamcategoryformedals = await prisma.contestteamcategoryformedals.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends contestteamcategoryformedalsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contestteamcategoryformedalsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contestteamcategoryformedals.
     * @param {contestteamcategoryformedalsDeleteArgs} args - Arguments to delete one Contestteamcategoryformedals.
     * @example
     * // Delete one Contestteamcategoryformedals
     * const Contestteamcategoryformedals = await prisma.contestteamcategoryformedals.delete({
     *   where: {
     *     // ... filter to delete one Contestteamcategoryformedals
     *   }
     * })
     * 
    **/
    delete<T extends contestteamcategoryformedalsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, contestteamcategoryformedalsDeleteArgs<ExtArgs>>
    ): Prisma__contestteamcategoryformedalsClient<$Result.GetResult<Prisma.$contestteamcategoryformedalsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Contestteamcategoryformedals.
     * @param {contestteamcategoryformedalsUpdateArgs} args - Arguments to update one Contestteamcategoryformedals.
     * @example
     * // Update one Contestteamcategoryformedals
     * const contestteamcategoryformedals = await prisma.contestteamcategoryformedals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends contestteamcategoryformedalsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, contestteamcategoryformedalsUpdateArgs<ExtArgs>>
    ): Prisma__contestteamcategoryformedalsClient<$Result.GetResult<Prisma.$contestteamcategoryformedalsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contestteamcategoryformedals.
     * @param {contestteamcategoryformedalsDeleteManyArgs} args - Arguments to filter Contestteamcategoryformedals to delete.
     * @example
     * // Delete a few Contestteamcategoryformedals
     * const { count } = await prisma.contestteamcategoryformedals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends contestteamcategoryformedalsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contestteamcategoryformedalsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contestteamcategoryformedals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestteamcategoryformedalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contestteamcategoryformedals
     * const contestteamcategoryformedals = await prisma.contestteamcategoryformedals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends contestteamcategoryformedalsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, contestteamcategoryformedalsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contestteamcategoryformedals.
     * @param {contestteamcategoryformedalsUpsertArgs} args - Arguments to update or create a Contestteamcategoryformedals.
     * @example
     * // Update or create a Contestteamcategoryformedals
     * const contestteamcategoryformedals = await prisma.contestteamcategoryformedals.upsert({
     *   create: {
     *     // ... data to create a Contestteamcategoryformedals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contestteamcategoryformedals we want to update
     *   }
     * })
    **/
    upsert<T extends contestteamcategoryformedalsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, contestteamcategoryformedalsUpsertArgs<ExtArgs>>
    ): Prisma__contestteamcategoryformedalsClient<$Result.GetResult<Prisma.$contestteamcategoryformedalsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Contestteamcategoryformedals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestteamcategoryformedalsCountArgs} args - Arguments to filter Contestteamcategoryformedals to count.
     * @example
     * // Count the number of Contestteamcategoryformedals
     * const count = await prisma.contestteamcategoryformedals.count({
     *   where: {
     *     // ... the filter for the Contestteamcategoryformedals we want to count
     *   }
     * })
    **/
    count<T extends contestteamcategoryformedalsCountArgs>(
      args?: Subset<T, contestteamcategoryformedalsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestteamcategoryformedalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contestteamcategoryformedals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestteamcategoryformedalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestteamcategoryformedalsAggregateArgs>(args: Subset<T, ContestteamcategoryformedalsAggregateArgs>): Prisma.PrismaPromise<GetContestteamcategoryformedalsAggregateType<T>>

    /**
     * Group by Contestteamcategoryformedals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contestteamcategoryformedalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contestteamcategoryformedalsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contestteamcategoryformedalsGroupByArgs['orderBy'] }
        : { orderBy?: contestteamcategoryformedalsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contestteamcategoryformedalsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestteamcategoryformedalsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contestteamcategoryformedals model
   */
  readonly fields: contestteamcategoryformedalsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contestteamcategoryformedals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contestteamcategoryformedalsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contest<T extends contestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, contestDefaultArgs<ExtArgs>>): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    team_category<T extends team_categoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, team_categoryDefaultArgs<ExtArgs>>): Prisma__team_categoryClient<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the contestteamcategoryformedals model
   */ 
  interface contestteamcategoryformedalsFieldRefs {
    readonly cid: FieldRef<"contestteamcategoryformedals", 'Int'>
    readonly categoryid: FieldRef<"contestteamcategoryformedals", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * contestteamcategoryformedals findUnique
   */
  export type contestteamcategoryformedalsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategoryformedals
     */
    select?: contestteamcategoryformedalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryformedalsInclude<ExtArgs> | null
    /**
     * Filter, which contestteamcategoryformedals to fetch.
     */
    where: contestteamcategoryformedalsWhereUniqueInput
  }


  /**
   * contestteamcategoryformedals findUniqueOrThrow
   */
  export type contestteamcategoryformedalsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategoryformedals
     */
    select?: contestteamcategoryformedalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryformedalsInclude<ExtArgs> | null
    /**
     * Filter, which contestteamcategoryformedals to fetch.
     */
    where: contestteamcategoryformedalsWhereUniqueInput
  }


  /**
   * contestteamcategoryformedals findFirst
   */
  export type contestteamcategoryformedalsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategoryformedals
     */
    select?: contestteamcategoryformedalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryformedalsInclude<ExtArgs> | null
    /**
     * Filter, which contestteamcategoryformedals to fetch.
     */
    where?: contestteamcategoryformedalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contestteamcategoryformedals to fetch.
     */
    orderBy?: contestteamcategoryformedalsOrderByWithRelationInput | contestteamcategoryformedalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contestteamcategoryformedals.
     */
    cursor?: contestteamcategoryformedalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contestteamcategoryformedals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contestteamcategoryformedals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contestteamcategoryformedals.
     */
    distinct?: ContestteamcategoryformedalsScalarFieldEnum | ContestteamcategoryformedalsScalarFieldEnum[]
  }


  /**
   * contestteamcategoryformedals findFirstOrThrow
   */
  export type contestteamcategoryformedalsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategoryformedals
     */
    select?: contestteamcategoryformedalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryformedalsInclude<ExtArgs> | null
    /**
     * Filter, which contestteamcategoryformedals to fetch.
     */
    where?: contestteamcategoryformedalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contestteamcategoryformedals to fetch.
     */
    orderBy?: contestteamcategoryformedalsOrderByWithRelationInput | contestteamcategoryformedalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contestteamcategoryformedals.
     */
    cursor?: contestteamcategoryformedalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contestteamcategoryformedals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contestteamcategoryformedals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contestteamcategoryformedals.
     */
    distinct?: ContestteamcategoryformedalsScalarFieldEnum | ContestteamcategoryformedalsScalarFieldEnum[]
  }


  /**
   * contestteamcategoryformedals findMany
   */
  export type contestteamcategoryformedalsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategoryformedals
     */
    select?: contestteamcategoryformedalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryformedalsInclude<ExtArgs> | null
    /**
     * Filter, which contestteamcategoryformedals to fetch.
     */
    where?: contestteamcategoryformedalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contestteamcategoryformedals to fetch.
     */
    orderBy?: contestteamcategoryformedalsOrderByWithRelationInput | contestteamcategoryformedalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contestteamcategoryformedals.
     */
    cursor?: contestteamcategoryformedalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contestteamcategoryformedals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contestteamcategoryformedals.
     */
    skip?: number
    distinct?: ContestteamcategoryformedalsScalarFieldEnum | ContestteamcategoryformedalsScalarFieldEnum[]
  }


  /**
   * contestteamcategoryformedals create
   */
  export type contestteamcategoryformedalsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategoryformedals
     */
    select?: contestteamcategoryformedalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryformedalsInclude<ExtArgs> | null
    /**
     * The data needed to create a contestteamcategoryformedals.
     */
    data: XOR<contestteamcategoryformedalsCreateInput, contestteamcategoryformedalsUncheckedCreateInput>
  }


  /**
   * contestteamcategoryformedals createMany
   */
  export type contestteamcategoryformedalsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contestteamcategoryformedals.
     */
    data: contestteamcategoryformedalsCreateManyInput | contestteamcategoryformedalsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * contestteamcategoryformedals update
   */
  export type contestteamcategoryformedalsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategoryformedals
     */
    select?: contestteamcategoryformedalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryformedalsInclude<ExtArgs> | null
    /**
     * The data needed to update a contestteamcategoryformedals.
     */
    data: XOR<contestteamcategoryformedalsUpdateInput, contestteamcategoryformedalsUncheckedUpdateInput>
    /**
     * Choose, which contestteamcategoryformedals to update.
     */
    where: contestteamcategoryformedalsWhereUniqueInput
  }


  /**
   * contestteamcategoryformedals updateMany
   */
  export type contestteamcategoryformedalsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contestteamcategoryformedals.
     */
    data: XOR<contestteamcategoryformedalsUpdateManyMutationInput, contestteamcategoryformedalsUncheckedUpdateManyInput>
    /**
     * Filter which contestteamcategoryformedals to update
     */
    where?: contestteamcategoryformedalsWhereInput
  }


  /**
   * contestteamcategoryformedals upsert
   */
  export type contestteamcategoryformedalsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategoryformedals
     */
    select?: contestteamcategoryformedalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryformedalsInclude<ExtArgs> | null
    /**
     * The filter to search for the contestteamcategoryformedals to update in case it exists.
     */
    where: contestteamcategoryformedalsWhereUniqueInput
    /**
     * In case the contestteamcategoryformedals found by the `where` argument doesn't exist, create a new contestteamcategoryformedals with this data.
     */
    create: XOR<contestteamcategoryformedalsCreateInput, contestteamcategoryformedalsUncheckedCreateInput>
    /**
     * In case the contestteamcategoryformedals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contestteamcategoryformedalsUpdateInput, contestteamcategoryformedalsUncheckedUpdateInput>
  }


  /**
   * contestteamcategoryformedals delete
   */
  export type contestteamcategoryformedalsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategoryformedals
     */
    select?: contestteamcategoryformedalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryformedalsInclude<ExtArgs> | null
    /**
     * Filter which contestteamcategoryformedals to delete.
     */
    where: contestteamcategoryformedalsWhereUniqueInput
  }


  /**
   * contestteamcategoryformedals deleteMany
   */
  export type contestteamcategoryformedalsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contestteamcategoryformedals to delete
     */
    where?: contestteamcategoryformedalsWhereInput
  }


  /**
   * contestteamcategoryformedals without action
   */
  export type contestteamcategoryformedalsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategoryformedals
     */
    select?: contestteamcategoryformedalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryformedalsInclude<ExtArgs> | null
  }



  /**
   * Model debug_package
   */

  export type AggregateDebug_package = {
    _count: Debug_packageCountAggregateOutputType | null
    _avg: Debug_packageAvgAggregateOutputType | null
    _sum: Debug_packageSumAggregateOutputType | null
    _min: Debug_packageMinAggregateOutputType | null
    _max: Debug_packageMaxAggregateOutputType | null
  }

  export type Debug_packageAvgAggregateOutputType = {
    debug_package_id: number | null
    judgingid: number | null
    judgehostid: number | null
  }

  export type Debug_packageSumAggregateOutputType = {
    debug_package_id: number | null
    judgingid: number | null
    judgehostid: number | null
  }

  export type Debug_packageMinAggregateOutputType = {
    debug_package_id: number | null
    judgingid: number | null
    judgehostid: number | null
    filename: string | null
  }

  export type Debug_packageMaxAggregateOutputType = {
    debug_package_id: number | null
    judgingid: number | null
    judgehostid: number | null
    filename: string | null
  }

  export type Debug_packageCountAggregateOutputType = {
    debug_package_id: number
    judgingid: number
    judgehostid: number
    filename: number
    _all: number
  }


  export type Debug_packageAvgAggregateInputType = {
    debug_package_id?: true
    judgingid?: true
    judgehostid?: true
  }

  export type Debug_packageSumAggregateInputType = {
    debug_package_id?: true
    judgingid?: true
    judgehostid?: true
  }

  export type Debug_packageMinAggregateInputType = {
    debug_package_id?: true
    judgingid?: true
    judgehostid?: true
    filename?: true
  }

  export type Debug_packageMaxAggregateInputType = {
    debug_package_id?: true
    judgingid?: true
    judgehostid?: true
    filename?: true
  }

  export type Debug_packageCountAggregateInputType = {
    debug_package_id?: true
    judgingid?: true
    judgehostid?: true
    filename?: true
    _all?: true
  }

  export type Debug_packageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which debug_package to aggregate.
     */
    where?: debug_packageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of debug_packages to fetch.
     */
    orderBy?: debug_packageOrderByWithRelationInput | debug_packageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: debug_packageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` debug_packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` debug_packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned debug_packages
    **/
    _count?: true | Debug_packageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Debug_packageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Debug_packageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Debug_packageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Debug_packageMaxAggregateInputType
  }

  export type GetDebug_packageAggregateType<T extends Debug_packageAggregateArgs> = {
        [P in keyof T & keyof AggregateDebug_package]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDebug_package[P]>
      : GetScalarType<T[P], AggregateDebug_package[P]>
  }




  export type debug_packageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: debug_packageWhereInput
    orderBy?: debug_packageOrderByWithAggregationInput | debug_packageOrderByWithAggregationInput[]
    by: Debug_packageScalarFieldEnum[] | Debug_packageScalarFieldEnum
    having?: debug_packageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Debug_packageCountAggregateInputType | true
    _avg?: Debug_packageAvgAggregateInputType
    _sum?: Debug_packageSumAggregateInputType
    _min?: Debug_packageMinAggregateInputType
    _max?: Debug_packageMaxAggregateInputType
  }

  export type Debug_packageGroupByOutputType = {
    debug_package_id: number
    judgingid: number | null
    judgehostid: number | null
    filename: string
    _count: Debug_packageCountAggregateOutputType | null
    _avg: Debug_packageAvgAggregateOutputType | null
    _sum: Debug_packageSumAggregateOutputType | null
    _min: Debug_packageMinAggregateOutputType | null
    _max: Debug_packageMaxAggregateOutputType | null
  }

  type GetDebug_packageGroupByPayload<T extends debug_packageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Debug_packageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Debug_packageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Debug_packageGroupByOutputType[P]>
            : GetScalarType<T[P], Debug_packageGroupByOutputType[P]>
        }
      >
    >


  export type debug_packageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    debug_package_id?: boolean
    judgingid?: boolean
    judgehostid?: boolean
    filename?: boolean
    judging?: boolean | debug_package$judgingArgs<ExtArgs>
    judgehost?: boolean | debug_package$judgehostArgs<ExtArgs>
  }, ExtArgs["result"]["debug_package"]>

  export type debug_packageSelectScalar = {
    debug_package_id?: boolean
    judgingid?: boolean
    judgehostid?: boolean
    filename?: boolean
  }

  export type debug_packageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    judging?: boolean | debug_package$judgingArgs<ExtArgs>
    judgehost?: boolean | debug_package$judgehostArgs<ExtArgs>
  }


  export type $debug_packagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "debug_package"
    objects: {
      judging: Prisma.$judgingPayload<ExtArgs> | null
      judgehost: Prisma.$judgehostPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      debug_package_id: number
      judgingid: number | null
      judgehostid: number | null
      filename: string
    }, ExtArgs["result"]["debug_package"]>
    composites: {}
  }


  type debug_packageGetPayload<S extends boolean | null | undefined | debug_packageDefaultArgs> = $Result.GetResult<Prisma.$debug_packagePayload, S>

  type debug_packageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<debug_packageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Debug_packageCountAggregateInputType | true
    }

  export interface debug_packageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['debug_package'], meta: { name: 'debug_package' } }
    /**
     * Find zero or one Debug_package that matches the filter.
     * @param {debug_packageFindUniqueArgs} args - Arguments to find a Debug_package
     * @example
     * // Get one Debug_package
     * const debug_package = await prisma.debug_package.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends debug_packageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, debug_packageFindUniqueArgs<ExtArgs>>
    ): Prisma__debug_packageClient<$Result.GetResult<Prisma.$debug_packagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Debug_package that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {debug_packageFindUniqueOrThrowArgs} args - Arguments to find a Debug_package
     * @example
     * // Get one Debug_package
     * const debug_package = await prisma.debug_package.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends debug_packageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, debug_packageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__debug_packageClient<$Result.GetResult<Prisma.$debug_packagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Debug_package that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debug_packageFindFirstArgs} args - Arguments to find a Debug_package
     * @example
     * // Get one Debug_package
     * const debug_package = await prisma.debug_package.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends debug_packageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, debug_packageFindFirstArgs<ExtArgs>>
    ): Prisma__debug_packageClient<$Result.GetResult<Prisma.$debug_packagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Debug_package that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debug_packageFindFirstOrThrowArgs} args - Arguments to find a Debug_package
     * @example
     * // Get one Debug_package
     * const debug_package = await prisma.debug_package.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends debug_packageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, debug_packageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__debug_packageClient<$Result.GetResult<Prisma.$debug_packagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Debug_packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debug_packageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Debug_packages
     * const debug_packages = await prisma.debug_package.findMany()
     * 
     * // Get first 10 Debug_packages
     * const debug_packages = await prisma.debug_package.findMany({ take: 10 })
     * 
     * // Only select the `debug_package_id`
     * const debug_packageWithDebug_package_idOnly = await prisma.debug_package.findMany({ select: { debug_package_id: true } })
     * 
    **/
    findMany<T extends debug_packageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, debug_packageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$debug_packagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Debug_package.
     * @param {debug_packageCreateArgs} args - Arguments to create a Debug_package.
     * @example
     * // Create one Debug_package
     * const Debug_package = await prisma.debug_package.create({
     *   data: {
     *     // ... data to create a Debug_package
     *   }
     * })
     * 
    **/
    create<T extends debug_packageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, debug_packageCreateArgs<ExtArgs>>
    ): Prisma__debug_packageClient<$Result.GetResult<Prisma.$debug_packagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Debug_packages.
     *     @param {debug_packageCreateManyArgs} args - Arguments to create many Debug_packages.
     *     @example
     *     // Create many Debug_packages
     *     const debug_package = await prisma.debug_package.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends debug_packageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, debug_packageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Debug_package.
     * @param {debug_packageDeleteArgs} args - Arguments to delete one Debug_package.
     * @example
     * // Delete one Debug_package
     * const Debug_package = await prisma.debug_package.delete({
     *   where: {
     *     // ... filter to delete one Debug_package
     *   }
     * })
     * 
    **/
    delete<T extends debug_packageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, debug_packageDeleteArgs<ExtArgs>>
    ): Prisma__debug_packageClient<$Result.GetResult<Prisma.$debug_packagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Debug_package.
     * @param {debug_packageUpdateArgs} args - Arguments to update one Debug_package.
     * @example
     * // Update one Debug_package
     * const debug_package = await prisma.debug_package.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends debug_packageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, debug_packageUpdateArgs<ExtArgs>>
    ): Prisma__debug_packageClient<$Result.GetResult<Prisma.$debug_packagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Debug_packages.
     * @param {debug_packageDeleteManyArgs} args - Arguments to filter Debug_packages to delete.
     * @example
     * // Delete a few Debug_packages
     * const { count } = await prisma.debug_package.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends debug_packageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, debug_packageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Debug_packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debug_packageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Debug_packages
     * const debug_package = await prisma.debug_package.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends debug_packageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, debug_packageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Debug_package.
     * @param {debug_packageUpsertArgs} args - Arguments to update or create a Debug_package.
     * @example
     * // Update or create a Debug_package
     * const debug_package = await prisma.debug_package.upsert({
     *   create: {
     *     // ... data to create a Debug_package
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Debug_package we want to update
     *   }
     * })
    **/
    upsert<T extends debug_packageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, debug_packageUpsertArgs<ExtArgs>>
    ): Prisma__debug_packageClient<$Result.GetResult<Prisma.$debug_packagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Debug_packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debug_packageCountArgs} args - Arguments to filter Debug_packages to count.
     * @example
     * // Count the number of Debug_packages
     * const count = await prisma.debug_package.count({
     *   where: {
     *     // ... the filter for the Debug_packages we want to count
     *   }
     * })
    **/
    count<T extends debug_packageCountArgs>(
      args?: Subset<T, debug_packageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Debug_packageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Debug_package.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Debug_packageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Debug_packageAggregateArgs>(args: Subset<T, Debug_packageAggregateArgs>): Prisma.PrismaPromise<GetDebug_packageAggregateType<T>>

    /**
     * Group by Debug_package.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debug_packageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends debug_packageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: debug_packageGroupByArgs['orderBy'] }
        : { orderBy?: debug_packageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, debug_packageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDebug_packageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the debug_package model
   */
  readonly fields: debug_packageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for debug_package.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__debug_packageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    judging<T extends debug_package$judgingArgs<ExtArgs> = {}>(args?: Subset<T, debug_package$judgingArgs<ExtArgs>>): Prisma__judgingClient<$Result.GetResult<Prisma.$judgingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    judgehost<T extends debug_package$judgehostArgs<ExtArgs> = {}>(args?: Subset<T, debug_package$judgehostArgs<ExtArgs>>): Prisma__judgehostClient<$Result.GetResult<Prisma.$judgehostPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the debug_package model
   */ 
  interface debug_packageFieldRefs {
    readonly debug_package_id: FieldRef<"debug_package", 'Int'>
    readonly judgingid: FieldRef<"debug_package", 'Int'>
    readonly judgehostid: FieldRef<"debug_package", 'Int'>
    readonly filename: FieldRef<"debug_package", 'String'>
  }
    

  // Custom InputTypes

  /**
   * debug_package findUnique
   */
  export type debug_packageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debug_package
     */
    select?: debug_packageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: debug_packageInclude<ExtArgs> | null
    /**
     * Filter, which debug_package to fetch.
     */
    where: debug_packageWhereUniqueInput
  }


  /**
   * debug_package findUniqueOrThrow
   */
  export type debug_packageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debug_package
     */
    select?: debug_packageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: debug_packageInclude<ExtArgs> | null
    /**
     * Filter, which debug_package to fetch.
     */
    where: debug_packageWhereUniqueInput
  }


  /**
   * debug_package findFirst
   */
  export type debug_packageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debug_package
     */
    select?: debug_packageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: debug_packageInclude<ExtArgs> | null
    /**
     * Filter, which debug_package to fetch.
     */
    where?: debug_packageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of debug_packages to fetch.
     */
    orderBy?: debug_packageOrderByWithRelationInput | debug_packageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for debug_packages.
     */
    cursor?: debug_packageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` debug_packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` debug_packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of debug_packages.
     */
    distinct?: Debug_packageScalarFieldEnum | Debug_packageScalarFieldEnum[]
  }


  /**
   * debug_package findFirstOrThrow
   */
  export type debug_packageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debug_package
     */
    select?: debug_packageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: debug_packageInclude<ExtArgs> | null
    /**
     * Filter, which debug_package to fetch.
     */
    where?: debug_packageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of debug_packages to fetch.
     */
    orderBy?: debug_packageOrderByWithRelationInput | debug_packageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for debug_packages.
     */
    cursor?: debug_packageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` debug_packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` debug_packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of debug_packages.
     */
    distinct?: Debug_packageScalarFieldEnum | Debug_packageScalarFieldEnum[]
  }


  /**
   * debug_package findMany
   */
  export type debug_packageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debug_package
     */
    select?: debug_packageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: debug_packageInclude<ExtArgs> | null
    /**
     * Filter, which debug_packages to fetch.
     */
    where?: debug_packageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of debug_packages to fetch.
     */
    orderBy?: debug_packageOrderByWithRelationInput | debug_packageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing debug_packages.
     */
    cursor?: debug_packageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` debug_packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` debug_packages.
     */
    skip?: number
    distinct?: Debug_packageScalarFieldEnum | Debug_packageScalarFieldEnum[]
  }


  /**
   * debug_package create
   */
  export type debug_packageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debug_package
     */
    select?: debug_packageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: debug_packageInclude<ExtArgs> | null
    /**
     * The data needed to create a debug_package.
     */
    data: XOR<debug_packageCreateInput, debug_packageUncheckedCreateInput>
  }


  /**
   * debug_package createMany
   */
  export type debug_packageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many debug_packages.
     */
    data: debug_packageCreateManyInput | debug_packageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * debug_package update
   */
  export type debug_packageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debug_package
     */
    select?: debug_packageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: debug_packageInclude<ExtArgs> | null
    /**
     * The data needed to update a debug_package.
     */
    data: XOR<debug_packageUpdateInput, debug_packageUncheckedUpdateInput>
    /**
     * Choose, which debug_package to update.
     */
    where: debug_packageWhereUniqueInput
  }


  /**
   * debug_package updateMany
   */
  export type debug_packageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update debug_packages.
     */
    data: XOR<debug_packageUpdateManyMutationInput, debug_packageUncheckedUpdateManyInput>
    /**
     * Filter which debug_packages to update
     */
    where?: debug_packageWhereInput
  }


  /**
   * debug_package upsert
   */
  export type debug_packageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debug_package
     */
    select?: debug_packageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: debug_packageInclude<ExtArgs> | null
    /**
     * The filter to search for the debug_package to update in case it exists.
     */
    where: debug_packageWhereUniqueInput
    /**
     * In case the debug_package found by the `where` argument doesn't exist, create a new debug_package with this data.
     */
    create: XOR<debug_packageCreateInput, debug_packageUncheckedCreateInput>
    /**
     * In case the debug_package was found with the provided `where` argument, update it with this data.
     */
    update: XOR<debug_packageUpdateInput, debug_packageUncheckedUpdateInput>
  }


  /**
   * debug_package delete
   */
  export type debug_packageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debug_package
     */
    select?: debug_packageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: debug_packageInclude<ExtArgs> | null
    /**
     * Filter which debug_package to delete.
     */
    where: debug_packageWhereUniqueInput
  }


  /**
   * debug_package deleteMany
   */
  export type debug_packageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which debug_packages to delete
     */
    where?: debug_packageWhereInput
  }


  /**
   * debug_package.judging
   */
  export type debug_package$judgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging
     */
    select?: judgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgingInclude<ExtArgs> | null
    where?: judgingWhereInput
  }


  /**
   * debug_package.judgehost
   */
  export type debug_package$judgehostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgehost
     */
    select?: judgehostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgehostInclude<ExtArgs> | null
    where?: judgehostWhereInput
  }


  /**
   * debug_package without action
   */
  export type debug_packageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debug_package
     */
    select?: debug_packageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: debug_packageInclude<ExtArgs> | null
  }



  /**
   * Model doctrine_migration_versions
   */

  export type AggregateDoctrine_migration_versions = {
    _count: Doctrine_migration_versionsCountAggregateOutputType | null
    _avg: Doctrine_migration_versionsAvgAggregateOutputType | null
    _sum: Doctrine_migration_versionsSumAggregateOutputType | null
    _min: Doctrine_migration_versionsMinAggregateOutputType | null
    _max: Doctrine_migration_versionsMaxAggregateOutputType | null
  }

  export type Doctrine_migration_versionsAvgAggregateOutputType = {
    execution_time: number | null
  }

  export type Doctrine_migration_versionsSumAggregateOutputType = {
    execution_time: number | null
  }

  export type Doctrine_migration_versionsMinAggregateOutputType = {
    version: string | null
    executed_at: Date | null
    execution_time: number | null
  }

  export type Doctrine_migration_versionsMaxAggregateOutputType = {
    version: string | null
    executed_at: Date | null
    execution_time: number | null
  }

  export type Doctrine_migration_versionsCountAggregateOutputType = {
    version: number
    executed_at: number
    execution_time: number
    _all: number
  }


  export type Doctrine_migration_versionsAvgAggregateInputType = {
    execution_time?: true
  }

  export type Doctrine_migration_versionsSumAggregateInputType = {
    execution_time?: true
  }

  export type Doctrine_migration_versionsMinAggregateInputType = {
    version?: true
    executed_at?: true
    execution_time?: true
  }

  export type Doctrine_migration_versionsMaxAggregateInputType = {
    version?: true
    executed_at?: true
    execution_time?: true
  }

  export type Doctrine_migration_versionsCountAggregateInputType = {
    version?: true
    executed_at?: true
    execution_time?: true
    _all?: true
  }

  export type Doctrine_migration_versionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which doctrine_migration_versions to aggregate.
     */
    where?: doctrine_migration_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of doctrine_migration_versions to fetch.
     */
    orderBy?: doctrine_migration_versionsOrderByWithRelationInput | doctrine_migration_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: doctrine_migration_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` doctrine_migration_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` doctrine_migration_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned doctrine_migration_versions
    **/
    _count?: true | Doctrine_migration_versionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Doctrine_migration_versionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Doctrine_migration_versionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Doctrine_migration_versionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Doctrine_migration_versionsMaxAggregateInputType
  }

  export type GetDoctrine_migration_versionsAggregateType<T extends Doctrine_migration_versionsAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctrine_migration_versions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctrine_migration_versions[P]>
      : GetScalarType<T[P], AggregateDoctrine_migration_versions[P]>
  }




  export type doctrine_migration_versionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: doctrine_migration_versionsWhereInput
    orderBy?: doctrine_migration_versionsOrderByWithAggregationInput | doctrine_migration_versionsOrderByWithAggregationInput[]
    by: Doctrine_migration_versionsScalarFieldEnum[] | Doctrine_migration_versionsScalarFieldEnum
    having?: doctrine_migration_versionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Doctrine_migration_versionsCountAggregateInputType | true
    _avg?: Doctrine_migration_versionsAvgAggregateInputType
    _sum?: Doctrine_migration_versionsSumAggregateInputType
    _min?: Doctrine_migration_versionsMinAggregateInputType
    _max?: Doctrine_migration_versionsMaxAggregateInputType
  }

  export type Doctrine_migration_versionsGroupByOutputType = {
    version: string
    executed_at: Date | null
    execution_time: number | null
    _count: Doctrine_migration_versionsCountAggregateOutputType | null
    _avg: Doctrine_migration_versionsAvgAggregateOutputType | null
    _sum: Doctrine_migration_versionsSumAggregateOutputType | null
    _min: Doctrine_migration_versionsMinAggregateOutputType | null
    _max: Doctrine_migration_versionsMaxAggregateOutputType | null
  }

  type GetDoctrine_migration_versionsGroupByPayload<T extends doctrine_migration_versionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Doctrine_migration_versionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Doctrine_migration_versionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Doctrine_migration_versionsGroupByOutputType[P]>
            : GetScalarType<T[P], Doctrine_migration_versionsGroupByOutputType[P]>
        }
      >
    >


  export type doctrine_migration_versionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    version?: boolean
    executed_at?: boolean
    execution_time?: boolean
  }, ExtArgs["result"]["doctrine_migration_versions"]>

  export type doctrine_migration_versionsSelectScalar = {
    version?: boolean
    executed_at?: boolean
    execution_time?: boolean
  }


  export type $doctrine_migration_versionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "doctrine_migration_versions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      version: string
      executed_at: Date | null
      execution_time: number | null
    }, ExtArgs["result"]["doctrine_migration_versions"]>
    composites: {}
  }


  type doctrine_migration_versionsGetPayload<S extends boolean | null | undefined | doctrine_migration_versionsDefaultArgs> = $Result.GetResult<Prisma.$doctrine_migration_versionsPayload, S>

  type doctrine_migration_versionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<doctrine_migration_versionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Doctrine_migration_versionsCountAggregateInputType | true
    }

  export interface doctrine_migration_versionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['doctrine_migration_versions'], meta: { name: 'doctrine_migration_versions' } }
    /**
     * Find zero or one Doctrine_migration_versions that matches the filter.
     * @param {doctrine_migration_versionsFindUniqueArgs} args - Arguments to find a Doctrine_migration_versions
     * @example
     * // Get one Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends doctrine_migration_versionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, doctrine_migration_versionsFindUniqueArgs<ExtArgs>>
    ): Prisma__doctrine_migration_versionsClient<$Result.GetResult<Prisma.$doctrine_migration_versionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Doctrine_migration_versions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {doctrine_migration_versionsFindUniqueOrThrowArgs} args - Arguments to find a Doctrine_migration_versions
     * @example
     * // Get one Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends doctrine_migration_versionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, doctrine_migration_versionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__doctrine_migration_versionsClient<$Result.GetResult<Prisma.$doctrine_migration_versionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Doctrine_migration_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctrine_migration_versionsFindFirstArgs} args - Arguments to find a Doctrine_migration_versions
     * @example
     * // Get one Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends doctrine_migration_versionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, doctrine_migration_versionsFindFirstArgs<ExtArgs>>
    ): Prisma__doctrine_migration_versionsClient<$Result.GetResult<Prisma.$doctrine_migration_versionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Doctrine_migration_versions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctrine_migration_versionsFindFirstOrThrowArgs} args - Arguments to find a Doctrine_migration_versions
     * @example
     * // Get one Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends doctrine_migration_versionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, doctrine_migration_versionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__doctrine_migration_versionsClient<$Result.GetResult<Prisma.$doctrine_migration_versionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Doctrine_migration_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctrine_migration_versionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findMany()
     * 
     * // Get first 10 Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findMany({ take: 10 })
     * 
     * // Only select the `version`
     * const doctrine_migration_versionsWithVersionOnly = await prisma.doctrine_migration_versions.findMany({ select: { version: true } })
     * 
    **/
    findMany<T extends doctrine_migration_versionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, doctrine_migration_versionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$doctrine_migration_versionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Doctrine_migration_versions.
     * @param {doctrine_migration_versionsCreateArgs} args - Arguments to create a Doctrine_migration_versions.
     * @example
     * // Create one Doctrine_migration_versions
     * const Doctrine_migration_versions = await prisma.doctrine_migration_versions.create({
     *   data: {
     *     // ... data to create a Doctrine_migration_versions
     *   }
     * })
     * 
    **/
    create<T extends doctrine_migration_versionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, doctrine_migration_versionsCreateArgs<ExtArgs>>
    ): Prisma__doctrine_migration_versionsClient<$Result.GetResult<Prisma.$doctrine_migration_versionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Doctrine_migration_versions.
     *     @param {doctrine_migration_versionsCreateManyArgs} args - Arguments to create many Doctrine_migration_versions.
     *     @example
     *     // Create many Doctrine_migration_versions
     *     const doctrine_migration_versions = await prisma.doctrine_migration_versions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends doctrine_migration_versionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, doctrine_migration_versionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Doctrine_migration_versions.
     * @param {doctrine_migration_versionsDeleteArgs} args - Arguments to delete one Doctrine_migration_versions.
     * @example
     * // Delete one Doctrine_migration_versions
     * const Doctrine_migration_versions = await prisma.doctrine_migration_versions.delete({
     *   where: {
     *     // ... filter to delete one Doctrine_migration_versions
     *   }
     * })
     * 
    **/
    delete<T extends doctrine_migration_versionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, doctrine_migration_versionsDeleteArgs<ExtArgs>>
    ): Prisma__doctrine_migration_versionsClient<$Result.GetResult<Prisma.$doctrine_migration_versionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Doctrine_migration_versions.
     * @param {doctrine_migration_versionsUpdateArgs} args - Arguments to update one Doctrine_migration_versions.
     * @example
     * // Update one Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends doctrine_migration_versionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, doctrine_migration_versionsUpdateArgs<ExtArgs>>
    ): Prisma__doctrine_migration_versionsClient<$Result.GetResult<Prisma.$doctrine_migration_versionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Doctrine_migration_versions.
     * @param {doctrine_migration_versionsDeleteManyArgs} args - Arguments to filter Doctrine_migration_versions to delete.
     * @example
     * // Delete a few Doctrine_migration_versions
     * const { count } = await prisma.doctrine_migration_versions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends doctrine_migration_versionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, doctrine_migration_versionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctrine_migration_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctrine_migration_versionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends doctrine_migration_versionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, doctrine_migration_versionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Doctrine_migration_versions.
     * @param {doctrine_migration_versionsUpsertArgs} args - Arguments to update or create a Doctrine_migration_versions.
     * @example
     * // Update or create a Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.upsert({
     *   create: {
     *     // ... data to create a Doctrine_migration_versions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Doctrine_migration_versions we want to update
     *   }
     * })
    **/
    upsert<T extends doctrine_migration_versionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, doctrine_migration_versionsUpsertArgs<ExtArgs>>
    ): Prisma__doctrine_migration_versionsClient<$Result.GetResult<Prisma.$doctrine_migration_versionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Doctrine_migration_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctrine_migration_versionsCountArgs} args - Arguments to filter Doctrine_migration_versions to count.
     * @example
     * // Count the number of Doctrine_migration_versions
     * const count = await prisma.doctrine_migration_versions.count({
     *   where: {
     *     // ... the filter for the Doctrine_migration_versions we want to count
     *   }
     * })
    **/
    count<T extends doctrine_migration_versionsCountArgs>(
      args?: Subset<T, doctrine_migration_versionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Doctrine_migration_versionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Doctrine_migration_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Doctrine_migration_versionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Doctrine_migration_versionsAggregateArgs>(args: Subset<T, Doctrine_migration_versionsAggregateArgs>): Prisma.PrismaPromise<GetDoctrine_migration_versionsAggregateType<T>>

    /**
     * Group by Doctrine_migration_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctrine_migration_versionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends doctrine_migration_versionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: doctrine_migration_versionsGroupByArgs['orderBy'] }
        : { orderBy?: doctrine_migration_versionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, doctrine_migration_versionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctrine_migration_versionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the doctrine_migration_versions model
   */
  readonly fields: doctrine_migration_versionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for doctrine_migration_versions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__doctrine_migration_versionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the doctrine_migration_versions model
   */ 
  interface doctrine_migration_versionsFieldRefs {
    readonly version: FieldRef<"doctrine_migration_versions", 'String'>
    readonly executed_at: FieldRef<"doctrine_migration_versions", 'DateTime'>
    readonly execution_time: FieldRef<"doctrine_migration_versions", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * doctrine_migration_versions findUnique
   */
  export type doctrine_migration_versionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect<ExtArgs> | null
    /**
     * Filter, which doctrine_migration_versions to fetch.
     */
    where: doctrine_migration_versionsWhereUniqueInput
  }


  /**
   * doctrine_migration_versions findUniqueOrThrow
   */
  export type doctrine_migration_versionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect<ExtArgs> | null
    /**
     * Filter, which doctrine_migration_versions to fetch.
     */
    where: doctrine_migration_versionsWhereUniqueInput
  }


  /**
   * doctrine_migration_versions findFirst
   */
  export type doctrine_migration_versionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect<ExtArgs> | null
    /**
     * Filter, which doctrine_migration_versions to fetch.
     */
    where?: doctrine_migration_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of doctrine_migration_versions to fetch.
     */
    orderBy?: doctrine_migration_versionsOrderByWithRelationInput | doctrine_migration_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for doctrine_migration_versions.
     */
    cursor?: doctrine_migration_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` doctrine_migration_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` doctrine_migration_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of doctrine_migration_versions.
     */
    distinct?: Doctrine_migration_versionsScalarFieldEnum | Doctrine_migration_versionsScalarFieldEnum[]
  }


  /**
   * doctrine_migration_versions findFirstOrThrow
   */
  export type doctrine_migration_versionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect<ExtArgs> | null
    /**
     * Filter, which doctrine_migration_versions to fetch.
     */
    where?: doctrine_migration_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of doctrine_migration_versions to fetch.
     */
    orderBy?: doctrine_migration_versionsOrderByWithRelationInput | doctrine_migration_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for doctrine_migration_versions.
     */
    cursor?: doctrine_migration_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` doctrine_migration_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` doctrine_migration_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of doctrine_migration_versions.
     */
    distinct?: Doctrine_migration_versionsScalarFieldEnum | Doctrine_migration_versionsScalarFieldEnum[]
  }


  /**
   * doctrine_migration_versions findMany
   */
  export type doctrine_migration_versionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect<ExtArgs> | null
    /**
     * Filter, which doctrine_migration_versions to fetch.
     */
    where?: doctrine_migration_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of doctrine_migration_versions to fetch.
     */
    orderBy?: doctrine_migration_versionsOrderByWithRelationInput | doctrine_migration_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing doctrine_migration_versions.
     */
    cursor?: doctrine_migration_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` doctrine_migration_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` doctrine_migration_versions.
     */
    skip?: number
    distinct?: Doctrine_migration_versionsScalarFieldEnum | Doctrine_migration_versionsScalarFieldEnum[]
  }


  /**
   * doctrine_migration_versions create
   */
  export type doctrine_migration_versionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect<ExtArgs> | null
    /**
     * The data needed to create a doctrine_migration_versions.
     */
    data: XOR<doctrine_migration_versionsCreateInput, doctrine_migration_versionsUncheckedCreateInput>
  }


  /**
   * doctrine_migration_versions createMany
   */
  export type doctrine_migration_versionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many doctrine_migration_versions.
     */
    data: doctrine_migration_versionsCreateManyInput | doctrine_migration_versionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * doctrine_migration_versions update
   */
  export type doctrine_migration_versionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect<ExtArgs> | null
    /**
     * The data needed to update a doctrine_migration_versions.
     */
    data: XOR<doctrine_migration_versionsUpdateInput, doctrine_migration_versionsUncheckedUpdateInput>
    /**
     * Choose, which doctrine_migration_versions to update.
     */
    where: doctrine_migration_versionsWhereUniqueInput
  }


  /**
   * doctrine_migration_versions updateMany
   */
  export type doctrine_migration_versionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update doctrine_migration_versions.
     */
    data: XOR<doctrine_migration_versionsUpdateManyMutationInput, doctrine_migration_versionsUncheckedUpdateManyInput>
    /**
     * Filter which doctrine_migration_versions to update
     */
    where?: doctrine_migration_versionsWhereInput
  }


  /**
   * doctrine_migration_versions upsert
   */
  export type doctrine_migration_versionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect<ExtArgs> | null
    /**
     * The filter to search for the doctrine_migration_versions to update in case it exists.
     */
    where: doctrine_migration_versionsWhereUniqueInput
    /**
     * In case the doctrine_migration_versions found by the `where` argument doesn't exist, create a new doctrine_migration_versions with this data.
     */
    create: XOR<doctrine_migration_versionsCreateInput, doctrine_migration_versionsUncheckedCreateInput>
    /**
     * In case the doctrine_migration_versions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<doctrine_migration_versionsUpdateInput, doctrine_migration_versionsUncheckedUpdateInput>
  }


  /**
   * doctrine_migration_versions delete
   */
  export type doctrine_migration_versionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect<ExtArgs> | null
    /**
     * Filter which doctrine_migration_versions to delete.
     */
    where: doctrine_migration_versionsWhereUniqueInput
  }


  /**
   * doctrine_migration_versions deleteMany
   */
  export type doctrine_migration_versionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which doctrine_migration_versions to delete
     */
    where?: doctrine_migration_versionsWhereInput
  }


  /**
   * doctrine_migration_versions without action
   */
  export type doctrine_migration_versionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect<ExtArgs> | null
  }



  /**
   * Model event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    eventid: number | null
    eventtime: Decimal | null
    cid: number | null
  }

  export type EventSumAggregateOutputType = {
    eventid: number | null
    eventtime: Decimal | null
    cid: number | null
  }

  export type EventMinAggregateOutputType = {
    eventid: number | null
    eventtime: Decimal | null
    cid: number | null
    endpointtype: string | null
    endpointid: string | null
    action: string | null
    content: Buffer | null
  }

  export type EventMaxAggregateOutputType = {
    eventid: number | null
    eventtime: Decimal | null
    cid: number | null
    endpointtype: string | null
    endpointid: string | null
    action: string | null
    content: Buffer | null
  }

  export type EventCountAggregateOutputType = {
    eventid: number
    eventtime: number
    cid: number
    endpointtype: number
    endpointid: number
    action: number
    content: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    eventid?: true
    eventtime?: true
    cid?: true
  }

  export type EventSumAggregateInputType = {
    eventid?: true
    eventtime?: true
    cid?: true
  }

  export type EventMinAggregateInputType = {
    eventid?: true
    eventtime?: true
    cid?: true
    endpointtype?: true
    endpointid?: true
    action?: true
    content?: true
  }

  export type EventMaxAggregateInputType = {
    eventid?: true
    eventtime?: true
    cid?: true
    endpointtype?: true
    endpointid?: true
    action?: true
    content?: true
  }

  export type EventCountAggregateInputType = {
    eventid?: true
    eventtime?: true
    cid?: true
    endpointtype?: true
    endpointid?: true
    action?: true
    content?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which event to aggregate.
     */
    where?: eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type eventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: eventWhereInput
    orderBy?: eventOrderByWithAggregationInput | eventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: eventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    eventid: number
    eventtime: Decimal
    cid: number | null
    endpointtype: string
    endpointid: string
    action: string
    content: Buffer
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends eventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type eventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    eventid?: boolean
    eventtime?: boolean
    cid?: boolean
    endpointtype?: boolean
    endpointid?: boolean
    action?: boolean
    content?: boolean
    contest?: boolean | event$contestArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type eventSelectScalar = {
    eventid?: boolean
    eventtime?: boolean
    cid?: boolean
    endpointtype?: boolean
    endpointid?: boolean
    action?: boolean
    content?: boolean
  }

  export type eventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contest?: boolean | event$contestArgs<ExtArgs>
  }


  export type $eventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "event"
    objects: {
      contest: Prisma.$contestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      eventid: number
      eventtime: Prisma.Decimal
      cid: number | null
      endpointtype: string
      endpointid: string
      action: string
      content: Buffer
    }, ExtArgs["result"]["event"]>
    composites: {}
  }


  type eventGetPayload<S extends boolean | null | undefined | eventDefaultArgs> = $Result.GetResult<Prisma.$eventPayload, S>

  type eventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<eventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface eventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['event'], meta: { name: 'event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {eventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends eventFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, eventFindUniqueArgs<ExtArgs>>
    ): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Event that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {eventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends eventFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, eventFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends eventFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, eventFindFirstArgs<ExtArgs>>
    ): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends eventFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, eventFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `eventid`
     * const eventWithEventidOnly = await prisma.event.findMany({ select: { eventid: true } })
     * 
    **/
    findMany<T extends eventFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eventFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Event.
     * @param {eventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
    **/
    create<T extends eventCreateArgs<ExtArgs>>(
      args: SelectSubset<T, eventCreateArgs<ExtArgs>>
    ): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Events.
     *     @param {eventCreateManyArgs} args - Arguments to create many Events.
     *     @example
     *     // Create many Events
     *     const event = await prisma.event.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends eventCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eventCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event.
     * @param {eventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
    **/
    delete<T extends eventDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, eventDeleteArgs<ExtArgs>>
    ): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Event.
     * @param {eventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends eventUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, eventUpdateArgs<ExtArgs>>
    ): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {eventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends eventDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eventDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends eventUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, eventUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {eventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
    **/
    upsert<T extends eventUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, eventUpsertArgs<ExtArgs>>
    ): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends eventCountArgs>(
      args?: Subset<T, eventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends eventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: eventGroupByArgs['orderBy'] }
        : { orderBy?: eventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, eventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the event model
   */
  readonly fields: eventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__eventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contest<T extends event$contestArgs<ExtArgs> = {}>(args?: Subset<T, event$contestArgs<ExtArgs>>): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the event model
   */ 
  interface eventFieldRefs {
    readonly eventid: FieldRef<"event", 'Int'>
    readonly eventtime: FieldRef<"event", 'Decimal'>
    readonly cid: FieldRef<"event", 'Int'>
    readonly endpointtype: FieldRef<"event", 'String'>
    readonly endpointid: FieldRef<"event", 'String'>
    readonly action: FieldRef<"event", 'String'>
    readonly content: FieldRef<"event", 'Bytes'>
  }
    

  // Custom InputTypes

  /**
   * event findUnique
   */
  export type eventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter, which event to fetch.
     */
    where: eventWhereUniqueInput
  }


  /**
   * event findUniqueOrThrow
   */
  export type eventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter, which event to fetch.
     */
    where: eventWhereUniqueInput
  }


  /**
   * event findFirst
   */
  export type eventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter, which event to fetch.
     */
    where?: eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events.
     */
    cursor?: eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }


  /**
   * event findFirstOrThrow
   */
  export type eventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter, which event to fetch.
     */
    where?: eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events.
     */
    cursor?: eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }


  /**
   * event findMany
   */
  export type eventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where?: eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing events.
     */
    cursor?: eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }


  /**
   * event create
   */
  export type eventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * The data needed to create a event.
     */
    data: XOR<eventCreateInput, eventUncheckedCreateInput>
  }


  /**
   * event createMany
   */
  export type eventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many events.
     */
    data: eventCreateManyInput | eventCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * event update
   */
  export type eventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * The data needed to update a event.
     */
    data: XOR<eventUpdateInput, eventUncheckedUpdateInput>
    /**
     * Choose, which event to update.
     */
    where: eventWhereUniqueInput
  }


  /**
   * event updateMany
   */
  export type eventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update events.
     */
    data: XOR<eventUpdateManyMutationInput, eventUncheckedUpdateManyInput>
    /**
     * Filter which events to update
     */
    where?: eventWhereInput
  }


  /**
   * event upsert
   */
  export type eventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * The filter to search for the event to update in case it exists.
     */
    where: eventWhereUniqueInput
    /**
     * In case the event found by the `where` argument doesn't exist, create a new event with this data.
     */
    create: XOR<eventCreateInput, eventUncheckedCreateInput>
    /**
     * In case the event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<eventUpdateInput, eventUncheckedUpdateInput>
  }


  /**
   * event delete
   */
  export type eventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter which event to delete.
     */
    where: eventWhereUniqueInput
  }


  /**
   * event deleteMany
   */
  export type eventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which events to delete
     */
    where?: eventWhereInput
  }


  /**
   * event.contest
   */
  export type event$contestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contest
     */
    select?: contestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestInclude<ExtArgs> | null
    where?: contestWhereInput
  }


  /**
   * event without action
   */
  export type eventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventInclude<ExtArgs> | null
  }



  /**
   * Model executable
   */

  export type AggregateExecutable = {
    _count: ExecutableCountAggregateOutputType | null
    _avg: ExecutableAvgAggregateOutputType | null
    _sum: ExecutableSumAggregateOutputType | null
    _min: ExecutableMinAggregateOutputType | null
    _max: ExecutableMaxAggregateOutputType | null
  }

  export type ExecutableAvgAggregateOutputType = {
    immutable_execid: number | null
  }

  export type ExecutableSumAggregateOutputType = {
    immutable_execid: number | null
  }

  export type ExecutableMinAggregateOutputType = {
    execid: string | null
    description: string | null
    type: string | null
    immutable_execid: number | null
  }

  export type ExecutableMaxAggregateOutputType = {
    execid: string | null
    description: string | null
    type: string | null
    immutable_execid: number | null
  }

  export type ExecutableCountAggregateOutputType = {
    execid: number
    description: number
    type: number
    immutable_execid: number
    _all: number
  }


  export type ExecutableAvgAggregateInputType = {
    immutable_execid?: true
  }

  export type ExecutableSumAggregateInputType = {
    immutable_execid?: true
  }

  export type ExecutableMinAggregateInputType = {
    execid?: true
    description?: true
    type?: true
    immutable_execid?: true
  }

  export type ExecutableMaxAggregateInputType = {
    execid?: true
    description?: true
    type?: true
    immutable_execid?: true
  }

  export type ExecutableCountAggregateInputType = {
    execid?: true
    description?: true
    type?: true
    immutable_execid?: true
    _all?: true
  }

  export type ExecutableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which executable to aggregate.
     */
    where?: executableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of executables to fetch.
     */
    orderBy?: executableOrderByWithRelationInput | executableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: executableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` executables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` executables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned executables
    **/
    _count?: true | ExecutableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExecutableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExecutableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExecutableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExecutableMaxAggregateInputType
  }

  export type GetExecutableAggregateType<T extends ExecutableAggregateArgs> = {
        [P in keyof T & keyof AggregateExecutable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExecutable[P]>
      : GetScalarType<T[P], AggregateExecutable[P]>
  }




  export type executableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: executableWhereInput
    orderBy?: executableOrderByWithAggregationInput | executableOrderByWithAggregationInput[]
    by: ExecutableScalarFieldEnum[] | ExecutableScalarFieldEnum
    having?: executableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExecutableCountAggregateInputType | true
    _avg?: ExecutableAvgAggregateInputType
    _sum?: ExecutableSumAggregateInputType
    _min?: ExecutableMinAggregateInputType
    _max?: ExecutableMaxAggregateInputType
  }

  export type ExecutableGroupByOutputType = {
    execid: string
    description: string | null
    type: string
    immutable_execid: number | null
    _count: ExecutableCountAggregateOutputType | null
    _avg: ExecutableAvgAggregateOutputType | null
    _sum: ExecutableSumAggregateOutputType | null
    _min: ExecutableMinAggregateOutputType | null
    _max: ExecutableMaxAggregateOutputType | null
  }

  type GetExecutableGroupByPayload<T extends executableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExecutableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExecutableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExecutableGroupByOutputType[P]>
            : GetScalarType<T[P], ExecutableGroupByOutputType[P]>
        }
      >
    >


  export type executableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    execid?: boolean
    description?: boolean
    type?: boolean
    immutable_execid?: boolean
    immutable_executable?: boolean | executable$immutable_executableArgs<ExtArgs>
    language?: boolean | executable$languageArgs<ExtArgs>
    problem_problem_special_runToexecutable?: boolean | executable$problem_problem_special_runToexecutableArgs<ExtArgs>
    problem_problem_special_compareToexecutable?: boolean | executable$problem_problem_special_compareToexecutableArgs<ExtArgs>
    _count?: boolean | ExecutableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["executable"]>

  export type executableSelectScalar = {
    execid?: boolean
    description?: boolean
    type?: boolean
    immutable_execid?: boolean
  }

  export type executableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    immutable_executable?: boolean | executable$immutable_executableArgs<ExtArgs>
    language?: boolean | executable$languageArgs<ExtArgs>
    problem_problem_special_runToexecutable?: boolean | executable$problem_problem_special_runToexecutableArgs<ExtArgs>
    problem_problem_special_compareToexecutable?: boolean | executable$problem_problem_special_compareToexecutableArgs<ExtArgs>
    _count?: boolean | ExecutableCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $executablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "executable"
    objects: {
      immutable_executable: Prisma.$immutable_executablePayload<ExtArgs> | null
      language: Prisma.$languagePayload<ExtArgs>[]
      problem_problem_special_runToexecutable: Prisma.$problemPayload<ExtArgs>[]
      problem_problem_special_compareToexecutable: Prisma.$problemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      execid: string
      description: string | null
      type: string
      immutable_execid: number | null
    }, ExtArgs["result"]["executable"]>
    composites: {}
  }


  type executableGetPayload<S extends boolean | null | undefined | executableDefaultArgs> = $Result.GetResult<Prisma.$executablePayload, S>

  type executableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<executableFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExecutableCountAggregateInputType | true
    }

  export interface executableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['executable'], meta: { name: 'executable' } }
    /**
     * Find zero or one Executable that matches the filter.
     * @param {executableFindUniqueArgs} args - Arguments to find a Executable
     * @example
     * // Get one Executable
     * const executable = await prisma.executable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends executableFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, executableFindUniqueArgs<ExtArgs>>
    ): Prisma__executableClient<$Result.GetResult<Prisma.$executablePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Executable that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {executableFindUniqueOrThrowArgs} args - Arguments to find a Executable
     * @example
     * // Get one Executable
     * const executable = await prisma.executable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends executableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, executableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__executableClient<$Result.GetResult<Prisma.$executablePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Executable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {executableFindFirstArgs} args - Arguments to find a Executable
     * @example
     * // Get one Executable
     * const executable = await prisma.executable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends executableFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, executableFindFirstArgs<ExtArgs>>
    ): Prisma__executableClient<$Result.GetResult<Prisma.$executablePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Executable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {executableFindFirstOrThrowArgs} args - Arguments to find a Executable
     * @example
     * // Get one Executable
     * const executable = await prisma.executable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends executableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, executableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__executableClient<$Result.GetResult<Prisma.$executablePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Executables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {executableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Executables
     * const executables = await prisma.executable.findMany()
     * 
     * // Get first 10 Executables
     * const executables = await prisma.executable.findMany({ take: 10 })
     * 
     * // Only select the `execid`
     * const executableWithExecidOnly = await prisma.executable.findMany({ select: { execid: true } })
     * 
    **/
    findMany<T extends executableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, executableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$executablePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Executable.
     * @param {executableCreateArgs} args - Arguments to create a Executable.
     * @example
     * // Create one Executable
     * const Executable = await prisma.executable.create({
     *   data: {
     *     // ... data to create a Executable
     *   }
     * })
     * 
    **/
    create<T extends executableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, executableCreateArgs<ExtArgs>>
    ): Prisma__executableClient<$Result.GetResult<Prisma.$executablePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Executables.
     *     @param {executableCreateManyArgs} args - Arguments to create many Executables.
     *     @example
     *     // Create many Executables
     *     const executable = await prisma.executable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends executableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, executableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Executable.
     * @param {executableDeleteArgs} args - Arguments to delete one Executable.
     * @example
     * // Delete one Executable
     * const Executable = await prisma.executable.delete({
     *   where: {
     *     // ... filter to delete one Executable
     *   }
     * })
     * 
    **/
    delete<T extends executableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, executableDeleteArgs<ExtArgs>>
    ): Prisma__executableClient<$Result.GetResult<Prisma.$executablePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Executable.
     * @param {executableUpdateArgs} args - Arguments to update one Executable.
     * @example
     * // Update one Executable
     * const executable = await prisma.executable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends executableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, executableUpdateArgs<ExtArgs>>
    ): Prisma__executableClient<$Result.GetResult<Prisma.$executablePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Executables.
     * @param {executableDeleteManyArgs} args - Arguments to filter Executables to delete.
     * @example
     * // Delete a few Executables
     * const { count } = await prisma.executable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends executableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, executableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Executables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {executableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Executables
     * const executable = await prisma.executable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends executableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, executableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Executable.
     * @param {executableUpsertArgs} args - Arguments to update or create a Executable.
     * @example
     * // Update or create a Executable
     * const executable = await prisma.executable.upsert({
     *   create: {
     *     // ... data to create a Executable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Executable we want to update
     *   }
     * })
    **/
    upsert<T extends executableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, executableUpsertArgs<ExtArgs>>
    ): Prisma__executableClient<$Result.GetResult<Prisma.$executablePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Executables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {executableCountArgs} args - Arguments to filter Executables to count.
     * @example
     * // Count the number of Executables
     * const count = await prisma.executable.count({
     *   where: {
     *     // ... the filter for the Executables we want to count
     *   }
     * })
    **/
    count<T extends executableCountArgs>(
      args?: Subset<T, executableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExecutableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Executable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExecutableAggregateArgs>(args: Subset<T, ExecutableAggregateArgs>): Prisma.PrismaPromise<GetExecutableAggregateType<T>>

    /**
     * Group by Executable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {executableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends executableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: executableGroupByArgs['orderBy'] }
        : { orderBy?: executableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, executableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExecutableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the executable model
   */
  readonly fields: executableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for executable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__executableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    immutable_executable<T extends executable$immutable_executableArgs<ExtArgs> = {}>(args?: Subset<T, executable$immutable_executableArgs<ExtArgs>>): Prisma__immutable_executableClient<$Result.GetResult<Prisma.$immutable_executablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    language<T extends executable$languageArgs<ExtArgs> = {}>(args?: Subset<T, executable$languageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$languagePayload<ExtArgs>, T, 'findMany'> | Null>;

    problem_problem_special_runToexecutable<T extends executable$problem_problem_special_runToexecutableArgs<ExtArgs> = {}>(args?: Subset<T, executable$problem_problem_special_runToexecutableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$problemPayload<ExtArgs>, T, 'findMany'> | Null>;

    problem_problem_special_compareToexecutable<T extends executable$problem_problem_special_compareToexecutableArgs<ExtArgs> = {}>(args?: Subset<T, executable$problem_problem_special_compareToexecutableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$problemPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the executable model
   */ 
  interface executableFieldRefs {
    readonly execid: FieldRef<"executable", 'String'>
    readonly description: FieldRef<"executable", 'String'>
    readonly type: FieldRef<"executable", 'String'>
    readonly immutable_execid: FieldRef<"executable", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * executable findUnique
   */
  export type executableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable
     */
    select?: executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executableInclude<ExtArgs> | null
    /**
     * Filter, which executable to fetch.
     */
    where: executableWhereUniqueInput
  }


  /**
   * executable findUniqueOrThrow
   */
  export type executableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable
     */
    select?: executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executableInclude<ExtArgs> | null
    /**
     * Filter, which executable to fetch.
     */
    where: executableWhereUniqueInput
  }


  /**
   * executable findFirst
   */
  export type executableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable
     */
    select?: executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executableInclude<ExtArgs> | null
    /**
     * Filter, which executable to fetch.
     */
    where?: executableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of executables to fetch.
     */
    orderBy?: executableOrderByWithRelationInput | executableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for executables.
     */
    cursor?: executableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` executables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` executables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of executables.
     */
    distinct?: ExecutableScalarFieldEnum | ExecutableScalarFieldEnum[]
  }


  /**
   * executable findFirstOrThrow
   */
  export type executableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable
     */
    select?: executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executableInclude<ExtArgs> | null
    /**
     * Filter, which executable to fetch.
     */
    where?: executableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of executables to fetch.
     */
    orderBy?: executableOrderByWithRelationInput | executableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for executables.
     */
    cursor?: executableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` executables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` executables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of executables.
     */
    distinct?: ExecutableScalarFieldEnum | ExecutableScalarFieldEnum[]
  }


  /**
   * executable findMany
   */
  export type executableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable
     */
    select?: executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executableInclude<ExtArgs> | null
    /**
     * Filter, which executables to fetch.
     */
    where?: executableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of executables to fetch.
     */
    orderBy?: executableOrderByWithRelationInput | executableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing executables.
     */
    cursor?: executableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` executables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` executables.
     */
    skip?: number
    distinct?: ExecutableScalarFieldEnum | ExecutableScalarFieldEnum[]
  }


  /**
   * executable create
   */
  export type executableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable
     */
    select?: executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executableInclude<ExtArgs> | null
    /**
     * The data needed to create a executable.
     */
    data: XOR<executableCreateInput, executableUncheckedCreateInput>
  }


  /**
   * executable createMany
   */
  export type executableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many executables.
     */
    data: executableCreateManyInput | executableCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * executable update
   */
  export type executableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable
     */
    select?: executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executableInclude<ExtArgs> | null
    /**
     * The data needed to update a executable.
     */
    data: XOR<executableUpdateInput, executableUncheckedUpdateInput>
    /**
     * Choose, which executable to update.
     */
    where: executableWhereUniqueInput
  }


  /**
   * executable updateMany
   */
  export type executableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update executables.
     */
    data: XOR<executableUpdateManyMutationInput, executableUncheckedUpdateManyInput>
    /**
     * Filter which executables to update
     */
    where?: executableWhereInput
  }


  /**
   * executable upsert
   */
  export type executableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable
     */
    select?: executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executableInclude<ExtArgs> | null
    /**
     * The filter to search for the executable to update in case it exists.
     */
    where: executableWhereUniqueInput
    /**
     * In case the executable found by the `where` argument doesn't exist, create a new executable with this data.
     */
    create: XOR<executableCreateInput, executableUncheckedCreateInput>
    /**
     * In case the executable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<executableUpdateInput, executableUncheckedUpdateInput>
  }


  /**
   * executable delete
   */
  export type executableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable
     */
    select?: executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executableInclude<ExtArgs> | null
    /**
     * Filter which executable to delete.
     */
    where: executableWhereUniqueInput
  }


  /**
   * executable deleteMany
   */
  export type executableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which executables to delete
     */
    where?: executableWhereInput
  }


  /**
   * executable.immutable_executable
   */
  export type executable$immutable_executableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the immutable_executable
     */
    select?: immutable_executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: immutable_executableInclude<ExtArgs> | null
    where?: immutable_executableWhereInput
  }


  /**
   * executable.language
   */
  export type executable$languageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: languageInclude<ExtArgs> | null
    where?: languageWhereInput
    orderBy?: languageOrderByWithRelationInput | languageOrderByWithRelationInput[]
    cursor?: languageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }


  /**
   * executable.problem_problem_special_runToexecutable
   */
  export type executable$problem_problem_special_runToexecutableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem
     */
    select?: problemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problemInclude<ExtArgs> | null
    where?: problemWhereInput
    orderBy?: problemOrderByWithRelationInput | problemOrderByWithRelationInput[]
    cursor?: problemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProblemScalarFieldEnum | ProblemScalarFieldEnum[]
  }


  /**
   * executable.problem_problem_special_compareToexecutable
   */
  export type executable$problem_problem_special_compareToexecutableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem
     */
    select?: problemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problemInclude<ExtArgs> | null
    where?: problemWhereInput
    orderBy?: problemOrderByWithRelationInput | problemOrderByWithRelationInput[]
    cursor?: problemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProblemScalarFieldEnum | ProblemScalarFieldEnum[]
  }


  /**
   * executable without action
   */
  export type executableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable
     */
    select?: executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executableInclude<ExtArgs> | null
  }



  /**
   * Model executable_file
   */

  export type AggregateExecutable_file = {
    _count: Executable_fileCountAggregateOutputType | null
    _avg: Executable_fileAvgAggregateOutputType | null
    _sum: Executable_fileSumAggregateOutputType | null
    _min: Executable_fileMinAggregateOutputType | null
    _max: Executable_fileMaxAggregateOutputType | null
  }

  export type Executable_fileAvgAggregateOutputType = {
    execfileid: number | null
    immutable_execid: number | null
    ranknumber: number | null
  }

  export type Executable_fileSumAggregateOutputType = {
    execfileid: number | null
    immutable_execid: number | null
    ranknumber: number | null
  }

  export type Executable_fileMinAggregateOutputType = {
    execfileid: number | null
    immutable_execid: number | null
    filename: string | null
    ranknumber: number | null
    file_content: Buffer | null
    hash: string | null
    is_executable: boolean | null
  }

  export type Executable_fileMaxAggregateOutputType = {
    execfileid: number | null
    immutable_execid: number | null
    filename: string | null
    ranknumber: number | null
    file_content: Buffer | null
    hash: string | null
    is_executable: boolean | null
  }

  export type Executable_fileCountAggregateOutputType = {
    execfileid: number
    immutable_execid: number
    filename: number
    ranknumber: number
    file_content: number
    hash: number
    is_executable: number
    _all: number
  }


  export type Executable_fileAvgAggregateInputType = {
    execfileid?: true
    immutable_execid?: true
    ranknumber?: true
  }

  export type Executable_fileSumAggregateInputType = {
    execfileid?: true
    immutable_execid?: true
    ranknumber?: true
  }

  export type Executable_fileMinAggregateInputType = {
    execfileid?: true
    immutable_execid?: true
    filename?: true
    ranknumber?: true
    file_content?: true
    hash?: true
    is_executable?: true
  }

  export type Executable_fileMaxAggregateInputType = {
    execfileid?: true
    immutable_execid?: true
    filename?: true
    ranknumber?: true
    file_content?: true
    hash?: true
    is_executable?: true
  }

  export type Executable_fileCountAggregateInputType = {
    execfileid?: true
    immutable_execid?: true
    filename?: true
    ranknumber?: true
    file_content?: true
    hash?: true
    is_executable?: true
    _all?: true
  }

  export type Executable_fileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which executable_file to aggregate.
     */
    where?: executable_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of executable_files to fetch.
     */
    orderBy?: executable_fileOrderByWithRelationInput | executable_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: executable_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` executable_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` executable_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned executable_files
    **/
    _count?: true | Executable_fileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Executable_fileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Executable_fileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Executable_fileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Executable_fileMaxAggregateInputType
  }

  export type GetExecutable_fileAggregateType<T extends Executable_fileAggregateArgs> = {
        [P in keyof T & keyof AggregateExecutable_file]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExecutable_file[P]>
      : GetScalarType<T[P], AggregateExecutable_file[P]>
  }




  export type executable_fileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: executable_fileWhereInput
    orderBy?: executable_fileOrderByWithAggregationInput | executable_fileOrderByWithAggregationInput[]
    by: Executable_fileScalarFieldEnum[] | Executable_fileScalarFieldEnum
    having?: executable_fileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Executable_fileCountAggregateInputType | true
    _avg?: Executable_fileAvgAggregateInputType
    _sum?: Executable_fileSumAggregateInputType
    _min?: Executable_fileMinAggregateInputType
    _max?: Executable_fileMaxAggregateInputType
  }

  export type Executable_fileGroupByOutputType = {
    execfileid: number
    immutable_execid: number | null
    filename: string
    ranknumber: number
    file_content: Buffer
    hash: string | null
    is_executable: boolean
    _count: Executable_fileCountAggregateOutputType | null
    _avg: Executable_fileAvgAggregateOutputType | null
    _sum: Executable_fileSumAggregateOutputType | null
    _min: Executable_fileMinAggregateOutputType | null
    _max: Executable_fileMaxAggregateOutputType | null
  }

  type GetExecutable_fileGroupByPayload<T extends executable_fileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Executable_fileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Executable_fileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Executable_fileGroupByOutputType[P]>
            : GetScalarType<T[P], Executable_fileGroupByOutputType[P]>
        }
      >
    >


  export type executable_fileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    execfileid?: boolean
    immutable_execid?: boolean
    filename?: boolean
    ranknumber?: boolean
    file_content?: boolean
    hash?: boolean
    is_executable?: boolean
    immutable_executable?: boolean | executable_file$immutable_executableArgs<ExtArgs>
  }, ExtArgs["result"]["executable_file"]>

  export type executable_fileSelectScalar = {
    execfileid?: boolean
    immutable_execid?: boolean
    filename?: boolean
    ranknumber?: boolean
    file_content?: boolean
    hash?: boolean
    is_executable?: boolean
  }

  export type executable_fileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    immutable_executable?: boolean | executable_file$immutable_executableArgs<ExtArgs>
  }


  export type $executable_filePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "executable_file"
    objects: {
      immutable_executable: Prisma.$immutable_executablePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      execfileid: number
      immutable_execid: number | null
      filename: string
      ranknumber: number
      file_content: Buffer
      hash: string | null
      is_executable: boolean
    }, ExtArgs["result"]["executable_file"]>
    composites: {}
  }


  type executable_fileGetPayload<S extends boolean | null | undefined | executable_fileDefaultArgs> = $Result.GetResult<Prisma.$executable_filePayload, S>

  type executable_fileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<executable_fileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Executable_fileCountAggregateInputType | true
    }

  export interface executable_fileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['executable_file'], meta: { name: 'executable_file' } }
    /**
     * Find zero or one Executable_file that matches the filter.
     * @param {executable_fileFindUniqueArgs} args - Arguments to find a Executable_file
     * @example
     * // Get one Executable_file
     * const executable_file = await prisma.executable_file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends executable_fileFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, executable_fileFindUniqueArgs<ExtArgs>>
    ): Prisma__executable_fileClient<$Result.GetResult<Prisma.$executable_filePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Executable_file that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {executable_fileFindUniqueOrThrowArgs} args - Arguments to find a Executable_file
     * @example
     * // Get one Executable_file
     * const executable_file = await prisma.executable_file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends executable_fileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, executable_fileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__executable_fileClient<$Result.GetResult<Prisma.$executable_filePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Executable_file that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {executable_fileFindFirstArgs} args - Arguments to find a Executable_file
     * @example
     * // Get one Executable_file
     * const executable_file = await prisma.executable_file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends executable_fileFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, executable_fileFindFirstArgs<ExtArgs>>
    ): Prisma__executable_fileClient<$Result.GetResult<Prisma.$executable_filePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Executable_file that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {executable_fileFindFirstOrThrowArgs} args - Arguments to find a Executable_file
     * @example
     * // Get one Executable_file
     * const executable_file = await prisma.executable_file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends executable_fileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, executable_fileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__executable_fileClient<$Result.GetResult<Prisma.$executable_filePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Executable_files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {executable_fileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Executable_files
     * const executable_files = await prisma.executable_file.findMany()
     * 
     * // Get first 10 Executable_files
     * const executable_files = await prisma.executable_file.findMany({ take: 10 })
     * 
     * // Only select the `execfileid`
     * const executable_fileWithExecfileidOnly = await prisma.executable_file.findMany({ select: { execfileid: true } })
     * 
    **/
    findMany<T extends executable_fileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, executable_fileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$executable_filePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Executable_file.
     * @param {executable_fileCreateArgs} args - Arguments to create a Executable_file.
     * @example
     * // Create one Executable_file
     * const Executable_file = await prisma.executable_file.create({
     *   data: {
     *     // ... data to create a Executable_file
     *   }
     * })
     * 
    **/
    create<T extends executable_fileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, executable_fileCreateArgs<ExtArgs>>
    ): Prisma__executable_fileClient<$Result.GetResult<Prisma.$executable_filePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Executable_files.
     *     @param {executable_fileCreateManyArgs} args - Arguments to create many Executable_files.
     *     @example
     *     // Create many Executable_files
     *     const executable_file = await prisma.executable_file.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends executable_fileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, executable_fileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Executable_file.
     * @param {executable_fileDeleteArgs} args - Arguments to delete one Executable_file.
     * @example
     * // Delete one Executable_file
     * const Executable_file = await prisma.executable_file.delete({
     *   where: {
     *     // ... filter to delete one Executable_file
     *   }
     * })
     * 
    **/
    delete<T extends executable_fileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, executable_fileDeleteArgs<ExtArgs>>
    ): Prisma__executable_fileClient<$Result.GetResult<Prisma.$executable_filePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Executable_file.
     * @param {executable_fileUpdateArgs} args - Arguments to update one Executable_file.
     * @example
     * // Update one Executable_file
     * const executable_file = await prisma.executable_file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends executable_fileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, executable_fileUpdateArgs<ExtArgs>>
    ): Prisma__executable_fileClient<$Result.GetResult<Prisma.$executable_filePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Executable_files.
     * @param {executable_fileDeleteManyArgs} args - Arguments to filter Executable_files to delete.
     * @example
     * // Delete a few Executable_files
     * const { count } = await prisma.executable_file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends executable_fileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, executable_fileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Executable_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {executable_fileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Executable_files
     * const executable_file = await prisma.executable_file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends executable_fileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, executable_fileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Executable_file.
     * @param {executable_fileUpsertArgs} args - Arguments to update or create a Executable_file.
     * @example
     * // Update or create a Executable_file
     * const executable_file = await prisma.executable_file.upsert({
     *   create: {
     *     // ... data to create a Executable_file
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Executable_file we want to update
     *   }
     * })
    **/
    upsert<T extends executable_fileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, executable_fileUpsertArgs<ExtArgs>>
    ): Prisma__executable_fileClient<$Result.GetResult<Prisma.$executable_filePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Executable_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {executable_fileCountArgs} args - Arguments to filter Executable_files to count.
     * @example
     * // Count the number of Executable_files
     * const count = await prisma.executable_file.count({
     *   where: {
     *     // ... the filter for the Executable_files we want to count
     *   }
     * })
    **/
    count<T extends executable_fileCountArgs>(
      args?: Subset<T, executable_fileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Executable_fileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Executable_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Executable_fileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Executable_fileAggregateArgs>(args: Subset<T, Executable_fileAggregateArgs>): Prisma.PrismaPromise<GetExecutable_fileAggregateType<T>>

    /**
     * Group by Executable_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {executable_fileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends executable_fileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: executable_fileGroupByArgs['orderBy'] }
        : { orderBy?: executable_fileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, executable_fileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExecutable_fileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the executable_file model
   */
  readonly fields: executable_fileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for executable_file.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__executable_fileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    immutable_executable<T extends executable_file$immutable_executableArgs<ExtArgs> = {}>(args?: Subset<T, executable_file$immutable_executableArgs<ExtArgs>>): Prisma__immutable_executableClient<$Result.GetResult<Prisma.$immutable_executablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the executable_file model
   */ 
  interface executable_fileFieldRefs {
    readonly execfileid: FieldRef<"executable_file", 'Int'>
    readonly immutable_execid: FieldRef<"executable_file", 'Int'>
    readonly filename: FieldRef<"executable_file", 'String'>
    readonly ranknumber: FieldRef<"executable_file", 'Int'>
    readonly file_content: FieldRef<"executable_file", 'Bytes'>
    readonly hash: FieldRef<"executable_file", 'String'>
    readonly is_executable: FieldRef<"executable_file", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * executable_file findUnique
   */
  export type executable_fileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable_file
     */
    select?: executable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executable_fileInclude<ExtArgs> | null
    /**
     * Filter, which executable_file to fetch.
     */
    where: executable_fileWhereUniqueInput
  }


  /**
   * executable_file findUniqueOrThrow
   */
  export type executable_fileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable_file
     */
    select?: executable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executable_fileInclude<ExtArgs> | null
    /**
     * Filter, which executable_file to fetch.
     */
    where: executable_fileWhereUniqueInput
  }


  /**
   * executable_file findFirst
   */
  export type executable_fileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable_file
     */
    select?: executable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executable_fileInclude<ExtArgs> | null
    /**
     * Filter, which executable_file to fetch.
     */
    where?: executable_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of executable_files to fetch.
     */
    orderBy?: executable_fileOrderByWithRelationInput | executable_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for executable_files.
     */
    cursor?: executable_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` executable_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` executable_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of executable_files.
     */
    distinct?: Executable_fileScalarFieldEnum | Executable_fileScalarFieldEnum[]
  }


  /**
   * executable_file findFirstOrThrow
   */
  export type executable_fileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable_file
     */
    select?: executable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executable_fileInclude<ExtArgs> | null
    /**
     * Filter, which executable_file to fetch.
     */
    where?: executable_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of executable_files to fetch.
     */
    orderBy?: executable_fileOrderByWithRelationInput | executable_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for executable_files.
     */
    cursor?: executable_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` executable_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` executable_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of executable_files.
     */
    distinct?: Executable_fileScalarFieldEnum | Executable_fileScalarFieldEnum[]
  }


  /**
   * executable_file findMany
   */
  export type executable_fileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable_file
     */
    select?: executable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executable_fileInclude<ExtArgs> | null
    /**
     * Filter, which executable_files to fetch.
     */
    where?: executable_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of executable_files to fetch.
     */
    orderBy?: executable_fileOrderByWithRelationInput | executable_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing executable_files.
     */
    cursor?: executable_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` executable_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` executable_files.
     */
    skip?: number
    distinct?: Executable_fileScalarFieldEnum | Executable_fileScalarFieldEnum[]
  }


  /**
   * executable_file create
   */
  export type executable_fileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable_file
     */
    select?: executable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executable_fileInclude<ExtArgs> | null
    /**
     * The data needed to create a executable_file.
     */
    data: XOR<executable_fileCreateInput, executable_fileUncheckedCreateInput>
  }


  /**
   * executable_file createMany
   */
  export type executable_fileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many executable_files.
     */
    data: executable_fileCreateManyInput | executable_fileCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * executable_file update
   */
  export type executable_fileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable_file
     */
    select?: executable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executable_fileInclude<ExtArgs> | null
    /**
     * The data needed to update a executable_file.
     */
    data: XOR<executable_fileUpdateInput, executable_fileUncheckedUpdateInput>
    /**
     * Choose, which executable_file to update.
     */
    where: executable_fileWhereUniqueInput
  }


  /**
   * executable_file updateMany
   */
  export type executable_fileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update executable_files.
     */
    data: XOR<executable_fileUpdateManyMutationInput, executable_fileUncheckedUpdateManyInput>
    /**
     * Filter which executable_files to update
     */
    where?: executable_fileWhereInput
  }


  /**
   * executable_file upsert
   */
  export type executable_fileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable_file
     */
    select?: executable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executable_fileInclude<ExtArgs> | null
    /**
     * The filter to search for the executable_file to update in case it exists.
     */
    where: executable_fileWhereUniqueInput
    /**
     * In case the executable_file found by the `where` argument doesn't exist, create a new executable_file with this data.
     */
    create: XOR<executable_fileCreateInput, executable_fileUncheckedCreateInput>
    /**
     * In case the executable_file was found with the provided `where` argument, update it with this data.
     */
    update: XOR<executable_fileUpdateInput, executable_fileUncheckedUpdateInput>
  }


  /**
   * executable_file delete
   */
  export type executable_fileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable_file
     */
    select?: executable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executable_fileInclude<ExtArgs> | null
    /**
     * Filter which executable_file to delete.
     */
    where: executable_fileWhereUniqueInput
  }


  /**
   * executable_file deleteMany
   */
  export type executable_fileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which executable_files to delete
     */
    where?: executable_fileWhereInput
  }


  /**
   * executable_file.immutable_executable
   */
  export type executable_file$immutable_executableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the immutable_executable
     */
    select?: immutable_executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: immutable_executableInclude<ExtArgs> | null
    where?: immutable_executableWhereInput
  }


  /**
   * executable_file without action
   */
  export type executable_fileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable_file
     */
    select?: executable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executable_fileInclude<ExtArgs> | null
  }



  /**
   * Model external_contest_source
   */

  export type AggregateExternal_contest_source = {
    _count: External_contest_sourceCountAggregateOutputType | null
    _avg: External_contest_sourceAvgAggregateOutputType | null
    _sum: External_contest_sourceSumAggregateOutputType | null
    _min: External_contest_sourceMinAggregateOutputType | null
    _max: External_contest_sourceMaxAggregateOutputType | null
  }

  export type External_contest_sourceAvgAggregateOutputType = {
    extsourceid: number | null
    cid: number | null
    last_poll_time: Decimal | null
  }

  export type External_contest_sourceSumAggregateOutputType = {
    extsourceid: number | null
    cid: number | null
    last_poll_time: Decimal | null
  }

  export type External_contest_sourceMinAggregateOutputType = {
    extsourceid: number | null
    cid: number | null
    type: string | null
    source: string | null
    username: string | null
    password: string | null
    last_event_id: string | null
    last_poll_time: Decimal | null
  }

  export type External_contest_sourceMaxAggregateOutputType = {
    extsourceid: number | null
    cid: number | null
    type: string | null
    source: string | null
    username: string | null
    password: string | null
    last_event_id: string | null
    last_poll_time: Decimal | null
  }

  export type External_contest_sourceCountAggregateOutputType = {
    extsourceid: number
    cid: number
    type: number
    source: number
    username: number
    password: number
    last_event_id: number
    last_poll_time: number
    _all: number
  }


  export type External_contest_sourceAvgAggregateInputType = {
    extsourceid?: true
    cid?: true
    last_poll_time?: true
  }

  export type External_contest_sourceSumAggregateInputType = {
    extsourceid?: true
    cid?: true
    last_poll_time?: true
  }

  export type External_contest_sourceMinAggregateInputType = {
    extsourceid?: true
    cid?: true
    type?: true
    source?: true
    username?: true
    password?: true
    last_event_id?: true
    last_poll_time?: true
  }

  export type External_contest_sourceMaxAggregateInputType = {
    extsourceid?: true
    cid?: true
    type?: true
    source?: true
    username?: true
    password?: true
    last_event_id?: true
    last_poll_time?: true
  }

  export type External_contest_sourceCountAggregateInputType = {
    extsourceid?: true
    cid?: true
    type?: true
    source?: true
    username?: true
    password?: true
    last_event_id?: true
    last_poll_time?: true
    _all?: true
  }

  export type External_contest_sourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which external_contest_source to aggregate.
     */
    where?: external_contest_sourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of external_contest_sources to fetch.
     */
    orderBy?: external_contest_sourceOrderByWithRelationInput | external_contest_sourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: external_contest_sourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` external_contest_sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` external_contest_sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned external_contest_sources
    **/
    _count?: true | External_contest_sourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: External_contest_sourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: External_contest_sourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: External_contest_sourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: External_contest_sourceMaxAggregateInputType
  }

  export type GetExternal_contest_sourceAggregateType<T extends External_contest_sourceAggregateArgs> = {
        [P in keyof T & keyof AggregateExternal_contest_source]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternal_contest_source[P]>
      : GetScalarType<T[P], AggregateExternal_contest_source[P]>
  }




  export type external_contest_sourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: external_contest_sourceWhereInput
    orderBy?: external_contest_sourceOrderByWithAggregationInput | external_contest_sourceOrderByWithAggregationInput[]
    by: External_contest_sourceScalarFieldEnum[] | External_contest_sourceScalarFieldEnum
    having?: external_contest_sourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: External_contest_sourceCountAggregateInputType | true
    _avg?: External_contest_sourceAvgAggregateInputType
    _sum?: External_contest_sourceSumAggregateInputType
    _min?: External_contest_sourceMinAggregateInputType
    _max?: External_contest_sourceMaxAggregateInputType
  }

  export type External_contest_sourceGroupByOutputType = {
    extsourceid: number
    cid: number | null
    type: string
    source: string
    username: string | null
    password: string | null
    last_event_id: string | null
    last_poll_time: Decimal | null
    _count: External_contest_sourceCountAggregateOutputType | null
    _avg: External_contest_sourceAvgAggregateOutputType | null
    _sum: External_contest_sourceSumAggregateOutputType | null
    _min: External_contest_sourceMinAggregateOutputType | null
    _max: External_contest_sourceMaxAggregateOutputType | null
  }

  type GetExternal_contest_sourceGroupByPayload<T extends external_contest_sourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<External_contest_sourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof External_contest_sourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], External_contest_sourceGroupByOutputType[P]>
            : GetScalarType<T[P], External_contest_sourceGroupByOutputType[P]>
        }
      >
    >


  export type external_contest_sourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    extsourceid?: boolean
    cid?: boolean
    type?: boolean
    source?: boolean
    username?: boolean
    password?: boolean
    last_event_id?: boolean
    last_poll_time?: boolean
    contest?: boolean | external_contest_source$contestArgs<ExtArgs>
    external_source_warning?: boolean | external_contest_source$external_source_warningArgs<ExtArgs>
    _count?: boolean | External_contest_sourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["external_contest_source"]>

  export type external_contest_sourceSelectScalar = {
    extsourceid?: boolean
    cid?: boolean
    type?: boolean
    source?: boolean
    username?: boolean
    password?: boolean
    last_event_id?: boolean
    last_poll_time?: boolean
  }

  export type external_contest_sourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contest?: boolean | external_contest_source$contestArgs<ExtArgs>
    external_source_warning?: boolean | external_contest_source$external_source_warningArgs<ExtArgs>
    _count?: boolean | External_contest_sourceCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $external_contest_sourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "external_contest_source"
    objects: {
      contest: Prisma.$contestPayload<ExtArgs> | null
      external_source_warning: Prisma.$external_source_warningPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      extsourceid: number
      cid: number | null
      type: string
      source: string
      username: string | null
      password: string | null
      last_event_id: string | null
      last_poll_time: Prisma.Decimal | null
    }, ExtArgs["result"]["external_contest_source"]>
    composites: {}
  }


  type external_contest_sourceGetPayload<S extends boolean | null | undefined | external_contest_sourceDefaultArgs> = $Result.GetResult<Prisma.$external_contest_sourcePayload, S>

  type external_contest_sourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<external_contest_sourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: External_contest_sourceCountAggregateInputType | true
    }

  export interface external_contest_sourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['external_contest_source'], meta: { name: 'external_contest_source' } }
    /**
     * Find zero or one External_contest_source that matches the filter.
     * @param {external_contest_sourceFindUniqueArgs} args - Arguments to find a External_contest_source
     * @example
     * // Get one External_contest_source
     * const external_contest_source = await prisma.external_contest_source.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends external_contest_sourceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, external_contest_sourceFindUniqueArgs<ExtArgs>>
    ): Prisma__external_contest_sourceClient<$Result.GetResult<Prisma.$external_contest_sourcePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one External_contest_source that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {external_contest_sourceFindUniqueOrThrowArgs} args - Arguments to find a External_contest_source
     * @example
     * // Get one External_contest_source
     * const external_contest_source = await prisma.external_contest_source.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends external_contest_sourceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, external_contest_sourceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__external_contest_sourceClient<$Result.GetResult<Prisma.$external_contest_sourcePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first External_contest_source that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_contest_sourceFindFirstArgs} args - Arguments to find a External_contest_source
     * @example
     * // Get one External_contest_source
     * const external_contest_source = await prisma.external_contest_source.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends external_contest_sourceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, external_contest_sourceFindFirstArgs<ExtArgs>>
    ): Prisma__external_contest_sourceClient<$Result.GetResult<Prisma.$external_contest_sourcePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first External_contest_source that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_contest_sourceFindFirstOrThrowArgs} args - Arguments to find a External_contest_source
     * @example
     * // Get one External_contest_source
     * const external_contest_source = await prisma.external_contest_source.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends external_contest_sourceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, external_contest_sourceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__external_contest_sourceClient<$Result.GetResult<Prisma.$external_contest_sourcePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more External_contest_sources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_contest_sourceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all External_contest_sources
     * const external_contest_sources = await prisma.external_contest_source.findMany()
     * 
     * // Get first 10 External_contest_sources
     * const external_contest_sources = await prisma.external_contest_source.findMany({ take: 10 })
     * 
     * // Only select the `extsourceid`
     * const external_contest_sourceWithExtsourceidOnly = await prisma.external_contest_source.findMany({ select: { extsourceid: true } })
     * 
    **/
    findMany<T extends external_contest_sourceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, external_contest_sourceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$external_contest_sourcePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a External_contest_source.
     * @param {external_contest_sourceCreateArgs} args - Arguments to create a External_contest_source.
     * @example
     * // Create one External_contest_source
     * const External_contest_source = await prisma.external_contest_source.create({
     *   data: {
     *     // ... data to create a External_contest_source
     *   }
     * })
     * 
    **/
    create<T extends external_contest_sourceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, external_contest_sourceCreateArgs<ExtArgs>>
    ): Prisma__external_contest_sourceClient<$Result.GetResult<Prisma.$external_contest_sourcePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many External_contest_sources.
     *     @param {external_contest_sourceCreateManyArgs} args - Arguments to create many External_contest_sources.
     *     @example
     *     // Create many External_contest_sources
     *     const external_contest_source = await prisma.external_contest_source.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends external_contest_sourceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, external_contest_sourceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a External_contest_source.
     * @param {external_contest_sourceDeleteArgs} args - Arguments to delete one External_contest_source.
     * @example
     * // Delete one External_contest_source
     * const External_contest_source = await prisma.external_contest_source.delete({
     *   where: {
     *     // ... filter to delete one External_contest_source
     *   }
     * })
     * 
    **/
    delete<T extends external_contest_sourceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, external_contest_sourceDeleteArgs<ExtArgs>>
    ): Prisma__external_contest_sourceClient<$Result.GetResult<Prisma.$external_contest_sourcePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one External_contest_source.
     * @param {external_contest_sourceUpdateArgs} args - Arguments to update one External_contest_source.
     * @example
     * // Update one External_contest_source
     * const external_contest_source = await prisma.external_contest_source.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends external_contest_sourceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, external_contest_sourceUpdateArgs<ExtArgs>>
    ): Prisma__external_contest_sourceClient<$Result.GetResult<Prisma.$external_contest_sourcePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more External_contest_sources.
     * @param {external_contest_sourceDeleteManyArgs} args - Arguments to filter External_contest_sources to delete.
     * @example
     * // Delete a few External_contest_sources
     * const { count } = await prisma.external_contest_source.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends external_contest_sourceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, external_contest_sourceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more External_contest_sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_contest_sourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many External_contest_sources
     * const external_contest_source = await prisma.external_contest_source.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends external_contest_sourceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, external_contest_sourceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one External_contest_source.
     * @param {external_contest_sourceUpsertArgs} args - Arguments to update or create a External_contest_source.
     * @example
     * // Update or create a External_contest_source
     * const external_contest_source = await prisma.external_contest_source.upsert({
     *   create: {
     *     // ... data to create a External_contest_source
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the External_contest_source we want to update
     *   }
     * })
    **/
    upsert<T extends external_contest_sourceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, external_contest_sourceUpsertArgs<ExtArgs>>
    ): Prisma__external_contest_sourceClient<$Result.GetResult<Prisma.$external_contest_sourcePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of External_contest_sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_contest_sourceCountArgs} args - Arguments to filter External_contest_sources to count.
     * @example
     * // Count the number of External_contest_sources
     * const count = await prisma.external_contest_source.count({
     *   where: {
     *     // ... the filter for the External_contest_sources we want to count
     *   }
     * })
    **/
    count<T extends external_contest_sourceCountArgs>(
      args?: Subset<T, external_contest_sourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], External_contest_sourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a External_contest_source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {External_contest_sourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends External_contest_sourceAggregateArgs>(args: Subset<T, External_contest_sourceAggregateArgs>): Prisma.PrismaPromise<GetExternal_contest_sourceAggregateType<T>>

    /**
     * Group by External_contest_source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_contest_sourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends external_contest_sourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: external_contest_sourceGroupByArgs['orderBy'] }
        : { orderBy?: external_contest_sourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, external_contest_sourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternal_contest_sourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the external_contest_source model
   */
  readonly fields: external_contest_sourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for external_contest_source.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__external_contest_sourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contest<T extends external_contest_source$contestArgs<ExtArgs> = {}>(args?: Subset<T, external_contest_source$contestArgs<ExtArgs>>): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    external_source_warning<T extends external_contest_source$external_source_warningArgs<ExtArgs> = {}>(args?: Subset<T, external_contest_source$external_source_warningArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$external_source_warningPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the external_contest_source model
   */ 
  interface external_contest_sourceFieldRefs {
    readonly extsourceid: FieldRef<"external_contest_source", 'Int'>
    readonly cid: FieldRef<"external_contest_source", 'Int'>
    readonly type: FieldRef<"external_contest_source", 'String'>
    readonly source: FieldRef<"external_contest_source", 'String'>
    readonly username: FieldRef<"external_contest_source", 'String'>
    readonly password: FieldRef<"external_contest_source", 'String'>
    readonly last_event_id: FieldRef<"external_contest_source", 'String'>
    readonly last_poll_time: FieldRef<"external_contest_source", 'Decimal'>
  }
    

  // Custom InputTypes

  /**
   * external_contest_source findUnique
   */
  export type external_contest_sourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_contest_source
     */
    select?: external_contest_sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_contest_sourceInclude<ExtArgs> | null
    /**
     * Filter, which external_contest_source to fetch.
     */
    where: external_contest_sourceWhereUniqueInput
  }


  /**
   * external_contest_source findUniqueOrThrow
   */
  export type external_contest_sourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_contest_source
     */
    select?: external_contest_sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_contest_sourceInclude<ExtArgs> | null
    /**
     * Filter, which external_contest_source to fetch.
     */
    where: external_contest_sourceWhereUniqueInput
  }


  /**
   * external_contest_source findFirst
   */
  export type external_contest_sourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_contest_source
     */
    select?: external_contest_sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_contest_sourceInclude<ExtArgs> | null
    /**
     * Filter, which external_contest_source to fetch.
     */
    where?: external_contest_sourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of external_contest_sources to fetch.
     */
    orderBy?: external_contest_sourceOrderByWithRelationInput | external_contest_sourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for external_contest_sources.
     */
    cursor?: external_contest_sourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` external_contest_sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` external_contest_sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of external_contest_sources.
     */
    distinct?: External_contest_sourceScalarFieldEnum | External_contest_sourceScalarFieldEnum[]
  }


  /**
   * external_contest_source findFirstOrThrow
   */
  export type external_contest_sourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_contest_source
     */
    select?: external_contest_sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_contest_sourceInclude<ExtArgs> | null
    /**
     * Filter, which external_contest_source to fetch.
     */
    where?: external_contest_sourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of external_contest_sources to fetch.
     */
    orderBy?: external_contest_sourceOrderByWithRelationInput | external_contest_sourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for external_contest_sources.
     */
    cursor?: external_contest_sourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` external_contest_sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` external_contest_sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of external_contest_sources.
     */
    distinct?: External_contest_sourceScalarFieldEnum | External_contest_sourceScalarFieldEnum[]
  }


  /**
   * external_contest_source findMany
   */
  export type external_contest_sourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_contest_source
     */
    select?: external_contest_sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_contest_sourceInclude<ExtArgs> | null
    /**
     * Filter, which external_contest_sources to fetch.
     */
    where?: external_contest_sourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of external_contest_sources to fetch.
     */
    orderBy?: external_contest_sourceOrderByWithRelationInput | external_contest_sourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing external_contest_sources.
     */
    cursor?: external_contest_sourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` external_contest_sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` external_contest_sources.
     */
    skip?: number
    distinct?: External_contest_sourceScalarFieldEnum | External_contest_sourceScalarFieldEnum[]
  }


  /**
   * external_contest_source create
   */
  export type external_contest_sourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_contest_source
     */
    select?: external_contest_sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_contest_sourceInclude<ExtArgs> | null
    /**
     * The data needed to create a external_contest_source.
     */
    data: XOR<external_contest_sourceCreateInput, external_contest_sourceUncheckedCreateInput>
  }


  /**
   * external_contest_source createMany
   */
  export type external_contest_sourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many external_contest_sources.
     */
    data: external_contest_sourceCreateManyInput | external_contest_sourceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * external_contest_source update
   */
  export type external_contest_sourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_contest_source
     */
    select?: external_contest_sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_contest_sourceInclude<ExtArgs> | null
    /**
     * The data needed to update a external_contest_source.
     */
    data: XOR<external_contest_sourceUpdateInput, external_contest_sourceUncheckedUpdateInput>
    /**
     * Choose, which external_contest_source to update.
     */
    where: external_contest_sourceWhereUniqueInput
  }


  /**
   * external_contest_source updateMany
   */
  export type external_contest_sourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update external_contest_sources.
     */
    data: XOR<external_contest_sourceUpdateManyMutationInput, external_contest_sourceUncheckedUpdateManyInput>
    /**
     * Filter which external_contest_sources to update
     */
    where?: external_contest_sourceWhereInput
  }


  /**
   * external_contest_source upsert
   */
  export type external_contest_sourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_contest_source
     */
    select?: external_contest_sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_contest_sourceInclude<ExtArgs> | null
    /**
     * The filter to search for the external_contest_source to update in case it exists.
     */
    where: external_contest_sourceWhereUniqueInput
    /**
     * In case the external_contest_source found by the `where` argument doesn't exist, create a new external_contest_source with this data.
     */
    create: XOR<external_contest_sourceCreateInput, external_contest_sourceUncheckedCreateInput>
    /**
     * In case the external_contest_source was found with the provided `where` argument, update it with this data.
     */
    update: XOR<external_contest_sourceUpdateInput, external_contest_sourceUncheckedUpdateInput>
  }


  /**
   * external_contest_source delete
   */
  export type external_contest_sourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_contest_source
     */
    select?: external_contest_sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_contest_sourceInclude<ExtArgs> | null
    /**
     * Filter which external_contest_source to delete.
     */
    where: external_contest_sourceWhereUniqueInput
  }


  /**
   * external_contest_source deleteMany
   */
  export type external_contest_sourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which external_contest_sources to delete
     */
    where?: external_contest_sourceWhereInput
  }


  /**
   * external_contest_source.contest
   */
  export type external_contest_source$contestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contest
     */
    select?: contestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestInclude<ExtArgs> | null
    where?: contestWhereInput
  }


  /**
   * external_contest_source.external_source_warning
   */
  export type external_contest_source$external_source_warningArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_source_warning
     */
    select?: external_source_warningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_source_warningInclude<ExtArgs> | null
    where?: external_source_warningWhereInput
    orderBy?: external_source_warningOrderByWithRelationInput | external_source_warningOrderByWithRelationInput[]
    cursor?: external_source_warningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: External_source_warningScalarFieldEnum | External_source_warningScalarFieldEnum[]
  }


  /**
   * external_contest_source without action
   */
  export type external_contest_sourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_contest_source
     */
    select?: external_contest_sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_contest_sourceInclude<ExtArgs> | null
  }



  /**
   * Model external_judgement
   */

  export type AggregateExternal_judgement = {
    _count: External_judgementCountAggregateOutputType | null
    _avg: External_judgementAvgAggregateOutputType | null
    _sum: External_judgementSumAggregateOutputType | null
    _min: External_judgementMinAggregateOutputType | null
    _max: External_judgementMaxAggregateOutputType | null
  }

  export type External_judgementAvgAggregateOutputType = {
    extjudgementid: number | null
    cid: number | null
    submitid: number | null
    starttime: Decimal | null
    endtime: Decimal | null
  }

  export type External_judgementSumAggregateOutputType = {
    extjudgementid: number | null
    cid: number | null
    submitid: number | null
    starttime: Decimal | null
    endtime: Decimal | null
  }

  export type External_judgementMinAggregateOutputType = {
    extjudgementid: number | null
    externalid: string | null
    cid: number | null
    submitid: number | null
    result: string | null
    verified: boolean | null
    jury_member: string | null
    verify_comment: string | null
    starttime: Decimal | null
    endtime: Decimal | null
    valid: boolean | null
  }

  export type External_judgementMaxAggregateOutputType = {
    extjudgementid: number | null
    externalid: string | null
    cid: number | null
    submitid: number | null
    result: string | null
    verified: boolean | null
    jury_member: string | null
    verify_comment: string | null
    starttime: Decimal | null
    endtime: Decimal | null
    valid: boolean | null
  }

  export type External_judgementCountAggregateOutputType = {
    extjudgementid: number
    externalid: number
    cid: number
    submitid: number
    result: number
    verified: number
    jury_member: number
    verify_comment: number
    starttime: number
    endtime: number
    valid: number
    _all: number
  }


  export type External_judgementAvgAggregateInputType = {
    extjudgementid?: true
    cid?: true
    submitid?: true
    starttime?: true
    endtime?: true
  }

  export type External_judgementSumAggregateInputType = {
    extjudgementid?: true
    cid?: true
    submitid?: true
    starttime?: true
    endtime?: true
  }

  export type External_judgementMinAggregateInputType = {
    extjudgementid?: true
    externalid?: true
    cid?: true
    submitid?: true
    result?: true
    verified?: true
    jury_member?: true
    verify_comment?: true
    starttime?: true
    endtime?: true
    valid?: true
  }

  export type External_judgementMaxAggregateInputType = {
    extjudgementid?: true
    externalid?: true
    cid?: true
    submitid?: true
    result?: true
    verified?: true
    jury_member?: true
    verify_comment?: true
    starttime?: true
    endtime?: true
    valid?: true
  }

  export type External_judgementCountAggregateInputType = {
    extjudgementid?: true
    externalid?: true
    cid?: true
    submitid?: true
    result?: true
    verified?: true
    jury_member?: true
    verify_comment?: true
    starttime?: true
    endtime?: true
    valid?: true
    _all?: true
  }

  export type External_judgementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which external_judgement to aggregate.
     */
    where?: external_judgementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of external_judgements to fetch.
     */
    orderBy?: external_judgementOrderByWithRelationInput | external_judgementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: external_judgementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` external_judgements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` external_judgements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned external_judgements
    **/
    _count?: true | External_judgementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: External_judgementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: External_judgementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: External_judgementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: External_judgementMaxAggregateInputType
  }

  export type GetExternal_judgementAggregateType<T extends External_judgementAggregateArgs> = {
        [P in keyof T & keyof AggregateExternal_judgement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternal_judgement[P]>
      : GetScalarType<T[P], AggregateExternal_judgement[P]>
  }




  export type external_judgementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: external_judgementWhereInput
    orderBy?: external_judgementOrderByWithAggregationInput | external_judgementOrderByWithAggregationInput[]
    by: External_judgementScalarFieldEnum[] | External_judgementScalarFieldEnum
    having?: external_judgementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: External_judgementCountAggregateInputType | true
    _avg?: External_judgementAvgAggregateInputType
    _sum?: External_judgementSumAggregateInputType
    _min?: External_judgementMinAggregateInputType
    _max?: External_judgementMaxAggregateInputType
  }

  export type External_judgementGroupByOutputType = {
    extjudgementid: number
    externalid: string | null
    cid: number | null
    submitid: number | null
    result: string | null
    verified: boolean
    jury_member: string | null
    verify_comment: string | null
    starttime: Decimal
    endtime: Decimal | null
    valid: boolean
    _count: External_judgementCountAggregateOutputType | null
    _avg: External_judgementAvgAggregateOutputType | null
    _sum: External_judgementSumAggregateOutputType | null
    _min: External_judgementMinAggregateOutputType | null
    _max: External_judgementMaxAggregateOutputType | null
  }

  type GetExternal_judgementGroupByPayload<T extends external_judgementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<External_judgementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof External_judgementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], External_judgementGroupByOutputType[P]>
            : GetScalarType<T[P], External_judgementGroupByOutputType[P]>
        }
      >
    >


  export type external_judgementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    extjudgementid?: boolean
    externalid?: boolean
    cid?: boolean
    submitid?: boolean
    result?: boolean
    verified?: boolean
    jury_member?: boolean
    verify_comment?: boolean
    starttime?: boolean
    endtime?: boolean
    valid?: boolean
    submission?: boolean | external_judgement$submissionArgs<ExtArgs>
    contest?: boolean | external_judgement$contestArgs<ExtArgs>
    external_run?: boolean | external_judgement$external_runArgs<ExtArgs>
    _count?: boolean | External_judgementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["external_judgement"]>

  export type external_judgementSelectScalar = {
    extjudgementid?: boolean
    externalid?: boolean
    cid?: boolean
    submitid?: boolean
    result?: boolean
    verified?: boolean
    jury_member?: boolean
    verify_comment?: boolean
    starttime?: boolean
    endtime?: boolean
    valid?: boolean
  }

  export type external_judgementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submission?: boolean | external_judgement$submissionArgs<ExtArgs>
    contest?: boolean | external_judgement$contestArgs<ExtArgs>
    external_run?: boolean | external_judgement$external_runArgs<ExtArgs>
    _count?: boolean | External_judgementCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $external_judgementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "external_judgement"
    objects: {
      submission: Prisma.$submissionPayload<ExtArgs> | null
      contest: Prisma.$contestPayload<ExtArgs> | null
      external_run: Prisma.$external_runPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      extjudgementid: number
      externalid: string | null
      cid: number | null
      submitid: number | null
      result: string | null
      verified: boolean
      jury_member: string | null
      verify_comment: string | null
      starttime: Prisma.Decimal
      endtime: Prisma.Decimal | null
      valid: boolean
    }, ExtArgs["result"]["external_judgement"]>
    composites: {}
  }


  type external_judgementGetPayload<S extends boolean | null | undefined | external_judgementDefaultArgs> = $Result.GetResult<Prisma.$external_judgementPayload, S>

  type external_judgementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<external_judgementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: External_judgementCountAggregateInputType | true
    }

  export interface external_judgementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['external_judgement'], meta: { name: 'external_judgement' } }
    /**
     * Find zero or one External_judgement that matches the filter.
     * @param {external_judgementFindUniqueArgs} args - Arguments to find a External_judgement
     * @example
     * // Get one External_judgement
     * const external_judgement = await prisma.external_judgement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends external_judgementFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, external_judgementFindUniqueArgs<ExtArgs>>
    ): Prisma__external_judgementClient<$Result.GetResult<Prisma.$external_judgementPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one External_judgement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {external_judgementFindUniqueOrThrowArgs} args - Arguments to find a External_judgement
     * @example
     * // Get one External_judgement
     * const external_judgement = await prisma.external_judgement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends external_judgementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, external_judgementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__external_judgementClient<$Result.GetResult<Prisma.$external_judgementPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first External_judgement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_judgementFindFirstArgs} args - Arguments to find a External_judgement
     * @example
     * // Get one External_judgement
     * const external_judgement = await prisma.external_judgement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends external_judgementFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, external_judgementFindFirstArgs<ExtArgs>>
    ): Prisma__external_judgementClient<$Result.GetResult<Prisma.$external_judgementPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first External_judgement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_judgementFindFirstOrThrowArgs} args - Arguments to find a External_judgement
     * @example
     * // Get one External_judgement
     * const external_judgement = await prisma.external_judgement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends external_judgementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, external_judgementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__external_judgementClient<$Result.GetResult<Prisma.$external_judgementPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more External_judgements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_judgementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all External_judgements
     * const external_judgements = await prisma.external_judgement.findMany()
     * 
     * // Get first 10 External_judgements
     * const external_judgements = await prisma.external_judgement.findMany({ take: 10 })
     * 
     * // Only select the `extjudgementid`
     * const external_judgementWithExtjudgementidOnly = await prisma.external_judgement.findMany({ select: { extjudgementid: true } })
     * 
    **/
    findMany<T extends external_judgementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, external_judgementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$external_judgementPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a External_judgement.
     * @param {external_judgementCreateArgs} args - Arguments to create a External_judgement.
     * @example
     * // Create one External_judgement
     * const External_judgement = await prisma.external_judgement.create({
     *   data: {
     *     // ... data to create a External_judgement
     *   }
     * })
     * 
    **/
    create<T extends external_judgementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, external_judgementCreateArgs<ExtArgs>>
    ): Prisma__external_judgementClient<$Result.GetResult<Prisma.$external_judgementPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many External_judgements.
     *     @param {external_judgementCreateManyArgs} args - Arguments to create many External_judgements.
     *     @example
     *     // Create many External_judgements
     *     const external_judgement = await prisma.external_judgement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends external_judgementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, external_judgementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a External_judgement.
     * @param {external_judgementDeleteArgs} args - Arguments to delete one External_judgement.
     * @example
     * // Delete one External_judgement
     * const External_judgement = await prisma.external_judgement.delete({
     *   where: {
     *     // ... filter to delete one External_judgement
     *   }
     * })
     * 
    **/
    delete<T extends external_judgementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, external_judgementDeleteArgs<ExtArgs>>
    ): Prisma__external_judgementClient<$Result.GetResult<Prisma.$external_judgementPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one External_judgement.
     * @param {external_judgementUpdateArgs} args - Arguments to update one External_judgement.
     * @example
     * // Update one External_judgement
     * const external_judgement = await prisma.external_judgement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends external_judgementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, external_judgementUpdateArgs<ExtArgs>>
    ): Prisma__external_judgementClient<$Result.GetResult<Prisma.$external_judgementPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more External_judgements.
     * @param {external_judgementDeleteManyArgs} args - Arguments to filter External_judgements to delete.
     * @example
     * // Delete a few External_judgements
     * const { count } = await prisma.external_judgement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends external_judgementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, external_judgementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more External_judgements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_judgementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many External_judgements
     * const external_judgement = await prisma.external_judgement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends external_judgementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, external_judgementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one External_judgement.
     * @param {external_judgementUpsertArgs} args - Arguments to update or create a External_judgement.
     * @example
     * // Update or create a External_judgement
     * const external_judgement = await prisma.external_judgement.upsert({
     *   create: {
     *     // ... data to create a External_judgement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the External_judgement we want to update
     *   }
     * })
    **/
    upsert<T extends external_judgementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, external_judgementUpsertArgs<ExtArgs>>
    ): Prisma__external_judgementClient<$Result.GetResult<Prisma.$external_judgementPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of External_judgements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_judgementCountArgs} args - Arguments to filter External_judgements to count.
     * @example
     * // Count the number of External_judgements
     * const count = await prisma.external_judgement.count({
     *   where: {
     *     // ... the filter for the External_judgements we want to count
     *   }
     * })
    **/
    count<T extends external_judgementCountArgs>(
      args?: Subset<T, external_judgementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], External_judgementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a External_judgement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {External_judgementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends External_judgementAggregateArgs>(args: Subset<T, External_judgementAggregateArgs>): Prisma.PrismaPromise<GetExternal_judgementAggregateType<T>>

    /**
     * Group by External_judgement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_judgementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends external_judgementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: external_judgementGroupByArgs['orderBy'] }
        : { orderBy?: external_judgementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, external_judgementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternal_judgementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the external_judgement model
   */
  readonly fields: external_judgementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for external_judgement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__external_judgementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    submission<T extends external_judgement$submissionArgs<ExtArgs> = {}>(args?: Subset<T, external_judgement$submissionArgs<ExtArgs>>): Prisma__submissionClient<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    contest<T extends external_judgement$contestArgs<ExtArgs> = {}>(args?: Subset<T, external_judgement$contestArgs<ExtArgs>>): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    external_run<T extends external_judgement$external_runArgs<ExtArgs> = {}>(args?: Subset<T, external_judgement$external_runArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$external_runPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the external_judgement model
   */ 
  interface external_judgementFieldRefs {
    readonly extjudgementid: FieldRef<"external_judgement", 'Int'>
    readonly externalid: FieldRef<"external_judgement", 'String'>
    readonly cid: FieldRef<"external_judgement", 'Int'>
    readonly submitid: FieldRef<"external_judgement", 'Int'>
    readonly result: FieldRef<"external_judgement", 'String'>
    readonly verified: FieldRef<"external_judgement", 'Boolean'>
    readonly jury_member: FieldRef<"external_judgement", 'String'>
    readonly verify_comment: FieldRef<"external_judgement", 'String'>
    readonly starttime: FieldRef<"external_judgement", 'Decimal'>
    readonly endtime: FieldRef<"external_judgement", 'Decimal'>
    readonly valid: FieldRef<"external_judgement", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * external_judgement findUnique
   */
  export type external_judgementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_judgement
     */
    select?: external_judgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_judgementInclude<ExtArgs> | null
    /**
     * Filter, which external_judgement to fetch.
     */
    where: external_judgementWhereUniqueInput
  }


  /**
   * external_judgement findUniqueOrThrow
   */
  export type external_judgementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_judgement
     */
    select?: external_judgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_judgementInclude<ExtArgs> | null
    /**
     * Filter, which external_judgement to fetch.
     */
    where: external_judgementWhereUniqueInput
  }


  /**
   * external_judgement findFirst
   */
  export type external_judgementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_judgement
     */
    select?: external_judgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_judgementInclude<ExtArgs> | null
    /**
     * Filter, which external_judgement to fetch.
     */
    where?: external_judgementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of external_judgements to fetch.
     */
    orderBy?: external_judgementOrderByWithRelationInput | external_judgementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for external_judgements.
     */
    cursor?: external_judgementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` external_judgements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` external_judgements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of external_judgements.
     */
    distinct?: External_judgementScalarFieldEnum | External_judgementScalarFieldEnum[]
  }


  /**
   * external_judgement findFirstOrThrow
   */
  export type external_judgementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_judgement
     */
    select?: external_judgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_judgementInclude<ExtArgs> | null
    /**
     * Filter, which external_judgement to fetch.
     */
    where?: external_judgementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of external_judgements to fetch.
     */
    orderBy?: external_judgementOrderByWithRelationInput | external_judgementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for external_judgements.
     */
    cursor?: external_judgementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` external_judgements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` external_judgements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of external_judgements.
     */
    distinct?: External_judgementScalarFieldEnum | External_judgementScalarFieldEnum[]
  }


  /**
   * external_judgement findMany
   */
  export type external_judgementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_judgement
     */
    select?: external_judgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_judgementInclude<ExtArgs> | null
    /**
     * Filter, which external_judgements to fetch.
     */
    where?: external_judgementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of external_judgements to fetch.
     */
    orderBy?: external_judgementOrderByWithRelationInput | external_judgementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing external_judgements.
     */
    cursor?: external_judgementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` external_judgements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` external_judgements.
     */
    skip?: number
    distinct?: External_judgementScalarFieldEnum | External_judgementScalarFieldEnum[]
  }


  /**
   * external_judgement create
   */
  export type external_judgementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_judgement
     */
    select?: external_judgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_judgementInclude<ExtArgs> | null
    /**
     * The data needed to create a external_judgement.
     */
    data: XOR<external_judgementCreateInput, external_judgementUncheckedCreateInput>
  }


  /**
   * external_judgement createMany
   */
  export type external_judgementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many external_judgements.
     */
    data: external_judgementCreateManyInput | external_judgementCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * external_judgement update
   */
  export type external_judgementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_judgement
     */
    select?: external_judgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_judgementInclude<ExtArgs> | null
    /**
     * The data needed to update a external_judgement.
     */
    data: XOR<external_judgementUpdateInput, external_judgementUncheckedUpdateInput>
    /**
     * Choose, which external_judgement to update.
     */
    where: external_judgementWhereUniqueInput
  }


  /**
   * external_judgement updateMany
   */
  export type external_judgementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update external_judgements.
     */
    data: XOR<external_judgementUpdateManyMutationInput, external_judgementUncheckedUpdateManyInput>
    /**
     * Filter which external_judgements to update
     */
    where?: external_judgementWhereInput
  }


  /**
   * external_judgement upsert
   */
  export type external_judgementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_judgement
     */
    select?: external_judgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_judgementInclude<ExtArgs> | null
    /**
     * The filter to search for the external_judgement to update in case it exists.
     */
    where: external_judgementWhereUniqueInput
    /**
     * In case the external_judgement found by the `where` argument doesn't exist, create a new external_judgement with this data.
     */
    create: XOR<external_judgementCreateInput, external_judgementUncheckedCreateInput>
    /**
     * In case the external_judgement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<external_judgementUpdateInput, external_judgementUncheckedUpdateInput>
  }


  /**
   * external_judgement delete
   */
  export type external_judgementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_judgement
     */
    select?: external_judgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_judgementInclude<ExtArgs> | null
    /**
     * Filter which external_judgement to delete.
     */
    where: external_judgementWhereUniqueInput
  }


  /**
   * external_judgement deleteMany
   */
  export type external_judgementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which external_judgements to delete
     */
    where?: external_judgementWhereInput
  }


  /**
   * external_judgement.submission
   */
  export type external_judgement$submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    where?: submissionWhereInput
  }


  /**
   * external_judgement.contest
   */
  export type external_judgement$contestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contest
     */
    select?: contestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestInclude<ExtArgs> | null
    where?: contestWhereInput
  }


  /**
   * external_judgement.external_run
   */
  export type external_judgement$external_runArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_run
     */
    select?: external_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_runInclude<ExtArgs> | null
    where?: external_runWhereInput
    orderBy?: external_runOrderByWithRelationInput | external_runOrderByWithRelationInput[]
    cursor?: external_runWhereUniqueInput
    take?: number
    skip?: number
    distinct?: External_runScalarFieldEnum | External_runScalarFieldEnum[]
  }


  /**
   * external_judgement without action
   */
  export type external_judgementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_judgement
     */
    select?: external_judgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_judgementInclude<ExtArgs> | null
  }



  /**
   * Model external_run
   */

  export type AggregateExternal_run = {
    _count: External_runCountAggregateOutputType | null
    _avg: External_runAvgAggregateOutputType | null
    _sum: External_runSumAggregateOutputType | null
    _min: External_runMinAggregateOutputType | null
    _max: External_runMaxAggregateOutputType | null
  }

  export type External_runAvgAggregateOutputType = {
    extrunid: number | null
    extjudgementid: number | null
    testcaseid: number | null
    cid: number | null
    endtime: Decimal | null
    runtime: number | null
  }

  export type External_runSumAggregateOutputType = {
    extrunid: number | null
    extjudgementid: number | null
    testcaseid: number | null
    cid: number | null
    endtime: Decimal | null
    runtime: number | null
  }

  export type External_runMinAggregateOutputType = {
    extrunid: number | null
    extjudgementid: number | null
    testcaseid: number | null
    externalid: string | null
    cid: number | null
    result: string | null
    endtime: Decimal | null
    runtime: number | null
  }

  export type External_runMaxAggregateOutputType = {
    extrunid: number | null
    extjudgementid: number | null
    testcaseid: number | null
    externalid: string | null
    cid: number | null
    result: string | null
    endtime: Decimal | null
    runtime: number | null
  }

  export type External_runCountAggregateOutputType = {
    extrunid: number
    extjudgementid: number
    testcaseid: number
    externalid: number
    cid: number
    result: number
    endtime: number
    runtime: number
    _all: number
  }


  export type External_runAvgAggregateInputType = {
    extrunid?: true
    extjudgementid?: true
    testcaseid?: true
    cid?: true
    endtime?: true
    runtime?: true
  }

  export type External_runSumAggregateInputType = {
    extrunid?: true
    extjudgementid?: true
    testcaseid?: true
    cid?: true
    endtime?: true
    runtime?: true
  }

  export type External_runMinAggregateInputType = {
    extrunid?: true
    extjudgementid?: true
    testcaseid?: true
    externalid?: true
    cid?: true
    result?: true
    endtime?: true
    runtime?: true
  }

  export type External_runMaxAggregateInputType = {
    extrunid?: true
    extjudgementid?: true
    testcaseid?: true
    externalid?: true
    cid?: true
    result?: true
    endtime?: true
    runtime?: true
  }

  export type External_runCountAggregateInputType = {
    extrunid?: true
    extjudgementid?: true
    testcaseid?: true
    externalid?: true
    cid?: true
    result?: true
    endtime?: true
    runtime?: true
    _all?: true
  }

  export type External_runAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which external_run to aggregate.
     */
    where?: external_runWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of external_runs to fetch.
     */
    orderBy?: external_runOrderByWithRelationInput | external_runOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: external_runWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` external_runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` external_runs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned external_runs
    **/
    _count?: true | External_runCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: External_runAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: External_runSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: External_runMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: External_runMaxAggregateInputType
  }

  export type GetExternal_runAggregateType<T extends External_runAggregateArgs> = {
        [P in keyof T & keyof AggregateExternal_run]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternal_run[P]>
      : GetScalarType<T[P], AggregateExternal_run[P]>
  }




  export type external_runGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: external_runWhereInput
    orderBy?: external_runOrderByWithAggregationInput | external_runOrderByWithAggregationInput[]
    by: External_runScalarFieldEnum[] | External_runScalarFieldEnum
    having?: external_runScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: External_runCountAggregateInputType | true
    _avg?: External_runAvgAggregateInputType
    _sum?: External_runSumAggregateInputType
    _min?: External_runMinAggregateInputType
    _max?: External_runMaxAggregateInputType
  }

  export type External_runGroupByOutputType = {
    extrunid: number
    extjudgementid: number | null
    testcaseid: number | null
    externalid: string | null
    cid: number | null
    result: string
    endtime: Decimal
    runtime: number
    _count: External_runCountAggregateOutputType | null
    _avg: External_runAvgAggregateOutputType | null
    _sum: External_runSumAggregateOutputType | null
    _min: External_runMinAggregateOutputType | null
    _max: External_runMaxAggregateOutputType | null
  }

  type GetExternal_runGroupByPayload<T extends external_runGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<External_runGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof External_runGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], External_runGroupByOutputType[P]>
            : GetScalarType<T[P], External_runGroupByOutputType[P]>
        }
      >
    >


  export type external_runSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    extrunid?: boolean
    extjudgementid?: boolean
    testcaseid?: boolean
    externalid?: boolean
    cid?: boolean
    result?: boolean
    endtime?: boolean
    runtime?: boolean
    external_judgement?: boolean | external_run$external_judgementArgs<ExtArgs>
    testcase?: boolean | external_run$testcaseArgs<ExtArgs>
    contest?: boolean | external_run$contestArgs<ExtArgs>
  }, ExtArgs["result"]["external_run"]>

  export type external_runSelectScalar = {
    extrunid?: boolean
    extjudgementid?: boolean
    testcaseid?: boolean
    externalid?: boolean
    cid?: boolean
    result?: boolean
    endtime?: boolean
    runtime?: boolean
  }

  export type external_runInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    external_judgement?: boolean | external_run$external_judgementArgs<ExtArgs>
    testcase?: boolean | external_run$testcaseArgs<ExtArgs>
    contest?: boolean | external_run$contestArgs<ExtArgs>
  }


  export type $external_runPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "external_run"
    objects: {
      external_judgement: Prisma.$external_judgementPayload<ExtArgs> | null
      testcase: Prisma.$testcasePayload<ExtArgs> | null
      contest: Prisma.$contestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      extrunid: number
      extjudgementid: number | null
      testcaseid: number | null
      externalid: string | null
      cid: number | null
      result: string
      endtime: Prisma.Decimal
      runtime: number
    }, ExtArgs["result"]["external_run"]>
    composites: {}
  }


  type external_runGetPayload<S extends boolean | null | undefined | external_runDefaultArgs> = $Result.GetResult<Prisma.$external_runPayload, S>

  type external_runCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<external_runFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: External_runCountAggregateInputType | true
    }

  export interface external_runDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['external_run'], meta: { name: 'external_run' } }
    /**
     * Find zero or one External_run that matches the filter.
     * @param {external_runFindUniqueArgs} args - Arguments to find a External_run
     * @example
     * // Get one External_run
     * const external_run = await prisma.external_run.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends external_runFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, external_runFindUniqueArgs<ExtArgs>>
    ): Prisma__external_runClient<$Result.GetResult<Prisma.$external_runPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one External_run that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {external_runFindUniqueOrThrowArgs} args - Arguments to find a External_run
     * @example
     * // Get one External_run
     * const external_run = await prisma.external_run.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends external_runFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, external_runFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__external_runClient<$Result.GetResult<Prisma.$external_runPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first External_run that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_runFindFirstArgs} args - Arguments to find a External_run
     * @example
     * // Get one External_run
     * const external_run = await prisma.external_run.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends external_runFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, external_runFindFirstArgs<ExtArgs>>
    ): Prisma__external_runClient<$Result.GetResult<Prisma.$external_runPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first External_run that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_runFindFirstOrThrowArgs} args - Arguments to find a External_run
     * @example
     * // Get one External_run
     * const external_run = await prisma.external_run.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends external_runFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, external_runFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__external_runClient<$Result.GetResult<Prisma.$external_runPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more External_runs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_runFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all External_runs
     * const external_runs = await prisma.external_run.findMany()
     * 
     * // Get first 10 External_runs
     * const external_runs = await prisma.external_run.findMany({ take: 10 })
     * 
     * // Only select the `extrunid`
     * const external_runWithExtrunidOnly = await prisma.external_run.findMany({ select: { extrunid: true } })
     * 
    **/
    findMany<T extends external_runFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, external_runFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$external_runPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a External_run.
     * @param {external_runCreateArgs} args - Arguments to create a External_run.
     * @example
     * // Create one External_run
     * const External_run = await prisma.external_run.create({
     *   data: {
     *     // ... data to create a External_run
     *   }
     * })
     * 
    **/
    create<T extends external_runCreateArgs<ExtArgs>>(
      args: SelectSubset<T, external_runCreateArgs<ExtArgs>>
    ): Prisma__external_runClient<$Result.GetResult<Prisma.$external_runPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many External_runs.
     *     @param {external_runCreateManyArgs} args - Arguments to create many External_runs.
     *     @example
     *     // Create many External_runs
     *     const external_run = await prisma.external_run.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends external_runCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, external_runCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a External_run.
     * @param {external_runDeleteArgs} args - Arguments to delete one External_run.
     * @example
     * // Delete one External_run
     * const External_run = await prisma.external_run.delete({
     *   where: {
     *     // ... filter to delete one External_run
     *   }
     * })
     * 
    **/
    delete<T extends external_runDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, external_runDeleteArgs<ExtArgs>>
    ): Prisma__external_runClient<$Result.GetResult<Prisma.$external_runPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one External_run.
     * @param {external_runUpdateArgs} args - Arguments to update one External_run.
     * @example
     * // Update one External_run
     * const external_run = await prisma.external_run.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends external_runUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, external_runUpdateArgs<ExtArgs>>
    ): Prisma__external_runClient<$Result.GetResult<Prisma.$external_runPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more External_runs.
     * @param {external_runDeleteManyArgs} args - Arguments to filter External_runs to delete.
     * @example
     * // Delete a few External_runs
     * const { count } = await prisma.external_run.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends external_runDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, external_runDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more External_runs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_runUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many External_runs
     * const external_run = await prisma.external_run.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends external_runUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, external_runUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one External_run.
     * @param {external_runUpsertArgs} args - Arguments to update or create a External_run.
     * @example
     * // Update or create a External_run
     * const external_run = await prisma.external_run.upsert({
     *   create: {
     *     // ... data to create a External_run
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the External_run we want to update
     *   }
     * })
    **/
    upsert<T extends external_runUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, external_runUpsertArgs<ExtArgs>>
    ): Prisma__external_runClient<$Result.GetResult<Prisma.$external_runPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of External_runs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_runCountArgs} args - Arguments to filter External_runs to count.
     * @example
     * // Count the number of External_runs
     * const count = await prisma.external_run.count({
     *   where: {
     *     // ... the filter for the External_runs we want to count
     *   }
     * })
    **/
    count<T extends external_runCountArgs>(
      args?: Subset<T, external_runCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], External_runCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a External_run.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {External_runAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends External_runAggregateArgs>(args: Subset<T, External_runAggregateArgs>): Prisma.PrismaPromise<GetExternal_runAggregateType<T>>

    /**
     * Group by External_run.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_runGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends external_runGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: external_runGroupByArgs['orderBy'] }
        : { orderBy?: external_runGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, external_runGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternal_runGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the external_run model
   */
  readonly fields: external_runFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for external_run.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__external_runClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    external_judgement<T extends external_run$external_judgementArgs<ExtArgs> = {}>(args?: Subset<T, external_run$external_judgementArgs<ExtArgs>>): Prisma__external_judgementClient<$Result.GetResult<Prisma.$external_judgementPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    testcase<T extends external_run$testcaseArgs<ExtArgs> = {}>(args?: Subset<T, external_run$testcaseArgs<ExtArgs>>): Prisma__testcaseClient<$Result.GetResult<Prisma.$testcasePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    contest<T extends external_run$contestArgs<ExtArgs> = {}>(args?: Subset<T, external_run$contestArgs<ExtArgs>>): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the external_run model
   */ 
  interface external_runFieldRefs {
    readonly extrunid: FieldRef<"external_run", 'Int'>
    readonly extjudgementid: FieldRef<"external_run", 'Int'>
    readonly testcaseid: FieldRef<"external_run", 'Int'>
    readonly externalid: FieldRef<"external_run", 'String'>
    readonly cid: FieldRef<"external_run", 'Int'>
    readonly result: FieldRef<"external_run", 'String'>
    readonly endtime: FieldRef<"external_run", 'Decimal'>
    readonly runtime: FieldRef<"external_run", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * external_run findUnique
   */
  export type external_runFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_run
     */
    select?: external_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_runInclude<ExtArgs> | null
    /**
     * Filter, which external_run to fetch.
     */
    where: external_runWhereUniqueInput
  }


  /**
   * external_run findUniqueOrThrow
   */
  export type external_runFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_run
     */
    select?: external_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_runInclude<ExtArgs> | null
    /**
     * Filter, which external_run to fetch.
     */
    where: external_runWhereUniqueInput
  }


  /**
   * external_run findFirst
   */
  export type external_runFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_run
     */
    select?: external_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_runInclude<ExtArgs> | null
    /**
     * Filter, which external_run to fetch.
     */
    where?: external_runWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of external_runs to fetch.
     */
    orderBy?: external_runOrderByWithRelationInput | external_runOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for external_runs.
     */
    cursor?: external_runWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` external_runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` external_runs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of external_runs.
     */
    distinct?: External_runScalarFieldEnum | External_runScalarFieldEnum[]
  }


  /**
   * external_run findFirstOrThrow
   */
  export type external_runFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_run
     */
    select?: external_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_runInclude<ExtArgs> | null
    /**
     * Filter, which external_run to fetch.
     */
    where?: external_runWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of external_runs to fetch.
     */
    orderBy?: external_runOrderByWithRelationInput | external_runOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for external_runs.
     */
    cursor?: external_runWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` external_runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` external_runs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of external_runs.
     */
    distinct?: External_runScalarFieldEnum | External_runScalarFieldEnum[]
  }


  /**
   * external_run findMany
   */
  export type external_runFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_run
     */
    select?: external_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_runInclude<ExtArgs> | null
    /**
     * Filter, which external_runs to fetch.
     */
    where?: external_runWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of external_runs to fetch.
     */
    orderBy?: external_runOrderByWithRelationInput | external_runOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing external_runs.
     */
    cursor?: external_runWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` external_runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` external_runs.
     */
    skip?: number
    distinct?: External_runScalarFieldEnum | External_runScalarFieldEnum[]
  }


  /**
   * external_run create
   */
  export type external_runCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_run
     */
    select?: external_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_runInclude<ExtArgs> | null
    /**
     * The data needed to create a external_run.
     */
    data: XOR<external_runCreateInput, external_runUncheckedCreateInput>
  }


  /**
   * external_run createMany
   */
  export type external_runCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many external_runs.
     */
    data: external_runCreateManyInput | external_runCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * external_run update
   */
  export type external_runUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_run
     */
    select?: external_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_runInclude<ExtArgs> | null
    /**
     * The data needed to update a external_run.
     */
    data: XOR<external_runUpdateInput, external_runUncheckedUpdateInput>
    /**
     * Choose, which external_run to update.
     */
    where: external_runWhereUniqueInput
  }


  /**
   * external_run updateMany
   */
  export type external_runUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update external_runs.
     */
    data: XOR<external_runUpdateManyMutationInput, external_runUncheckedUpdateManyInput>
    /**
     * Filter which external_runs to update
     */
    where?: external_runWhereInput
  }


  /**
   * external_run upsert
   */
  export type external_runUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_run
     */
    select?: external_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_runInclude<ExtArgs> | null
    /**
     * The filter to search for the external_run to update in case it exists.
     */
    where: external_runWhereUniqueInput
    /**
     * In case the external_run found by the `where` argument doesn't exist, create a new external_run with this data.
     */
    create: XOR<external_runCreateInput, external_runUncheckedCreateInput>
    /**
     * In case the external_run was found with the provided `where` argument, update it with this data.
     */
    update: XOR<external_runUpdateInput, external_runUncheckedUpdateInput>
  }


  /**
   * external_run delete
   */
  export type external_runDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_run
     */
    select?: external_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_runInclude<ExtArgs> | null
    /**
     * Filter which external_run to delete.
     */
    where: external_runWhereUniqueInput
  }


  /**
   * external_run deleteMany
   */
  export type external_runDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which external_runs to delete
     */
    where?: external_runWhereInput
  }


  /**
   * external_run.external_judgement
   */
  export type external_run$external_judgementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_judgement
     */
    select?: external_judgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_judgementInclude<ExtArgs> | null
    where?: external_judgementWhereInput
  }


  /**
   * external_run.testcase
   */
  export type external_run$testcaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase
     */
    select?: testcaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcaseInclude<ExtArgs> | null
    where?: testcaseWhereInput
  }


  /**
   * external_run.contest
   */
  export type external_run$contestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contest
     */
    select?: contestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestInclude<ExtArgs> | null
    where?: contestWhereInput
  }


  /**
   * external_run without action
   */
  export type external_runDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_run
     */
    select?: external_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_runInclude<ExtArgs> | null
  }



  /**
   * Model external_source_warning
   */

  export type AggregateExternal_source_warning = {
    _count: External_source_warningCountAggregateOutputType | null
    _avg: External_source_warningAvgAggregateOutputType | null
    _sum: External_source_warningSumAggregateOutputType | null
    _min: External_source_warningMinAggregateOutputType | null
    _max: External_source_warningMaxAggregateOutputType | null
  }

  export type External_source_warningAvgAggregateOutputType = {
    extwarningid: number | null
    extsourceid: number | null
    time: Decimal | null
  }

  export type External_source_warningSumAggregateOutputType = {
    extwarningid: number | null
    extsourceid: number | null
    time: Decimal | null
  }

  export type External_source_warningMinAggregateOutputType = {
    extwarningid: number | null
    extsourceid: number | null
    last_event_id: string | null
    time: Decimal | null
    entity_type: string | null
    entity_id: string | null
    type: string | null
    hash: string | null
    content: string | null
  }

  export type External_source_warningMaxAggregateOutputType = {
    extwarningid: number | null
    extsourceid: number | null
    last_event_id: string | null
    time: Decimal | null
    entity_type: string | null
    entity_id: string | null
    type: string | null
    hash: string | null
    content: string | null
  }

  export type External_source_warningCountAggregateOutputType = {
    extwarningid: number
    extsourceid: number
    last_event_id: number
    time: number
    entity_type: number
    entity_id: number
    type: number
    hash: number
    content: number
    _all: number
  }


  export type External_source_warningAvgAggregateInputType = {
    extwarningid?: true
    extsourceid?: true
    time?: true
  }

  export type External_source_warningSumAggregateInputType = {
    extwarningid?: true
    extsourceid?: true
    time?: true
  }

  export type External_source_warningMinAggregateInputType = {
    extwarningid?: true
    extsourceid?: true
    last_event_id?: true
    time?: true
    entity_type?: true
    entity_id?: true
    type?: true
    hash?: true
    content?: true
  }

  export type External_source_warningMaxAggregateInputType = {
    extwarningid?: true
    extsourceid?: true
    last_event_id?: true
    time?: true
    entity_type?: true
    entity_id?: true
    type?: true
    hash?: true
    content?: true
  }

  export type External_source_warningCountAggregateInputType = {
    extwarningid?: true
    extsourceid?: true
    last_event_id?: true
    time?: true
    entity_type?: true
    entity_id?: true
    type?: true
    hash?: true
    content?: true
    _all?: true
  }

  export type External_source_warningAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which external_source_warning to aggregate.
     */
    where?: external_source_warningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of external_source_warnings to fetch.
     */
    orderBy?: external_source_warningOrderByWithRelationInput | external_source_warningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: external_source_warningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` external_source_warnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` external_source_warnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned external_source_warnings
    **/
    _count?: true | External_source_warningCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: External_source_warningAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: External_source_warningSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: External_source_warningMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: External_source_warningMaxAggregateInputType
  }

  export type GetExternal_source_warningAggregateType<T extends External_source_warningAggregateArgs> = {
        [P in keyof T & keyof AggregateExternal_source_warning]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternal_source_warning[P]>
      : GetScalarType<T[P], AggregateExternal_source_warning[P]>
  }




  export type external_source_warningGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: external_source_warningWhereInput
    orderBy?: external_source_warningOrderByWithAggregationInput | external_source_warningOrderByWithAggregationInput[]
    by: External_source_warningScalarFieldEnum[] | External_source_warningScalarFieldEnum
    having?: external_source_warningScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: External_source_warningCountAggregateInputType | true
    _avg?: External_source_warningAvgAggregateInputType
    _sum?: External_source_warningSumAggregateInputType
    _min?: External_source_warningMinAggregateInputType
    _max?: External_source_warningMaxAggregateInputType
  }

  export type External_source_warningGroupByOutputType = {
    extwarningid: number
    extsourceid: number | null
    last_event_id: string | null
    time: Decimal
    entity_type: string
    entity_id: string
    type: string
    hash: string
    content: string
    _count: External_source_warningCountAggregateOutputType | null
    _avg: External_source_warningAvgAggregateOutputType | null
    _sum: External_source_warningSumAggregateOutputType | null
    _min: External_source_warningMinAggregateOutputType | null
    _max: External_source_warningMaxAggregateOutputType | null
  }

  type GetExternal_source_warningGroupByPayload<T extends external_source_warningGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<External_source_warningGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof External_source_warningGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], External_source_warningGroupByOutputType[P]>
            : GetScalarType<T[P], External_source_warningGroupByOutputType[P]>
        }
      >
    >


  export type external_source_warningSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    extwarningid?: boolean
    extsourceid?: boolean
    last_event_id?: boolean
    time?: boolean
    entity_type?: boolean
    entity_id?: boolean
    type?: boolean
    hash?: boolean
    content?: boolean
    external_contest_source?: boolean | external_source_warning$external_contest_sourceArgs<ExtArgs>
  }, ExtArgs["result"]["external_source_warning"]>

  export type external_source_warningSelectScalar = {
    extwarningid?: boolean
    extsourceid?: boolean
    last_event_id?: boolean
    time?: boolean
    entity_type?: boolean
    entity_id?: boolean
    type?: boolean
    hash?: boolean
    content?: boolean
  }

  export type external_source_warningInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    external_contest_source?: boolean | external_source_warning$external_contest_sourceArgs<ExtArgs>
  }


  export type $external_source_warningPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "external_source_warning"
    objects: {
      external_contest_source: Prisma.$external_contest_sourcePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      extwarningid: number
      extsourceid: number | null
      last_event_id: string | null
      time: Prisma.Decimal
      entity_type: string
      entity_id: string
      type: string
      hash: string
      content: string
    }, ExtArgs["result"]["external_source_warning"]>
    composites: {}
  }


  type external_source_warningGetPayload<S extends boolean | null | undefined | external_source_warningDefaultArgs> = $Result.GetResult<Prisma.$external_source_warningPayload, S>

  type external_source_warningCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<external_source_warningFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: External_source_warningCountAggregateInputType | true
    }

  export interface external_source_warningDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['external_source_warning'], meta: { name: 'external_source_warning' } }
    /**
     * Find zero or one External_source_warning that matches the filter.
     * @param {external_source_warningFindUniqueArgs} args - Arguments to find a External_source_warning
     * @example
     * // Get one External_source_warning
     * const external_source_warning = await prisma.external_source_warning.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends external_source_warningFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, external_source_warningFindUniqueArgs<ExtArgs>>
    ): Prisma__external_source_warningClient<$Result.GetResult<Prisma.$external_source_warningPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one External_source_warning that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {external_source_warningFindUniqueOrThrowArgs} args - Arguments to find a External_source_warning
     * @example
     * // Get one External_source_warning
     * const external_source_warning = await prisma.external_source_warning.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends external_source_warningFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, external_source_warningFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__external_source_warningClient<$Result.GetResult<Prisma.$external_source_warningPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first External_source_warning that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_source_warningFindFirstArgs} args - Arguments to find a External_source_warning
     * @example
     * // Get one External_source_warning
     * const external_source_warning = await prisma.external_source_warning.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends external_source_warningFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, external_source_warningFindFirstArgs<ExtArgs>>
    ): Prisma__external_source_warningClient<$Result.GetResult<Prisma.$external_source_warningPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first External_source_warning that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_source_warningFindFirstOrThrowArgs} args - Arguments to find a External_source_warning
     * @example
     * // Get one External_source_warning
     * const external_source_warning = await prisma.external_source_warning.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends external_source_warningFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, external_source_warningFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__external_source_warningClient<$Result.GetResult<Prisma.$external_source_warningPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more External_source_warnings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_source_warningFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all External_source_warnings
     * const external_source_warnings = await prisma.external_source_warning.findMany()
     * 
     * // Get first 10 External_source_warnings
     * const external_source_warnings = await prisma.external_source_warning.findMany({ take: 10 })
     * 
     * // Only select the `extwarningid`
     * const external_source_warningWithExtwarningidOnly = await prisma.external_source_warning.findMany({ select: { extwarningid: true } })
     * 
    **/
    findMany<T extends external_source_warningFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, external_source_warningFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$external_source_warningPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a External_source_warning.
     * @param {external_source_warningCreateArgs} args - Arguments to create a External_source_warning.
     * @example
     * // Create one External_source_warning
     * const External_source_warning = await prisma.external_source_warning.create({
     *   data: {
     *     // ... data to create a External_source_warning
     *   }
     * })
     * 
    **/
    create<T extends external_source_warningCreateArgs<ExtArgs>>(
      args: SelectSubset<T, external_source_warningCreateArgs<ExtArgs>>
    ): Prisma__external_source_warningClient<$Result.GetResult<Prisma.$external_source_warningPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many External_source_warnings.
     *     @param {external_source_warningCreateManyArgs} args - Arguments to create many External_source_warnings.
     *     @example
     *     // Create many External_source_warnings
     *     const external_source_warning = await prisma.external_source_warning.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends external_source_warningCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, external_source_warningCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a External_source_warning.
     * @param {external_source_warningDeleteArgs} args - Arguments to delete one External_source_warning.
     * @example
     * // Delete one External_source_warning
     * const External_source_warning = await prisma.external_source_warning.delete({
     *   where: {
     *     // ... filter to delete one External_source_warning
     *   }
     * })
     * 
    **/
    delete<T extends external_source_warningDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, external_source_warningDeleteArgs<ExtArgs>>
    ): Prisma__external_source_warningClient<$Result.GetResult<Prisma.$external_source_warningPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one External_source_warning.
     * @param {external_source_warningUpdateArgs} args - Arguments to update one External_source_warning.
     * @example
     * // Update one External_source_warning
     * const external_source_warning = await prisma.external_source_warning.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends external_source_warningUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, external_source_warningUpdateArgs<ExtArgs>>
    ): Prisma__external_source_warningClient<$Result.GetResult<Prisma.$external_source_warningPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more External_source_warnings.
     * @param {external_source_warningDeleteManyArgs} args - Arguments to filter External_source_warnings to delete.
     * @example
     * // Delete a few External_source_warnings
     * const { count } = await prisma.external_source_warning.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends external_source_warningDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, external_source_warningDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more External_source_warnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_source_warningUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many External_source_warnings
     * const external_source_warning = await prisma.external_source_warning.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends external_source_warningUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, external_source_warningUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one External_source_warning.
     * @param {external_source_warningUpsertArgs} args - Arguments to update or create a External_source_warning.
     * @example
     * // Update or create a External_source_warning
     * const external_source_warning = await prisma.external_source_warning.upsert({
     *   create: {
     *     // ... data to create a External_source_warning
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the External_source_warning we want to update
     *   }
     * })
    **/
    upsert<T extends external_source_warningUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, external_source_warningUpsertArgs<ExtArgs>>
    ): Prisma__external_source_warningClient<$Result.GetResult<Prisma.$external_source_warningPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of External_source_warnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_source_warningCountArgs} args - Arguments to filter External_source_warnings to count.
     * @example
     * // Count the number of External_source_warnings
     * const count = await prisma.external_source_warning.count({
     *   where: {
     *     // ... the filter for the External_source_warnings we want to count
     *   }
     * })
    **/
    count<T extends external_source_warningCountArgs>(
      args?: Subset<T, external_source_warningCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], External_source_warningCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a External_source_warning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {External_source_warningAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends External_source_warningAggregateArgs>(args: Subset<T, External_source_warningAggregateArgs>): Prisma.PrismaPromise<GetExternal_source_warningAggregateType<T>>

    /**
     * Group by External_source_warning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {external_source_warningGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends external_source_warningGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: external_source_warningGroupByArgs['orderBy'] }
        : { orderBy?: external_source_warningGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, external_source_warningGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternal_source_warningGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the external_source_warning model
   */
  readonly fields: external_source_warningFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for external_source_warning.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__external_source_warningClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    external_contest_source<T extends external_source_warning$external_contest_sourceArgs<ExtArgs> = {}>(args?: Subset<T, external_source_warning$external_contest_sourceArgs<ExtArgs>>): Prisma__external_contest_sourceClient<$Result.GetResult<Prisma.$external_contest_sourcePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the external_source_warning model
   */ 
  interface external_source_warningFieldRefs {
    readonly extwarningid: FieldRef<"external_source_warning", 'Int'>
    readonly extsourceid: FieldRef<"external_source_warning", 'Int'>
    readonly last_event_id: FieldRef<"external_source_warning", 'String'>
    readonly time: FieldRef<"external_source_warning", 'Decimal'>
    readonly entity_type: FieldRef<"external_source_warning", 'String'>
    readonly entity_id: FieldRef<"external_source_warning", 'String'>
    readonly type: FieldRef<"external_source_warning", 'String'>
    readonly hash: FieldRef<"external_source_warning", 'String'>
    readonly content: FieldRef<"external_source_warning", 'String'>
  }
    

  // Custom InputTypes

  /**
   * external_source_warning findUnique
   */
  export type external_source_warningFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_source_warning
     */
    select?: external_source_warningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_source_warningInclude<ExtArgs> | null
    /**
     * Filter, which external_source_warning to fetch.
     */
    where: external_source_warningWhereUniqueInput
  }


  /**
   * external_source_warning findUniqueOrThrow
   */
  export type external_source_warningFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_source_warning
     */
    select?: external_source_warningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_source_warningInclude<ExtArgs> | null
    /**
     * Filter, which external_source_warning to fetch.
     */
    where: external_source_warningWhereUniqueInput
  }


  /**
   * external_source_warning findFirst
   */
  export type external_source_warningFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_source_warning
     */
    select?: external_source_warningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_source_warningInclude<ExtArgs> | null
    /**
     * Filter, which external_source_warning to fetch.
     */
    where?: external_source_warningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of external_source_warnings to fetch.
     */
    orderBy?: external_source_warningOrderByWithRelationInput | external_source_warningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for external_source_warnings.
     */
    cursor?: external_source_warningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` external_source_warnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` external_source_warnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of external_source_warnings.
     */
    distinct?: External_source_warningScalarFieldEnum | External_source_warningScalarFieldEnum[]
  }


  /**
   * external_source_warning findFirstOrThrow
   */
  export type external_source_warningFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_source_warning
     */
    select?: external_source_warningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_source_warningInclude<ExtArgs> | null
    /**
     * Filter, which external_source_warning to fetch.
     */
    where?: external_source_warningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of external_source_warnings to fetch.
     */
    orderBy?: external_source_warningOrderByWithRelationInput | external_source_warningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for external_source_warnings.
     */
    cursor?: external_source_warningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` external_source_warnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` external_source_warnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of external_source_warnings.
     */
    distinct?: External_source_warningScalarFieldEnum | External_source_warningScalarFieldEnum[]
  }


  /**
   * external_source_warning findMany
   */
  export type external_source_warningFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_source_warning
     */
    select?: external_source_warningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_source_warningInclude<ExtArgs> | null
    /**
     * Filter, which external_source_warnings to fetch.
     */
    where?: external_source_warningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of external_source_warnings to fetch.
     */
    orderBy?: external_source_warningOrderByWithRelationInput | external_source_warningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing external_source_warnings.
     */
    cursor?: external_source_warningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` external_source_warnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` external_source_warnings.
     */
    skip?: number
    distinct?: External_source_warningScalarFieldEnum | External_source_warningScalarFieldEnum[]
  }


  /**
   * external_source_warning create
   */
  export type external_source_warningCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_source_warning
     */
    select?: external_source_warningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_source_warningInclude<ExtArgs> | null
    /**
     * The data needed to create a external_source_warning.
     */
    data: XOR<external_source_warningCreateInput, external_source_warningUncheckedCreateInput>
  }


  /**
   * external_source_warning createMany
   */
  export type external_source_warningCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many external_source_warnings.
     */
    data: external_source_warningCreateManyInput | external_source_warningCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * external_source_warning update
   */
  export type external_source_warningUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_source_warning
     */
    select?: external_source_warningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_source_warningInclude<ExtArgs> | null
    /**
     * The data needed to update a external_source_warning.
     */
    data: XOR<external_source_warningUpdateInput, external_source_warningUncheckedUpdateInput>
    /**
     * Choose, which external_source_warning to update.
     */
    where: external_source_warningWhereUniqueInput
  }


  /**
   * external_source_warning updateMany
   */
  export type external_source_warningUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update external_source_warnings.
     */
    data: XOR<external_source_warningUpdateManyMutationInput, external_source_warningUncheckedUpdateManyInput>
    /**
     * Filter which external_source_warnings to update
     */
    where?: external_source_warningWhereInput
  }


  /**
   * external_source_warning upsert
   */
  export type external_source_warningUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_source_warning
     */
    select?: external_source_warningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_source_warningInclude<ExtArgs> | null
    /**
     * The filter to search for the external_source_warning to update in case it exists.
     */
    where: external_source_warningWhereUniqueInput
    /**
     * In case the external_source_warning found by the `where` argument doesn't exist, create a new external_source_warning with this data.
     */
    create: XOR<external_source_warningCreateInput, external_source_warningUncheckedCreateInput>
    /**
     * In case the external_source_warning was found with the provided `where` argument, update it with this data.
     */
    update: XOR<external_source_warningUpdateInput, external_source_warningUncheckedUpdateInput>
  }


  /**
   * external_source_warning delete
   */
  export type external_source_warningDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_source_warning
     */
    select?: external_source_warningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_source_warningInclude<ExtArgs> | null
    /**
     * Filter which external_source_warning to delete.
     */
    where: external_source_warningWhereUniqueInput
  }


  /**
   * external_source_warning deleteMany
   */
  export type external_source_warningDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which external_source_warnings to delete
     */
    where?: external_source_warningWhereInput
  }


  /**
   * external_source_warning.external_contest_source
   */
  export type external_source_warning$external_contest_sourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_contest_source
     */
    select?: external_contest_sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_contest_sourceInclude<ExtArgs> | null
    where?: external_contest_sourceWhereInput
  }


  /**
   * external_source_warning without action
   */
  export type external_source_warningDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_source_warning
     */
    select?: external_source_warningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_source_warningInclude<ExtArgs> | null
  }



  /**
   * Model immutable_executable
   */

  export type AggregateImmutable_executable = {
    _count: Immutable_executableCountAggregateOutputType | null
    _avg: Immutable_executableAvgAggregateOutputType | null
    _sum: Immutable_executableSumAggregateOutputType | null
    _min: Immutable_executableMinAggregateOutputType | null
    _max: Immutable_executableMaxAggregateOutputType | null
  }

  export type Immutable_executableAvgAggregateOutputType = {
    immutable_execid: number | null
    userid: number | null
  }

  export type Immutable_executableSumAggregateOutputType = {
    immutable_execid: number | null
    userid: number | null
  }

  export type Immutable_executableMinAggregateOutputType = {
    immutable_execid: number | null
    userid: number | null
    hash: string | null
  }

  export type Immutable_executableMaxAggregateOutputType = {
    immutable_execid: number | null
    userid: number | null
    hash: string | null
  }

  export type Immutable_executableCountAggregateOutputType = {
    immutable_execid: number
    userid: number
    hash: number
    _all: number
  }


  export type Immutable_executableAvgAggregateInputType = {
    immutable_execid?: true
    userid?: true
  }

  export type Immutable_executableSumAggregateInputType = {
    immutable_execid?: true
    userid?: true
  }

  export type Immutable_executableMinAggregateInputType = {
    immutable_execid?: true
    userid?: true
    hash?: true
  }

  export type Immutable_executableMaxAggregateInputType = {
    immutable_execid?: true
    userid?: true
    hash?: true
  }

  export type Immutable_executableCountAggregateInputType = {
    immutable_execid?: true
    userid?: true
    hash?: true
    _all?: true
  }

  export type Immutable_executableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which immutable_executable to aggregate.
     */
    where?: immutable_executableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of immutable_executables to fetch.
     */
    orderBy?: immutable_executableOrderByWithRelationInput | immutable_executableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: immutable_executableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` immutable_executables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` immutable_executables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned immutable_executables
    **/
    _count?: true | Immutable_executableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Immutable_executableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Immutable_executableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Immutable_executableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Immutable_executableMaxAggregateInputType
  }

  export type GetImmutable_executableAggregateType<T extends Immutable_executableAggregateArgs> = {
        [P in keyof T & keyof AggregateImmutable_executable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImmutable_executable[P]>
      : GetScalarType<T[P], AggregateImmutable_executable[P]>
  }




  export type immutable_executableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: immutable_executableWhereInput
    orderBy?: immutable_executableOrderByWithAggregationInput | immutable_executableOrderByWithAggregationInput[]
    by: Immutable_executableScalarFieldEnum[] | Immutable_executableScalarFieldEnum
    having?: immutable_executableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Immutable_executableCountAggregateInputType | true
    _avg?: Immutable_executableAvgAggregateInputType
    _sum?: Immutable_executableSumAggregateInputType
    _min?: Immutable_executableMinAggregateInputType
    _max?: Immutable_executableMaxAggregateInputType
  }

  export type Immutable_executableGroupByOutputType = {
    immutable_execid: number
    userid: number | null
    hash: string | null
    _count: Immutable_executableCountAggregateOutputType | null
    _avg: Immutable_executableAvgAggregateOutputType | null
    _sum: Immutable_executableSumAggregateOutputType | null
    _min: Immutable_executableMinAggregateOutputType | null
    _max: Immutable_executableMaxAggregateOutputType | null
  }

  type GetImmutable_executableGroupByPayload<T extends immutable_executableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Immutable_executableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Immutable_executableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Immutable_executableGroupByOutputType[P]>
            : GetScalarType<T[P], Immutable_executableGroupByOutputType[P]>
        }
      >
    >


  export type immutable_executableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    immutable_execid?: boolean
    userid?: boolean
    hash?: boolean
    executable?: boolean | immutable_executable$executableArgs<ExtArgs>
    executable_file?: boolean | immutable_executable$executable_fileArgs<ExtArgs>
    user?: boolean | immutable_executable$userArgs<ExtArgs>
    _count?: boolean | Immutable_executableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["immutable_executable"]>

  export type immutable_executableSelectScalar = {
    immutable_execid?: boolean
    userid?: boolean
    hash?: boolean
  }

  export type immutable_executableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executable?: boolean | immutable_executable$executableArgs<ExtArgs>
    executable_file?: boolean | immutable_executable$executable_fileArgs<ExtArgs>
    user?: boolean | immutable_executable$userArgs<ExtArgs>
    _count?: boolean | Immutable_executableCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $immutable_executablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "immutable_executable"
    objects: {
      executable: Prisma.$executablePayload<ExtArgs> | null
      executable_file: Prisma.$executable_filePayload<ExtArgs>[]
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      immutable_execid: number
      userid: number | null
      hash: string | null
    }, ExtArgs["result"]["immutable_executable"]>
    composites: {}
  }


  type immutable_executableGetPayload<S extends boolean | null | undefined | immutable_executableDefaultArgs> = $Result.GetResult<Prisma.$immutable_executablePayload, S>

  type immutable_executableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<immutable_executableFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Immutable_executableCountAggregateInputType | true
    }

  export interface immutable_executableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['immutable_executable'], meta: { name: 'immutable_executable' } }
    /**
     * Find zero or one Immutable_executable that matches the filter.
     * @param {immutable_executableFindUniqueArgs} args - Arguments to find a Immutable_executable
     * @example
     * // Get one Immutable_executable
     * const immutable_executable = await prisma.immutable_executable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends immutable_executableFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, immutable_executableFindUniqueArgs<ExtArgs>>
    ): Prisma__immutable_executableClient<$Result.GetResult<Prisma.$immutable_executablePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Immutable_executable that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {immutable_executableFindUniqueOrThrowArgs} args - Arguments to find a Immutable_executable
     * @example
     * // Get one Immutable_executable
     * const immutable_executable = await prisma.immutable_executable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends immutable_executableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, immutable_executableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__immutable_executableClient<$Result.GetResult<Prisma.$immutable_executablePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Immutable_executable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {immutable_executableFindFirstArgs} args - Arguments to find a Immutable_executable
     * @example
     * // Get one Immutable_executable
     * const immutable_executable = await prisma.immutable_executable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends immutable_executableFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, immutable_executableFindFirstArgs<ExtArgs>>
    ): Prisma__immutable_executableClient<$Result.GetResult<Prisma.$immutable_executablePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Immutable_executable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {immutable_executableFindFirstOrThrowArgs} args - Arguments to find a Immutable_executable
     * @example
     * // Get one Immutable_executable
     * const immutable_executable = await prisma.immutable_executable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends immutable_executableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, immutable_executableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__immutable_executableClient<$Result.GetResult<Prisma.$immutable_executablePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Immutable_executables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {immutable_executableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Immutable_executables
     * const immutable_executables = await prisma.immutable_executable.findMany()
     * 
     * // Get first 10 Immutable_executables
     * const immutable_executables = await prisma.immutable_executable.findMany({ take: 10 })
     * 
     * // Only select the `immutable_execid`
     * const immutable_executableWithImmutable_execidOnly = await prisma.immutable_executable.findMany({ select: { immutable_execid: true } })
     * 
    **/
    findMany<T extends immutable_executableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, immutable_executableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$immutable_executablePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Immutable_executable.
     * @param {immutable_executableCreateArgs} args - Arguments to create a Immutable_executable.
     * @example
     * // Create one Immutable_executable
     * const Immutable_executable = await prisma.immutable_executable.create({
     *   data: {
     *     // ... data to create a Immutable_executable
     *   }
     * })
     * 
    **/
    create<T extends immutable_executableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, immutable_executableCreateArgs<ExtArgs>>
    ): Prisma__immutable_executableClient<$Result.GetResult<Prisma.$immutable_executablePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Immutable_executables.
     *     @param {immutable_executableCreateManyArgs} args - Arguments to create many Immutable_executables.
     *     @example
     *     // Create many Immutable_executables
     *     const immutable_executable = await prisma.immutable_executable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends immutable_executableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, immutable_executableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Immutable_executable.
     * @param {immutable_executableDeleteArgs} args - Arguments to delete one Immutable_executable.
     * @example
     * // Delete one Immutable_executable
     * const Immutable_executable = await prisma.immutable_executable.delete({
     *   where: {
     *     // ... filter to delete one Immutable_executable
     *   }
     * })
     * 
    **/
    delete<T extends immutable_executableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, immutable_executableDeleteArgs<ExtArgs>>
    ): Prisma__immutable_executableClient<$Result.GetResult<Prisma.$immutable_executablePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Immutable_executable.
     * @param {immutable_executableUpdateArgs} args - Arguments to update one Immutable_executable.
     * @example
     * // Update one Immutable_executable
     * const immutable_executable = await prisma.immutable_executable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends immutable_executableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, immutable_executableUpdateArgs<ExtArgs>>
    ): Prisma__immutable_executableClient<$Result.GetResult<Prisma.$immutable_executablePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Immutable_executables.
     * @param {immutable_executableDeleteManyArgs} args - Arguments to filter Immutable_executables to delete.
     * @example
     * // Delete a few Immutable_executables
     * const { count } = await prisma.immutable_executable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends immutable_executableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, immutable_executableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Immutable_executables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {immutable_executableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Immutable_executables
     * const immutable_executable = await prisma.immutable_executable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends immutable_executableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, immutable_executableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Immutable_executable.
     * @param {immutable_executableUpsertArgs} args - Arguments to update or create a Immutable_executable.
     * @example
     * // Update or create a Immutable_executable
     * const immutable_executable = await prisma.immutable_executable.upsert({
     *   create: {
     *     // ... data to create a Immutable_executable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Immutable_executable we want to update
     *   }
     * })
    **/
    upsert<T extends immutable_executableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, immutable_executableUpsertArgs<ExtArgs>>
    ): Prisma__immutable_executableClient<$Result.GetResult<Prisma.$immutable_executablePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Immutable_executables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {immutable_executableCountArgs} args - Arguments to filter Immutable_executables to count.
     * @example
     * // Count the number of Immutable_executables
     * const count = await prisma.immutable_executable.count({
     *   where: {
     *     // ... the filter for the Immutable_executables we want to count
     *   }
     * })
    **/
    count<T extends immutable_executableCountArgs>(
      args?: Subset<T, immutable_executableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Immutable_executableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Immutable_executable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Immutable_executableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Immutable_executableAggregateArgs>(args: Subset<T, Immutable_executableAggregateArgs>): Prisma.PrismaPromise<GetImmutable_executableAggregateType<T>>

    /**
     * Group by Immutable_executable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {immutable_executableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends immutable_executableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: immutable_executableGroupByArgs['orderBy'] }
        : { orderBy?: immutable_executableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, immutable_executableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImmutable_executableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the immutable_executable model
   */
  readonly fields: immutable_executableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for immutable_executable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__immutable_executableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    executable<T extends immutable_executable$executableArgs<ExtArgs> = {}>(args?: Subset<T, immutable_executable$executableArgs<ExtArgs>>): Prisma__executableClient<$Result.GetResult<Prisma.$executablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    executable_file<T extends immutable_executable$executable_fileArgs<ExtArgs> = {}>(args?: Subset<T, immutable_executable$executable_fileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$executable_filePayload<ExtArgs>, T, 'findMany'> | Null>;

    user<T extends immutable_executable$userArgs<ExtArgs> = {}>(args?: Subset<T, immutable_executable$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the immutable_executable model
   */ 
  interface immutable_executableFieldRefs {
    readonly immutable_execid: FieldRef<"immutable_executable", 'Int'>
    readonly userid: FieldRef<"immutable_executable", 'Int'>
    readonly hash: FieldRef<"immutable_executable", 'String'>
  }
    

  // Custom InputTypes

  /**
   * immutable_executable findUnique
   */
  export type immutable_executableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the immutable_executable
     */
    select?: immutable_executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: immutable_executableInclude<ExtArgs> | null
    /**
     * Filter, which immutable_executable to fetch.
     */
    where: immutable_executableWhereUniqueInput
  }


  /**
   * immutable_executable findUniqueOrThrow
   */
  export type immutable_executableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the immutable_executable
     */
    select?: immutable_executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: immutable_executableInclude<ExtArgs> | null
    /**
     * Filter, which immutable_executable to fetch.
     */
    where: immutable_executableWhereUniqueInput
  }


  /**
   * immutable_executable findFirst
   */
  export type immutable_executableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the immutable_executable
     */
    select?: immutable_executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: immutable_executableInclude<ExtArgs> | null
    /**
     * Filter, which immutable_executable to fetch.
     */
    where?: immutable_executableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of immutable_executables to fetch.
     */
    orderBy?: immutable_executableOrderByWithRelationInput | immutable_executableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for immutable_executables.
     */
    cursor?: immutable_executableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` immutable_executables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` immutable_executables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of immutable_executables.
     */
    distinct?: Immutable_executableScalarFieldEnum | Immutable_executableScalarFieldEnum[]
  }


  /**
   * immutable_executable findFirstOrThrow
   */
  export type immutable_executableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the immutable_executable
     */
    select?: immutable_executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: immutable_executableInclude<ExtArgs> | null
    /**
     * Filter, which immutable_executable to fetch.
     */
    where?: immutable_executableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of immutable_executables to fetch.
     */
    orderBy?: immutable_executableOrderByWithRelationInput | immutable_executableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for immutable_executables.
     */
    cursor?: immutable_executableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` immutable_executables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` immutable_executables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of immutable_executables.
     */
    distinct?: Immutable_executableScalarFieldEnum | Immutable_executableScalarFieldEnum[]
  }


  /**
   * immutable_executable findMany
   */
  export type immutable_executableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the immutable_executable
     */
    select?: immutable_executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: immutable_executableInclude<ExtArgs> | null
    /**
     * Filter, which immutable_executables to fetch.
     */
    where?: immutable_executableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of immutable_executables to fetch.
     */
    orderBy?: immutable_executableOrderByWithRelationInput | immutable_executableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing immutable_executables.
     */
    cursor?: immutable_executableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` immutable_executables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` immutable_executables.
     */
    skip?: number
    distinct?: Immutable_executableScalarFieldEnum | Immutable_executableScalarFieldEnum[]
  }


  /**
   * immutable_executable create
   */
  export type immutable_executableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the immutable_executable
     */
    select?: immutable_executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: immutable_executableInclude<ExtArgs> | null
    /**
     * The data needed to create a immutable_executable.
     */
    data?: XOR<immutable_executableCreateInput, immutable_executableUncheckedCreateInput>
  }


  /**
   * immutable_executable createMany
   */
  export type immutable_executableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many immutable_executables.
     */
    data: immutable_executableCreateManyInput | immutable_executableCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * immutable_executable update
   */
  export type immutable_executableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the immutable_executable
     */
    select?: immutable_executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: immutable_executableInclude<ExtArgs> | null
    /**
     * The data needed to update a immutable_executable.
     */
    data: XOR<immutable_executableUpdateInput, immutable_executableUncheckedUpdateInput>
    /**
     * Choose, which immutable_executable to update.
     */
    where: immutable_executableWhereUniqueInput
  }


  /**
   * immutable_executable updateMany
   */
  export type immutable_executableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update immutable_executables.
     */
    data: XOR<immutable_executableUpdateManyMutationInput, immutable_executableUncheckedUpdateManyInput>
    /**
     * Filter which immutable_executables to update
     */
    where?: immutable_executableWhereInput
  }


  /**
   * immutable_executable upsert
   */
  export type immutable_executableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the immutable_executable
     */
    select?: immutable_executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: immutable_executableInclude<ExtArgs> | null
    /**
     * The filter to search for the immutable_executable to update in case it exists.
     */
    where: immutable_executableWhereUniqueInput
    /**
     * In case the immutable_executable found by the `where` argument doesn't exist, create a new immutable_executable with this data.
     */
    create: XOR<immutable_executableCreateInput, immutable_executableUncheckedCreateInput>
    /**
     * In case the immutable_executable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<immutable_executableUpdateInput, immutable_executableUncheckedUpdateInput>
  }


  /**
   * immutable_executable delete
   */
  export type immutable_executableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the immutable_executable
     */
    select?: immutable_executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: immutable_executableInclude<ExtArgs> | null
    /**
     * Filter which immutable_executable to delete.
     */
    where: immutable_executableWhereUniqueInput
  }


  /**
   * immutable_executable deleteMany
   */
  export type immutable_executableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which immutable_executables to delete
     */
    where?: immutable_executableWhereInput
  }


  /**
   * immutable_executable.executable
   */
  export type immutable_executable$executableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable
     */
    select?: executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executableInclude<ExtArgs> | null
    where?: executableWhereInput
  }


  /**
   * immutable_executable.executable_file
   */
  export type immutable_executable$executable_fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable_file
     */
    select?: executable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executable_fileInclude<ExtArgs> | null
    where?: executable_fileWhereInput
    orderBy?: executable_fileOrderByWithRelationInput | executable_fileOrderByWithRelationInput[]
    cursor?: executable_fileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Executable_fileScalarFieldEnum | Executable_fileScalarFieldEnum[]
  }


  /**
   * immutable_executable.user
   */
  export type immutable_executable$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }


  /**
   * immutable_executable without action
   */
  export type immutable_executableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the immutable_executable
     */
    select?: immutable_executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: immutable_executableInclude<ExtArgs> | null
  }



  /**
   * Model internal_error
   */

  export type AggregateInternal_error = {
    _count: Internal_errorCountAggregateOutputType | null
    _avg: Internal_errorAvgAggregateOutputType | null
    _sum: Internal_errorSumAggregateOutputType | null
    _min: Internal_errorMinAggregateOutputType | null
    _max: Internal_errorMaxAggregateOutputType | null
  }

  export type Internal_errorAvgAggregateOutputType = {
    errorid: number | null
    judgingid: number | null
    cid: number | null
    time: Decimal | null
  }

  export type Internal_errorSumAggregateOutputType = {
    errorid: number | null
    judgingid: number | null
    cid: number | null
    time: Decimal | null
  }

  export type Internal_errorMinAggregateOutputType = {
    errorid: number | null
    judgingid: number | null
    cid: number | null
    description: string | null
    judgehostlog: string | null
    time: Decimal | null
    disabled: string | null
    status: $Enums.internal_error_status | null
  }

  export type Internal_errorMaxAggregateOutputType = {
    errorid: number | null
    judgingid: number | null
    cid: number | null
    description: string | null
    judgehostlog: string | null
    time: Decimal | null
    disabled: string | null
    status: $Enums.internal_error_status | null
  }

  export type Internal_errorCountAggregateOutputType = {
    errorid: number
    judgingid: number
    cid: number
    description: number
    judgehostlog: number
    time: number
    disabled: number
    status: number
    _all: number
  }


  export type Internal_errorAvgAggregateInputType = {
    errorid?: true
    judgingid?: true
    cid?: true
    time?: true
  }

  export type Internal_errorSumAggregateInputType = {
    errorid?: true
    judgingid?: true
    cid?: true
    time?: true
  }

  export type Internal_errorMinAggregateInputType = {
    errorid?: true
    judgingid?: true
    cid?: true
    description?: true
    judgehostlog?: true
    time?: true
    disabled?: true
    status?: true
  }

  export type Internal_errorMaxAggregateInputType = {
    errorid?: true
    judgingid?: true
    cid?: true
    description?: true
    judgehostlog?: true
    time?: true
    disabled?: true
    status?: true
  }

  export type Internal_errorCountAggregateInputType = {
    errorid?: true
    judgingid?: true
    cid?: true
    description?: true
    judgehostlog?: true
    time?: true
    disabled?: true
    status?: true
    _all?: true
  }

  export type Internal_errorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which internal_error to aggregate.
     */
    where?: internal_errorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of internal_errors to fetch.
     */
    orderBy?: internal_errorOrderByWithRelationInput | internal_errorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: internal_errorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` internal_errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` internal_errors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned internal_errors
    **/
    _count?: true | Internal_errorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Internal_errorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Internal_errorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Internal_errorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Internal_errorMaxAggregateInputType
  }

  export type GetInternal_errorAggregateType<T extends Internal_errorAggregateArgs> = {
        [P in keyof T & keyof AggregateInternal_error]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInternal_error[P]>
      : GetScalarType<T[P], AggregateInternal_error[P]>
  }




  export type internal_errorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: internal_errorWhereInput
    orderBy?: internal_errorOrderByWithAggregationInput | internal_errorOrderByWithAggregationInput[]
    by: Internal_errorScalarFieldEnum[] | Internal_errorScalarFieldEnum
    having?: internal_errorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Internal_errorCountAggregateInputType | true
    _avg?: Internal_errorAvgAggregateInputType
    _sum?: Internal_errorSumAggregateInputType
    _min?: Internal_errorMinAggregateInputType
    _max?: Internal_errorMaxAggregateInputType
  }

  export type Internal_errorGroupByOutputType = {
    errorid: number
    judgingid: number | null
    cid: number | null
    description: string
    judgehostlog: string
    time: Decimal
    disabled: string
    status: $Enums.internal_error_status
    _count: Internal_errorCountAggregateOutputType | null
    _avg: Internal_errorAvgAggregateOutputType | null
    _sum: Internal_errorSumAggregateOutputType | null
    _min: Internal_errorMinAggregateOutputType | null
    _max: Internal_errorMaxAggregateOutputType | null
  }

  type GetInternal_errorGroupByPayload<T extends internal_errorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Internal_errorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Internal_errorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Internal_errorGroupByOutputType[P]>
            : GetScalarType<T[P], Internal_errorGroupByOutputType[P]>
        }
      >
    >


  export type internal_errorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    errorid?: boolean
    judgingid?: boolean
    cid?: boolean
    description?: boolean
    judgehostlog?: boolean
    time?: boolean
    disabled?: boolean
    status?: boolean
    judging_internal_error_judgingidTojudging?: boolean | internal_error$judging_internal_error_judgingidTojudgingArgs<ExtArgs>
    contest?: boolean | internal_error$contestArgs<ExtArgs>
    judging_judging_erroridTointernal_error?: boolean | internal_error$judging_judging_erroridTointernal_errorArgs<ExtArgs>
    _count?: boolean | Internal_errorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["internal_error"]>

  export type internal_errorSelectScalar = {
    errorid?: boolean
    judgingid?: boolean
    cid?: boolean
    description?: boolean
    judgehostlog?: boolean
    time?: boolean
    disabled?: boolean
    status?: boolean
  }

  export type internal_errorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    judging_internal_error_judgingidTojudging?: boolean | internal_error$judging_internal_error_judgingidTojudgingArgs<ExtArgs>
    contest?: boolean | internal_error$contestArgs<ExtArgs>
    judging_judging_erroridTointernal_error?: boolean | internal_error$judging_judging_erroridTointernal_errorArgs<ExtArgs>
    _count?: boolean | Internal_errorCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $internal_errorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "internal_error"
    objects: {
      judging_internal_error_judgingidTojudging: Prisma.$judgingPayload<ExtArgs> | null
      contest: Prisma.$contestPayload<ExtArgs> | null
      judging_judging_erroridTointernal_error: Prisma.$judgingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      errorid: number
      judgingid: number | null
      cid: number | null
      description: string
      judgehostlog: string
      time: Prisma.Decimal
      disabled: string
      status: $Enums.internal_error_status
    }, ExtArgs["result"]["internal_error"]>
    composites: {}
  }


  type internal_errorGetPayload<S extends boolean | null | undefined | internal_errorDefaultArgs> = $Result.GetResult<Prisma.$internal_errorPayload, S>

  type internal_errorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<internal_errorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Internal_errorCountAggregateInputType | true
    }

  export interface internal_errorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['internal_error'], meta: { name: 'internal_error' } }
    /**
     * Find zero or one Internal_error that matches the filter.
     * @param {internal_errorFindUniqueArgs} args - Arguments to find a Internal_error
     * @example
     * // Get one Internal_error
     * const internal_error = await prisma.internal_error.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends internal_errorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, internal_errorFindUniqueArgs<ExtArgs>>
    ): Prisma__internal_errorClient<$Result.GetResult<Prisma.$internal_errorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Internal_error that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {internal_errorFindUniqueOrThrowArgs} args - Arguments to find a Internal_error
     * @example
     * // Get one Internal_error
     * const internal_error = await prisma.internal_error.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends internal_errorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, internal_errorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__internal_errorClient<$Result.GetResult<Prisma.$internal_errorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Internal_error that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internal_errorFindFirstArgs} args - Arguments to find a Internal_error
     * @example
     * // Get one Internal_error
     * const internal_error = await prisma.internal_error.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends internal_errorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, internal_errorFindFirstArgs<ExtArgs>>
    ): Prisma__internal_errorClient<$Result.GetResult<Prisma.$internal_errorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Internal_error that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internal_errorFindFirstOrThrowArgs} args - Arguments to find a Internal_error
     * @example
     * // Get one Internal_error
     * const internal_error = await prisma.internal_error.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends internal_errorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, internal_errorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__internal_errorClient<$Result.GetResult<Prisma.$internal_errorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Internal_errors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internal_errorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Internal_errors
     * const internal_errors = await prisma.internal_error.findMany()
     * 
     * // Get first 10 Internal_errors
     * const internal_errors = await prisma.internal_error.findMany({ take: 10 })
     * 
     * // Only select the `errorid`
     * const internal_errorWithErroridOnly = await prisma.internal_error.findMany({ select: { errorid: true } })
     * 
    **/
    findMany<T extends internal_errorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, internal_errorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$internal_errorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Internal_error.
     * @param {internal_errorCreateArgs} args - Arguments to create a Internal_error.
     * @example
     * // Create one Internal_error
     * const Internal_error = await prisma.internal_error.create({
     *   data: {
     *     // ... data to create a Internal_error
     *   }
     * })
     * 
    **/
    create<T extends internal_errorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, internal_errorCreateArgs<ExtArgs>>
    ): Prisma__internal_errorClient<$Result.GetResult<Prisma.$internal_errorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Internal_errors.
     *     @param {internal_errorCreateManyArgs} args - Arguments to create many Internal_errors.
     *     @example
     *     // Create many Internal_errors
     *     const internal_error = await prisma.internal_error.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends internal_errorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, internal_errorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Internal_error.
     * @param {internal_errorDeleteArgs} args - Arguments to delete one Internal_error.
     * @example
     * // Delete one Internal_error
     * const Internal_error = await prisma.internal_error.delete({
     *   where: {
     *     // ... filter to delete one Internal_error
     *   }
     * })
     * 
    **/
    delete<T extends internal_errorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, internal_errorDeleteArgs<ExtArgs>>
    ): Prisma__internal_errorClient<$Result.GetResult<Prisma.$internal_errorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Internal_error.
     * @param {internal_errorUpdateArgs} args - Arguments to update one Internal_error.
     * @example
     * // Update one Internal_error
     * const internal_error = await prisma.internal_error.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends internal_errorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, internal_errorUpdateArgs<ExtArgs>>
    ): Prisma__internal_errorClient<$Result.GetResult<Prisma.$internal_errorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Internal_errors.
     * @param {internal_errorDeleteManyArgs} args - Arguments to filter Internal_errors to delete.
     * @example
     * // Delete a few Internal_errors
     * const { count } = await prisma.internal_error.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends internal_errorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, internal_errorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Internal_errors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internal_errorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Internal_errors
     * const internal_error = await prisma.internal_error.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends internal_errorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, internal_errorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Internal_error.
     * @param {internal_errorUpsertArgs} args - Arguments to update or create a Internal_error.
     * @example
     * // Update or create a Internal_error
     * const internal_error = await prisma.internal_error.upsert({
     *   create: {
     *     // ... data to create a Internal_error
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Internal_error we want to update
     *   }
     * })
    **/
    upsert<T extends internal_errorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, internal_errorUpsertArgs<ExtArgs>>
    ): Prisma__internal_errorClient<$Result.GetResult<Prisma.$internal_errorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Internal_errors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internal_errorCountArgs} args - Arguments to filter Internal_errors to count.
     * @example
     * // Count the number of Internal_errors
     * const count = await prisma.internal_error.count({
     *   where: {
     *     // ... the filter for the Internal_errors we want to count
     *   }
     * })
    **/
    count<T extends internal_errorCountArgs>(
      args?: Subset<T, internal_errorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Internal_errorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Internal_error.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Internal_errorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Internal_errorAggregateArgs>(args: Subset<T, Internal_errorAggregateArgs>): Prisma.PrismaPromise<GetInternal_errorAggregateType<T>>

    /**
     * Group by Internal_error.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internal_errorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends internal_errorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: internal_errorGroupByArgs['orderBy'] }
        : { orderBy?: internal_errorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, internal_errorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInternal_errorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the internal_error model
   */
  readonly fields: internal_errorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for internal_error.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__internal_errorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    judging_internal_error_judgingidTojudging<T extends internal_error$judging_internal_error_judgingidTojudgingArgs<ExtArgs> = {}>(args?: Subset<T, internal_error$judging_internal_error_judgingidTojudgingArgs<ExtArgs>>): Prisma__judgingClient<$Result.GetResult<Prisma.$judgingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    contest<T extends internal_error$contestArgs<ExtArgs> = {}>(args?: Subset<T, internal_error$contestArgs<ExtArgs>>): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    judging_judging_erroridTointernal_error<T extends internal_error$judging_judging_erroridTointernal_errorArgs<ExtArgs> = {}>(args?: Subset<T, internal_error$judging_judging_erroridTointernal_errorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$judgingPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the internal_error model
   */ 
  interface internal_errorFieldRefs {
    readonly errorid: FieldRef<"internal_error", 'Int'>
    readonly judgingid: FieldRef<"internal_error", 'Int'>
    readonly cid: FieldRef<"internal_error", 'Int'>
    readonly description: FieldRef<"internal_error", 'String'>
    readonly judgehostlog: FieldRef<"internal_error", 'String'>
    readonly time: FieldRef<"internal_error", 'Decimal'>
    readonly disabled: FieldRef<"internal_error", 'String'>
    readonly status: FieldRef<"internal_error", 'internal_error_status'>
  }
    

  // Custom InputTypes

  /**
   * internal_error findUnique
   */
  export type internal_errorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal_error
     */
    select?: internal_errorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: internal_errorInclude<ExtArgs> | null
    /**
     * Filter, which internal_error to fetch.
     */
    where: internal_errorWhereUniqueInput
  }


  /**
   * internal_error findUniqueOrThrow
   */
  export type internal_errorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal_error
     */
    select?: internal_errorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: internal_errorInclude<ExtArgs> | null
    /**
     * Filter, which internal_error to fetch.
     */
    where: internal_errorWhereUniqueInput
  }


  /**
   * internal_error findFirst
   */
  export type internal_errorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal_error
     */
    select?: internal_errorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: internal_errorInclude<ExtArgs> | null
    /**
     * Filter, which internal_error to fetch.
     */
    where?: internal_errorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of internal_errors to fetch.
     */
    orderBy?: internal_errorOrderByWithRelationInput | internal_errorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for internal_errors.
     */
    cursor?: internal_errorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` internal_errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` internal_errors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of internal_errors.
     */
    distinct?: Internal_errorScalarFieldEnum | Internal_errorScalarFieldEnum[]
  }


  /**
   * internal_error findFirstOrThrow
   */
  export type internal_errorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal_error
     */
    select?: internal_errorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: internal_errorInclude<ExtArgs> | null
    /**
     * Filter, which internal_error to fetch.
     */
    where?: internal_errorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of internal_errors to fetch.
     */
    orderBy?: internal_errorOrderByWithRelationInput | internal_errorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for internal_errors.
     */
    cursor?: internal_errorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` internal_errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` internal_errors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of internal_errors.
     */
    distinct?: Internal_errorScalarFieldEnum | Internal_errorScalarFieldEnum[]
  }


  /**
   * internal_error findMany
   */
  export type internal_errorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal_error
     */
    select?: internal_errorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: internal_errorInclude<ExtArgs> | null
    /**
     * Filter, which internal_errors to fetch.
     */
    where?: internal_errorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of internal_errors to fetch.
     */
    orderBy?: internal_errorOrderByWithRelationInput | internal_errorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing internal_errors.
     */
    cursor?: internal_errorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` internal_errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` internal_errors.
     */
    skip?: number
    distinct?: Internal_errorScalarFieldEnum | Internal_errorScalarFieldEnum[]
  }


  /**
   * internal_error create
   */
  export type internal_errorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal_error
     */
    select?: internal_errorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: internal_errorInclude<ExtArgs> | null
    /**
     * The data needed to create a internal_error.
     */
    data: XOR<internal_errorCreateInput, internal_errorUncheckedCreateInput>
  }


  /**
   * internal_error createMany
   */
  export type internal_errorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many internal_errors.
     */
    data: internal_errorCreateManyInput | internal_errorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * internal_error update
   */
  export type internal_errorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal_error
     */
    select?: internal_errorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: internal_errorInclude<ExtArgs> | null
    /**
     * The data needed to update a internal_error.
     */
    data: XOR<internal_errorUpdateInput, internal_errorUncheckedUpdateInput>
    /**
     * Choose, which internal_error to update.
     */
    where: internal_errorWhereUniqueInput
  }


  /**
   * internal_error updateMany
   */
  export type internal_errorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update internal_errors.
     */
    data: XOR<internal_errorUpdateManyMutationInput, internal_errorUncheckedUpdateManyInput>
    /**
     * Filter which internal_errors to update
     */
    where?: internal_errorWhereInput
  }


  /**
   * internal_error upsert
   */
  export type internal_errorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal_error
     */
    select?: internal_errorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: internal_errorInclude<ExtArgs> | null
    /**
     * The filter to search for the internal_error to update in case it exists.
     */
    where: internal_errorWhereUniqueInput
    /**
     * In case the internal_error found by the `where` argument doesn't exist, create a new internal_error with this data.
     */
    create: XOR<internal_errorCreateInput, internal_errorUncheckedCreateInput>
    /**
     * In case the internal_error was found with the provided `where` argument, update it with this data.
     */
    update: XOR<internal_errorUpdateInput, internal_errorUncheckedUpdateInput>
  }


  /**
   * internal_error delete
   */
  export type internal_errorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal_error
     */
    select?: internal_errorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: internal_errorInclude<ExtArgs> | null
    /**
     * Filter which internal_error to delete.
     */
    where: internal_errorWhereUniqueInput
  }


  /**
   * internal_error deleteMany
   */
  export type internal_errorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which internal_errors to delete
     */
    where?: internal_errorWhereInput
  }


  /**
   * internal_error.judging_internal_error_judgingidTojudging
   */
  export type internal_error$judging_internal_error_judgingidTojudgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging
     */
    select?: judgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgingInclude<ExtArgs> | null
    where?: judgingWhereInput
  }


  /**
   * internal_error.contest
   */
  export type internal_error$contestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contest
     */
    select?: contestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestInclude<ExtArgs> | null
    where?: contestWhereInput
  }


  /**
   * internal_error.judging_judging_erroridTointernal_error
   */
  export type internal_error$judging_judging_erroridTointernal_errorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging
     */
    select?: judgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgingInclude<ExtArgs> | null
    where?: judgingWhereInput
    orderBy?: judgingOrderByWithRelationInput | judgingOrderByWithRelationInput[]
    cursor?: judgingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JudgingScalarFieldEnum | JudgingScalarFieldEnum[]
  }


  /**
   * internal_error without action
   */
  export type internal_errorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal_error
     */
    select?: internal_errorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: internal_errorInclude<ExtArgs> | null
  }



  /**
   * Model judgehost
   */

  export type AggregateJudgehost = {
    _count: JudgehostCountAggregateOutputType | null
    _avg: JudgehostAvgAggregateOutputType | null
    _sum: JudgehostSumAggregateOutputType | null
    _min: JudgehostMinAggregateOutputType | null
    _max: JudgehostMaxAggregateOutputType | null
  }

  export type JudgehostAvgAggregateOutputType = {
    judgehostid: number | null
    polltime: Decimal | null
  }

  export type JudgehostSumAggregateOutputType = {
    judgehostid: number | null
    polltime: Decimal | null
  }

  export type JudgehostMinAggregateOutputType = {
    judgehostid: number | null
    hostname: string | null
    enabled: boolean | null
    polltime: Decimal | null
    hidden: boolean | null
  }

  export type JudgehostMaxAggregateOutputType = {
    judgehostid: number | null
    hostname: string | null
    enabled: boolean | null
    polltime: Decimal | null
    hidden: boolean | null
  }

  export type JudgehostCountAggregateOutputType = {
    judgehostid: number
    hostname: number
    enabled: number
    polltime: number
    hidden: number
    _all: number
  }


  export type JudgehostAvgAggregateInputType = {
    judgehostid?: true
    polltime?: true
  }

  export type JudgehostSumAggregateInputType = {
    judgehostid?: true
    polltime?: true
  }

  export type JudgehostMinAggregateInputType = {
    judgehostid?: true
    hostname?: true
    enabled?: true
    polltime?: true
    hidden?: true
  }

  export type JudgehostMaxAggregateInputType = {
    judgehostid?: true
    hostname?: true
    enabled?: true
    polltime?: true
    hidden?: true
  }

  export type JudgehostCountAggregateInputType = {
    judgehostid?: true
    hostname?: true
    enabled?: true
    polltime?: true
    hidden?: true
    _all?: true
  }

  export type JudgehostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which judgehost to aggregate.
     */
    where?: judgehostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of judgehosts to fetch.
     */
    orderBy?: judgehostOrderByWithRelationInput | judgehostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: judgehostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` judgehosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` judgehosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned judgehosts
    **/
    _count?: true | JudgehostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JudgehostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JudgehostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JudgehostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JudgehostMaxAggregateInputType
  }

  export type GetJudgehostAggregateType<T extends JudgehostAggregateArgs> = {
        [P in keyof T & keyof AggregateJudgehost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJudgehost[P]>
      : GetScalarType<T[P], AggregateJudgehost[P]>
  }




  export type judgehostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: judgehostWhereInput
    orderBy?: judgehostOrderByWithAggregationInput | judgehostOrderByWithAggregationInput[]
    by: JudgehostScalarFieldEnum[] | JudgehostScalarFieldEnum
    having?: judgehostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JudgehostCountAggregateInputType | true
    _avg?: JudgehostAvgAggregateInputType
    _sum?: JudgehostSumAggregateInputType
    _min?: JudgehostMinAggregateInputType
    _max?: JudgehostMaxAggregateInputType
  }

  export type JudgehostGroupByOutputType = {
    judgehostid: number
    hostname: string
    enabled: boolean
    polltime: Decimal | null
    hidden: boolean
    _count: JudgehostCountAggregateOutputType | null
    _avg: JudgehostAvgAggregateOutputType | null
    _sum: JudgehostSumAggregateOutputType | null
    _min: JudgehostMinAggregateOutputType | null
    _max: JudgehostMaxAggregateOutputType | null
  }

  type GetJudgehostGroupByPayload<T extends judgehostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JudgehostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JudgehostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JudgehostGroupByOutputType[P]>
            : GetScalarType<T[P], JudgehostGroupByOutputType[P]>
        }
      >
    >


  export type judgehostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    judgehostid?: boolean
    hostname?: boolean
    enabled?: boolean
    polltime?: boolean
    hidden?: boolean
    debug_package?: boolean | judgehost$debug_packageArgs<ExtArgs>
    judgetask?: boolean | judgehost$judgetaskArgs<ExtArgs>
    _count?: boolean | JudgehostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["judgehost"]>

  export type judgehostSelectScalar = {
    judgehostid?: boolean
    hostname?: boolean
    enabled?: boolean
    polltime?: boolean
    hidden?: boolean
  }

  export type judgehostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debug_package?: boolean | judgehost$debug_packageArgs<ExtArgs>
    judgetask?: boolean | judgehost$judgetaskArgs<ExtArgs>
    _count?: boolean | JudgehostCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $judgehostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "judgehost"
    objects: {
      debug_package: Prisma.$debug_packagePayload<ExtArgs>[]
      judgetask: Prisma.$judgetaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      judgehostid: number
      hostname: string
      enabled: boolean
      polltime: Prisma.Decimal | null
      hidden: boolean
    }, ExtArgs["result"]["judgehost"]>
    composites: {}
  }


  type judgehostGetPayload<S extends boolean | null | undefined | judgehostDefaultArgs> = $Result.GetResult<Prisma.$judgehostPayload, S>

  type judgehostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<judgehostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JudgehostCountAggregateInputType | true
    }

  export interface judgehostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['judgehost'], meta: { name: 'judgehost' } }
    /**
     * Find zero or one Judgehost that matches the filter.
     * @param {judgehostFindUniqueArgs} args - Arguments to find a Judgehost
     * @example
     * // Get one Judgehost
     * const judgehost = await prisma.judgehost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends judgehostFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, judgehostFindUniqueArgs<ExtArgs>>
    ): Prisma__judgehostClient<$Result.GetResult<Prisma.$judgehostPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Judgehost that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {judgehostFindUniqueOrThrowArgs} args - Arguments to find a Judgehost
     * @example
     * // Get one Judgehost
     * const judgehost = await prisma.judgehost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends judgehostFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, judgehostFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__judgehostClient<$Result.GetResult<Prisma.$judgehostPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Judgehost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judgehostFindFirstArgs} args - Arguments to find a Judgehost
     * @example
     * // Get one Judgehost
     * const judgehost = await prisma.judgehost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends judgehostFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, judgehostFindFirstArgs<ExtArgs>>
    ): Prisma__judgehostClient<$Result.GetResult<Prisma.$judgehostPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Judgehost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judgehostFindFirstOrThrowArgs} args - Arguments to find a Judgehost
     * @example
     * // Get one Judgehost
     * const judgehost = await prisma.judgehost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends judgehostFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, judgehostFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__judgehostClient<$Result.GetResult<Prisma.$judgehostPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Judgehosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judgehostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Judgehosts
     * const judgehosts = await prisma.judgehost.findMany()
     * 
     * // Get first 10 Judgehosts
     * const judgehosts = await prisma.judgehost.findMany({ take: 10 })
     * 
     * // Only select the `judgehostid`
     * const judgehostWithJudgehostidOnly = await prisma.judgehost.findMany({ select: { judgehostid: true } })
     * 
    **/
    findMany<T extends judgehostFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, judgehostFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$judgehostPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Judgehost.
     * @param {judgehostCreateArgs} args - Arguments to create a Judgehost.
     * @example
     * // Create one Judgehost
     * const Judgehost = await prisma.judgehost.create({
     *   data: {
     *     // ... data to create a Judgehost
     *   }
     * })
     * 
    **/
    create<T extends judgehostCreateArgs<ExtArgs>>(
      args: SelectSubset<T, judgehostCreateArgs<ExtArgs>>
    ): Prisma__judgehostClient<$Result.GetResult<Prisma.$judgehostPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Judgehosts.
     *     @param {judgehostCreateManyArgs} args - Arguments to create many Judgehosts.
     *     @example
     *     // Create many Judgehosts
     *     const judgehost = await prisma.judgehost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends judgehostCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, judgehostCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Judgehost.
     * @param {judgehostDeleteArgs} args - Arguments to delete one Judgehost.
     * @example
     * // Delete one Judgehost
     * const Judgehost = await prisma.judgehost.delete({
     *   where: {
     *     // ... filter to delete one Judgehost
     *   }
     * })
     * 
    **/
    delete<T extends judgehostDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, judgehostDeleteArgs<ExtArgs>>
    ): Prisma__judgehostClient<$Result.GetResult<Prisma.$judgehostPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Judgehost.
     * @param {judgehostUpdateArgs} args - Arguments to update one Judgehost.
     * @example
     * // Update one Judgehost
     * const judgehost = await prisma.judgehost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends judgehostUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, judgehostUpdateArgs<ExtArgs>>
    ): Prisma__judgehostClient<$Result.GetResult<Prisma.$judgehostPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Judgehosts.
     * @param {judgehostDeleteManyArgs} args - Arguments to filter Judgehosts to delete.
     * @example
     * // Delete a few Judgehosts
     * const { count } = await prisma.judgehost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends judgehostDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, judgehostDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Judgehosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judgehostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Judgehosts
     * const judgehost = await prisma.judgehost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends judgehostUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, judgehostUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Judgehost.
     * @param {judgehostUpsertArgs} args - Arguments to update or create a Judgehost.
     * @example
     * // Update or create a Judgehost
     * const judgehost = await prisma.judgehost.upsert({
     *   create: {
     *     // ... data to create a Judgehost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Judgehost we want to update
     *   }
     * })
    **/
    upsert<T extends judgehostUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, judgehostUpsertArgs<ExtArgs>>
    ): Prisma__judgehostClient<$Result.GetResult<Prisma.$judgehostPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Judgehosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judgehostCountArgs} args - Arguments to filter Judgehosts to count.
     * @example
     * // Count the number of Judgehosts
     * const count = await prisma.judgehost.count({
     *   where: {
     *     // ... the filter for the Judgehosts we want to count
     *   }
     * })
    **/
    count<T extends judgehostCountArgs>(
      args?: Subset<T, judgehostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JudgehostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Judgehost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgehostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JudgehostAggregateArgs>(args: Subset<T, JudgehostAggregateArgs>): Prisma.PrismaPromise<GetJudgehostAggregateType<T>>

    /**
     * Group by Judgehost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judgehostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends judgehostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: judgehostGroupByArgs['orderBy'] }
        : { orderBy?: judgehostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, judgehostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJudgehostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the judgehost model
   */
  readonly fields: judgehostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for judgehost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__judgehostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    debug_package<T extends judgehost$debug_packageArgs<ExtArgs> = {}>(args?: Subset<T, judgehost$debug_packageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$debug_packagePayload<ExtArgs>, T, 'findMany'> | Null>;

    judgetask<T extends judgehost$judgetaskArgs<ExtArgs> = {}>(args?: Subset<T, judgehost$judgetaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$judgetaskPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the judgehost model
   */ 
  interface judgehostFieldRefs {
    readonly judgehostid: FieldRef<"judgehost", 'Int'>
    readonly hostname: FieldRef<"judgehost", 'String'>
    readonly enabled: FieldRef<"judgehost", 'Boolean'>
    readonly polltime: FieldRef<"judgehost", 'Decimal'>
    readonly hidden: FieldRef<"judgehost", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * judgehost findUnique
   */
  export type judgehostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgehost
     */
    select?: judgehostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgehostInclude<ExtArgs> | null
    /**
     * Filter, which judgehost to fetch.
     */
    where: judgehostWhereUniqueInput
  }


  /**
   * judgehost findUniqueOrThrow
   */
  export type judgehostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgehost
     */
    select?: judgehostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgehostInclude<ExtArgs> | null
    /**
     * Filter, which judgehost to fetch.
     */
    where: judgehostWhereUniqueInput
  }


  /**
   * judgehost findFirst
   */
  export type judgehostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgehost
     */
    select?: judgehostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgehostInclude<ExtArgs> | null
    /**
     * Filter, which judgehost to fetch.
     */
    where?: judgehostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of judgehosts to fetch.
     */
    orderBy?: judgehostOrderByWithRelationInput | judgehostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for judgehosts.
     */
    cursor?: judgehostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` judgehosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` judgehosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of judgehosts.
     */
    distinct?: JudgehostScalarFieldEnum | JudgehostScalarFieldEnum[]
  }


  /**
   * judgehost findFirstOrThrow
   */
  export type judgehostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgehost
     */
    select?: judgehostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgehostInclude<ExtArgs> | null
    /**
     * Filter, which judgehost to fetch.
     */
    where?: judgehostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of judgehosts to fetch.
     */
    orderBy?: judgehostOrderByWithRelationInput | judgehostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for judgehosts.
     */
    cursor?: judgehostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` judgehosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` judgehosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of judgehosts.
     */
    distinct?: JudgehostScalarFieldEnum | JudgehostScalarFieldEnum[]
  }


  /**
   * judgehost findMany
   */
  export type judgehostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgehost
     */
    select?: judgehostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgehostInclude<ExtArgs> | null
    /**
     * Filter, which judgehosts to fetch.
     */
    where?: judgehostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of judgehosts to fetch.
     */
    orderBy?: judgehostOrderByWithRelationInput | judgehostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing judgehosts.
     */
    cursor?: judgehostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` judgehosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` judgehosts.
     */
    skip?: number
    distinct?: JudgehostScalarFieldEnum | JudgehostScalarFieldEnum[]
  }


  /**
   * judgehost create
   */
  export type judgehostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgehost
     */
    select?: judgehostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgehostInclude<ExtArgs> | null
    /**
     * The data needed to create a judgehost.
     */
    data: XOR<judgehostCreateInput, judgehostUncheckedCreateInput>
  }


  /**
   * judgehost createMany
   */
  export type judgehostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many judgehosts.
     */
    data: judgehostCreateManyInput | judgehostCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * judgehost update
   */
  export type judgehostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgehost
     */
    select?: judgehostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgehostInclude<ExtArgs> | null
    /**
     * The data needed to update a judgehost.
     */
    data: XOR<judgehostUpdateInput, judgehostUncheckedUpdateInput>
    /**
     * Choose, which judgehost to update.
     */
    where: judgehostWhereUniqueInput
  }


  /**
   * judgehost updateMany
   */
  export type judgehostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update judgehosts.
     */
    data: XOR<judgehostUpdateManyMutationInput, judgehostUncheckedUpdateManyInput>
    /**
     * Filter which judgehosts to update
     */
    where?: judgehostWhereInput
  }


  /**
   * judgehost upsert
   */
  export type judgehostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgehost
     */
    select?: judgehostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgehostInclude<ExtArgs> | null
    /**
     * The filter to search for the judgehost to update in case it exists.
     */
    where: judgehostWhereUniqueInput
    /**
     * In case the judgehost found by the `where` argument doesn't exist, create a new judgehost with this data.
     */
    create: XOR<judgehostCreateInput, judgehostUncheckedCreateInput>
    /**
     * In case the judgehost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<judgehostUpdateInput, judgehostUncheckedUpdateInput>
  }


  /**
   * judgehost delete
   */
  export type judgehostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgehost
     */
    select?: judgehostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgehostInclude<ExtArgs> | null
    /**
     * Filter which judgehost to delete.
     */
    where: judgehostWhereUniqueInput
  }


  /**
   * judgehost deleteMany
   */
  export type judgehostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which judgehosts to delete
     */
    where?: judgehostWhereInput
  }


  /**
   * judgehost.debug_package
   */
  export type judgehost$debug_packageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debug_package
     */
    select?: debug_packageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: debug_packageInclude<ExtArgs> | null
    where?: debug_packageWhereInput
    orderBy?: debug_packageOrderByWithRelationInput | debug_packageOrderByWithRelationInput[]
    cursor?: debug_packageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Debug_packageScalarFieldEnum | Debug_packageScalarFieldEnum[]
  }


  /**
   * judgehost.judgetask
   */
  export type judgehost$judgetaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgetask
     */
    select?: judgetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgetaskInclude<ExtArgs> | null
    where?: judgetaskWhereInput
    orderBy?: judgetaskOrderByWithRelationInput | judgetaskOrderByWithRelationInput[]
    cursor?: judgetaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JudgetaskScalarFieldEnum | JudgetaskScalarFieldEnum[]
  }


  /**
   * judgehost without action
   */
  export type judgehostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgehost
     */
    select?: judgehostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgehostInclude<ExtArgs> | null
  }



  /**
   * Model judgetask
   */

  export type AggregateJudgetask = {
    _count: JudgetaskCountAggregateOutputType | null
    _avg: JudgetaskAvgAggregateOutputType | null
    _sum: JudgetaskSumAggregateOutputType | null
    _min: JudgetaskMinAggregateOutputType | null
    _max: JudgetaskMaxAggregateOutputType | null
  }

  export type JudgetaskAvgAggregateOutputType = {
    judgetaskid: number | null
    judgehostid: number | null
    priority: number | null
    jobid: number | null
    submitid: number | null
    compile_script_id: number | null
    run_script_id: number | null
    compare_script_id: number | null
    testcase_id: number | null
    starttime: Decimal | null
  }

  export type JudgetaskSumAggregateOutputType = {
    judgetaskid: number | null
    judgehostid: number | null
    priority: number | null
    jobid: number | null
    submitid: number | null
    compile_script_id: number | null
    run_script_id: number | null
    compare_script_id: number | null
    testcase_id: number | null
    starttime: Decimal | null
  }

  export type JudgetaskMinAggregateOutputType = {
    judgetaskid: number | null
    judgehostid: number | null
    type: $Enums.judgetask_type | null
    priority: number | null
    jobid: number | null
    submitid: number | null
    compile_script_id: number | null
    run_script_id: number | null
    compare_script_id: number | null
    testcase_id: number | null
    compile_config: string | null
    run_config: string | null
    compare_config: string | null
    valid: boolean | null
    starttime: Decimal | null
    uuid: string | null
    testcase_hash: string | null
  }

  export type JudgetaskMaxAggregateOutputType = {
    judgetaskid: number | null
    judgehostid: number | null
    type: $Enums.judgetask_type | null
    priority: number | null
    jobid: number | null
    submitid: number | null
    compile_script_id: number | null
    run_script_id: number | null
    compare_script_id: number | null
    testcase_id: number | null
    compile_config: string | null
    run_config: string | null
    compare_config: string | null
    valid: boolean | null
    starttime: Decimal | null
    uuid: string | null
    testcase_hash: string | null
  }

  export type JudgetaskCountAggregateOutputType = {
    judgetaskid: number
    judgehostid: number
    type: number
    priority: number
    jobid: number
    submitid: number
    compile_script_id: number
    run_script_id: number
    compare_script_id: number
    testcase_id: number
    compile_config: number
    run_config: number
    compare_config: number
    valid: number
    starttime: number
    uuid: number
    testcase_hash: number
    _all: number
  }


  export type JudgetaskAvgAggregateInputType = {
    judgetaskid?: true
    judgehostid?: true
    priority?: true
    jobid?: true
    submitid?: true
    compile_script_id?: true
    run_script_id?: true
    compare_script_id?: true
    testcase_id?: true
    starttime?: true
  }

  export type JudgetaskSumAggregateInputType = {
    judgetaskid?: true
    judgehostid?: true
    priority?: true
    jobid?: true
    submitid?: true
    compile_script_id?: true
    run_script_id?: true
    compare_script_id?: true
    testcase_id?: true
    starttime?: true
  }

  export type JudgetaskMinAggregateInputType = {
    judgetaskid?: true
    judgehostid?: true
    type?: true
    priority?: true
    jobid?: true
    submitid?: true
    compile_script_id?: true
    run_script_id?: true
    compare_script_id?: true
    testcase_id?: true
    compile_config?: true
    run_config?: true
    compare_config?: true
    valid?: true
    starttime?: true
    uuid?: true
    testcase_hash?: true
  }

  export type JudgetaskMaxAggregateInputType = {
    judgetaskid?: true
    judgehostid?: true
    type?: true
    priority?: true
    jobid?: true
    submitid?: true
    compile_script_id?: true
    run_script_id?: true
    compare_script_id?: true
    testcase_id?: true
    compile_config?: true
    run_config?: true
    compare_config?: true
    valid?: true
    starttime?: true
    uuid?: true
    testcase_hash?: true
  }

  export type JudgetaskCountAggregateInputType = {
    judgetaskid?: true
    judgehostid?: true
    type?: true
    priority?: true
    jobid?: true
    submitid?: true
    compile_script_id?: true
    run_script_id?: true
    compare_script_id?: true
    testcase_id?: true
    compile_config?: true
    run_config?: true
    compare_config?: true
    valid?: true
    starttime?: true
    uuid?: true
    testcase_hash?: true
    _all?: true
  }

  export type JudgetaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which judgetask to aggregate.
     */
    where?: judgetaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of judgetasks to fetch.
     */
    orderBy?: judgetaskOrderByWithRelationInput | judgetaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: judgetaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` judgetasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` judgetasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned judgetasks
    **/
    _count?: true | JudgetaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JudgetaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JudgetaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JudgetaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JudgetaskMaxAggregateInputType
  }

  export type GetJudgetaskAggregateType<T extends JudgetaskAggregateArgs> = {
        [P in keyof T & keyof AggregateJudgetask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJudgetask[P]>
      : GetScalarType<T[P], AggregateJudgetask[P]>
  }




  export type judgetaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: judgetaskWhereInput
    orderBy?: judgetaskOrderByWithAggregationInput | judgetaskOrderByWithAggregationInput[]
    by: JudgetaskScalarFieldEnum[] | JudgetaskScalarFieldEnum
    having?: judgetaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JudgetaskCountAggregateInputType | true
    _avg?: JudgetaskAvgAggregateInputType
    _sum?: JudgetaskSumAggregateInputType
    _min?: JudgetaskMinAggregateInputType
    _max?: JudgetaskMaxAggregateInputType
  }

  export type JudgetaskGroupByOutputType = {
    judgetaskid: number
    judgehostid: number | null
    type: $Enums.judgetask_type
    priority: number
    jobid: number | null
    submitid: number | null
    compile_script_id: number | null
    run_script_id: number | null
    compare_script_id: number | null
    testcase_id: number | null
    compile_config: string | null
    run_config: string | null
    compare_config: string | null
    valid: boolean
    starttime: Decimal | null
    uuid: string | null
    testcase_hash: string | null
    _count: JudgetaskCountAggregateOutputType | null
    _avg: JudgetaskAvgAggregateOutputType | null
    _sum: JudgetaskSumAggregateOutputType | null
    _min: JudgetaskMinAggregateOutputType | null
    _max: JudgetaskMaxAggregateOutputType | null
  }

  type GetJudgetaskGroupByPayload<T extends judgetaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JudgetaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JudgetaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JudgetaskGroupByOutputType[P]>
            : GetScalarType<T[P], JudgetaskGroupByOutputType[P]>
        }
      >
    >


  export type judgetaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    judgetaskid?: boolean
    judgehostid?: boolean
    type?: boolean
    priority?: boolean
    jobid?: boolean
    submitid?: boolean
    compile_script_id?: boolean
    run_script_id?: boolean
    compare_script_id?: boolean
    testcase_id?: boolean
    compile_config?: boolean
    run_config?: boolean
    compare_config?: boolean
    valid?: boolean
    starttime?: boolean
    uuid?: boolean
    testcase_hash?: boolean
    judgehost?: boolean | judgetask$judgehostArgs<ExtArgs>
    judging_run?: boolean | judgetask$judging_runArgs<ExtArgs>
    _count?: boolean | JudgetaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["judgetask"]>

  export type judgetaskSelectScalar = {
    judgetaskid?: boolean
    judgehostid?: boolean
    type?: boolean
    priority?: boolean
    jobid?: boolean
    submitid?: boolean
    compile_script_id?: boolean
    run_script_id?: boolean
    compare_script_id?: boolean
    testcase_id?: boolean
    compile_config?: boolean
    run_config?: boolean
    compare_config?: boolean
    valid?: boolean
    starttime?: boolean
    uuid?: boolean
    testcase_hash?: boolean
  }

  export type judgetaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    judgehost?: boolean | judgetask$judgehostArgs<ExtArgs>
    judging_run?: boolean | judgetask$judging_runArgs<ExtArgs>
    _count?: boolean | JudgetaskCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $judgetaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "judgetask"
    objects: {
      judgehost: Prisma.$judgehostPayload<ExtArgs> | null
      judging_run: Prisma.$judging_runPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      judgetaskid: number
      judgehostid: number | null
      type: $Enums.judgetask_type
      priority: number
      jobid: number | null
      submitid: number | null
      compile_script_id: number | null
      run_script_id: number | null
      compare_script_id: number | null
      testcase_id: number | null
      compile_config: string | null
      run_config: string | null
      compare_config: string | null
      valid: boolean
      starttime: Prisma.Decimal | null
      uuid: string | null
      testcase_hash: string | null
    }, ExtArgs["result"]["judgetask"]>
    composites: {}
  }


  type judgetaskGetPayload<S extends boolean | null | undefined | judgetaskDefaultArgs> = $Result.GetResult<Prisma.$judgetaskPayload, S>

  type judgetaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<judgetaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JudgetaskCountAggregateInputType | true
    }

  export interface judgetaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['judgetask'], meta: { name: 'judgetask' } }
    /**
     * Find zero or one Judgetask that matches the filter.
     * @param {judgetaskFindUniqueArgs} args - Arguments to find a Judgetask
     * @example
     * // Get one Judgetask
     * const judgetask = await prisma.judgetask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends judgetaskFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, judgetaskFindUniqueArgs<ExtArgs>>
    ): Prisma__judgetaskClient<$Result.GetResult<Prisma.$judgetaskPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Judgetask that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {judgetaskFindUniqueOrThrowArgs} args - Arguments to find a Judgetask
     * @example
     * // Get one Judgetask
     * const judgetask = await prisma.judgetask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends judgetaskFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, judgetaskFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__judgetaskClient<$Result.GetResult<Prisma.$judgetaskPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Judgetask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judgetaskFindFirstArgs} args - Arguments to find a Judgetask
     * @example
     * // Get one Judgetask
     * const judgetask = await prisma.judgetask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends judgetaskFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, judgetaskFindFirstArgs<ExtArgs>>
    ): Prisma__judgetaskClient<$Result.GetResult<Prisma.$judgetaskPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Judgetask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judgetaskFindFirstOrThrowArgs} args - Arguments to find a Judgetask
     * @example
     * // Get one Judgetask
     * const judgetask = await prisma.judgetask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends judgetaskFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, judgetaskFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__judgetaskClient<$Result.GetResult<Prisma.$judgetaskPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Judgetasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judgetaskFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Judgetasks
     * const judgetasks = await prisma.judgetask.findMany()
     * 
     * // Get first 10 Judgetasks
     * const judgetasks = await prisma.judgetask.findMany({ take: 10 })
     * 
     * // Only select the `judgetaskid`
     * const judgetaskWithJudgetaskidOnly = await prisma.judgetask.findMany({ select: { judgetaskid: true } })
     * 
    **/
    findMany<T extends judgetaskFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, judgetaskFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$judgetaskPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Judgetask.
     * @param {judgetaskCreateArgs} args - Arguments to create a Judgetask.
     * @example
     * // Create one Judgetask
     * const Judgetask = await prisma.judgetask.create({
     *   data: {
     *     // ... data to create a Judgetask
     *   }
     * })
     * 
    **/
    create<T extends judgetaskCreateArgs<ExtArgs>>(
      args: SelectSubset<T, judgetaskCreateArgs<ExtArgs>>
    ): Prisma__judgetaskClient<$Result.GetResult<Prisma.$judgetaskPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Judgetasks.
     *     @param {judgetaskCreateManyArgs} args - Arguments to create many Judgetasks.
     *     @example
     *     // Create many Judgetasks
     *     const judgetask = await prisma.judgetask.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends judgetaskCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, judgetaskCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Judgetask.
     * @param {judgetaskDeleteArgs} args - Arguments to delete one Judgetask.
     * @example
     * // Delete one Judgetask
     * const Judgetask = await prisma.judgetask.delete({
     *   where: {
     *     // ... filter to delete one Judgetask
     *   }
     * })
     * 
    **/
    delete<T extends judgetaskDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, judgetaskDeleteArgs<ExtArgs>>
    ): Prisma__judgetaskClient<$Result.GetResult<Prisma.$judgetaskPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Judgetask.
     * @param {judgetaskUpdateArgs} args - Arguments to update one Judgetask.
     * @example
     * // Update one Judgetask
     * const judgetask = await prisma.judgetask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends judgetaskUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, judgetaskUpdateArgs<ExtArgs>>
    ): Prisma__judgetaskClient<$Result.GetResult<Prisma.$judgetaskPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Judgetasks.
     * @param {judgetaskDeleteManyArgs} args - Arguments to filter Judgetasks to delete.
     * @example
     * // Delete a few Judgetasks
     * const { count } = await prisma.judgetask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends judgetaskDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, judgetaskDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Judgetasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judgetaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Judgetasks
     * const judgetask = await prisma.judgetask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends judgetaskUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, judgetaskUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Judgetask.
     * @param {judgetaskUpsertArgs} args - Arguments to update or create a Judgetask.
     * @example
     * // Update or create a Judgetask
     * const judgetask = await prisma.judgetask.upsert({
     *   create: {
     *     // ... data to create a Judgetask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Judgetask we want to update
     *   }
     * })
    **/
    upsert<T extends judgetaskUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, judgetaskUpsertArgs<ExtArgs>>
    ): Prisma__judgetaskClient<$Result.GetResult<Prisma.$judgetaskPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Judgetasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judgetaskCountArgs} args - Arguments to filter Judgetasks to count.
     * @example
     * // Count the number of Judgetasks
     * const count = await prisma.judgetask.count({
     *   where: {
     *     // ... the filter for the Judgetasks we want to count
     *   }
     * })
    **/
    count<T extends judgetaskCountArgs>(
      args?: Subset<T, judgetaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JudgetaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Judgetask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgetaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JudgetaskAggregateArgs>(args: Subset<T, JudgetaskAggregateArgs>): Prisma.PrismaPromise<GetJudgetaskAggregateType<T>>

    /**
     * Group by Judgetask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judgetaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends judgetaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: judgetaskGroupByArgs['orderBy'] }
        : { orderBy?: judgetaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, judgetaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJudgetaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the judgetask model
   */
  readonly fields: judgetaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for judgetask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__judgetaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    judgehost<T extends judgetask$judgehostArgs<ExtArgs> = {}>(args?: Subset<T, judgetask$judgehostArgs<ExtArgs>>): Prisma__judgehostClient<$Result.GetResult<Prisma.$judgehostPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    judging_run<T extends judgetask$judging_runArgs<ExtArgs> = {}>(args?: Subset<T, judgetask$judging_runArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$judging_runPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the judgetask model
   */ 
  interface judgetaskFieldRefs {
    readonly judgetaskid: FieldRef<"judgetask", 'Int'>
    readonly judgehostid: FieldRef<"judgetask", 'Int'>
    readonly type: FieldRef<"judgetask", 'judgetask_type'>
    readonly priority: FieldRef<"judgetask", 'Int'>
    readonly jobid: FieldRef<"judgetask", 'Int'>
    readonly submitid: FieldRef<"judgetask", 'Int'>
    readonly compile_script_id: FieldRef<"judgetask", 'Int'>
    readonly run_script_id: FieldRef<"judgetask", 'Int'>
    readonly compare_script_id: FieldRef<"judgetask", 'Int'>
    readonly testcase_id: FieldRef<"judgetask", 'Int'>
    readonly compile_config: FieldRef<"judgetask", 'String'>
    readonly run_config: FieldRef<"judgetask", 'String'>
    readonly compare_config: FieldRef<"judgetask", 'String'>
    readonly valid: FieldRef<"judgetask", 'Boolean'>
    readonly starttime: FieldRef<"judgetask", 'Decimal'>
    readonly uuid: FieldRef<"judgetask", 'String'>
    readonly testcase_hash: FieldRef<"judgetask", 'String'>
  }
    

  // Custom InputTypes

  /**
   * judgetask findUnique
   */
  export type judgetaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgetask
     */
    select?: judgetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgetaskInclude<ExtArgs> | null
    /**
     * Filter, which judgetask to fetch.
     */
    where: judgetaskWhereUniqueInput
  }


  /**
   * judgetask findUniqueOrThrow
   */
  export type judgetaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgetask
     */
    select?: judgetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgetaskInclude<ExtArgs> | null
    /**
     * Filter, which judgetask to fetch.
     */
    where: judgetaskWhereUniqueInput
  }


  /**
   * judgetask findFirst
   */
  export type judgetaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgetask
     */
    select?: judgetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgetaskInclude<ExtArgs> | null
    /**
     * Filter, which judgetask to fetch.
     */
    where?: judgetaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of judgetasks to fetch.
     */
    orderBy?: judgetaskOrderByWithRelationInput | judgetaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for judgetasks.
     */
    cursor?: judgetaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` judgetasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` judgetasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of judgetasks.
     */
    distinct?: JudgetaskScalarFieldEnum | JudgetaskScalarFieldEnum[]
  }


  /**
   * judgetask findFirstOrThrow
   */
  export type judgetaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgetask
     */
    select?: judgetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgetaskInclude<ExtArgs> | null
    /**
     * Filter, which judgetask to fetch.
     */
    where?: judgetaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of judgetasks to fetch.
     */
    orderBy?: judgetaskOrderByWithRelationInput | judgetaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for judgetasks.
     */
    cursor?: judgetaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` judgetasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` judgetasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of judgetasks.
     */
    distinct?: JudgetaskScalarFieldEnum | JudgetaskScalarFieldEnum[]
  }


  /**
   * judgetask findMany
   */
  export type judgetaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgetask
     */
    select?: judgetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgetaskInclude<ExtArgs> | null
    /**
     * Filter, which judgetasks to fetch.
     */
    where?: judgetaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of judgetasks to fetch.
     */
    orderBy?: judgetaskOrderByWithRelationInput | judgetaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing judgetasks.
     */
    cursor?: judgetaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` judgetasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` judgetasks.
     */
    skip?: number
    distinct?: JudgetaskScalarFieldEnum | JudgetaskScalarFieldEnum[]
  }


  /**
   * judgetask create
   */
  export type judgetaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgetask
     */
    select?: judgetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgetaskInclude<ExtArgs> | null
    /**
     * The data needed to create a judgetask.
     */
    data: XOR<judgetaskCreateInput, judgetaskUncheckedCreateInput>
  }


  /**
   * judgetask createMany
   */
  export type judgetaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many judgetasks.
     */
    data: judgetaskCreateManyInput | judgetaskCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * judgetask update
   */
  export type judgetaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgetask
     */
    select?: judgetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgetaskInclude<ExtArgs> | null
    /**
     * The data needed to update a judgetask.
     */
    data: XOR<judgetaskUpdateInput, judgetaskUncheckedUpdateInput>
    /**
     * Choose, which judgetask to update.
     */
    where: judgetaskWhereUniqueInput
  }


  /**
   * judgetask updateMany
   */
  export type judgetaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update judgetasks.
     */
    data: XOR<judgetaskUpdateManyMutationInput, judgetaskUncheckedUpdateManyInput>
    /**
     * Filter which judgetasks to update
     */
    where?: judgetaskWhereInput
  }


  /**
   * judgetask upsert
   */
  export type judgetaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgetask
     */
    select?: judgetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgetaskInclude<ExtArgs> | null
    /**
     * The filter to search for the judgetask to update in case it exists.
     */
    where: judgetaskWhereUniqueInput
    /**
     * In case the judgetask found by the `where` argument doesn't exist, create a new judgetask with this data.
     */
    create: XOR<judgetaskCreateInput, judgetaskUncheckedCreateInput>
    /**
     * In case the judgetask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<judgetaskUpdateInput, judgetaskUncheckedUpdateInput>
  }


  /**
   * judgetask delete
   */
  export type judgetaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgetask
     */
    select?: judgetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgetaskInclude<ExtArgs> | null
    /**
     * Filter which judgetask to delete.
     */
    where: judgetaskWhereUniqueInput
  }


  /**
   * judgetask deleteMany
   */
  export type judgetaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which judgetasks to delete
     */
    where?: judgetaskWhereInput
  }


  /**
   * judgetask.judgehost
   */
  export type judgetask$judgehostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgehost
     */
    select?: judgehostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgehostInclude<ExtArgs> | null
    where?: judgehostWhereInput
  }


  /**
   * judgetask.judging_run
   */
  export type judgetask$judging_runArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run
     */
    select?: judging_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_runInclude<ExtArgs> | null
    where?: judging_runWhereInput
    orderBy?: judging_runOrderByWithRelationInput | judging_runOrderByWithRelationInput[]
    cursor?: judging_runWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Judging_runScalarFieldEnum | Judging_runScalarFieldEnum[]
  }


  /**
   * judgetask without action
   */
  export type judgetaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgetask
     */
    select?: judgetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgetaskInclude<ExtArgs> | null
  }



  /**
   * Model judging
   */

  export type AggregateJudging = {
    _count: JudgingCountAggregateOutputType | null
    _avg: JudgingAvgAggregateOutputType | null
    _sum: JudgingSumAggregateOutputType | null
    _min: JudgingMinAggregateOutputType | null
    _max: JudgingMaxAggregateOutputType | null
  }

  export type JudgingAvgAggregateOutputType = {
    judgingid: number | null
    cid: number | null
    submitid: number | null
    starttime: Decimal | null
    endtime: Decimal | null
    rejudgingid: number | null
    prevjudgingid: number | null
    errorid: number | null
  }

  export type JudgingSumAggregateOutputType = {
    judgingid: number | null
    cid: number | null
    submitid: number | null
    starttime: Decimal | null
    endtime: Decimal | null
    rejudgingid: number | null
    prevjudgingid: number | null
    errorid: number | null
  }

  export type JudgingMinAggregateOutputType = {
    judgingid: number | null
    cid: number | null
    submitid: number | null
    starttime: Decimal | null
    endtime: Decimal | null
    result: string | null
    verified: boolean | null
    jury_member: string | null
    verify_comment: string | null
    valid: boolean | null
    output_compile: Buffer | null
    seen: boolean | null
    rejudgingid: number | null
    prevjudgingid: number | null
    judge_completely: boolean | null
    errorid: number | null
    uuid: string | null
    metadata: Buffer | null
  }

  export type JudgingMaxAggregateOutputType = {
    judgingid: number | null
    cid: number | null
    submitid: number | null
    starttime: Decimal | null
    endtime: Decimal | null
    result: string | null
    verified: boolean | null
    jury_member: string | null
    verify_comment: string | null
    valid: boolean | null
    output_compile: Buffer | null
    seen: boolean | null
    rejudgingid: number | null
    prevjudgingid: number | null
    judge_completely: boolean | null
    errorid: number | null
    uuid: string | null
    metadata: Buffer | null
  }

  export type JudgingCountAggregateOutputType = {
    judgingid: number
    cid: number
    submitid: number
    starttime: number
    endtime: number
    result: number
    verified: number
    jury_member: number
    verify_comment: number
    valid: number
    output_compile: number
    seen: number
    rejudgingid: number
    prevjudgingid: number
    judge_completely: number
    errorid: number
    uuid: number
    metadata: number
    _all: number
  }


  export type JudgingAvgAggregateInputType = {
    judgingid?: true
    cid?: true
    submitid?: true
    starttime?: true
    endtime?: true
    rejudgingid?: true
    prevjudgingid?: true
    errorid?: true
  }

  export type JudgingSumAggregateInputType = {
    judgingid?: true
    cid?: true
    submitid?: true
    starttime?: true
    endtime?: true
    rejudgingid?: true
    prevjudgingid?: true
    errorid?: true
  }

  export type JudgingMinAggregateInputType = {
    judgingid?: true
    cid?: true
    submitid?: true
    starttime?: true
    endtime?: true
    result?: true
    verified?: true
    jury_member?: true
    verify_comment?: true
    valid?: true
    output_compile?: true
    seen?: true
    rejudgingid?: true
    prevjudgingid?: true
    judge_completely?: true
    errorid?: true
    uuid?: true
    metadata?: true
  }

  export type JudgingMaxAggregateInputType = {
    judgingid?: true
    cid?: true
    submitid?: true
    starttime?: true
    endtime?: true
    result?: true
    verified?: true
    jury_member?: true
    verify_comment?: true
    valid?: true
    output_compile?: true
    seen?: true
    rejudgingid?: true
    prevjudgingid?: true
    judge_completely?: true
    errorid?: true
    uuid?: true
    metadata?: true
  }

  export type JudgingCountAggregateInputType = {
    judgingid?: true
    cid?: true
    submitid?: true
    starttime?: true
    endtime?: true
    result?: true
    verified?: true
    jury_member?: true
    verify_comment?: true
    valid?: true
    output_compile?: true
    seen?: true
    rejudgingid?: true
    prevjudgingid?: true
    judge_completely?: true
    errorid?: true
    uuid?: true
    metadata?: true
    _all?: true
  }

  export type JudgingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which judging to aggregate.
     */
    where?: judgingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of judgings to fetch.
     */
    orderBy?: judgingOrderByWithRelationInput | judgingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: judgingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` judgings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` judgings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned judgings
    **/
    _count?: true | JudgingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JudgingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JudgingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JudgingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JudgingMaxAggregateInputType
  }

  export type GetJudgingAggregateType<T extends JudgingAggregateArgs> = {
        [P in keyof T & keyof AggregateJudging]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJudging[P]>
      : GetScalarType<T[P], AggregateJudging[P]>
  }




  export type judgingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: judgingWhereInput
    orderBy?: judgingOrderByWithAggregationInput | judgingOrderByWithAggregationInput[]
    by: JudgingScalarFieldEnum[] | JudgingScalarFieldEnum
    having?: judgingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JudgingCountAggregateInputType | true
    _avg?: JudgingAvgAggregateInputType
    _sum?: JudgingSumAggregateInputType
    _min?: JudgingMinAggregateInputType
    _max?: JudgingMaxAggregateInputType
  }

  export type JudgingGroupByOutputType = {
    judgingid: number
    cid: number | null
    submitid: number | null
    starttime: Decimal | null
    endtime: Decimal | null
    result: string | null
    verified: boolean
    jury_member: string | null
    verify_comment: string | null
    valid: boolean
    output_compile: Buffer | null
    seen: boolean
    rejudgingid: number | null
    prevjudgingid: number | null
    judge_completely: boolean
    errorid: number | null
    uuid: string
    metadata: Buffer | null
    _count: JudgingCountAggregateOutputType | null
    _avg: JudgingAvgAggregateOutputType | null
    _sum: JudgingSumAggregateOutputType | null
    _min: JudgingMinAggregateOutputType | null
    _max: JudgingMaxAggregateOutputType | null
  }

  type GetJudgingGroupByPayload<T extends judgingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JudgingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JudgingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JudgingGroupByOutputType[P]>
            : GetScalarType<T[P], JudgingGroupByOutputType[P]>
        }
      >
    >


  export type judgingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    judgingid?: boolean
    cid?: boolean
    submitid?: boolean
    starttime?: boolean
    endtime?: boolean
    result?: boolean
    verified?: boolean
    jury_member?: boolean
    verify_comment?: boolean
    valid?: boolean
    output_compile?: boolean
    seen?: boolean
    rejudgingid?: boolean
    prevjudgingid?: boolean
    judge_completely?: boolean
    errorid?: boolean
    uuid?: boolean
    metadata?: boolean
    debug_package?: boolean | judging$debug_packageArgs<ExtArgs>
    internal_error_internal_error_judgingidTojudging?: boolean | judging$internal_error_internal_error_judgingidTojudgingArgs<ExtArgs>
    internal_error_judging_erroridTointernal_error?: boolean | judging$internal_error_judging_erroridTointernal_errorArgs<ExtArgs>
    contest?: boolean | judging$contestArgs<ExtArgs>
    submission?: boolean | judging$submissionArgs<ExtArgs>
    rejudging?: boolean | judging$rejudgingArgs<ExtArgs>
    judging?: boolean | judging$judgingArgs<ExtArgs>
    other_judging?: boolean | judging$other_judgingArgs<ExtArgs>
    judging_run?: boolean | judging$judging_runArgs<ExtArgs>
    _count?: boolean | JudgingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["judging"]>

  export type judgingSelectScalar = {
    judgingid?: boolean
    cid?: boolean
    submitid?: boolean
    starttime?: boolean
    endtime?: boolean
    result?: boolean
    verified?: boolean
    jury_member?: boolean
    verify_comment?: boolean
    valid?: boolean
    output_compile?: boolean
    seen?: boolean
    rejudgingid?: boolean
    prevjudgingid?: boolean
    judge_completely?: boolean
    errorid?: boolean
    uuid?: boolean
    metadata?: boolean
  }

  export type judgingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debug_package?: boolean | judging$debug_packageArgs<ExtArgs>
    internal_error_internal_error_judgingidTojudging?: boolean | judging$internal_error_internal_error_judgingidTojudgingArgs<ExtArgs>
    internal_error_judging_erroridTointernal_error?: boolean | judging$internal_error_judging_erroridTointernal_errorArgs<ExtArgs>
    contest?: boolean | judging$contestArgs<ExtArgs>
    submission?: boolean | judging$submissionArgs<ExtArgs>
    rejudging?: boolean | judging$rejudgingArgs<ExtArgs>
    judging?: boolean | judging$judgingArgs<ExtArgs>
    other_judging?: boolean | judging$other_judgingArgs<ExtArgs>
    judging_run?: boolean | judging$judging_runArgs<ExtArgs>
    _count?: boolean | JudgingCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $judgingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "judging"
    objects: {
      debug_package: Prisma.$debug_packagePayload<ExtArgs>[]
      internal_error_internal_error_judgingidTojudging: Prisma.$internal_errorPayload<ExtArgs>[]
      internal_error_judging_erroridTointernal_error: Prisma.$internal_errorPayload<ExtArgs> | null
      contest: Prisma.$contestPayload<ExtArgs> | null
      submission: Prisma.$submissionPayload<ExtArgs> | null
      rejudging: Prisma.$rejudgingPayload<ExtArgs> | null
      judging: Prisma.$judgingPayload<ExtArgs> | null
      other_judging: Prisma.$judgingPayload<ExtArgs>[]
      judging_run: Prisma.$judging_runPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      judgingid: number
      cid: number | null
      submitid: number | null
      starttime: Prisma.Decimal | null
      endtime: Prisma.Decimal | null
      result: string | null
      verified: boolean
      jury_member: string | null
      verify_comment: string | null
      valid: boolean
      output_compile: Buffer | null
      seen: boolean
      rejudgingid: number | null
      prevjudgingid: number | null
      judge_completely: boolean
      errorid: number | null
      uuid: string
      metadata: Buffer | null
    }, ExtArgs["result"]["judging"]>
    composites: {}
  }


  type judgingGetPayload<S extends boolean | null | undefined | judgingDefaultArgs> = $Result.GetResult<Prisma.$judgingPayload, S>

  type judgingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<judgingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JudgingCountAggregateInputType | true
    }

  export interface judgingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['judging'], meta: { name: 'judging' } }
    /**
     * Find zero or one Judging that matches the filter.
     * @param {judgingFindUniqueArgs} args - Arguments to find a Judging
     * @example
     * // Get one Judging
     * const judging = await prisma.judging.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends judgingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, judgingFindUniqueArgs<ExtArgs>>
    ): Prisma__judgingClient<$Result.GetResult<Prisma.$judgingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Judging that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {judgingFindUniqueOrThrowArgs} args - Arguments to find a Judging
     * @example
     * // Get one Judging
     * const judging = await prisma.judging.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends judgingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, judgingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__judgingClient<$Result.GetResult<Prisma.$judgingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Judging that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judgingFindFirstArgs} args - Arguments to find a Judging
     * @example
     * // Get one Judging
     * const judging = await prisma.judging.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends judgingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, judgingFindFirstArgs<ExtArgs>>
    ): Prisma__judgingClient<$Result.GetResult<Prisma.$judgingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Judging that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judgingFindFirstOrThrowArgs} args - Arguments to find a Judging
     * @example
     * // Get one Judging
     * const judging = await prisma.judging.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends judgingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, judgingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__judgingClient<$Result.GetResult<Prisma.$judgingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Judgings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judgingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Judgings
     * const judgings = await prisma.judging.findMany()
     * 
     * // Get first 10 Judgings
     * const judgings = await prisma.judging.findMany({ take: 10 })
     * 
     * // Only select the `judgingid`
     * const judgingWithJudgingidOnly = await prisma.judging.findMany({ select: { judgingid: true } })
     * 
    **/
    findMany<T extends judgingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, judgingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$judgingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Judging.
     * @param {judgingCreateArgs} args - Arguments to create a Judging.
     * @example
     * // Create one Judging
     * const Judging = await prisma.judging.create({
     *   data: {
     *     // ... data to create a Judging
     *   }
     * })
     * 
    **/
    create<T extends judgingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, judgingCreateArgs<ExtArgs>>
    ): Prisma__judgingClient<$Result.GetResult<Prisma.$judgingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Judgings.
     *     @param {judgingCreateManyArgs} args - Arguments to create many Judgings.
     *     @example
     *     // Create many Judgings
     *     const judging = await prisma.judging.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends judgingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, judgingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Judging.
     * @param {judgingDeleteArgs} args - Arguments to delete one Judging.
     * @example
     * // Delete one Judging
     * const Judging = await prisma.judging.delete({
     *   where: {
     *     // ... filter to delete one Judging
     *   }
     * })
     * 
    **/
    delete<T extends judgingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, judgingDeleteArgs<ExtArgs>>
    ): Prisma__judgingClient<$Result.GetResult<Prisma.$judgingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Judging.
     * @param {judgingUpdateArgs} args - Arguments to update one Judging.
     * @example
     * // Update one Judging
     * const judging = await prisma.judging.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends judgingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, judgingUpdateArgs<ExtArgs>>
    ): Prisma__judgingClient<$Result.GetResult<Prisma.$judgingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Judgings.
     * @param {judgingDeleteManyArgs} args - Arguments to filter Judgings to delete.
     * @example
     * // Delete a few Judgings
     * const { count } = await prisma.judging.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends judgingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, judgingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Judgings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judgingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Judgings
     * const judging = await prisma.judging.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends judgingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, judgingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Judging.
     * @param {judgingUpsertArgs} args - Arguments to update or create a Judging.
     * @example
     * // Update or create a Judging
     * const judging = await prisma.judging.upsert({
     *   create: {
     *     // ... data to create a Judging
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Judging we want to update
     *   }
     * })
    **/
    upsert<T extends judgingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, judgingUpsertArgs<ExtArgs>>
    ): Prisma__judgingClient<$Result.GetResult<Prisma.$judgingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Judgings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judgingCountArgs} args - Arguments to filter Judgings to count.
     * @example
     * // Count the number of Judgings
     * const count = await prisma.judging.count({
     *   where: {
     *     // ... the filter for the Judgings we want to count
     *   }
     * })
    **/
    count<T extends judgingCountArgs>(
      args?: Subset<T, judgingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JudgingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Judging.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JudgingAggregateArgs>(args: Subset<T, JudgingAggregateArgs>): Prisma.PrismaPromise<GetJudgingAggregateType<T>>

    /**
     * Group by Judging.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judgingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends judgingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: judgingGroupByArgs['orderBy'] }
        : { orderBy?: judgingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, judgingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJudgingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the judging model
   */
  readonly fields: judgingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for judging.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__judgingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    debug_package<T extends judging$debug_packageArgs<ExtArgs> = {}>(args?: Subset<T, judging$debug_packageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$debug_packagePayload<ExtArgs>, T, 'findMany'> | Null>;

    internal_error_internal_error_judgingidTojudging<T extends judging$internal_error_internal_error_judgingidTojudgingArgs<ExtArgs> = {}>(args?: Subset<T, judging$internal_error_internal_error_judgingidTojudgingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$internal_errorPayload<ExtArgs>, T, 'findMany'> | Null>;

    internal_error_judging_erroridTointernal_error<T extends judging$internal_error_judging_erroridTointernal_errorArgs<ExtArgs> = {}>(args?: Subset<T, judging$internal_error_judging_erroridTointernal_errorArgs<ExtArgs>>): Prisma__internal_errorClient<$Result.GetResult<Prisma.$internal_errorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    contest<T extends judging$contestArgs<ExtArgs> = {}>(args?: Subset<T, judging$contestArgs<ExtArgs>>): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    submission<T extends judging$submissionArgs<ExtArgs> = {}>(args?: Subset<T, judging$submissionArgs<ExtArgs>>): Prisma__submissionClient<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    rejudging<T extends judging$rejudgingArgs<ExtArgs> = {}>(args?: Subset<T, judging$rejudgingArgs<ExtArgs>>): Prisma__rejudgingClient<$Result.GetResult<Prisma.$rejudgingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    judging<T extends judging$judgingArgs<ExtArgs> = {}>(args?: Subset<T, judging$judgingArgs<ExtArgs>>): Prisma__judgingClient<$Result.GetResult<Prisma.$judgingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    other_judging<T extends judging$other_judgingArgs<ExtArgs> = {}>(args?: Subset<T, judging$other_judgingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$judgingPayload<ExtArgs>, T, 'findMany'> | Null>;

    judging_run<T extends judging$judging_runArgs<ExtArgs> = {}>(args?: Subset<T, judging$judging_runArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$judging_runPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the judging model
   */ 
  interface judgingFieldRefs {
    readonly judgingid: FieldRef<"judging", 'Int'>
    readonly cid: FieldRef<"judging", 'Int'>
    readonly submitid: FieldRef<"judging", 'Int'>
    readonly starttime: FieldRef<"judging", 'Decimal'>
    readonly endtime: FieldRef<"judging", 'Decimal'>
    readonly result: FieldRef<"judging", 'String'>
    readonly verified: FieldRef<"judging", 'Boolean'>
    readonly jury_member: FieldRef<"judging", 'String'>
    readonly verify_comment: FieldRef<"judging", 'String'>
    readonly valid: FieldRef<"judging", 'Boolean'>
    readonly output_compile: FieldRef<"judging", 'Bytes'>
    readonly seen: FieldRef<"judging", 'Boolean'>
    readonly rejudgingid: FieldRef<"judging", 'Int'>
    readonly prevjudgingid: FieldRef<"judging", 'Int'>
    readonly judge_completely: FieldRef<"judging", 'Boolean'>
    readonly errorid: FieldRef<"judging", 'Int'>
    readonly uuid: FieldRef<"judging", 'String'>
    readonly metadata: FieldRef<"judging", 'Bytes'>
  }
    

  // Custom InputTypes

  /**
   * judging findUnique
   */
  export type judgingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging
     */
    select?: judgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgingInclude<ExtArgs> | null
    /**
     * Filter, which judging to fetch.
     */
    where: judgingWhereUniqueInput
  }


  /**
   * judging findUniqueOrThrow
   */
  export type judgingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging
     */
    select?: judgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgingInclude<ExtArgs> | null
    /**
     * Filter, which judging to fetch.
     */
    where: judgingWhereUniqueInput
  }


  /**
   * judging findFirst
   */
  export type judgingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging
     */
    select?: judgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgingInclude<ExtArgs> | null
    /**
     * Filter, which judging to fetch.
     */
    where?: judgingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of judgings to fetch.
     */
    orderBy?: judgingOrderByWithRelationInput | judgingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for judgings.
     */
    cursor?: judgingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` judgings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` judgings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of judgings.
     */
    distinct?: JudgingScalarFieldEnum | JudgingScalarFieldEnum[]
  }


  /**
   * judging findFirstOrThrow
   */
  export type judgingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging
     */
    select?: judgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgingInclude<ExtArgs> | null
    /**
     * Filter, which judging to fetch.
     */
    where?: judgingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of judgings to fetch.
     */
    orderBy?: judgingOrderByWithRelationInput | judgingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for judgings.
     */
    cursor?: judgingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` judgings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` judgings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of judgings.
     */
    distinct?: JudgingScalarFieldEnum | JudgingScalarFieldEnum[]
  }


  /**
   * judging findMany
   */
  export type judgingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging
     */
    select?: judgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgingInclude<ExtArgs> | null
    /**
     * Filter, which judgings to fetch.
     */
    where?: judgingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of judgings to fetch.
     */
    orderBy?: judgingOrderByWithRelationInput | judgingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing judgings.
     */
    cursor?: judgingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` judgings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` judgings.
     */
    skip?: number
    distinct?: JudgingScalarFieldEnum | JudgingScalarFieldEnum[]
  }


  /**
   * judging create
   */
  export type judgingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging
     */
    select?: judgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgingInclude<ExtArgs> | null
    /**
     * The data needed to create a judging.
     */
    data: XOR<judgingCreateInput, judgingUncheckedCreateInput>
  }


  /**
   * judging createMany
   */
  export type judgingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many judgings.
     */
    data: judgingCreateManyInput | judgingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * judging update
   */
  export type judgingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging
     */
    select?: judgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgingInclude<ExtArgs> | null
    /**
     * The data needed to update a judging.
     */
    data: XOR<judgingUpdateInput, judgingUncheckedUpdateInput>
    /**
     * Choose, which judging to update.
     */
    where: judgingWhereUniqueInput
  }


  /**
   * judging updateMany
   */
  export type judgingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update judgings.
     */
    data: XOR<judgingUpdateManyMutationInput, judgingUncheckedUpdateManyInput>
    /**
     * Filter which judgings to update
     */
    where?: judgingWhereInput
  }


  /**
   * judging upsert
   */
  export type judgingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging
     */
    select?: judgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgingInclude<ExtArgs> | null
    /**
     * The filter to search for the judging to update in case it exists.
     */
    where: judgingWhereUniqueInput
    /**
     * In case the judging found by the `where` argument doesn't exist, create a new judging with this data.
     */
    create: XOR<judgingCreateInput, judgingUncheckedCreateInput>
    /**
     * In case the judging was found with the provided `where` argument, update it with this data.
     */
    update: XOR<judgingUpdateInput, judgingUncheckedUpdateInput>
  }


  /**
   * judging delete
   */
  export type judgingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging
     */
    select?: judgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgingInclude<ExtArgs> | null
    /**
     * Filter which judging to delete.
     */
    where: judgingWhereUniqueInput
  }


  /**
   * judging deleteMany
   */
  export type judgingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which judgings to delete
     */
    where?: judgingWhereInput
  }


  /**
   * judging.debug_package
   */
  export type judging$debug_packageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the debug_package
     */
    select?: debug_packageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: debug_packageInclude<ExtArgs> | null
    where?: debug_packageWhereInput
    orderBy?: debug_packageOrderByWithRelationInput | debug_packageOrderByWithRelationInput[]
    cursor?: debug_packageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Debug_packageScalarFieldEnum | Debug_packageScalarFieldEnum[]
  }


  /**
   * judging.internal_error_internal_error_judgingidTojudging
   */
  export type judging$internal_error_internal_error_judgingidTojudgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal_error
     */
    select?: internal_errorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: internal_errorInclude<ExtArgs> | null
    where?: internal_errorWhereInput
    orderBy?: internal_errorOrderByWithRelationInput | internal_errorOrderByWithRelationInput[]
    cursor?: internal_errorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Internal_errorScalarFieldEnum | Internal_errorScalarFieldEnum[]
  }


  /**
   * judging.internal_error_judging_erroridTointernal_error
   */
  export type judging$internal_error_judging_erroridTointernal_errorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal_error
     */
    select?: internal_errorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: internal_errorInclude<ExtArgs> | null
    where?: internal_errorWhereInput
  }


  /**
   * judging.contest
   */
  export type judging$contestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contest
     */
    select?: contestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestInclude<ExtArgs> | null
    where?: contestWhereInput
  }


  /**
   * judging.submission
   */
  export type judging$submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    where?: submissionWhereInput
  }


  /**
   * judging.rejudging
   */
  export type judging$rejudgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejudging
     */
    select?: rejudgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rejudgingInclude<ExtArgs> | null
    where?: rejudgingWhereInput
  }


  /**
   * judging.judging
   */
  export type judging$judgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging
     */
    select?: judgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgingInclude<ExtArgs> | null
    where?: judgingWhereInput
  }


  /**
   * judging.other_judging
   */
  export type judging$other_judgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging
     */
    select?: judgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgingInclude<ExtArgs> | null
    where?: judgingWhereInput
    orderBy?: judgingOrderByWithRelationInput | judgingOrderByWithRelationInput[]
    cursor?: judgingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JudgingScalarFieldEnum | JudgingScalarFieldEnum[]
  }


  /**
   * judging.judging_run
   */
  export type judging$judging_runArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run
     */
    select?: judging_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_runInclude<ExtArgs> | null
    where?: judging_runWhereInput
    orderBy?: judging_runOrderByWithRelationInput | judging_runOrderByWithRelationInput[]
    cursor?: judging_runWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Judging_runScalarFieldEnum | Judging_runScalarFieldEnum[]
  }


  /**
   * judging without action
   */
  export type judgingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging
     */
    select?: judgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgingInclude<ExtArgs> | null
  }



  /**
   * Model judging_run
   */

  export type AggregateJudging_run = {
    _count: Judging_runCountAggregateOutputType | null
    _avg: Judging_runAvgAggregateOutputType | null
    _sum: Judging_runSumAggregateOutputType | null
    _min: Judging_runMinAggregateOutputType | null
    _max: Judging_runMaxAggregateOutputType | null
  }

  export type Judging_runAvgAggregateOutputType = {
    runid: number | null
    judgingid: number | null
    testcaseid: number | null
    runtime: number | null
    endtime: Decimal | null
    judgetaskid: number | null
  }

  export type Judging_runSumAggregateOutputType = {
    runid: number | null
    judgingid: number | null
    testcaseid: number | null
    runtime: number | null
    endtime: Decimal | null
    judgetaskid: number | null
  }

  export type Judging_runMinAggregateOutputType = {
    runid: number | null
    judgingid: number | null
    testcaseid: number | null
    runresult: string | null
    runtime: number | null
    endtime: Decimal | null
    judgetaskid: number | null
  }

  export type Judging_runMaxAggregateOutputType = {
    runid: number | null
    judgingid: number | null
    testcaseid: number | null
    runresult: string | null
    runtime: number | null
    endtime: Decimal | null
    judgetaskid: number | null
  }

  export type Judging_runCountAggregateOutputType = {
    runid: number
    judgingid: number
    testcaseid: number
    runresult: number
    runtime: number
    endtime: number
    judgetaskid: number
    _all: number
  }


  export type Judging_runAvgAggregateInputType = {
    runid?: true
    judgingid?: true
    testcaseid?: true
    runtime?: true
    endtime?: true
    judgetaskid?: true
  }

  export type Judging_runSumAggregateInputType = {
    runid?: true
    judgingid?: true
    testcaseid?: true
    runtime?: true
    endtime?: true
    judgetaskid?: true
  }

  export type Judging_runMinAggregateInputType = {
    runid?: true
    judgingid?: true
    testcaseid?: true
    runresult?: true
    runtime?: true
    endtime?: true
    judgetaskid?: true
  }

  export type Judging_runMaxAggregateInputType = {
    runid?: true
    judgingid?: true
    testcaseid?: true
    runresult?: true
    runtime?: true
    endtime?: true
    judgetaskid?: true
  }

  export type Judging_runCountAggregateInputType = {
    runid?: true
    judgingid?: true
    testcaseid?: true
    runresult?: true
    runtime?: true
    endtime?: true
    judgetaskid?: true
    _all?: true
  }

  export type Judging_runAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which judging_run to aggregate.
     */
    where?: judging_runWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of judging_runs to fetch.
     */
    orderBy?: judging_runOrderByWithRelationInput | judging_runOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: judging_runWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` judging_runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` judging_runs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned judging_runs
    **/
    _count?: true | Judging_runCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Judging_runAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Judging_runSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Judging_runMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Judging_runMaxAggregateInputType
  }

  export type GetJudging_runAggregateType<T extends Judging_runAggregateArgs> = {
        [P in keyof T & keyof AggregateJudging_run]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJudging_run[P]>
      : GetScalarType<T[P], AggregateJudging_run[P]>
  }




  export type judging_runGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: judging_runWhereInput
    orderBy?: judging_runOrderByWithAggregationInput | judging_runOrderByWithAggregationInput[]
    by: Judging_runScalarFieldEnum[] | Judging_runScalarFieldEnum
    having?: judging_runScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Judging_runCountAggregateInputType | true
    _avg?: Judging_runAvgAggregateInputType
    _sum?: Judging_runSumAggregateInputType
    _min?: Judging_runMinAggregateInputType
    _max?: Judging_runMaxAggregateInputType
  }

  export type Judging_runGroupByOutputType = {
    runid: number
    judgingid: number | null
    testcaseid: number | null
    runresult: string | null
    runtime: number | null
    endtime: Decimal | null
    judgetaskid: number | null
    _count: Judging_runCountAggregateOutputType | null
    _avg: Judging_runAvgAggregateOutputType | null
    _sum: Judging_runSumAggregateOutputType | null
    _min: Judging_runMinAggregateOutputType | null
    _max: Judging_runMaxAggregateOutputType | null
  }

  type GetJudging_runGroupByPayload<T extends judging_runGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Judging_runGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Judging_runGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Judging_runGroupByOutputType[P]>
            : GetScalarType<T[P], Judging_runGroupByOutputType[P]>
        }
      >
    >


  export type judging_runSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    runid?: boolean
    judgingid?: boolean
    testcaseid?: boolean
    runresult?: boolean
    runtime?: boolean
    endtime?: boolean
    judgetaskid?: boolean
    judgetask?: boolean | judging_run$judgetaskArgs<ExtArgs>
    testcase?: boolean | judging_run$testcaseArgs<ExtArgs>
    judging?: boolean | judging_run$judgingArgs<ExtArgs>
    judging_run_output?: boolean | judging_run$judging_run_outputArgs<ExtArgs>
  }, ExtArgs["result"]["judging_run"]>

  export type judging_runSelectScalar = {
    runid?: boolean
    judgingid?: boolean
    testcaseid?: boolean
    runresult?: boolean
    runtime?: boolean
    endtime?: boolean
    judgetaskid?: boolean
  }

  export type judging_runInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    judgetask?: boolean | judging_run$judgetaskArgs<ExtArgs>
    testcase?: boolean | judging_run$testcaseArgs<ExtArgs>
    judging?: boolean | judging_run$judgingArgs<ExtArgs>
    judging_run_output?: boolean | judging_run$judging_run_outputArgs<ExtArgs>
  }


  export type $judging_runPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "judging_run"
    objects: {
      judgetask: Prisma.$judgetaskPayload<ExtArgs> | null
      testcase: Prisma.$testcasePayload<ExtArgs> | null
      judging: Prisma.$judgingPayload<ExtArgs> | null
      judging_run_output: Prisma.$judging_run_outputPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      runid: number
      judgingid: number | null
      testcaseid: number | null
      runresult: string | null
      runtime: number | null
      endtime: Prisma.Decimal | null
      judgetaskid: number | null
    }, ExtArgs["result"]["judging_run"]>
    composites: {}
  }


  type judging_runGetPayload<S extends boolean | null | undefined | judging_runDefaultArgs> = $Result.GetResult<Prisma.$judging_runPayload, S>

  type judging_runCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<judging_runFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Judging_runCountAggregateInputType | true
    }

  export interface judging_runDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['judging_run'], meta: { name: 'judging_run' } }
    /**
     * Find zero or one Judging_run that matches the filter.
     * @param {judging_runFindUniqueArgs} args - Arguments to find a Judging_run
     * @example
     * // Get one Judging_run
     * const judging_run = await prisma.judging_run.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends judging_runFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, judging_runFindUniqueArgs<ExtArgs>>
    ): Prisma__judging_runClient<$Result.GetResult<Prisma.$judging_runPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Judging_run that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {judging_runFindUniqueOrThrowArgs} args - Arguments to find a Judging_run
     * @example
     * // Get one Judging_run
     * const judging_run = await prisma.judging_run.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends judging_runFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, judging_runFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__judging_runClient<$Result.GetResult<Prisma.$judging_runPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Judging_run that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judging_runFindFirstArgs} args - Arguments to find a Judging_run
     * @example
     * // Get one Judging_run
     * const judging_run = await prisma.judging_run.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends judging_runFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, judging_runFindFirstArgs<ExtArgs>>
    ): Prisma__judging_runClient<$Result.GetResult<Prisma.$judging_runPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Judging_run that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judging_runFindFirstOrThrowArgs} args - Arguments to find a Judging_run
     * @example
     * // Get one Judging_run
     * const judging_run = await prisma.judging_run.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends judging_runFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, judging_runFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__judging_runClient<$Result.GetResult<Prisma.$judging_runPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Judging_runs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judging_runFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Judging_runs
     * const judging_runs = await prisma.judging_run.findMany()
     * 
     * // Get first 10 Judging_runs
     * const judging_runs = await prisma.judging_run.findMany({ take: 10 })
     * 
     * // Only select the `runid`
     * const judging_runWithRunidOnly = await prisma.judging_run.findMany({ select: { runid: true } })
     * 
    **/
    findMany<T extends judging_runFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, judging_runFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$judging_runPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Judging_run.
     * @param {judging_runCreateArgs} args - Arguments to create a Judging_run.
     * @example
     * // Create one Judging_run
     * const Judging_run = await prisma.judging_run.create({
     *   data: {
     *     // ... data to create a Judging_run
     *   }
     * })
     * 
    **/
    create<T extends judging_runCreateArgs<ExtArgs>>(
      args: SelectSubset<T, judging_runCreateArgs<ExtArgs>>
    ): Prisma__judging_runClient<$Result.GetResult<Prisma.$judging_runPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Judging_runs.
     *     @param {judging_runCreateManyArgs} args - Arguments to create many Judging_runs.
     *     @example
     *     // Create many Judging_runs
     *     const judging_run = await prisma.judging_run.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends judging_runCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, judging_runCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Judging_run.
     * @param {judging_runDeleteArgs} args - Arguments to delete one Judging_run.
     * @example
     * // Delete one Judging_run
     * const Judging_run = await prisma.judging_run.delete({
     *   where: {
     *     // ... filter to delete one Judging_run
     *   }
     * })
     * 
    **/
    delete<T extends judging_runDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, judging_runDeleteArgs<ExtArgs>>
    ): Prisma__judging_runClient<$Result.GetResult<Prisma.$judging_runPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Judging_run.
     * @param {judging_runUpdateArgs} args - Arguments to update one Judging_run.
     * @example
     * // Update one Judging_run
     * const judging_run = await prisma.judging_run.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends judging_runUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, judging_runUpdateArgs<ExtArgs>>
    ): Prisma__judging_runClient<$Result.GetResult<Prisma.$judging_runPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Judging_runs.
     * @param {judging_runDeleteManyArgs} args - Arguments to filter Judging_runs to delete.
     * @example
     * // Delete a few Judging_runs
     * const { count } = await prisma.judging_run.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends judging_runDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, judging_runDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Judging_runs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judging_runUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Judging_runs
     * const judging_run = await prisma.judging_run.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends judging_runUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, judging_runUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Judging_run.
     * @param {judging_runUpsertArgs} args - Arguments to update or create a Judging_run.
     * @example
     * // Update or create a Judging_run
     * const judging_run = await prisma.judging_run.upsert({
     *   create: {
     *     // ... data to create a Judging_run
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Judging_run we want to update
     *   }
     * })
    **/
    upsert<T extends judging_runUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, judging_runUpsertArgs<ExtArgs>>
    ): Prisma__judging_runClient<$Result.GetResult<Prisma.$judging_runPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Judging_runs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judging_runCountArgs} args - Arguments to filter Judging_runs to count.
     * @example
     * // Count the number of Judging_runs
     * const count = await prisma.judging_run.count({
     *   where: {
     *     // ... the filter for the Judging_runs we want to count
     *   }
     * })
    **/
    count<T extends judging_runCountArgs>(
      args?: Subset<T, judging_runCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Judging_runCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Judging_run.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Judging_runAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Judging_runAggregateArgs>(args: Subset<T, Judging_runAggregateArgs>): Prisma.PrismaPromise<GetJudging_runAggregateType<T>>

    /**
     * Group by Judging_run.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judging_runGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends judging_runGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: judging_runGroupByArgs['orderBy'] }
        : { orderBy?: judging_runGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, judging_runGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJudging_runGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the judging_run model
   */
  readonly fields: judging_runFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for judging_run.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__judging_runClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    judgetask<T extends judging_run$judgetaskArgs<ExtArgs> = {}>(args?: Subset<T, judging_run$judgetaskArgs<ExtArgs>>): Prisma__judgetaskClient<$Result.GetResult<Prisma.$judgetaskPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    testcase<T extends judging_run$testcaseArgs<ExtArgs> = {}>(args?: Subset<T, judging_run$testcaseArgs<ExtArgs>>): Prisma__testcaseClient<$Result.GetResult<Prisma.$testcasePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    judging<T extends judging_run$judgingArgs<ExtArgs> = {}>(args?: Subset<T, judging_run$judgingArgs<ExtArgs>>): Prisma__judgingClient<$Result.GetResult<Prisma.$judgingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    judging_run_output<T extends judging_run$judging_run_outputArgs<ExtArgs> = {}>(args?: Subset<T, judging_run$judging_run_outputArgs<ExtArgs>>): Prisma__judging_run_outputClient<$Result.GetResult<Prisma.$judging_run_outputPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the judging_run model
   */ 
  interface judging_runFieldRefs {
    readonly runid: FieldRef<"judging_run", 'Int'>
    readonly judgingid: FieldRef<"judging_run", 'Int'>
    readonly testcaseid: FieldRef<"judging_run", 'Int'>
    readonly runresult: FieldRef<"judging_run", 'String'>
    readonly runtime: FieldRef<"judging_run", 'Float'>
    readonly endtime: FieldRef<"judging_run", 'Decimal'>
    readonly judgetaskid: FieldRef<"judging_run", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * judging_run findUnique
   */
  export type judging_runFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run
     */
    select?: judging_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_runInclude<ExtArgs> | null
    /**
     * Filter, which judging_run to fetch.
     */
    where: judging_runWhereUniqueInput
  }


  /**
   * judging_run findUniqueOrThrow
   */
  export type judging_runFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run
     */
    select?: judging_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_runInclude<ExtArgs> | null
    /**
     * Filter, which judging_run to fetch.
     */
    where: judging_runWhereUniqueInput
  }


  /**
   * judging_run findFirst
   */
  export type judging_runFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run
     */
    select?: judging_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_runInclude<ExtArgs> | null
    /**
     * Filter, which judging_run to fetch.
     */
    where?: judging_runWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of judging_runs to fetch.
     */
    orderBy?: judging_runOrderByWithRelationInput | judging_runOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for judging_runs.
     */
    cursor?: judging_runWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` judging_runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` judging_runs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of judging_runs.
     */
    distinct?: Judging_runScalarFieldEnum | Judging_runScalarFieldEnum[]
  }


  /**
   * judging_run findFirstOrThrow
   */
  export type judging_runFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run
     */
    select?: judging_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_runInclude<ExtArgs> | null
    /**
     * Filter, which judging_run to fetch.
     */
    where?: judging_runWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of judging_runs to fetch.
     */
    orderBy?: judging_runOrderByWithRelationInput | judging_runOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for judging_runs.
     */
    cursor?: judging_runWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` judging_runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` judging_runs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of judging_runs.
     */
    distinct?: Judging_runScalarFieldEnum | Judging_runScalarFieldEnum[]
  }


  /**
   * judging_run findMany
   */
  export type judging_runFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run
     */
    select?: judging_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_runInclude<ExtArgs> | null
    /**
     * Filter, which judging_runs to fetch.
     */
    where?: judging_runWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of judging_runs to fetch.
     */
    orderBy?: judging_runOrderByWithRelationInput | judging_runOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing judging_runs.
     */
    cursor?: judging_runWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` judging_runs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` judging_runs.
     */
    skip?: number
    distinct?: Judging_runScalarFieldEnum | Judging_runScalarFieldEnum[]
  }


  /**
   * judging_run create
   */
  export type judging_runCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run
     */
    select?: judging_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_runInclude<ExtArgs> | null
    /**
     * The data needed to create a judging_run.
     */
    data?: XOR<judging_runCreateInput, judging_runUncheckedCreateInput>
  }


  /**
   * judging_run createMany
   */
  export type judging_runCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many judging_runs.
     */
    data: judging_runCreateManyInput | judging_runCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * judging_run update
   */
  export type judging_runUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run
     */
    select?: judging_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_runInclude<ExtArgs> | null
    /**
     * The data needed to update a judging_run.
     */
    data: XOR<judging_runUpdateInput, judging_runUncheckedUpdateInput>
    /**
     * Choose, which judging_run to update.
     */
    where: judging_runWhereUniqueInput
  }


  /**
   * judging_run updateMany
   */
  export type judging_runUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update judging_runs.
     */
    data: XOR<judging_runUpdateManyMutationInput, judging_runUncheckedUpdateManyInput>
    /**
     * Filter which judging_runs to update
     */
    where?: judging_runWhereInput
  }


  /**
   * judging_run upsert
   */
  export type judging_runUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run
     */
    select?: judging_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_runInclude<ExtArgs> | null
    /**
     * The filter to search for the judging_run to update in case it exists.
     */
    where: judging_runWhereUniqueInput
    /**
     * In case the judging_run found by the `where` argument doesn't exist, create a new judging_run with this data.
     */
    create: XOR<judging_runCreateInput, judging_runUncheckedCreateInput>
    /**
     * In case the judging_run was found with the provided `where` argument, update it with this data.
     */
    update: XOR<judging_runUpdateInput, judging_runUncheckedUpdateInput>
  }


  /**
   * judging_run delete
   */
  export type judging_runDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run
     */
    select?: judging_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_runInclude<ExtArgs> | null
    /**
     * Filter which judging_run to delete.
     */
    where: judging_runWhereUniqueInput
  }


  /**
   * judging_run deleteMany
   */
  export type judging_runDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which judging_runs to delete
     */
    where?: judging_runWhereInput
  }


  /**
   * judging_run.judgetask
   */
  export type judging_run$judgetaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judgetask
     */
    select?: judgetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgetaskInclude<ExtArgs> | null
    where?: judgetaskWhereInput
  }


  /**
   * judging_run.testcase
   */
  export type judging_run$testcaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase
     */
    select?: testcaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcaseInclude<ExtArgs> | null
    where?: testcaseWhereInput
  }


  /**
   * judging_run.judging
   */
  export type judging_run$judgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging
     */
    select?: judgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgingInclude<ExtArgs> | null
    where?: judgingWhereInput
  }


  /**
   * judging_run.judging_run_output
   */
  export type judging_run$judging_run_outputArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run_output
     */
    select?: judging_run_outputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_run_outputInclude<ExtArgs> | null
    where?: judging_run_outputWhereInput
  }


  /**
   * judging_run without action
   */
  export type judging_runDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run
     */
    select?: judging_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_runInclude<ExtArgs> | null
  }



  /**
   * Model judging_run_output
   */

  export type AggregateJudging_run_output = {
    _count: Judging_run_outputCountAggregateOutputType | null
    _avg: Judging_run_outputAvgAggregateOutputType | null
    _sum: Judging_run_outputSumAggregateOutputType | null
    _min: Judging_run_outputMinAggregateOutputType | null
    _max: Judging_run_outputMaxAggregateOutputType | null
  }

  export type Judging_run_outputAvgAggregateOutputType = {
    runid: number | null
  }

  export type Judging_run_outputSumAggregateOutputType = {
    runid: number | null
  }

  export type Judging_run_outputMinAggregateOutputType = {
    runid: number | null
    output_run: Buffer | null
    output_diff: Buffer | null
    output_error: Buffer | null
    output_system: Buffer | null
    metadata: Buffer | null
  }

  export type Judging_run_outputMaxAggregateOutputType = {
    runid: number | null
    output_run: Buffer | null
    output_diff: Buffer | null
    output_error: Buffer | null
    output_system: Buffer | null
    metadata: Buffer | null
  }

  export type Judging_run_outputCountAggregateOutputType = {
    runid: number
    output_run: number
    output_diff: number
    output_error: number
    output_system: number
    metadata: number
    _all: number
  }


  export type Judging_run_outputAvgAggregateInputType = {
    runid?: true
  }

  export type Judging_run_outputSumAggregateInputType = {
    runid?: true
  }

  export type Judging_run_outputMinAggregateInputType = {
    runid?: true
    output_run?: true
    output_diff?: true
    output_error?: true
    output_system?: true
    metadata?: true
  }

  export type Judging_run_outputMaxAggregateInputType = {
    runid?: true
    output_run?: true
    output_diff?: true
    output_error?: true
    output_system?: true
    metadata?: true
  }

  export type Judging_run_outputCountAggregateInputType = {
    runid?: true
    output_run?: true
    output_diff?: true
    output_error?: true
    output_system?: true
    metadata?: true
    _all?: true
  }

  export type Judging_run_outputAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which judging_run_output to aggregate.
     */
    where?: judging_run_outputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of judging_run_outputs to fetch.
     */
    orderBy?: judging_run_outputOrderByWithRelationInput | judging_run_outputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: judging_run_outputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` judging_run_outputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` judging_run_outputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned judging_run_outputs
    **/
    _count?: true | Judging_run_outputCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Judging_run_outputAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Judging_run_outputSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Judging_run_outputMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Judging_run_outputMaxAggregateInputType
  }

  export type GetJudging_run_outputAggregateType<T extends Judging_run_outputAggregateArgs> = {
        [P in keyof T & keyof AggregateJudging_run_output]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJudging_run_output[P]>
      : GetScalarType<T[P], AggregateJudging_run_output[P]>
  }




  export type judging_run_outputGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: judging_run_outputWhereInput
    orderBy?: judging_run_outputOrderByWithAggregationInput | judging_run_outputOrderByWithAggregationInput[]
    by: Judging_run_outputScalarFieldEnum[] | Judging_run_outputScalarFieldEnum
    having?: judging_run_outputScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Judging_run_outputCountAggregateInputType | true
    _avg?: Judging_run_outputAvgAggregateInputType
    _sum?: Judging_run_outputSumAggregateInputType
    _min?: Judging_run_outputMinAggregateInputType
    _max?: Judging_run_outputMaxAggregateInputType
  }

  export type Judging_run_outputGroupByOutputType = {
    runid: number
    output_run: Buffer | null
    output_diff: Buffer | null
    output_error: Buffer | null
    output_system: Buffer | null
    metadata: Buffer | null
    _count: Judging_run_outputCountAggregateOutputType | null
    _avg: Judging_run_outputAvgAggregateOutputType | null
    _sum: Judging_run_outputSumAggregateOutputType | null
    _min: Judging_run_outputMinAggregateOutputType | null
    _max: Judging_run_outputMaxAggregateOutputType | null
  }

  type GetJudging_run_outputGroupByPayload<T extends judging_run_outputGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Judging_run_outputGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Judging_run_outputGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Judging_run_outputGroupByOutputType[P]>
            : GetScalarType<T[P], Judging_run_outputGroupByOutputType[P]>
        }
      >
    >


  export type judging_run_outputSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    runid?: boolean
    output_run?: boolean
    output_diff?: boolean
    output_error?: boolean
    output_system?: boolean
    metadata?: boolean
    judging_run?: boolean | judging_runDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["judging_run_output"]>

  export type judging_run_outputSelectScalar = {
    runid?: boolean
    output_run?: boolean
    output_diff?: boolean
    output_error?: boolean
    output_system?: boolean
    metadata?: boolean
  }

  export type judging_run_outputInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    judging_run?: boolean | judging_runDefaultArgs<ExtArgs>
  }


  export type $judging_run_outputPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "judging_run_output"
    objects: {
      judging_run: Prisma.$judging_runPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      runid: number
      output_run: Buffer | null
      output_diff: Buffer | null
      output_error: Buffer | null
      output_system: Buffer | null
      metadata: Buffer | null
    }, ExtArgs["result"]["judging_run_output"]>
    composites: {}
  }


  type judging_run_outputGetPayload<S extends boolean | null | undefined | judging_run_outputDefaultArgs> = $Result.GetResult<Prisma.$judging_run_outputPayload, S>

  type judging_run_outputCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<judging_run_outputFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Judging_run_outputCountAggregateInputType | true
    }

  export interface judging_run_outputDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['judging_run_output'], meta: { name: 'judging_run_output' } }
    /**
     * Find zero or one Judging_run_output that matches the filter.
     * @param {judging_run_outputFindUniqueArgs} args - Arguments to find a Judging_run_output
     * @example
     * // Get one Judging_run_output
     * const judging_run_output = await prisma.judging_run_output.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends judging_run_outputFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, judging_run_outputFindUniqueArgs<ExtArgs>>
    ): Prisma__judging_run_outputClient<$Result.GetResult<Prisma.$judging_run_outputPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Judging_run_output that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {judging_run_outputFindUniqueOrThrowArgs} args - Arguments to find a Judging_run_output
     * @example
     * // Get one Judging_run_output
     * const judging_run_output = await prisma.judging_run_output.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends judging_run_outputFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, judging_run_outputFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__judging_run_outputClient<$Result.GetResult<Prisma.$judging_run_outputPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Judging_run_output that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judging_run_outputFindFirstArgs} args - Arguments to find a Judging_run_output
     * @example
     * // Get one Judging_run_output
     * const judging_run_output = await prisma.judging_run_output.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends judging_run_outputFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, judging_run_outputFindFirstArgs<ExtArgs>>
    ): Prisma__judging_run_outputClient<$Result.GetResult<Prisma.$judging_run_outputPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Judging_run_output that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judging_run_outputFindFirstOrThrowArgs} args - Arguments to find a Judging_run_output
     * @example
     * // Get one Judging_run_output
     * const judging_run_output = await prisma.judging_run_output.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends judging_run_outputFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, judging_run_outputFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__judging_run_outputClient<$Result.GetResult<Prisma.$judging_run_outputPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Judging_run_outputs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judging_run_outputFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Judging_run_outputs
     * const judging_run_outputs = await prisma.judging_run_output.findMany()
     * 
     * // Get first 10 Judging_run_outputs
     * const judging_run_outputs = await prisma.judging_run_output.findMany({ take: 10 })
     * 
     * // Only select the `runid`
     * const judging_run_outputWithRunidOnly = await prisma.judging_run_output.findMany({ select: { runid: true } })
     * 
    **/
    findMany<T extends judging_run_outputFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, judging_run_outputFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$judging_run_outputPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Judging_run_output.
     * @param {judging_run_outputCreateArgs} args - Arguments to create a Judging_run_output.
     * @example
     * // Create one Judging_run_output
     * const Judging_run_output = await prisma.judging_run_output.create({
     *   data: {
     *     // ... data to create a Judging_run_output
     *   }
     * })
     * 
    **/
    create<T extends judging_run_outputCreateArgs<ExtArgs>>(
      args: SelectSubset<T, judging_run_outputCreateArgs<ExtArgs>>
    ): Prisma__judging_run_outputClient<$Result.GetResult<Prisma.$judging_run_outputPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Judging_run_outputs.
     *     @param {judging_run_outputCreateManyArgs} args - Arguments to create many Judging_run_outputs.
     *     @example
     *     // Create many Judging_run_outputs
     *     const judging_run_output = await prisma.judging_run_output.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends judging_run_outputCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, judging_run_outputCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Judging_run_output.
     * @param {judging_run_outputDeleteArgs} args - Arguments to delete one Judging_run_output.
     * @example
     * // Delete one Judging_run_output
     * const Judging_run_output = await prisma.judging_run_output.delete({
     *   where: {
     *     // ... filter to delete one Judging_run_output
     *   }
     * })
     * 
    **/
    delete<T extends judging_run_outputDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, judging_run_outputDeleteArgs<ExtArgs>>
    ): Prisma__judging_run_outputClient<$Result.GetResult<Prisma.$judging_run_outputPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Judging_run_output.
     * @param {judging_run_outputUpdateArgs} args - Arguments to update one Judging_run_output.
     * @example
     * // Update one Judging_run_output
     * const judging_run_output = await prisma.judging_run_output.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends judging_run_outputUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, judging_run_outputUpdateArgs<ExtArgs>>
    ): Prisma__judging_run_outputClient<$Result.GetResult<Prisma.$judging_run_outputPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Judging_run_outputs.
     * @param {judging_run_outputDeleteManyArgs} args - Arguments to filter Judging_run_outputs to delete.
     * @example
     * // Delete a few Judging_run_outputs
     * const { count } = await prisma.judging_run_output.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends judging_run_outputDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, judging_run_outputDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Judging_run_outputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judging_run_outputUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Judging_run_outputs
     * const judging_run_output = await prisma.judging_run_output.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends judging_run_outputUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, judging_run_outputUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Judging_run_output.
     * @param {judging_run_outputUpsertArgs} args - Arguments to update or create a Judging_run_output.
     * @example
     * // Update or create a Judging_run_output
     * const judging_run_output = await prisma.judging_run_output.upsert({
     *   create: {
     *     // ... data to create a Judging_run_output
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Judging_run_output we want to update
     *   }
     * })
    **/
    upsert<T extends judging_run_outputUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, judging_run_outputUpsertArgs<ExtArgs>>
    ): Prisma__judging_run_outputClient<$Result.GetResult<Prisma.$judging_run_outputPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Judging_run_outputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judging_run_outputCountArgs} args - Arguments to filter Judging_run_outputs to count.
     * @example
     * // Count the number of Judging_run_outputs
     * const count = await prisma.judging_run_output.count({
     *   where: {
     *     // ... the filter for the Judging_run_outputs we want to count
     *   }
     * })
    **/
    count<T extends judging_run_outputCountArgs>(
      args?: Subset<T, judging_run_outputCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Judging_run_outputCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Judging_run_output.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Judging_run_outputAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Judging_run_outputAggregateArgs>(args: Subset<T, Judging_run_outputAggregateArgs>): Prisma.PrismaPromise<GetJudging_run_outputAggregateType<T>>

    /**
     * Group by Judging_run_output.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {judging_run_outputGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends judging_run_outputGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: judging_run_outputGroupByArgs['orderBy'] }
        : { orderBy?: judging_run_outputGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, judging_run_outputGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJudging_run_outputGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the judging_run_output model
   */
  readonly fields: judging_run_outputFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for judging_run_output.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__judging_run_outputClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    judging_run<T extends judging_runDefaultArgs<ExtArgs> = {}>(args?: Subset<T, judging_runDefaultArgs<ExtArgs>>): Prisma__judging_runClient<$Result.GetResult<Prisma.$judging_runPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the judging_run_output model
   */ 
  interface judging_run_outputFieldRefs {
    readonly runid: FieldRef<"judging_run_output", 'Int'>
    readonly output_run: FieldRef<"judging_run_output", 'Bytes'>
    readonly output_diff: FieldRef<"judging_run_output", 'Bytes'>
    readonly output_error: FieldRef<"judging_run_output", 'Bytes'>
    readonly output_system: FieldRef<"judging_run_output", 'Bytes'>
    readonly metadata: FieldRef<"judging_run_output", 'Bytes'>
  }
    

  // Custom InputTypes

  /**
   * judging_run_output findUnique
   */
  export type judging_run_outputFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run_output
     */
    select?: judging_run_outputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_run_outputInclude<ExtArgs> | null
    /**
     * Filter, which judging_run_output to fetch.
     */
    where: judging_run_outputWhereUniqueInput
  }


  /**
   * judging_run_output findUniqueOrThrow
   */
  export type judging_run_outputFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run_output
     */
    select?: judging_run_outputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_run_outputInclude<ExtArgs> | null
    /**
     * Filter, which judging_run_output to fetch.
     */
    where: judging_run_outputWhereUniqueInput
  }


  /**
   * judging_run_output findFirst
   */
  export type judging_run_outputFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run_output
     */
    select?: judging_run_outputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_run_outputInclude<ExtArgs> | null
    /**
     * Filter, which judging_run_output to fetch.
     */
    where?: judging_run_outputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of judging_run_outputs to fetch.
     */
    orderBy?: judging_run_outputOrderByWithRelationInput | judging_run_outputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for judging_run_outputs.
     */
    cursor?: judging_run_outputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` judging_run_outputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` judging_run_outputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of judging_run_outputs.
     */
    distinct?: Judging_run_outputScalarFieldEnum | Judging_run_outputScalarFieldEnum[]
  }


  /**
   * judging_run_output findFirstOrThrow
   */
  export type judging_run_outputFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run_output
     */
    select?: judging_run_outputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_run_outputInclude<ExtArgs> | null
    /**
     * Filter, which judging_run_output to fetch.
     */
    where?: judging_run_outputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of judging_run_outputs to fetch.
     */
    orderBy?: judging_run_outputOrderByWithRelationInput | judging_run_outputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for judging_run_outputs.
     */
    cursor?: judging_run_outputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` judging_run_outputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` judging_run_outputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of judging_run_outputs.
     */
    distinct?: Judging_run_outputScalarFieldEnum | Judging_run_outputScalarFieldEnum[]
  }


  /**
   * judging_run_output findMany
   */
  export type judging_run_outputFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run_output
     */
    select?: judging_run_outputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_run_outputInclude<ExtArgs> | null
    /**
     * Filter, which judging_run_outputs to fetch.
     */
    where?: judging_run_outputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of judging_run_outputs to fetch.
     */
    orderBy?: judging_run_outputOrderByWithRelationInput | judging_run_outputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing judging_run_outputs.
     */
    cursor?: judging_run_outputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` judging_run_outputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` judging_run_outputs.
     */
    skip?: number
    distinct?: Judging_run_outputScalarFieldEnum | Judging_run_outputScalarFieldEnum[]
  }


  /**
   * judging_run_output create
   */
  export type judging_run_outputCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run_output
     */
    select?: judging_run_outputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_run_outputInclude<ExtArgs> | null
    /**
     * The data needed to create a judging_run_output.
     */
    data: XOR<judging_run_outputCreateInput, judging_run_outputUncheckedCreateInput>
  }


  /**
   * judging_run_output createMany
   */
  export type judging_run_outputCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many judging_run_outputs.
     */
    data: judging_run_outputCreateManyInput | judging_run_outputCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * judging_run_output update
   */
  export type judging_run_outputUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run_output
     */
    select?: judging_run_outputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_run_outputInclude<ExtArgs> | null
    /**
     * The data needed to update a judging_run_output.
     */
    data: XOR<judging_run_outputUpdateInput, judging_run_outputUncheckedUpdateInput>
    /**
     * Choose, which judging_run_output to update.
     */
    where: judging_run_outputWhereUniqueInput
  }


  /**
   * judging_run_output updateMany
   */
  export type judging_run_outputUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update judging_run_outputs.
     */
    data: XOR<judging_run_outputUpdateManyMutationInput, judging_run_outputUncheckedUpdateManyInput>
    /**
     * Filter which judging_run_outputs to update
     */
    where?: judging_run_outputWhereInput
  }


  /**
   * judging_run_output upsert
   */
  export type judging_run_outputUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run_output
     */
    select?: judging_run_outputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_run_outputInclude<ExtArgs> | null
    /**
     * The filter to search for the judging_run_output to update in case it exists.
     */
    where: judging_run_outputWhereUniqueInput
    /**
     * In case the judging_run_output found by the `where` argument doesn't exist, create a new judging_run_output with this data.
     */
    create: XOR<judging_run_outputCreateInput, judging_run_outputUncheckedCreateInput>
    /**
     * In case the judging_run_output was found with the provided `where` argument, update it with this data.
     */
    update: XOR<judging_run_outputUpdateInput, judging_run_outputUncheckedUpdateInput>
  }


  /**
   * judging_run_output delete
   */
  export type judging_run_outputDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run_output
     */
    select?: judging_run_outputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_run_outputInclude<ExtArgs> | null
    /**
     * Filter which judging_run_output to delete.
     */
    where: judging_run_outputWhereUniqueInput
  }


  /**
   * judging_run_output deleteMany
   */
  export type judging_run_outputDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which judging_run_outputs to delete
     */
    where?: judging_run_outputWhereInput
  }


  /**
   * judging_run_output without action
   */
  export type judging_run_outputDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run_output
     */
    select?: judging_run_outputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_run_outputInclude<ExtArgs> | null
  }



  /**
   * Model language
   */

  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _avg: LanguageAvgAggregateOutputType | null
    _sum: LanguageSumAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageAvgAggregateOutputType = {
    time_factor: number | null
  }

  export type LanguageSumAggregateOutputType = {
    time_factor: number | null
  }

  export type LanguageMinAggregateOutputType = {
    langid: string | null
    externalid: string | null
    name: string | null
    extensions: string | null
    require_entry_point: boolean | null
    entry_point_description: string | null
    allow_submit: boolean | null
    allow_judge: boolean | null
    time_factor: number | null
    compile_script: string | null
    filter_compiler_files: boolean | null
  }

  export type LanguageMaxAggregateOutputType = {
    langid: string | null
    externalid: string | null
    name: string | null
    extensions: string | null
    require_entry_point: boolean | null
    entry_point_description: string | null
    allow_submit: boolean | null
    allow_judge: boolean | null
    time_factor: number | null
    compile_script: string | null
    filter_compiler_files: boolean | null
  }

  export type LanguageCountAggregateOutputType = {
    langid: number
    externalid: number
    name: number
    extensions: number
    require_entry_point: number
    entry_point_description: number
    allow_submit: number
    allow_judge: number
    time_factor: number
    compile_script: number
    filter_compiler_files: number
    _all: number
  }


  export type LanguageAvgAggregateInputType = {
    time_factor?: true
  }

  export type LanguageSumAggregateInputType = {
    time_factor?: true
  }

  export type LanguageMinAggregateInputType = {
    langid?: true
    externalid?: true
    name?: true
    extensions?: true
    require_entry_point?: true
    entry_point_description?: true
    allow_submit?: true
    allow_judge?: true
    time_factor?: true
    compile_script?: true
    filter_compiler_files?: true
  }

  export type LanguageMaxAggregateInputType = {
    langid?: true
    externalid?: true
    name?: true
    extensions?: true
    require_entry_point?: true
    entry_point_description?: true
    allow_submit?: true
    allow_judge?: true
    time_factor?: true
    compile_script?: true
    filter_compiler_files?: true
  }

  export type LanguageCountAggregateInputType = {
    langid?: true
    externalid?: true
    name?: true
    extensions?: true
    require_entry_point?: true
    entry_point_description?: true
    allow_submit?: true
    allow_judge?: true
    time_factor?: true
    compile_script?: true
    filter_compiler_files?: true
    _all?: true
  }

  export type LanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which language to aggregate.
     */
    where?: languageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of languages to fetch.
     */
    orderBy?: languageOrderByWithRelationInput | languageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: languageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LanguageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LanguageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type languageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: languageWhereInput
    orderBy?: languageOrderByWithAggregationInput | languageOrderByWithAggregationInput[]
    by: LanguageScalarFieldEnum[] | LanguageScalarFieldEnum
    having?: languageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _avg?: LanguageAvgAggregateInputType
    _sum?: LanguageSumAggregateInputType
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }

  export type LanguageGroupByOutputType = {
    langid: string
    externalid: string | null
    name: string
    extensions: string | null
    require_entry_point: boolean
    entry_point_description: string | null
    allow_submit: boolean
    allow_judge: boolean
    time_factor: number
    compile_script: string | null
    filter_compiler_files: boolean
    _count: LanguageCountAggregateOutputType | null
    _avg: LanguageAvgAggregateOutputType | null
    _sum: LanguageSumAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends languageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type languageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    langid?: boolean
    externalid?: boolean
    name?: boolean
    extensions?: boolean
    require_entry_point?: boolean
    entry_point_description?: boolean
    allow_submit?: boolean
    allow_judge?: boolean
    time_factor?: boolean
    compile_script?: boolean
    filter_compiler_files?: boolean
    executable?: boolean | language$executableArgs<ExtArgs>
    submission?: boolean | language$submissionArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["language"]>

  export type languageSelectScalar = {
    langid?: boolean
    externalid?: boolean
    name?: boolean
    extensions?: boolean
    require_entry_point?: boolean
    entry_point_description?: boolean
    allow_submit?: boolean
    allow_judge?: boolean
    time_factor?: boolean
    compile_script?: boolean
    filter_compiler_files?: boolean
  }

  export type languageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executable?: boolean | language$executableArgs<ExtArgs>
    submission?: boolean | language$submissionArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $languagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "language"
    objects: {
      executable: Prisma.$executablePayload<ExtArgs> | null
      submission: Prisma.$submissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      langid: string
      externalid: string | null
      name: string
      extensions: string | null
      require_entry_point: boolean
      entry_point_description: string | null
      allow_submit: boolean
      allow_judge: boolean
      time_factor: number
      compile_script: string | null
      filter_compiler_files: boolean
    }, ExtArgs["result"]["language"]>
    composites: {}
  }


  type languageGetPayload<S extends boolean | null | undefined | languageDefaultArgs> = $Result.GetResult<Prisma.$languagePayload, S>

  type languageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<languageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LanguageCountAggregateInputType | true
    }

  export interface languageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['language'], meta: { name: 'language' } }
    /**
     * Find zero or one Language that matches the filter.
     * @param {languageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends languageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, languageFindUniqueArgs<ExtArgs>>
    ): Prisma__languageClient<$Result.GetResult<Prisma.$languagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Language that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {languageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends languageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, languageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__languageClient<$Result.GetResult<Prisma.$languagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends languageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, languageFindFirstArgs<ExtArgs>>
    ): Prisma__languageClient<$Result.GetResult<Prisma.$languagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends languageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, languageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__languageClient<$Result.GetResult<Prisma.$languagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `langid`
     * const languageWithLangidOnly = await prisma.language.findMany({ select: { langid: true } })
     * 
    **/
    findMany<T extends languageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, languageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$languagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Language.
     * @param {languageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
    **/
    create<T extends languageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, languageCreateArgs<ExtArgs>>
    ): Prisma__languageClient<$Result.GetResult<Prisma.$languagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Languages.
     *     @param {languageCreateManyArgs} args - Arguments to create many Languages.
     *     @example
     *     // Create many Languages
     *     const language = await prisma.language.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends languageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, languageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Language.
     * @param {languageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
    **/
    delete<T extends languageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, languageDeleteArgs<ExtArgs>>
    ): Prisma__languageClient<$Result.GetResult<Prisma.$languagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Language.
     * @param {languageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends languageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, languageUpdateArgs<ExtArgs>>
    ): Prisma__languageClient<$Result.GetResult<Prisma.$languagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Languages.
     * @param {languageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends languageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, languageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends languageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, languageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Language.
     * @param {languageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
    **/
    upsert<T extends languageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, languageUpsertArgs<ExtArgs>>
    ): Prisma__languageClient<$Result.GetResult<Prisma.$languagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends languageCountArgs>(
      args?: Subset<T, languageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): Prisma.PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends languageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: languageGroupByArgs['orderBy'] }
        : { orderBy?: languageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, languageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the language model
   */
  readonly fields: languageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__languageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    executable<T extends language$executableArgs<ExtArgs> = {}>(args?: Subset<T, language$executableArgs<ExtArgs>>): Prisma__executableClient<$Result.GetResult<Prisma.$executablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    submission<T extends language$submissionArgs<ExtArgs> = {}>(args?: Subset<T, language$submissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the language model
   */ 
  interface languageFieldRefs {
    readonly langid: FieldRef<"language", 'String'>
    readonly externalid: FieldRef<"language", 'String'>
    readonly name: FieldRef<"language", 'String'>
    readonly extensions: FieldRef<"language", 'String'>
    readonly require_entry_point: FieldRef<"language", 'Boolean'>
    readonly entry_point_description: FieldRef<"language", 'String'>
    readonly allow_submit: FieldRef<"language", 'Boolean'>
    readonly allow_judge: FieldRef<"language", 'Boolean'>
    readonly time_factor: FieldRef<"language", 'Float'>
    readonly compile_script: FieldRef<"language", 'String'>
    readonly filter_compiler_files: FieldRef<"language", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * language findUnique
   */
  export type languageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: languageInclude<ExtArgs> | null
    /**
     * Filter, which language to fetch.
     */
    where: languageWhereUniqueInput
  }


  /**
   * language findUniqueOrThrow
   */
  export type languageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: languageInclude<ExtArgs> | null
    /**
     * Filter, which language to fetch.
     */
    where: languageWhereUniqueInput
  }


  /**
   * language findFirst
   */
  export type languageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: languageInclude<ExtArgs> | null
    /**
     * Filter, which language to fetch.
     */
    where?: languageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of languages to fetch.
     */
    orderBy?: languageOrderByWithRelationInput | languageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for languages.
     */
    cursor?: languageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }


  /**
   * language findFirstOrThrow
   */
  export type languageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: languageInclude<ExtArgs> | null
    /**
     * Filter, which language to fetch.
     */
    where?: languageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of languages to fetch.
     */
    orderBy?: languageOrderByWithRelationInput | languageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for languages.
     */
    cursor?: languageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }


  /**
   * language findMany
   */
  export type languageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: languageInclude<ExtArgs> | null
    /**
     * Filter, which languages to fetch.
     */
    where?: languageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of languages to fetch.
     */
    orderBy?: languageOrderByWithRelationInput | languageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing languages.
     */
    cursor?: languageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` languages.
     */
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }


  /**
   * language create
   */
  export type languageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: languageInclude<ExtArgs> | null
    /**
     * The data needed to create a language.
     */
    data: XOR<languageCreateInput, languageUncheckedCreateInput>
  }


  /**
   * language createMany
   */
  export type languageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many languages.
     */
    data: languageCreateManyInput | languageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * language update
   */
  export type languageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: languageInclude<ExtArgs> | null
    /**
     * The data needed to update a language.
     */
    data: XOR<languageUpdateInput, languageUncheckedUpdateInput>
    /**
     * Choose, which language to update.
     */
    where: languageWhereUniqueInput
  }


  /**
   * language updateMany
   */
  export type languageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update languages.
     */
    data: XOR<languageUpdateManyMutationInput, languageUncheckedUpdateManyInput>
    /**
     * Filter which languages to update
     */
    where?: languageWhereInput
  }


  /**
   * language upsert
   */
  export type languageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: languageInclude<ExtArgs> | null
    /**
     * The filter to search for the language to update in case it exists.
     */
    where: languageWhereUniqueInput
    /**
     * In case the language found by the `where` argument doesn't exist, create a new language with this data.
     */
    create: XOR<languageCreateInput, languageUncheckedCreateInput>
    /**
     * In case the language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<languageUpdateInput, languageUncheckedUpdateInput>
  }


  /**
   * language delete
   */
  export type languageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: languageInclude<ExtArgs> | null
    /**
     * Filter which language to delete.
     */
    where: languageWhereUniqueInput
  }


  /**
   * language deleteMany
   */
  export type languageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which languages to delete
     */
    where?: languageWhereInput
  }


  /**
   * language.executable
   */
  export type language$executableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable
     */
    select?: executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executableInclude<ExtArgs> | null
    where?: executableWhereInput
  }


  /**
   * language.submission
   */
  export type language$submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    where?: submissionWhereInput
    orderBy?: submissionOrderByWithRelationInput | submissionOrderByWithRelationInput[]
    cursor?: submissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }


  /**
   * language without action
   */
  export type languageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: languageInclude<ExtArgs> | null
  }



  /**
   * Model problem
   */

  export type AggregateProblem = {
    _count: ProblemCountAggregateOutputType | null
    _avg: ProblemAvgAggregateOutputType | null
    _sum: ProblemSumAggregateOutputType | null
    _min: ProblemMinAggregateOutputType | null
    _max: ProblemMaxAggregateOutputType | null
  }

  export type ProblemAvgAggregateOutputType = {
    probid: number | null
    timelimit: number | null
    memlimit: number | null
    outputlimit: number | null
  }

  export type ProblemSumAggregateOutputType = {
    probid: number | null
    timelimit: number | null
    memlimit: number | null
    outputlimit: number | null
  }

  export type ProblemMinAggregateOutputType = {
    probid: number | null
    externalid: string | null
    name: string | null
    timelimit: number | null
    memlimit: number | null
    outputlimit: number | null
    special_run: string | null
    special_compare: string | null
    special_compare_args: string | null
    combined_run_compare: boolean | null
    problemtext: Buffer | null
    problemtext_type: string | null
  }

  export type ProblemMaxAggregateOutputType = {
    probid: number | null
    externalid: string | null
    name: string | null
    timelimit: number | null
    memlimit: number | null
    outputlimit: number | null
    special_run: string | null
    special_compare: string | null
    special_compare_args: string | null
    combined_run_compare: boolean | null
    problemtext: Buffer | null
    problemtext_type: string | null
  }

  export type ProblemCountAggregateOutputType = {
    probid: number
    externalid: number
    name: number
    timelimit: number
    memlimit: number
    outputlimit: number
    special_run: number
    special_compare: number
    special_compare_args: number
    combined_run_compare: number
    problemtext: number
    problemtext_type: number
    _all: number
  }


  export type ProblemAvgAggregateInputType = {
    probid?: true
    timelimit?: true
    memlimit?: true
    outputlimit?: true
  }

  export type ProblemSumAggregateInputType = {
    probid?: true
    timelimit?: true
    memlimit?: true
    outputlimit?: true
  }

  export type ProblemMinAggregateInputType = {
    probid?: true
    externalid?: true
    name?: true
    timelimit?: true
    memlimit?: true
    outputlimit?: true
    special_run?: true
    special_compare?: true
    special_compare_args?: true
    combined_run_compare?: true
    problemtext?: true
    problemtext_type?: true
  }

  export type ProblemMaxAggregateInputType = {
    probid?: true
    externalid?: true
    name?: true
    timelimit?: true
    memlimit?: true
    outputlimit?: true
    special_run?: true
    special_compare?: true
    special_compare_args?: true
    combined_run_compare?: true
    problemtext?: true
    problemtext_type?: true
  }

  export type ProblemCountAggregateInputType = {
    probid?: true
    externalid?: true
    name?: true
    timelimit?: true
    memlimit?: true
    outputlimit?: true
    special_run?: true
    special_compare?: true
    special_compare_args?: true
    combined_run_compare?: true
    problemtext?: true
    problemtext_type?: true
    _all?: true
  }

  export type ProblemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which problem to aggregate.
     */
    where?: problemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problems to fetch.
     */
    orderBy?: problemOrderByWithRelationInput | problemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: problemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned problems
    **/
    _count?: true | ProblemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProblemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProblemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProblemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProblemMaxAggregateInputType
  }

  export type GetProblemAggregateType<T extends ProblemAggregateArgs> = {
        [P in keyof T & keyof AggregateProblem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProblem[P]>
      : GetScalarType<T[P], AggregateProblem[P]>
  }




  export type problemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: problemWhereInput
    orderBy?: problemOrderByWithAggregationInput | problemOrderByWithAggregationInput[]
    by: ProblemScalarFieldEnum[] | ProblemScalarFieldEnum
    having?: problemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProblemCountAggregateInputType | true
    _avg?: ProblemAvgAggregateInputType
    _sum?: ProblemSumAggregateInputType
    _min?: ProblemMinAggregateInputType
    _max?: ProblemMaxAggregateInputType
  }

  export type ProblemGroupByOutputType = {
    probid: number
    externalid: string | null
    name: string
    timelimit: number
    memlimit: number | null
    outputlimit: number | null
    special_run: string | null
    special_compare: string | null
    special_compare_args: string | null
    combined_run_compare: boolean
    problemtext: Buffer | null
    problemtext_type: string | null
    _count: ProblemCountAggregateOutputType | null
    _avg: ProblemAvgAggregateOutputType | null
    _sum: ProblemSumAggregateOutputType | null
    _min: ProblemMinAggregateOutputType | null
    _max: ProblemMaxAggregateOutputType | null
  }

  type GetProblemGroupByPayload<T extends problemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProblemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProblemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProblemGroupByOutputType[P]>
            : GetScalarType<T[P], ProblemGroupByOutputType[P]>
        }
      >
    >


  export type problemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    probid?: boolean
    externalid?: boolean
    name?: boolean
    timelimit?: boolean
    memlimit?: boolean
    outputlimit?: boolean
    special_run?: boolean
    special_compare?: boolean
    special_compare_args?: boolean
    combined_run_compare?: boolean
    problemtext?: boolean
    problemtext_type?: boolean
    clarification?: boolean | problem$clarificationArgs<ExtArgs>
    contestproblem?: boolean | problem$contestproblemArgs<ExtArgs>
    executable_problem_special_runToexecutable?: boolean | problem$executable_problem_special_runToexecutableArgs<ExtArgs>
    executable_problem_special_compareToexecutable?: boolean | problem$executable_problem_special_compareToexecutableArgs<ExtArgs>
    problem_attachment?: boolean | problem$problem_attachmentArgs<ExtArgs>
    scorecache?: boolean | problem$scorecacheArgs<ExtArgs>
    submission?: boolean | problem$submissionArgs<ExtArgs>
    testcase?: boolean | problem$testcaseArgs<ExtArgs>
    _count?: boolean | ProblemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["problem"]>

  export type problemSelectScalar = {
    probid?: boolean
    externalid?: boolean
    name?: boolean
    timelimit?: boolean
    memlimit?: boolean
    outputlimit?: boolean
    special_run?: boolean
    special_compare?: boolean
    special_compare_args?: boolean
    combined_run_compare?: boolean
    problemtext?: boolean
    problemtext_type?: boolean
  }

  export type problemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clarification?: boolean | problem$clarificationArgs<ExtArgs>
    contestproblem?: boolean | problem$contestproblemArgs<ExtArgs>
    executable_problem_special_runToexecutable?: boolean | problem$executable_problem_special_runToexecutableArgs<ExtArgs>
    executable_problem_special_compareToexecutable?: boolean | problem$executable_problem_special_compareToexecutableArgs<ExtArgs>
    problem_attachment?: boolean | problem$problem_attachmentArgs<ExtArgs>
    scorecache?: boolean | problem$scorecacheArgs<ExtArgs>
    submission?: boolean | problem$submissionArgs<ExtArgs>
    testcase?: boolean | problem$testcaseArgs<ExtArgs>
    _count?: boolean | ProblemCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $problemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "problem"
    objects: {
      clarification: Prisma.$clarificationPayload<ExtArgs>[]
      contestproblem: Prisma.$contestproblemPayload<ExtArgs>[]
      executable_problem_special_runToexecutable: Prisma.$executablePayload<ExtArgs> | null
      executable_problem_special_compareToexecutable: Prisma.$executablePayload<ExtArgs> | null
      problem_attachment: Prisma.$problem_attachmentPayload<ExtArgs>[]
      scorecache: Prisma.$scorecachePayload<ExtArgs>[]
      submission: Prisma.$submissionPayload<ExtArgs>[]
      testcase: Prisma.$testcasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      probid: number
      externalid: string | null
      name: string
      timelimit: number
      memlimit: number | null
      outputlimit: number | null
      special_run: string | null
      special_compare: string | null
      special_compare_args: string | null
      combined_run_compare: boolean
      problemtext: Buffer | null
      problemtext_type: string | null
    }, ExtArgs["result"]["problem"]>
    composites: {}
  }


  type problemGetPayload<S extends boolean | null | undefined | problemDefaultArgs> = $Result.GetResult<Prisma.$problemPayload, S>

  type problemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<problemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProblemCountAggregateInputType | true
    }

  export interface problemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['problem'], meta: { name: 'problem' } }
    /**
     * Find zero or one Problem that matches the filter.
     * @param {problemFindUniqueArgs} args - Arguments to find a Problem
     * @example
     * // Get one Problem
     * const problem = await prisma.problem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends problemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, problemFindUniqueArgs<ExtArgs>>
    ): Prisma__problemClient<$Result.GetResult<Prisma.$problemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Problem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {problemFindUniqueOrThrowArgs} args - Arguments to find a Problem
     * @example
     * // Get one Problem
     * const problem = await prisma.problem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends problemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, problemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__problemClient<$Result.GetResult<Prisma.$problemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Problem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problemFindFirstArgs} args - Arguments to find a Problem
     * @example
     * // Get one Problem
     * const problem = await prisma.problem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends problemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, problemFindFirstArgs<ExtArgs>>
    ): Prisma__problemClient<$Result.GetResult<Prisma.$problemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Problem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problemFindFirstOrThrowArgs} args - Arguments to find a Problem
     * @example
     * // Get one Problem
     * const problem = await prisma.problem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends problemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, problemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__problemClient<$Result.GetResult<Prisma.$problemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Problems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Problems
     * const problems = await prisma.problem.findMany()
     * 
     * // Get first 10 Problems
     * const problems = await prisma.problem.findMany({ take: 10 })
     * 
     * // Only select the `probid`
     * const problemWithProbidOnly = await prisma.problem.findMany({ select: { probid: true } })
     * 
    **/
    findMany<T extends problemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, problemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$problemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Problem.
     * @param {problemCreateArgs} args - Arguments to create a Problem.
     * @example
     * // Create one Problem
     * const Problem = await prisma.problem.create({
     *   data: {
     *     // ... data to create a Problem
     *   }
     * })
     * 
    **/
    create<T extends problemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, problemCreateArgs<ExtArgs>>
    ): Prisma__problemClient<$Result.GetResult<Prisma.$problemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Problems.
     *     @param {problemCreateManyArgs} args - Arguments to create many Problems.
     *     @example
     *     // Create many Problems
     *     const problem = await prisma.problem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends problemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, problemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Problem.
     * @param {problemDeleteArgs} args - Arguments to delete one Problem.
     * @example
     * // Delete one Problem
     * const Problem = await prisma.problem.delete({
     *   where: {
     *     // ... filter to delete one Problem
     *   }
     * })
     * 
    **/
    delete<T extends problemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, problemDeleteArgs<ExtArgs>>
    ): Prisma__problemClient<$Result.GetResult<Prisma.$problemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Problem.
     * @param {problemUpdateArgs} args - Arguments to update one Problem.
     * @example
     * // Update one Problem
     * const problem = await prisma.problem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends problemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, problemUpdateArgs<ExtArgs>>
    ): Prisma__problemClient<$Result.GetResult<Prisma.$problemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Problems.
     * @param {problemDeleteManyArgs} args - Arguments to filter Problems to delete.
     * @example
     * // Delete a few Problems
     * const { count } = await prisma.problem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends problemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, problemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Problems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Problems
     * const problem = await prisma.problem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends problemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, problemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Problem.
     * @param {problemUpsertArgs} args - Arguments to update or create a Problem.
     * @example
     * // Update or create a Problem
     * const problem = await prisma.problem.upsert({
     *   create: {
     *     // ... data to create a Problem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Problem we want to update
     *   }
     * })
    **/
    upsert<T extends problemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, problemUpsertArgs<ExtArgs>>
    ): Prisma__problemClient<$Result.GetResult<Prisma.$problemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Problems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problemCountArgs} args - Arguments to filter Problems to count.
     * @example
     * // Count the number of Problems
     * const count = await prisma.problem.count({
     *   where: {
     *     // ... the filter for the Problems we want to count
     *   }
     * })
    **/
    count<T extends problemCountArgs>(
      args?: Subset<T, problemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProblemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Problem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProblemAggregateArgs>(args: Subset<T, ProblemAggregateArgs>): Prisma.PrismaPromise<GetProblemAggregateType<T>>

    /**
     * Group by Problem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends problemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: problemGroupByArgs['orderBy'] }
        : { orderBy?: problemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, problemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProblemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the problem model
   */
  readonly fields: problemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for problem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__problemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    clarification<T extends problem$clarificationArgs<ExtArgs> = {}>(args?: Subset<T, problem$clarificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clarificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    contestproblem<T extends problem$contestproblemArgs<ExtArgs> = {}>(args?: Subset<T, problem$contestproblemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contestproblemPayload<ExtArgs>, T, 'findMany'> | Null>;

    executable_problem_special_runToexecutable<T extends problem$executable_problem_special_runToexecutableArgs<ExtArgs> = {}>(args?: Subset<T, problem$executable_problem_special_runToexecutableArgs<ExtArgs>>): Prisma__executableClient<$Result.GetResult<Prisma.$executablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    executable_problem_special_compareToexecutable<T extends problem$executable_problem_special_compareToexecutableArgs<ExtArgs> = {}>(args?: Subset<T, problem$executable_problem_special_compareToexecutableArgs<ExtArgs>>): Prisma__executableClient<$Result.GetResult<Prisma.$executablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    problem_attachment<T extends problem$problem_attachmentArgs<ExtArgs> = {}>(args?: Subset<T, problem$problem_attachmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$problem_attachmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    scorecache<T extends problem$scorecacheArgs<ExtArgs> = {}>(args?: Subset<T, problem$scorecacheArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$scorecachePayload<ExtArgs>, T, 'findMany'> | Null>;

    submission<T extends problem$submissionArgs<ExtArgs> = {}>(args?: Subset<T, problem$submissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'findMany'> | Null>;

    testcase<T extends problem$testcaseArgs<ExtArgs> = {}>(args?: Subset<T, problem$testcaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$testcasePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the problem model
   */ 
  interface problemFieldRefs {
    readonly probid: FieldRef<"problem", 'Int'>
    readonly externalid: FieldRef<"problem", 'String'>
    readonly name: FieldRef<"problem", 'String'>
    readonly timelimit: FieldRef<"problem", 'Float'>
    readonly memlimit: FieldRef<"problem", 'Int'>
    readonly outputlimit: FieldRef<"problem", 'Int'>
    readonly special_run: FieldRef<"problem", 'String'>
    readonly special_compare: FieldRef<"problem", 'String'>
    readonly special_compare_args: FieldRef<"problem", 'String'>
    readonly combined_run_compare: FieldRef<"problem", 'Boolean'>
    readonly problemtext: FieldRef<"problem", 'Bytes'>
    readonly problemtext_type: FieldRef<"problem", 'String'>
  }
    

  // Custom InputTypes

  /**
   * problem findUnique
   */
  export type problemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem
     */
    select?: problemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problemInclude<ExtArgs> | null
    /**
     * Filter, which problem to fetch.
     */
    where: problemWhereUniqueInput
  }


  /**
   * problem findUniqueOrThrow
   */
  export type problemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem
     */
    select?: problemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problemInclude<ExtArgs> | null
    /**
     * Filter, which problem to fetch.
     */
    where: problemWhereUniqueInput
  }


  /**
   * problem findFirst
   */
  export type problemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem
     */
    select?: problemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problemInclude<ExtArgs> | null
    /**
     * Filter, which problem to fetch.
     */
    where?: problemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problems to fetch.
     */
    orderBy?: problemOrderByWithRelationInput | problemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for problems.
     */
    cursor?: problemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of problems.
     */
    distinct?: ProblemScalarFieldEnum | ProblemScalarFieldEnum[]
  }


  /**
   * problem findFirstOrThrow
   */
  export type problemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem
     */
    select?: problemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problemInclude<ExtArgs> | null
    /**
     * Filter, which problem to fetch.
     */
    where?: problemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problems to fetch.
     */
    orderBy?: problemOrderByWithRelationInput | problemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for problems.
     */
    cursor?: problemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of problems.
     */
    distinct?: ProblemScalarFieldEnum | ProblemScalarFieldEnum[]
  }


  /**
   * problem findMany
   */
  export type problemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem
     */
    select?: problemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problemInclude<ExtArgs> | null
    /**
     * Filter, which problems to fetch.
     */
    where?: problemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problems to fetch.
     */
    orderBy?: problemOrderByWithRelationInput | problemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing problems.
     */
    cursor?: problemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problems.
     */
    skip?: number
    distinct?: ProblemScalarFieldEnum | ProblemScalarFieldEnum[]
  }


  /**
   * problem create
   */
  export type problemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem
     */
    select?: problemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problemInclude<ExtArgs> | null
    /**
     * The data needed to create a problem.
     */
    data: XOR<problemCreateInput, problemUncheckedCreateInput>
  }


  /**
   * problem createMany
   */
  export type problemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many problems.
     */
    data: problemCreateManyInput | problemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * problem update
   */
  export type problemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem
     */
    select?: problemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problemInclude<ExtArgs> | null
    /**
     * The data needed to update a problem.
     */
    data: XOR<problemUpdateInput, problemUncheckedUpdateInput>
    /**
     * Choose, which problem to update.
     */
    where: problemWhereUniqueInput
  }


  /**
   * problem updateMany
   */
  export type problemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update problems.
     */
    data: XOR<problemUpdateManyMutationInput, problemUncheckedUpdateManyInput>
    /**
     * Filter which problems to update
     */
    where?: problemWhereInput
  }


  /**
   * problem upsert
   */
  export type problemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem
     */
    select?: problemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problemInclude<ExtArgs> | null
    /**
     * The filter to search for the problem to update in case it exists.
     */
    where: problemWhereUniqueInput
    /**
     * In case the problem found by the `where` argument doesn't exist, create a new problem with this data.
     */
    create: XOR<problemCreateInput, problemUncheckedCreateInput>
    /**
     * In case the problem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<problemUpdateInput, problemUncheckedUpdateInput>
  }


  /**
   * problem delete
   */
  export type problemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem
     */
    select?: problemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problemInclude<ExtArgs> | null
    /**
     * Filter which problem to delete.
     */
    where: problemWhereUniqueInput
  }


  /**
   * problem deleteMany
   */
  export type problemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which problems to delete
     */
    where?: problemWhereInput
  }


  /**
   * problem.clarification
   */
  export type problem$clarificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clarification
     */
    select?: clarificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clarificationInclude<ExtArgs> | null
    where?: clarificationWhereInput
    orderBy?: clarificationOrderByWithRelationInput | clarificationOrderByWithRelationInput[]
    cursor?: clarificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClarificationScalarFieldEnum | ClarificationScalarFieldEnum[]
  }


  /**
   * problem.contestproblem
   */
  export type problem$contestproblemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestproblem
     */
    select?: contestproblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestproblemInclude<ExtArgs> | null
    where?: contestproblemWhereInput
    orderBy?: contestproblemOrderByWithRelationInput | contestproblemOrderByWithRelationInput[]
    cursor?: contestproblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestproblemScalarFieldEnum | ContestproblemScalarFieldEnum[]
  }


  /**
   * problem.executable_problem_special_runToexecutable
   */
  export type problem$executable_problem_special_runToexecutableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable
     */
    select?: executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executableInclude<ExtArgs> | null
    where?: executableWhereInput
  }


  /**
   * problem.executable_problem_special_compareToexecutable
   */
  export type problem$executable_problem_special_compareToexecutableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the executable
     */
    select?: executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: executableInclude<ExtArgs> | null
    where?: executableWhereInput
  }


  /**
   * problem.problem_attachment
   */
  export type problem$problem_attachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment
     */
    select?: problem_attachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachmentInclude<ExtArgs> | null
    where?: problem_attachmentWhereInput
    orderBy?: problem_attachmentOrderByWithRelationInput | problem_attachmentOrderByWithRelationInput[]
    cursor?: problem_attachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Problem_attachmentScalarFieldEnum | Problem_attachmentScalarFieldEnum[]
  }


  /**
   * problem.scorecache
   */
  export type problem$scorecacheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scorecache
     */
    select?: scorecacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: scorecacheInclude<ExtArgs> | null
    where?: scorecacheWhereInput
    orderBy?: scorecacheOrderByWithRelationInput | scorecacheOrderByWithRelationInput[]
    cursor?: scorecacheWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScorecacheScalarFieldEnum | ScorecacheScalarFieldEnum[]
  }


  /**
   * problem.submission
   */
  export type problem$submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    where?: submissionWhereInput
    orderBy?: submissionOrderByWithRelationInput | submissionOrderByWithRelationInput[]
    cursor?: submissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }


  /**
   * problem.testcase
   */
  export type problem$testcaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase
     */
    select?: testcaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcaseInclude<ExtArgs> | null
    where?: testcaseWhereInput
    orderBy?: testcaseOrderByWithRelationInput | testcaseOrderByWithRelationInput[]
    cursor?: testcaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestcaseScalarFieldEnum | TestcaseScalarFieldEnum[]
  }


  /**
   * problem without action
   */
  export type problemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem
     */
    select?: problemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problemInclude<ExtArgs> | null
  }



  /**
   * Model problem_attachment
   */

  export type AggregateProblem_attachment = {
    _count: Problem_attachmentCountAggregateOutputType | null
    _avg: Problem_attachmentAvgAggregateOutputType | null
    _sum: Problem_attachmentSumAggregateOutputType | null
    _min: Problem_attachmentMinAggregateOutputType | null
    _max: Problem_attachmentMaxAggregateOutputType | null
  }

  export type Problem_attachmentAvgAggregateOutputType = {
    attachmentid: number | null
    probid: number | null
  }

  export type Problem_attachmentSumAggregateOutputType = {
    attachmentid: number | null
    probid: number | null
  }

  export type Problem_attachmentMinAggregateOutputType = {
    attachmentid: number | null
    probid: number | null
    name: string | null
    type: string | null
  }

  export type Problem_attachmentMaxAggregateOutputType = {
    attachmentid: number | null
    probid: number | null
    name: string | null
    type: string | null
  }

  export type Problem_attachmentCountAggregateOutputType = {
    attachmentid: number
    probid: number
    name: number
    type: number
    _all: number
  }


  export type Problem_attachmentAvgAggregateInputType = {
    attachmentid?: true
    probid?: true
  }

  export type Problem_attachmentSumAggregateInputType = {
    attachmentid?: true
    probid?: true
  }

  export type Problem_attachmentMinAggregateInputType = {
    attachmentid?: true
    probid?: true
    name?: true
    type?: true
  }

  export type Problem_attachmentMaxAggregateInputType = {
    attachmentid?: true
    probid?: true
    name?: true
    type?: true
  }

  export type Problem_attachmentCountAggregateInputType = {
    attachmentid?: true
    probid?: true
    name?: true
    type?: true
    _all?: true
  }

  export type Problem_attachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which problem_attachment to aggregate.
     */
    where?: problem_attachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problem_attachments to fetch.
     */
    orderBy?: problem_attachmentOrderByWithRelationInput | problem_attachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: problem_attachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problem_attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problem_attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned problem_attachments
    **/
    _count?: true | Problem_attachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Problem_attachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Problem_attachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Problem_attachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Problem_attachmentMaxAggregateInputType
  }

  export type GetProblem_attachmentAggregateType<T extends Problem_attachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateProblem_attachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProblem_attachment[P]>
      : GetScalarType<T[P], AggregateProblem_attachment[P]>
  }




  export type problem_attachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: problem_attachmentWhereInput
    orderBy?: problem_attachmentOrderByWithAggregationInput | problem_attachmentOrderByWithAggregationInput[]
    by: Problem_attachmentScalarFieldEnum[] | Problem_attachmentScalarFieldEnum
    having?: problem_attachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Problem_attachmentCountAggregateInputType | true
    _avg?: Problem_attachmentAvgAggregateInputType
    _sum?: Problem_attachmentSumAggregateInputType
    _min?: Problem_attachmentMinAggregateInputType
    _max?: Problem_attachmentMaxAggregateInputType
  }

  export type Problem_attachmentGroupByOutputType = {
    attachmentid: number
    probid: number | null
    name: string
    type: string
    _count: Problem_attachmentCountAggregateOutputType | null
    _avg: Problem_attachmentAvgAggregateOutputType | null
    _sum: Problem_attachmentSumAggregateOutputType | null
    _min: Problem_attachmentMinAggregateOutputType | null
    _max: Problem_attachmentMaxAggregateOutputType | null
  }

  type GetProblem_attachmentGroupByPayload<T extends problem_attachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Problem_attachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Problem_attachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Problem_attachmentGroupByOutputType[P]>
            : GetScalarType<T[P], Problem_attachmentGroupByOutputType[P]>
        }
      >
    >


  export type problem_attachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    attachmentid?: boolean
    probid?: boolean
    name?: boolean
    type?: boolean
    problem?: boolean | problem_attachment$problemArgs<ExtArgs>
    problem_attachment_content?: boolean | problem_attachment$problem_attachment_contentArgs<ExtArgs>
  }, ExtArgs["result"]["problem_attachment"]>

  export type problem_attachmentSelectScalar = {
    attachmentid?: boolean
    probid?: boolean
    name?: boolean
    type?: boolean
  }

  export type problem_attachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    problem?: boolean | problem_attachment$problemArgs<ExtArgs>
    problem_attachment_content?: boolean | problem_attachment$problem_attachment_contentArgs<ExtArgs>
  }


  export type $problem_attachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "problem_attachment"
    objects: {
      problem: Prisma.$problemPayload<ExtArgs> | null
      problem_attachment_content: Prisma.$problem_attachment_contentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      attachmentid: number
      probid: number | null
      name: string
      type: string
    }, ExtArgs["result"]["problem_attachment"]>
    composites: {}
  }


  type problem_attachmentGetPayload<S extends boolean | null | undefined | problem_attachmentDefaultArgs> = $Result.GetResult<Prisma.$problem_attachmentPayload, S>

  type problem_attachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<problem_attachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Problem_attachmentCountAggregateInputType | true
    }

  export interface problem_attachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['problem_attachment'], meta: { name: 'problem_attachment' } }
    /**
     * Find zero or one Problem_attachment that matches the filter.
     * @param {problem_attachmentFindUniqueArgs} args - Arguments to find a Problem_attachment
     * @example
     * // Get one Problem_attachment
     * const problem_attachment = await prisma.problem_attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends problem_attachmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, problem_attachmentFindUniqueArgs<ExtArgs>>
    ): Prisma__problem_attachmentClient<$Result.GetResult<Prisma.$problem_attachmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Problem_attachment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {problem_attachmentFindUniqueOrThrowArgs} args - Arguments to find a Problem_attachment
     * @example
     * // Get one Problem_attachment
     * const problem_attachment = await prisma.problem_attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends problem_attachmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, problem_attachmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__problem_attachmentClient<$Result.GetResult<Prisma.$problem_attachmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Problem_attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problem_attachmentFindFirstArgs} args - Arguments to find a Problem_attachment
     * @example
     * // Get one Problem_attachment
     * const problem_attachment = await prisma.problem_attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends problem_attachmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, problem_attachmentFindFirstArgs<ExtArgs>>
    ): Prisma__problem_attachmentClient<$Result.GetResult<Prisma.$problem_attachmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Problem_attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problem_attachmentFindFirstOrThrowArgs} args - Arguments to find a Problem_attachment
     * @example
     * // Get one Problem_attachment
     * const problem_attachment = await prisma.problem_attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends problem_attachmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, problem_attachmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__problem_attachmentClient<$Result.GetResult<Prisma.$problem_attachmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Problem_attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problem_attachmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Problem_attachments
     * const problem_attachments = await prisma.problem_attachment.findMany()
     * 
     * // Get first 10 Problem_attachments
     * const problem_attachments = await prisma.problem_attachment.findMany({ take: 10 })
     * 
     * // Only select the `attachmentid`
     * const problem_attachmentWithAttachmentidOnly = await prisma.problem_attachment.findMany({ select: { attachmentid: true } })
     * 
    **/
    findMany<T extends problem_attachmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, problem_attachmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$problem_attachmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Problem_attachment.
     * @param {problem_attachmentCreateArgs} args - Arguments to create a Problem_attachment.
     * @example
     * // Create one Problem_attachment
     * const Problem_attachment = await prisma.problem_attachment.create({
     *   data: {
     *     // ... data to create a Problem_attachment
     *   }
     * })
     * 
    **/
    create<T extends problem_attachmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, problem_attachmentCreateArgs<ExtArgs>>
    ): Prisma__problem_attachmentClient<$Result.GetResult<Prisma.$problem_attachmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Problem_attachments.
     *     @param {problem_attachmentCreateManyArgs} args - Arguments to create many Problem_attachments.
     *     @example
     *     // Create many Problem_attachments
     *     const problem_attachment = await prisma.problem_attachment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends problem_attachmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, problem_attachmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Problem_attachment.
     * @param {problem_attachmentDeleteArgs} args - Arguments to delete one Problem_attachment.
     * @example
     * // Delete one Problem_attachment
     * const Problem_attachment = await prisma.problem_attachment.delete({
     *   where: {
     *     // ... filter to delete one Problem_attachment
     *   }
     * })
     * 
    **/
    delete<T extends problem_attachmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, problem_attachmentDeleteArgs<ExtArgs>>
    ): Prisma__problem_attachmentClient<$Result.GetResult<Prisma.$problem_attachmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Problem_attachment.
     * @param {problem_attachmentUpdateArgs} args - Arguments to update one Problem_attachment.
     * @example
     * // Update one Problem_attachment
     * const problem_attachment = await prisma.problem_attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends problem_attachmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, problem_attachmentUpdateArgs<ExtArgs>>
    ): Prisma__problem_attachmentClient<$Result.GetResult<Prisma.$problem_attachmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Problem_attachments.
     * @param {problem_attachmentDeleteManyArgs} args - Arguments to filter Problem_attachments to delete.
     * @example
     * // Delete a few Problem_attachments
     * const { count } = await prisma.problem_attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends problem_attachmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, problem_attachmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Problem_attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problem_attachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Problem_attachments
     * const problem_attachment = await prisma.problem_attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends problem_attachmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, problem_attachmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Problem_attachment.
     * @param {problem_attachmentUpsertArgs} args - Arguments to update or create a Problem_attachment.
     * @example
     * // Update or create a Problem_attachment
     * const problem_attachment = await prisma.problem_attachment.upsert({
     *   create: {
     *     // ... data to create a Problem_attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Problem_attachment we want to update
     *   }
     * })
    **/
    upsert<T extends problem_attachmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, problem_attachmentUpsertArgs<ExtArgs>>
    ): Prisma__problem_attachmentClient<$Result.GetResult<Prisma.$problem_attachmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Problem_attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problem_attachmentCountArgs} args - Arguments to filter Problem_attachments to count.
     * @example
     * // Count the number of Problem_attachments
     * const count = await prisma.problem_attachment.count({
     *   where: {
     *     // ... the filter for the Problem_attachments we want to count
     *   }
     * })
    **/
    count<T extends problem_attachmentCountArgs>(
      args?: Subset<T, problem_attachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Problem_attachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Problem_attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Problem_attachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Problem_attachmentAggregateArgs>(args: Subset<T, Problem_attachmentAggregateArgs>): Prisma.PrismaPromise<GetProblem_attachmentAggregateType<T>>

    /**
     * Group by Problem_attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problem_attachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends problem_attachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: problem_attachmentGroupByArgs['orderBy'] }
        : { orderBy?: problem_attachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, problem_attachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProblem_attachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the problem_attachment model
   */
  readonly fields: problem_attachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for problem_attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__problem_attachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    problem<T extends problem_attachment$problemArgs<ExtArgs> = {}>(args?: Subset<T, problem_attachment$problemArgs<ExtArgs>>): Prisma__problemClient<$Result.GetResult<Prisma.$problemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    problem_attachment_content<T extends problem_attachment$problem_attachment_contentArgs<ExtArgs> = {}>(args?: Subset<T, problem_attachment$problem_attachment_contentArgs<ExtArgs>>): Prisma__problem_attachment_contentClient<$Result.GetResult<Prisma.$problem_attachment_contentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the problem_attachment model
   */ 
  interface problem_attachmentFieldRefs {
    readonly attachmentid: FieldRef<"problem_attachment", 'Int'>
    readonly probid: FieldRef<"problem_attachment", 'Int'>
    readonly name: FieldRef<"problem_attachment", 'String'>
    readonly type: FieldRef<"problem_attachment", 'String'>
  }
    

  // Custom InputTypes

  /**
   * problem_attachment findUnique
   */
  export type problem_attachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment
     */
    select?: problem_attachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachmentInclude<ExtArgs> | null
    /**
     * Filter, which problem_attachment to fetch.
     */
    where: problem_attachmentWhereUniqueInput
  }


  /**
   * problem_attachment findUniqueOrThrow
   */
  export type problem_attachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment
     */
    select?: problem_attachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachmentInclude<ExtArgs> | null
    /**
     * Filter, which problem_attachment to fetch.
     */
    where: problem_attachmentWhereUniqueInput
  }


  /**
   * problem_attachment findFirst
   */
  export type problem_attachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment
     */
    select?: problem_attachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachmentInclude<ExtArgs> | null
    /**
     * Filter, which problem_attachment to fetch.
     */
    where?: problem_attachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problem_attachments to fetch.
     */
    orderBy?: problem_attachmentOrderByWithRelationInput | problem_attachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for problem_attachments.
     */
    cursor?: problem_attachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problem_attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problem_attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of problem_attachments.
     */
    distinct?: Problem_attachmentScalarFieldEnum | Problem_attachmentScalarFieldEnum[]
  }


  /**
   * problem_attachment findFirstOrThrow
   */
  export type problem_attachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment
     */
    select?: problem_attachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachmentInclude<ExtArgs> | null
    /**
     * Filter, which problem_attachment to fetch.
     */
    where?: problem_attachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problem_attachments to fetch.
     */
    orderBy?: problem_attachmentOrderByWithRelationInput | problem_attachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for problem_attachments.
     */
    cursor?: problem_attachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problem_attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problem_attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of problem_attachments.
     */
    distinct?: Problem_attachmentScalarFieldEnum | Problem_attachmentScalarFieldEnum[]
  }


  /**
   * problem_attachment findMany
   */
  export type problem_attachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment
     */
    select?: problem_attachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachmentInclude<ExtArgs> | null
    /**
     * Filter, which problem_attachments to fetch.
     */
    where?: problem_attachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problem_attachments to fetch.
     */
    orderBy?: problem_attachmentOrderByWithRelationInput | problem_attachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing problem_attachments.
     */
    cursor?: problem_attachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problem_attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problem_attachments.
     */
    skip?: number
    distinct?: Problem_attachmentScalarFieldEnum | Problem_attachmentScalarFieldEnum[]
  }


  /**
   * problem_attachment create
   */
  export type problem_attachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment
     */
    select?: problem_attachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a problem_attachment.
     */
    data: XOR<problem_attachmentCreateInput, problem_attachmentUncheckedCreateInput>
  }


  /**
   * problem_attachment createMany
   */
  export type problem_attachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many problem_attachments.
     */
    data: problem_attachmentCreateManyInput | problem_attachmentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * problem_attachment update
   */
  export type problem_attachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment
     */
    select?: problem_attachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a problem_attachment.
     */
    data: XOR<problem_attachmentUpdateInput, problem_attachmentUncheckedUpdateInput>
    /**
     * Choose, which problem_attachment to update.
     */
    where: problem_attachmentWhereUniqueInput
  }


  /**
   * problem_attachment updateMany
   */
  export type problem_attachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update problem_attachments.
     */
    data: XOR<problem_attachmentUpdateManyMutationInput, problem_attachmentUncheckedUpdateManyInput>
    /**
     * Filter which problem_attachments to update
     */
    where?: problem_attachmentWhereInput
  }


  /**
   * problem_attachment upsert
   */
  export type problem_attachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment
     */
    select?: problem_attachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the problem_attachment to update in case it exists.
     */
    where: problem_attachmentWhereUniqueInput
    /**
     * In case the problem_attachment found by the `where` argument doesn't exist, create a new problem_attachment with this data.
     */
    create: XOR<problem_attachmentCreateInput, problem_attachmentUncheckedCreateInput>
    /**
     * In case the problem_attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<problem_attachmentUpdateInput, problem_attachmentUncheckedUpdateInput>
  }


  /**
   * problem_attachment delete
   */
  export type problem_attachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment
     */
    select?: problem_attachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachmentInclude<ExtArgs> | null
    /**
     * Filter which problem_attachment to delete.
     */
    where: problem_attachmentWhereUniqueInput
  }


  /**
   * problem_attachment deleteMany
   */
  export type problem_attachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which problem_attachments to delete
     */
    where?: problem_attachmentWhereInput
  }


  /**
   * problem_attachment.problem
   */
  export type problem_attachment$problemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem
     */
    select?: problemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problemInclude<ExtArgs> | null
    where?: problemWhereInput
  }


  /**
   * problem_attachment.problem_attachment_content
   */
  export type problem_attachment$problem_attachment_contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment_content
     */
    select?: problem_attachment_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachment_contentInclude<ExtArgs> | null
    where?: problem_attachment_contentWhereInput
  }


  /**
   * problem_attachment without action
   */
  export type problem_attachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment
     */
    select?: problem_attachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachmentInclude<ExtArgs> | null
  }



  /**
   * Model problem_attachment_content
   */

  export type AggregateProblem_attachment_content = {
    _count: Problem_attachment_contentCountAggregateOutputType | null
    _avg: Problem_attachment_contentAvgAggregateOutputType | null
    _sum: Problem_attachment_contentSumAggregateOutputType | null
    _min: Problem_attachment_contentMinAggregateOutputType | null
    _max: Problem_attachment_contentMaxAggregateOutputType | null
  }

  export type Problem_attachment_contentAvgAggregateOutputType = {
    attachmentid: number | null
  }

  export type Problem_attachment_contentSumAggregateOutputType = {
    attachmentid: number | null
  }

  export type Problem_attachment_contentMinAggregateOutputType = {
    attachmentid: number | null
    content: Buffer | null
  }

  export type Problem_attachment_contentMaxAggregateOutputType = {
    attachmentid: number | null
    content: Buffer | null
  }

  export type Problem_attachment_contentCountAggregateOutputType = {
    attachmentid: number
    content: number
    _all: number
  }


  export type Problem_attachment_contentAvgAggregateInputType = {
    attachmentid?: true
  }

  export type Problem_attachment_contentSumAggregateInputType = {
    attachmentid?: true
  }

  export type Problem_attachment_contentMinAggregateInputType = {
    attachmentid?: true
    content?: true
  }

  export type Problem_attachment_contentMaxAggregateInputType = {
    attachmentid?: true
    content?: true
  }

  export type Problem_attachment_contentCountAggregateInputType = {
    attachmentid?: true
    content?: true
    _all?: true
  }

  export type Problem_attachment_contentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which problem_attachment_content to aggregate.
     */
    where?: problem_attachment_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problem_attachment_contents to fetch.
     */
    orderBy?: problem_attachment_contentOrderByWithRelationInput | problem_attachment_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: problem_attachment_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problem_attachment_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problem_attachment_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned problem_attachment_contents
    **/
    _count?: true | Problem_attachment_contentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Problem_attachment_contentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Problem_attachment_contentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Problem_attachment_contentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Problem_attachment_contentMaxAggregateInputType
  }

  export type GetProblem_attachment_contentAggregateType<T extends Problem_attachment_contentAggregateArgs> = {
        [P in keyof T & keyof AggregateProblem_attachment_content]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProblem_attachment_content[P]>
      : GetScalarType<T[P], AggregateProblem_attachment_content[P]>
  }




  export type problem_attachment_contentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: problem_attachment_contentWhereInput
    orderBy?: problem_attachment_contentOrderByWithAggregationInput | problem_attachment_contentOrderByWithAggregationInput[]
    by: Problem_attachment_contentScalarFieldEnum[] | Problem_attachment_contentScalarFieldEnum
    having?: problem_attachment_contentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Problem_attachment_contentCountAggregateInputType | true
    _avg?: Problem_attachment_contentAvgAggregateInputType
    _sum?: Problem_attachment_contentSumAggregateInputType
    _min?: Problem_attachment_contentMinAggregateInputType
    _max?: Problem_attachment_contentMaxAggregateInputType
  }

  export type Problem_attachment_contentGroupByOutputType = {
    attachmentid: number
    content: Buffer
    _count: Problem_attachment_contentCountAggregateOutputType | null
    _avg: Problem_attachment_contentAvgAggregateOutputType | null
    _sum: Problem_attachment_contentSumAggregateOutputType | null
    _min: Problem_attachment_contentMinAggregateOutputType | null
    _max: Problem_attachment_contentMaxAggregateOutputType | null
  }

  type GetProblem_attachment_contentGroupByPayload<T extends problem_attachment_contentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Problem_attachment_contentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Problem_attachment_contentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Problem_attachment_contentGroupByOutputType[P]>
            : GetScalarType<T[P], Problem_attachment_contentGroupByOutputType[P]>
        }
      >
    >


  export type problem_attachment_contentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    attachmentid?: boolean
    content?: boolean
    problem_attachment?: boolean | problem_attachmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["problem_attachment_content"]>

  export type problem_attachment_contentSelectScalar = {
    attachmentid?: boolean
    content?: boolean
  }

  export type problem_attachment_contentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    problem_attachment?: boolean | problem_attachmentDefaultArgs<ExtArgs>
  }


  export type $problem_attachment_contentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "problem_attachment_content"
    objects: {
      problem_attachment: Prisma.$problem_attachmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      attachmentid: number
      content: Buffer
    }, ExtArgs["result"]["problem_attachment_content"]>
    composites: {}
  }


  type problem_attachment_contentGetPayload<S extends boolean | null | undefined | problem_attachment_contentDefaultArgs> = $Result.GetResult<Prisma.$problem_attachment_contentPayload, S>

  type problem_attachment_contentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<problem_attachment_contentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Problem_attachment_contentCountAggregateInputType | true
    }

  export interface problem_attachment_contentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['problem_attachment_content'], meta: { name: 'problem_attachment_content' } }
    /**
     * Find zero or one Problem_attachment_content that matches the filter.
     * @param {problem_attachment_contentFindUniqueArgs} args - Arguments to find a Problem_attachment_content
     * @example
     * // Get one Problem_attachment_content
     * const problem_attachment_content = await prisma.problem_attachment_content.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends problem_attachment_contentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, problem_attachment_contentFindUniqueArgs<ExtArgs>>
    ): Prisma__problem_attachment_contentClient<$Result.GetResult<Prisma.$problem_attachment_contentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Problem_attachment_content that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {problem_attachment_contentFindUniqueOrThrowArgs} args - Arguments to find a Problem_attachment_content
     * @example
     * // Get one Problem_attachment_content
     * const problem_attachment_content = await prisma.problem_attachment_content.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends problem_attachment_contentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, problem_attachment_contentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__problem_attachment_contentClient<$Result.GetResult<Prisma.$problem_attachment_contentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Problem_attachment_content that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problem_attachment_contentFindFirstArgs} args - Arguments to find a Problem_attachment_content
     * @example
     * // Get one Problem_attachment_content
     * const problem_attachment_content = await prisma.problem_attachment_content.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends problem_attachment_contentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, problem_attachment_contentFindFirstArgs<ExtArgs>>
    ): Prisma__problem_attachment_contentClient<$Result.GetResult<Prisma.$problem_attachment_contentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Problem_attachment_content that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problem_attachment_contentFindFirstOrThrowArgs} args - Arguments to find a Problem_attachment_content
     * @example
     * // Get one Problem_attachment_content
     * const problem_attachment_content = await prisma.problem_attachment_content.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends problem_attachment_contentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, problem_attachment_contentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__problem_attachment_contentClient<$Result.GetResult<Prisma.$problem_attachment_contentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Problem_attachment_contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problem_attachment_contentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Problem_attachment_contents
     * const problem_attachment_contents = await prisma.problem_attachment_content.findMany()
     * 
     * // Get first 10 Problem_attachment_contents
     * const problem_attachment_contents = await prisma.problem_attachment_content.findMany({ take: 10 })
     * 
     * // Only select the `attachmentid`
     * const problem_attachment_contentWithAttachmentidOnly = await prisma.problem_attachment_content.findMany({ select: { attachmentid: true } })
     * 
    **/
    findMany<T extends problem_attachment_contentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, problem_attachment_contentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$problem_attachment_contentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Problem_attachment_content.
     * @param {problem_attachment_contentCreateArgs} args - Arguments to create a Problem_attachment_content.
     * @example
     * // Create one Problem_attachment_content
     * const Problem_attachment_content = await prisma.problem_attachment_content.create({
     *   data: {
     *     // ... data to create a Problem_attachment_content
     *   }
     * })
     * 
    **/
    create<T extends problem_attachment_contentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, problem_attachment_contentCreateArgs<ExtArgs>>
    ): Prisma__problem_attachment_contentClient<$Result.GetResult<Prisma.$problem_attachment_contentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Problem_attachment_contents.
     *     @param {problem_attachment_contentCreateManyArgs} args - Arguments to create many Problem_attachment_contents.
     *     @example
     *     // Create many Problem_attachment_contents
     *     const problem_attachment_content = await prisma.problem_attachment_content.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends problem_attachment_contentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, problem_attachment_contentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Problem_attachment_content.
     * @param {problem_attachment_contentDeleteArgs} args - Arguments to delete one Problem_attachment_content.
     * @example
     * // Delete one Problem_attachment_content
     * const Problem_attachment_content = await prisma.problem_attachment_content.delete({
     *   where: {
     *     // ... filter to delete one Problem_attachment_content
     *   }
     * })
     * 
    **/
    delete<T extends problem_attachment_contentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, problem_attachment_contentDeleteArgs<ExtArgs>>
    ): Prisma__problem_attachment_contentClient<$Result.GetResult<Prisma.$problem_attachment_contentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Problem_attachment_content.
     * @param {problem_attachment_contentUpdateArgs} args - Arguments to update one Problem_attachment_content.
     * @example
     * // Update one Problem_attachment_content
     * const problem_attachment_content = await prisma.problem_attachment_content.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends problem_attachment_contentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, problem_attachment_contentUpdateArgs<ExtArgs>>
    ): Prisma__problem_attachment_contentClient<$Result.GetResult<Prisma.$problem_attachment_contentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Problem_attachment_contents.
     * @param {problem_attachment_contentDeleteManyArgs} args - Arguments to filter Problem_attachment_contents to delete.
     * @example
     * // Delete a few Problem_attachment_contents
     * const { count } = await prisma.problem_attachment_content.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends problem_attachment_contentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, problem_attachment_contentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Problem_attachment_contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problem_attachment_contentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Problem_attachment_contents
     * const problem_attachment_content = await prisma.problem_attachment_content.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends problem_attachment_contentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, problem_attachment_contentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Problem_attachment_content.
     * @param {problem_attachment_contentUpsertArgs} args - Arguments to update or create a Problem_attachment_content.
     * @example
     * // Update or create a Problem_attachment_content
     * const problem_attachment_content = await prisma.problem_attachment_content.upsert({
     *   create: {
     *     // ... data to create a Problem_attachment_content
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Problem_attachment_content we want to update
     *   }
     * })
    **/
    upsert<T extends problem_attachment_contentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, problem_attachment_contentUpsertArgs<ExtArgs>>
    ): Prisma__problem_attachment_contentClient<$Result.GetResult<Prisma.$problem_attachment_contentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Problem_attachment_contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problem_attachment_contentCountArgs} args - Arguments to filter Problem_attachment_contents to count.
     * @example
     * // Count the number of Problem_attachment_contents
     * const count = await prisma.problem_attachment_content.count({
     *   where: {
     *     // ... the filter for the Problem_attachment_contents we want to count
     *   }
     * })
    **/
    count<T extends problem_attachment_contentCountArgs>(
      args?: Subset<T, problem_attachment_contentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Problem_attachment_contentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Problem_attachment_content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Problem_attachment_contentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Problem_attachment_contentAggregateArgs>(args: Subset<T, Problem_attachment_contentAggregateArgs>): Prisma.PrismaPromise<GetProblem_attachment_contentAggregateType<T>>

    /**
     * Group by Problem_attachment_content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problem_attachment_contentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends problem_attachment_contentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: problem_attachment_contentGroupByArgs['orderBy'] }
        : { orderBy?: problem_attachment_contentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, problem_attachment_contentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProblem_attachment_contentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the problem_attachment_content model
   */
  readonly fields: problem_attachment_contentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for problem_attachment_content.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__problem_attachment_contentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    problem_attachment<T extends problem_attachmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, problem_attachmentDefaultArgs<ExtArgs>>): Prisma__problem_attachmentClient<$Result.GetResult<Prisma.$problem_attachmentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the problem_attachment_content model
   */ 
  interface problem_attachment_contentFieldRefs {
    readonly attachmentid: FieldRef<"problem_attachment_content", 'Int'>
    readonly content: FieldRef<"problem_attachment_content", 'Bytes'>
  }
    

  // Custom InputTypes

  /**
   * problem_attachment_content findUnique
   */
  export type problem_attachment_contentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment_content
     */
    select?: problem_attachment_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachment_contentInclude<ExtArgs> | null
    /**
     * Filter, which problem_attachment_content to fetch.
     */
    where: problem_attachment_contentWhereUniqueInput
  }


  /**
   * problem_attachment_content findUniqueOrThrow
   */
  export type problem_attachment_contentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment_content
     */
    select?: problem_attachment_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachment_contentInclude<ExtArgs> | null
    /**
     * Filter, which problem_attachment_content to fetch.
     */
    where: problem_attachment_contentWhereUniqueInput
  }


  /**
   * problem_attachment_content findFirst
   */
  export type problem_attachment_contentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment_content
     */
    select?: problem_attachment_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachment_contentInclude<ExtArgs> | null
    /**
     * Filter, which problem_attachment_content to fetch.
     */
    where?: problem_attachment_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problem_attachment_contents to fetch.
     */
    orderBy?: problem_attachment_contentOrderByWithRelationInput | problem_attachment_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for problem_attachment_contents.
     */
    cursor?: problem_attachment_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problem_attachment_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problem_attachment_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of problem_attachment_contents.
     */
    distinct?: Problem_attachment_contentScalarFieldEnum | Problem_attachment_contentScalarFieldEnum[]
  }


  /**
   * problem_attachment_content findFirstOrThrow
   */
  export type problem_attachment_contentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment_content
     */
    select?: problem_attachment_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachment_contentInclude<ExtArgs> | null
    /**
     * Filter, which problem_attachment_content to fetch.
     */
    where?: problem_attachment_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problem_attachment_contents to fetch.
     */
    orderBy?: problem_attachment_contentOrderByWithRelationInput | problem_attachment_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for problem_attachment_contents.
     */
    cursor?: problem_attachment_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problem_attachment_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problem_attachment_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of problem_attachment_contents.
     */
    distinct?: Problem_attachment_contentScalarFieldEnum | Problem_attachment_contentScalarFieldEnum[]
  }


  /**
   * problem_attachment_content findMany
   */
  export type problem_attachment_contentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment_content
     */
    select?: problem_attachment_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachment_contentInclude<ExtArgs> | null
    /**
     * Filter, which problem_attachment_contents to fetch.
     */
    where?: problem_attachment_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problem_attachment_contents to fetch.
     */
    orderBy?: problem_attachment_contentOrderByWithRelationInput | problem_attachment_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing problem_attachment_contents.
     */
    cursor?: problem_attachment_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problem_attachment_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problem_attachment_contents.
     */
    skip?: number
    distinct?: Problem_attachment_contentScalarFieldEnum | Problem_attachment_contentScalarFieldEnum[]
  }


  /**
   * problem_attachment_content create
   */
  export type problem_attachment_contentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment_content
     */
    select?: problem_attachment_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachment_contentInclude<ExtArgs> | null
    /**
     * The data needed to create a problem_attachment_content.
     */
    data: XOR<problem_attachment_contentCreateInput, problem_attachment_contentUncheckedCreateInput>
  }


  /**
   * problem_attachment_content createMany
   */
  export type problem_attachment_contentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many problem_attachment_contents.
     */
    data: problem_attachment_contentCreateManyInput | problem_attachment_contentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * problem_attachment_content update
   */
  export type problem_attachment_contentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment_content
     */
    select?: problem_attachment_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachment_contentInclude<ExtArgs> | null
    /**
     * The data needed to update a problem_attachment_content.
     */
    data: XOR<problem_attachment_contentUpdateInput, problem_attachment_contentUncheckedUpdateInput>
    /**
     * Choose, which problem_attachment_content to update.
     */
    where: problem_attachment_contentWhereUniqueInput
  }


  /**
   * problem_attachment_content updateMany
   */
  export type problem_attachment_contentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update problem_attachment_contents.
     */
    data: XOR<problem_attachment_contentUpdateManyMutationInput, problem_attachment_contentUncheckedUpdateManyInput>
    /**
     * Filter which problem_attachment_contents to update
     */
    where?: problem_attachment_contentWhereInput
  }


  /**
   * problem_attachment_content upsert
   */
  export type problem_attachment_contentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment_content
     */
    select?: problem_attachment_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachment_contentInclude<ExtArgs> | null
    /**
     * The filter to search for the problem_attachment_content to update in case it exists.
     */
    where: problem_attachment_contentWhereUniqueInput
    /**
     * In case the problem_attachment_content found by the `where` argument doesn't exist, create a new problem_attachment_content with this data.
     */
    create: XOR<problem_attachment_contentCreateInput, problem_attachment_contentUncheckedCreateInput>
    /**
     * In case the problem_attachment_content was found with the provided `where` argument, update it with this data.
     */
    update: XOR<problem_attachment_contentUpdateInput, problem_attachment_contentUncheckedUpdateInput>
  }


  /**
   * problem_attachment_content delete
   */
  export type problem_attachment_contentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment_content
     */
    select?: problem_attachment_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachment_contentInclude<ExtArgs> | null
    /**
     * Filter which problem_attachment_content to delete.
     */
    where: problem_attachment_contentWhereUniqueInput
  }


  /**
   * problem_attachment_content deleteMany
   */
  export type problem_attachment_contentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which problem_attachment_contents to delete
     */
    where?: problem_attachment_contentWhereInput
  }


  /**
   * problem_attachment_content without action
   */
  export type problem_attachment_contentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_attachment_content
     */
    select?: problem_attachment_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problem_attachment_contentInclude<ExtArgs> | null
  }



  /**
   * Model queuetask
   */

  export type AggregateQueuetask = {
    _count: QueuetaskCountAggregateOutputType | null
    _avg: QueuetaskAvgAggregateOutputType | null
    _sum: QueuetaskSumAggregateOutputType | null
    _min: QueuetaskMinAggregateOutputType | null
    _max: QueuetaskMaxAggregateOutputType | null
  }

  export type QueuetaskAvgAggregateOutputType = {
    queuetaskid: number | null
    teamid: number | null
    jobid: number | null
    priority: number | null
    teampriority: number | null
    starttime: Decimal | null
  }

  export type QueuetaskSumAggregateOutputType = {
    queuetaskid: number | null
    teamid: number | null
    jobid: number | null
    priority: number | null
    teampriority: number | null
    starttime: Decimal | null
  }

  export type QueuetaskMinAggregateOutputType = {
    queuetaskid: number | null
    teamid: number | null
    jobid: number | null
    priority: number | null
    teampriority: number | null
    starttime: Decimal | null
  }

  export type QueuetaskMaxAggregateOutputType = {
    queuetaskid: number | null
    teamid: number | null
    jobid: number | null
    priority: number | null
    teampriority: number | null
    starttime: Decimal | null
  }

  export type QueuetaskCountAggregateOutputType = {
    queuetaskid: number
    teamid: number
    jobid: number
    priority: number
    teampriority: number
    starttime: number
    _all: number
  }


  export type QueuetaskAvgAggregateInputType = {
    queuetaskid?: true
    teamid?: true
    jobid?: true
    priority?: true
    teampriority?: true
    starttime?: true
  }

  export type QueuetaskSumAggregateInputType = {
    queuetaskid?: true
    teamid?: true
    jobid?: true
    priority?: true
    teampriority?: true
    starttime?: true
  }

  export type QueuetaskMinAggregateInputType = {
    queuetaskid?: true
    teamid?: true
    jobid?: true
    priority?: true
    teampriority?: true
    starttime?: true
  }

  export type QueuetaskMaxAggregateInputType = {
    queuetaskid?: true
    teamid?: true
    jobid?: true
    priority?: true
    teampriority?: true
    starttime?: true
  }

  export type QueuetaskCountAggregateInputType = {
    queuetaskid?: true
    teamid?: true
    jobid?: true
    priority?: true
    teampriority?: true
    starttime?: true
    _all?: true
  }

  export type QueuetaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which queuetask to aggregate.
     */
    where?: queuetaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of queuetasks to fetch.
     */
    orderBy?: queuetaskOrderByWithRelationInput | queuetaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: queuetaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` queuetasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` queuetasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned queuetasks
    **/
    _count?: true | QueuetaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QueuetaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QueuetaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueuetaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueuetaskMaxAggregateInputType
  }

  export type GetQueuetaskAggregateType<T extends QueuetaskAggregateArgs> = {
        [P in keyof T & keyof AggregateQueuetask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueuetask[P]>
      : GetScalarType<T[P], AggregateQueuetask[P]>
  }




  export type queuetaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: queuetaskWhereInput
    orderBy?: queuetaskOrderByWithAggregationInput | queuetaskOrderByWithAggregationInput[]
    by: QueuetaskScalarFieldEnum[] | QueuetaskScalarFieldEnum
    having?: queuetaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueuetaskCountAggregateInputType | true
    _avg?: QueuetaskAvgAggregateInputType
    _sum?: QueuetaskSumAggregateInputType
    _min?: QueuetaskMinAggregateInputType
    _max?: QueuetaskMaxAggregateInputType
  }

  export type QueuetaskGroupByOutputType = {
    queuetaskid: number
    teamid: number | null
    jobid: number | null
    priority: number
    teampriority: number
    starttime: Decimal | null
    _count: QueuetaskCountAggregateOutputType | null
    _avg: QueuetaskAvgAggregateOutputType | null
    _sum: QueuetaskSumAggregateOutputType | null
    _min: QueuetaskMinAggregateOutputType | null
    _max: QueuetaskMaxAggregateOutputType | null
  }

  type GetQueuetaskGroupByPayload<T extends queuetaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueuetaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueuetaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueuetaskGroupByOutputType[P]>
            : GetScalarType<T[P], QueuetaskGroupByOutputType[P]>
        }
      >
    >


  export type queuetaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    queuetaskid?: boolean
    teamid?: boolean
    jobid?: boolean
    priority?: boolean
    teampriority?: boolean
    starttime?: boolean
    team?: boolean | queuetask$teamArgs<ExtArgs>
  }, ExtArgs["result"]["queuetask"]>

  export type queuetaskSelectScalar = {
    queuetaskid?: boolean
    teamid?: boolean
    jobid?: boolean
    priority?: boolean
    teampriority?: boolean
    starttime?: boolean
  }

  export type queuetaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | queuetask$teamArgs<ExtArgs>
  }


  export type $queuetaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "queuetask"
    objects: {
      team: Prisma.$teamPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      queuetaskid: number
      teamid: number | null
      jobid: number | null
      priority: number
      teampriority: number
      starttime: Prisma.Decimal | null
    }, ExtArgs["result"]["queuetask"]>
    composites: {}
  }


  type queuetaskGetPayload<S extends boolean | null | undefined | queuetaskDefaultArgs> = $Result.GetResult<Prisma.$queuetaskPayload, S>

  type queuetaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<queuetaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QueuetaskCountAggregateInputType | true
    }

  export interface queuetaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['queuetask'], meta: { name: 'queuetask' } }
    /**
     * Find zero or one Queuetask that matches the filter.
     * @param {queuetaskFindUniqueArgs} args - Arguments to find a Queuetask
     * @example
     * // Get one Queuetask
     * const queuetask = await prisma.queuetask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends queuetaskFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, queuetaskFindUniqueArgs<ExtArgs>>
    ): Prisma__queuetaskClient<$Result.GetResult<Prisma.$queuetaskPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Queuetask that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {queuetaskFindUniqueOrThrowArgs} args - Arguments to find a Queuetask
     * @example
     * // Get one Queuetask
     * const queuetask = await prisma.queuetask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends queuetaskFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, queuetaskFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__queuetaskClient<$Result.GetResult<Prisma.$queuetaskPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Queuetask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {queuetaskFindFirstArgs} args - Arguments to find a Queuetask
     * @example
     * // Get one Queuetask
     * const queuetask = await prisma.queuetask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends queuetaskFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, queuetaskFindFirstArgs<ExtArgs>>
    ): Prisma__queuetaskClient<$Result.GetResult<Prisma.$queuetaskPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Queuetask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {queuetaskFindFirstOrThrowArgs} args - Arguments to find a Queuetask
     * @example
     * // Get one Queuetask
     * const queuetask = await prisma.queuetask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends queuetaskFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, queuetaskFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__queuetaskClient<$Result.GetResult<Prisma.$queuetaskPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Queuetasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {queuetaskFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Queuetasks
     * const queuetasks = await prisma.queuetask.findMany()
     * 
     * // Get first 10 Queuetasks
     * const queuetasks = await prisma.queuetask.findMany({ take: 10 })
     * 
     * // Only select the `queuetaskid`
     * const queuetaskWithQueuetaskidOnly = await prisma.queuetask.findMany({ select: { queuetaskid: true } })
     * 
    **/
    findMany<T extends queuetaskFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, queuetaskFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$queuetaskPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Queuetask.
     * @param {queuetaskCreateArgs} args - Arguments to create a Queuetask.
     * @example
     * // Create one Queuetask
     * const Queuetask = await prisma.queuetask.create({
     *   data: {
     *     // ... data to create a Queuetask
     *   }
     * })
     * 
    **/
    create<T extends queuetaskCreateArgs<ExtArgs>>(
      args: SelectSubset<T, queuetaskCreateArgs<ExtArgs>>
    ): Prisma__queuetaskClient<$Result.GetResult<Prisma.$queuetaskPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Queuetasks.
     *     @param {queuetaskCreateManyArgs} args - Arguments to create many Queuetasks.
     *     @example
     *     // Create many Queuetasks
     *     const queuetask = await prisma.queuetask.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends queuetaskCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, queuetaskCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Queuetask.
     * @param {queuetaskDeleteArgs} args - Arguments to delete one Queuetask.
     * @example
     * // Delete one Queuetask
     * const Queuetask = await prisma.queuetask.delete({
     *   where: {
     *     // ... filter to delete one Queuetask
     *   }
     * })
     * 
    **/
    delete<T extends queuetaskDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, queuetaskDeleteArgs<ExtArgs>>
    ): Prisma__queuetaskClient<$Result.GetResult<Prisma.$queuetaskPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Queuetask.
     * @param {queuetaskUpdateArgs} args - Arguments to update one Queuetask.
     * @example
     * // Update one Queuetask
     * const queuetask = await prisma.queuetask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends queuetaskUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, queuetaskUpdateArgs<ExtArgs>>
    ): Prisma__queuetaskClient<$Result.GetResult<Prisma.$queuetaskPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Queuetasks.
     * @param {queuetaskDeleteManyArgs} args - Arguments to filter Queuetasks to delete.
     * @example
     * // Delete a few Queuetasks
     * const { count } = await prisma.queuetask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends queuetaskDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, queuetaskDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Queuetasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {queuetaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Queuetasks
     * const queuetask = await prisma.queuetask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends queuetaskUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, queuetaskUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Queuetask.
     * @param {queuetaskUpsertArgs} args - Arguments to update or create a Queuetask.
     * @example
     * // Update or create a Queuetask
     * const queuetask = await prisma.queuetask.upsert({
     *   create: {
     *     // ... data to create a Queuetask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Queuetask we want to update
     *   }
     * })
    **/
    upsert<T extends queuetaskUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, queuetaskUpsertArgs<ExtArgs>>
    ): Prisma__queuetaskClient<$Result.GetResult<Prisma.$queuetaskPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Queuetasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {queuetaskCountArgs} args - Arguments to filter Queuetasks to count.
     * @example
     * // Count the number of Queuetasks
     * const count = await prisma.queuetask.count({
     *   where: {
     *     // ... the filter for the Queuetasks we want to count
     *   }
     * })
    **/
    count<T extends queuetaskCountArgs>(
      args?: Subset<T, queuetaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueuetaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Queuetask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueuetaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueuetaskAggregateArgs>(args: Subset<T, QueuetaskAggregateArgs>): Prisma.PrismaPromise<GetQueuetaskAggregateType<T>>

    /**
     * Group by Queuetask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {queuetaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends queuetaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: queuetaskGroupByArgs['orderBy'] }
        : { orderBy?: queuetaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, queuetaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueuetaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the queuetask model
   */
  readonly fields: queuetaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for queuetask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__queuetaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    team<T extends queuetask$teamArgs<ExtArgs> = {}>(args?: Subset<T, queuetask$teamArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the queuetask model
   */ 
  interface queuetaskFieldRefs {
    readonly queuetaskid: FieldRef<"queuetask", 'Int'>
    readonly teamid: FieldRef<"queuetask", 'Int'>
    readonly jobid: FieldRef<"queuetask", 'Int'>
    readonly priority: FieldRef<"queuetask", 'Int'>
    readonly teampriority: FieldRef<"queuetask", 'Int'>
    readonly starttime: FieldRef<"queuetask", 'Decimal'>
  }
    

  // Custom InputTypes

  /**
   * queuetask findUnique
   */
  export type queuetaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queuetask
     */
    select?: queuetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: queuetaskInclude<ExtArgs> | null
    /**
     * Filter, which queuetask to fetch.
     */
    where: queuetaskWhereUniqueInput
  }


  /**
   * queuetask findUniqueOrThrow
   */
  export type queuetaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queuetask
     */
    select?: queuetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: queuetaskInclude<ExtArgs> | null
    /**
     * Filter, which queuetask to fetch.
     */
    where: queuetaskWhereUniqueInput
  }


  /**
   * queuetask findFirst
   */
  export type queuetaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queuetask
     */
    select?: queuetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: queuetaskInclude<ExtArgs> | null
    /**
     * Filter, which queuetask to fetch.
     */
    where?: queuetaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of queuetasks to fetch.
     */
    orderBy?: queuetaskOrderByWithRelationInput | queuetaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for queuetasks.
     */
    cursor?: queuetaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` queuetasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` queuetasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of queuetasks.
     */
    distinct?: QueuetaskScalarFieldEnum | QueuetaskScalarFieldEnum[]
  }


  /**
   * queuetask findFirstOrThrow
   */
  export type queuetaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queuetask
     */
    select?: queuetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: queuetaskInclude<ExtArgs> | null
    /**
     * Filter, which queuetask to fetch.
     */
    where?: queuetaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of queuetasks to fetch.
     */
    orderBy?: queuetaskOrderByWithRelationInput | queuetaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for queuetasks.
     */
    cursor?: queuetaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` queuetasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` queuetasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of queuetasks.
     */
    distinct?: QueuetaskScalarFieldEnum | QueuetaskScalarFieldEnum[]
  }


  /**
   * queuetask findMany
   */
  export type queuetaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queuetask
     */
    select?: queuetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: queuetaskInclude<ExtArgs> | null
    /**
     * Filter, which queuetasks to fetch.
     */
    where?: queuetaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of queuetasks to fetch.
     */
    orderBy?: queuetaskOrderByWithRelationInput | queuetaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing queuetasks.
     */
    cursor?: queuetaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` queuetasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` queuetasks.
     */
    skip?: number
    distinct?: QueuetaskScalarFieldEnum | QueuetaskScalarFieldEnum[]
  }


  /**
   * queuetask create
   */
  export type queuetaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queuetask
     */
    select?: queuetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: queuetaskInclude<ExtArgs> | null
    /**
     * The data needed to create a queuetask.
     */
    data: XOR<queuetaskCreateInput, queuetaskUncheckedCreateInput>
  }


  /**
   * queuetask createMany
   */
  export type queuetaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many queuetasks.
     */
    data: queuetaskCreateManyInput | queuetaskCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * queuetask update
   */
  export type queuetaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queuetask
     */
    select?: queuetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: queuetaskInclude<ExtArgs> | null
    /**
     * The data needed to update a queuetask.
     */
    data: XOR<queuetaskUpdateInput, queuetaskUncheckedUpdateInput>
    /**
     * Choose, which queuetask to update.
     */
    where: queuetaskWhereUniqueInput
  }


  /**
   * queuetask updateMany
   */
  export type queuetaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update queuetasks.
     */
    data: XOR<queuetaskUpdateManyMutationInput, queuetaskUncheckedUpdateManyInput>
    /**
     * Filter which queuetasks to update
     */
    where?: queuetaskWhereInput
  }


  /**
   * queuetask upsert
   */
  export type queuetaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queuetask
     */
    select?: queuetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: queuetaskInclude<ExtArgs> | null
    /**
     * The filter to search for the queuetask to update in case it exists.
     */
    where: queuetaskWhereUniqueInput
    /**
     * In case the queuetask found by the `where` argument doesn't exist, create a new queuetask with this data.
     */
    create: XOR<queuetaskCreateInput, queuetaskUncheckedCreateInput>
    /**
     * In case the queuetask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<queuetaskUpdateInput, queuetaskUncheckedUpdateInput>
  }


  /**
   * queuetask delete
   */
  export type queuetaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queuetask
     */
    select?: queuetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: queuetaskInclude<ExtArgs> | null
    /**
     * Filter which queuetask to delete.
     */
    where: queuetaskWhereUniqueInput
  }


  /**
   * queuetask deleteMany
   */
  export type queuetaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which queuetasks to delete
     */
    where?: queuetaskWhereInput
  }


  /**
   * queuetask.team
   */
  export type queuetask$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    where?: teamWhereInput
  }


  /**
   * queuetask without action
   */
  export type queuetaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queuetask
     */
    select?: queuetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: queuetaskInclude<ExtArgs> | null
  }



  /**
   * Model rankcache
   */

  export type AggregateRankcache = {
    _count: RankcacheCountAggregateOutputType | null
    _avg: RankcacheAvgAggregateOutputType | null
    _sum: RankcacheSumAggregateOutputType | null
    _min: RankcacheMinAggregateOutputType | null
    _max: RankcacheMaxAggregateOutputType | null
  }

  export type RankcacheAvgAggregateOutputType = {
    cid: number | null
    teamid: number | null
    points_restricted: number | null
    totaltime_restricted: number | null
    points_public: number | null
    totaltime_public: number | null
  }

  export type RankcacheSumAggregateOutputType = {
    cid: number | null
    teamid: number | null
    points_restricted: number | null
    totaltime_restricted: number | null
    points_public: number | null
    totaltime_public: number | null
  }

  export type RankcacheMinAggregateOutputType = {
    cid: number | null
    teamid: number | null
    points_restricted: number | null
    totaltime_restricted: number | null
    points_public: number | null
    totaltime_public: number | null
  }

  export type RankcacheMaxAggregateOutputType = {
    cid: number | null
    teamid: number | null
    points_restricted: number | null
    totaltime_restricted: number | null
    points_public: number | null
    totaltime_public: number | null
  }

  export type RankcacheCountAggregateOutputType = {
    cid: number
    teamid: number
    points_restricted: number
    totaltime_restricted: number
    points_public: number
    totaltime_public: number
    _all: number
  }


  export type RankcacheAvgAggregateInputType = {
    cid?: true
    teamid?: true
    points_restricted?: true
    totaltime_restricted?: true
    points_public?: true
    totaltime_public?: true
  }

  export type RankcacheSumAggregateInputType = {
    cid?: true
    teamid?: true
    points_restricted?: true
    totaltime_restricted?: true
    points_public?: true
    totaltime_public?: true
  }

  export type RankcacheMinAggregateInputType = {
    cid?: true
    teamid?: true
    points_restricted?: true
    totaltime_restricted?: true
    points_public?: true
    totaltime_public?: true
  }

  export type RankcacheMaxAggregateInputType = {
    cid?: true
    teamid?: true
    points_restricted?: true
    totaltime_restricted?: true
    points_public?: true
    totaltime_public?: true
  }

  export type RankcacheCountAggregateInputType = {
    cid?: true
    teamid?: true
    points_restricted?: true
    totaltime_restricted?: true
    points_public?: true
    totaltime_public?: true
    _all?: true
  }

  export type RankcacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rankcache to aggregate.
     */
    where?: rankcacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rankcaches to fetch.
     */
    orderBy?: rankcacheOrderByWithRelationInput | rankcacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rankcacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rankcaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rankcaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rankcaches
    **/
    _count?: true | RankcacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RankcacheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RankcacheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RankcacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RankcacheMaxAggregateInputType
  }

  export type GetRankcacheAggregateType<T extends RankcacheAggregateArgs> = {
        [P in keyof T & keyof AggregateRankcache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRankcache[P]>
      : GetScalarType<T[P], AggregateRankcache[P]>
  }




  export type rankcacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rankcacheWhereInput
    orderBy?: rankcacheOrderByWithAggregationInput | rankcacheOrderByWithAggregationInput[]
    by: RankcacheScalarFieldEnum[] | RankcacheScalarFieldEnum
    having?: rankcacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RankcacheCountAggregateInputType | true
    _avg?: RankcacheAvgAggregateInputType
    _sum?: RankcacheSumAggregateInputType
    _min?: RankcacheMinAggregateInputType
    _max?: RankcacheMaxAggregateInputType
  }

  export type RankcacheGroupByOutputType = {
    cid: number
    teamid: number
    points_restricted: number
    totaltime_restricted: number
    points_public: number
    totaltime_public: number
    _count: RankcacheCountAggregateOutputType | null
    _avg: RankcacheAvgAggregateOutputType | null
    _sum: RankcacheSumAggregateOutputType | null
    _min: RankcacheMinAggregateOutputType | null
    _max: RankcacheMaxAggregateOutputType | null
  }

  type GetRankcacheGroupByPayload<T extends rankcacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RankcacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RankcacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RankcacheGroupByOutputType[P]>
            : GetScalarType<T[P], RankcacheGroupByOutputType[P]>
        }
      >
    >


  export type rankcacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cid?: boolean
    teamid?: boolean
    points_restricted?: boolean
    totaltime_restricted?: boolean
    points_public?: boolean
    totaltime_public?: boolean
    contest?: boolean | contestDefaultArgs<ExtArgs>
    team?: boolean | teamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rankcache"]>

  export type rankcacheSelectScalar = {
    cid?: boolean
    teamid?: boolean
    points_restricted?: boolean
    totaltime_restricted?: boolean
    points_public?: boolean
    totaltime_public?: boolean
  }

  export type rankcacheInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contest?: boolean | contestDefaultArgs<ExtArgs>
    team?: boolean | teamDefaultArgs<ExtArgs>
  }


  export type $rankcachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rankcache"
    objects: {
      contest: Prisma.$contestPayload<ExtArgs>
      team: Prisma.$teamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cid: number
      teamid: number
      points_restricted: number
      totaltime_restricted: number
      points_public: number
      totaltime_public: number
    }, ExtArgs["result"]["rankcache"]>
    composites: {}
  }


  type rankcacheGetPayload<S extends boolean | null | undefined | rankcacheDefaultArgs> = $Result.GetResult<Prisma.$rankcachePayload, S>

  type rankcacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rankcacheFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RankcacheCountAggregateInputType | true
    }

  export interface rankcacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rankcache'], meta: { name: 'rankcache' } }
    /**
     * Find zero or one Rankcache that matches the filter.
     * @param {rankcacheFindUniqueArgs} args - Arguments to find a Rankcache
     * @example
     * // Get one Rankcache
     * const rankcache = await prisma.rankcache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rankcacheFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, rankcacheFindUniqueArgs<ExtArgs>>
    ): Prisma__rankcacheClient<$Result.GetResult<Prisma.$rankcachePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Rankcache that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {rankcacheFindUniqueOrThrowArgs} args - Arguments to find a Rankcache
     * @example
     * // Get one Rankcache
     * const rankcache = await prisma.rankcache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends rankcacheFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rankcacheFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__rankcacheClient<$Result.GetResult<Prisma.$rankcachePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Rankcache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rankcacheFindFirstArgs} args - Arguments to find a Rankcache
     * @example
     * // Get one Rankcache
     * const rankcache = await prisma.rankcache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rankcacheFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, rankcacheFindFirstArgs<ExtArgs>>
    ): Prisma__rankcacheClient<$Result.GetResult<Prisma.$rankcachePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Rankcache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rankcacheFindFirstOrThrowArgs} args - Arguments to find a Rankcache
     * @example
     * // Get one Rankcache
     * const rankcache = await prisma.rankcache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends rankcacheFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rankcacheFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__rankcacheClient<$Result.GetResult<Prisma.$rankcachePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Rankcaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rankcacheFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rankcaches
     * const rankcaches = await prisma.rankcache.findMany()
     * 
     * // Get first 10 Rankcaches
     * const rankcaches = await prisma.rankcache.findMany({ take: 10 })
     * 
     * // Only select the `cid`
     * const rankcacheWithCidOnly = await prisma.rankcache.findMany({ select: { cid: true } })
     * 
    **/
    findMany<T extends rankcacheFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rankcacheFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rankcachePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Rankcache.
     * @param {rankcacheCreateArgs} args - Arguments to create a Rankcache.
     * @example
     * // Create one Rankcache
     * const Rankcache = await prisma.rankcache.create({
     *   data: {
     *     // ... data to create a Rankcache
     *   }
     * })
     * 
    **/
    create<T extends rankcacheCreateArgs<ExtArgs>>(
      args: SelectSubset<T, rankcacheCreateArgs<ExtArgs>>
    ): Prisma__rankcacheClient<$Result.GetResult<Prisma.$rankcachePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Rankcaches.
     *     @param {rankcacheCreateManyArgs} args - Arguments to create many Rankcaches.
     *     @example
     *     // Create many Rankcaches
     *     const rankcache = await prisma.rankcache.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends rankcacheCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rankcacheCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rankcache.
     * @param {rankcacheDeleteArgs} args - Arguments to delete one Rankcache.
     * @example
     * // Delete one Rankcache
     * const Rankcache = await prisma.rankcache.delete({
     *   where: {
     *     // ... filter to delete one Rankcache
     *   }
     * })
     * 
    **/
    delete<T extends rankcacheDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, rankcacheDeleteArgs<ExtArgs>>
    ): Prisma__rankcacheClient<$Result.GetResult<Prisma.$rankcachePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Rankcache.
     * @param {rankcacheUpdateArgs} args - Arguments to update one Rankcache.
     * @example
     * // Update one Rankcache
     * const rankcache = await prisma.rankcache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rankcacheUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, rankcacheUpdateArgs<ExtArgs>>
    ): Prisma__rankcacheClient<$Result.GetResult<Prisma.$rankcachePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Rankcaches.
     * @param {rankcacheDeleteManyArgs} args - Arguments to filter Rankcaches to delete.
     * @example
     * // Delete a few Rankcaches
     * const { count } = await prisma.rankcache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rankcacheDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rankcacheDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rankcaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rankcacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rankcaches
     * const rankcache = await prisma.rankcache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rankcacheUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, rankcacheUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rankcache.
     * @param {rankcacheUpsertArgs} args - Arguments to update or create a Rankcache.
     * @example
     * // Update or create a Rankcache
     * const rankcache = await prisma.rankcache.upsert({
     *   create: {
     *     // ... data to create a Rankcache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rankcache we want to update
     *   }
     * })
    **/
    upsert<T extends rankcacheUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, rankcacheUpsertArgs<ExtArgs>>
    ): Prisma__rankcacheClient<$Result.GetResult<Prisma.$rankcachePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Rankcaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rankcacheCountArgs} args - Arguments to filter Rankcaches to count.
     * @example
     * // Count the number of Rankcaches
     * const count = await prisma.rankcache.count({
     *   where: {
     *     // ... the filter for the Rankcaches we want to count
     *   }
     * })
    **/
    count<T extends rankcacheCountArgs>(
      args?: Subset<T, rankcacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RankcacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rankcache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankcacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RankcacheAggregateArgs>(args: Subset<T, RankcacheAggregateArgs>): Prisma.PrismaPromise<GetRankcacheAggregateType<T>>

    /**
     * Group by Rankcache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rankcacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rankcacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rankcacheGroupByArgs['orderBy'] }
        : { orderBy?: rankcacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rankcacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRankcacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rankcache model
   */
  readonly fields: rankcacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rankcache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rankcacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contest<T extends contestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, contestDefaultArgs<ExtArgs>>): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    team<T extends teamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teamDefaultArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the rankcache model
   */ 
  interface rankcacheFieldRefs {
    readonly cid: FieldRef<"rankcache", 'Int'>
    readonly teamid: FieldRef<"rankcache", 'Int'>
    readonly points_restricted: FieldRef<"rankcache", 'Int'>
    readonly totaltime_restricted: FieldRef<"rankcache", 'Int'>
    readonly points_public: FieldRef<"rankcache", 'Int'>
    readonly totaltime_public: FieldRef<"rankcache", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * rankcache findUnique
   */
  export type rankcacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rankcache
     */
    select?: rankcacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rankcacheInclude<ExtArgs> | null
    /**
     * Filter, which rankcache to fetch.
     */
    where: rankcacheWhereUniqueInput
  }


  /**
   * rankcache findUniqueOrThrow
   */
  export type rankcacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rankcache
     */
    select?: rankcacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rankcacheInclude<ExtArgs> | null
    /**
     * Filter, which rankcache to fetch.
     */
    where: rankcacheWhereUniqueInput
  }


  /**
   * rankcache findFirst
   */
  export type rankcacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rankcache
     */
    select?: rankcacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rankcacheInclude<ExtArgs> | null
    /**
     * Filter, which rankcache to fetch.
     */
    where?: rankcacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rankcaches to fetch.
     */
    orderBy?: rankcacheOrderByWithRelationInput | rankcacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rankcaches.
     */
    cursor?: rankcacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rankcaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rankcaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rankcaches.
     */
    distinct?: RankcacheScalarFieldEnum | RankcacheScalarFieldEnum[]
  }


  /**
   * rankcache findFirstOrThrow
   */
  export type rankcacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rankcache
     */
    select?: rankcacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rankcacheInclude<ExtArgs> | null
    /**
     * Filter, which rankcache to fetch.
     */
    where?: rankcacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rankcaches to fetch.
     */
    orderBy?: rankcacheOrderByWithRelationInput | rankcacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rankcaches.
     */
    cursor?: rankcacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rankcaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rankcaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rankcaches.
     */
    distinct?: RankcacheScalarFieldEnum | RankcacheScalarFieldEnum[]
  }


  /**
   * rankcache findMany
   */
  export type rankcacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rankcache
     */
    select?: rankcacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rankcacheInclude<ExtArgs> | null
    /**
     * Filter, which rankcaches to fetch.
     */
    where?: rankcacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rankcaches to fetch.
     */
    orderBy?: rankcacheOrderByWithRelationInput | rankcacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rankcaches.
     */
    cursor?: rankcacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rankcaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rankcaches.
     */
    skip?: number
    distinct?: RankcacheScalarFieldEnum | RankcacheScalarFieldEnum[]
  }


  /**
   * rankcache create
   */
  export type rankcacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rankcache
     */
    select?: rankcacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rankcacheInclude<ExtArgs> | null
    /**
     * The data needed to create a rankcache.
     */
    data: XOR<rankcacheCreateInput, rankcacheUncheckedCreateInput>
  }


  /**
   * rankcache createMany
   */
  export type rankcacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rankcaches.
     */
    data: rankcacheCreateManyInput | rankcacheCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * rankcache update
   */
  export type rankcacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rankcache
     */
    select?: rankcacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rankcacheInclude<ExtArgs> | null
    /**
     * The data needed to update a rankcache.
     */
    data: XOR<rankcacheUpdateInput, rankcacheUncheckedUpdateInput>
    /**
     * Choose, which rankcache to update.
     */
    where: rankcacheWhereUniqueInput
  }


  /**
   * rankcache updateMany
   */
  export type rankcacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rankcaches.
     */
    data: XOR<rankcacheUpdateManyMutationInput, rankcacheUncheckedUpdateManyInput>
    /**
     * Filter which rankcaches to update
     */
    where?: rankcacheWhereInput
  }


  /**
   * rankcache upsert
   */
  export type rankcacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rankcache
     */
    select?: rankcacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rankcacheInclude<ExtArgs> | null
    /**
     * The filter to search for the rankcache to update in case it exists.
     */
    where: rankcacheWhereUniqueInput
    /**
     * In case the rankcache found by the `where` argument doesn't exist, create a new rankcache with this data.
     */
    create: XOR<rankcacheCreateInput, rankcacheUncheckedCreateInput>
    /**
     * In case the rankcache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rankcacheUpdateInput, rankcacheUncheckedUpdateInput>
  }


  /**
   * rankcache delete
   */
  export type rankcacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rankcache
     */
    select?: rankcacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rankcacheInclude<ExtArgs> | null
    /**
     * Filter which rankcache to delete.
     */
    where: rankcacheWhereUniqueInput
  }


  /**
   * rankcache deleteMany
   */
  export type rankcacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rankcaches to delete
     */
    where?: rankcacheWhereInput
  }


  /**
   * rankcache without action
   */
  export type rankcacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rankcache
     */
    select?: rankcacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rankcacheInclude<ExtArgs> | null
  }



  /**
   * Model rejudging
   */

  export type AggregateRejudging = {
    _count: RejudgingCountAggregateOutputType | null
    _avg: RejudgingAvgAggregateOutputType | null
    _sum: RejudgingSumAggregateOutputType | null
    _min: RejudgingMinAggregateOutputType | null
    _max: RejudgingMaxAggregateOutputType | null
  }

  export type RejudgingAvgAggregateOutputType = {
    rejudgingid: number | null
    userid_start: number | null
    userid_finish: number | null
    starttime: Decimal | null
    endtime: Decimal | null
    repeat: number | null
    repeat_rejudgingid: number | null
  }

  export type RejudgingSumAggregateOutputType = {
    rejudgingid: number | null
    userid_start: number | null
    userid_finish: number | null
    starttime: Decimal | null
    endtime: Decimal | null
    repeat: number | null
    repeat_rejudgingid: number | null
  }

  export type RejudgingMinAggregateOutputType = {
    rejudgingid: number | null
    userid_start: number | null
    userid_finish: number | null
    starttime: Decimal | null
    endtime: Decimal | null
    reason: string | null
    valid: boolean | null
    auto_apply: boolean | null
    repeat: number | null
    repeat_rejudgingid: number | null
  }

  export type RejudgingMaxAggregateOutputType = {
    rejudgingid: number | null
    userid_start: number | null
    userid_finish: number | null
    starttime: Decimal | null
    endtime: Decimal | null
    reason: string | null
    valid: boolean | null
    auto_apply: boolean | null
    repeat: number | null
    repeat_rejudgingid: number | null
  }

  export type RejudgingCountAggregateOutputType = {
    rejudgingid: number
    userid_start: number
    userid_finish: number
    starttime: number
    endtime: number
    reason: number
    valid: number
    auto_apply: number
    repeat: number
    repeat_rejudgingid: number
    _all: number
  }


  export type RejudgingAvgAggregateInputType = {
    rejudgingid?: true
    userid_start?: true
    userid_finish?: true
    starttime?: true
    endtime?: true
    repeat?: true
    repeat_rejudgingid?: true
  }

  export type RejudgingSumAggregateInputType = {
    rejudgingid?: true
    userid_start?: true
    userid_finish?: true
    starttime?: true
    endtime?: true
    repeat?: true
    repeat_rejudgingid?: true
  }

  export type RejudgingMinAggregateInputType = {
    rejudgingid?: true
    userid_start?: true
    userid_finish?: true
    starttime?: true
    endtime?: true
    reason?: true
    valid?: true
    auto_apply?: true
    repeat?: true
    repeat_rejudgingid?: true
  }

  export type RejudgingMaxAggregateInputType = {
    rejudgingid?: true
    userid_start?: true
    userid_finish?: true
    starttime?: true
    endtime?: true
    reason?: true
    valid?: true
    auto_apply?: true
    repeat?: true
    repeat_rejudgingid?: true
  }

  export type RejudgingCountAggregateInputType = {
    rejudgingid?: true
    userid_start?: true
    userid_finish?: true
    starttime?: true
    endtime?: true
    reason?: true
    valid?: true
    auto_apply?: true
    repeat?: true
    repeat_rejudgingid?: true
    _all?: true
  }

  export type RejudgingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rejudging to aggregate.
     */
    where?: rejudgingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rejudgings to fetch.
     */
    orderBy?: rejudgingOrderByWithRelationInput | rejudgingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rejudgingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rejudgings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rejudgings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rejudgings
    **/
    _count?: true | RejudgingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RejudgingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RejudgingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RejudgingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RejudgingMaxAggregateInputType
  }

  export type GetRejudgingAggregateType<T extends RejudgingAggregateArgs> = {
        [P in keyof T & keyof AggregateRejudging]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRejudging[P]>
      : GetScalarType<T[P], AggregateRejudging[P]>
  }




  export type rejudgingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rejudgingWhereInput
    orderBy?: rejudgingOrderByWithAggregationInput | rejudgingOrderByWithAggregationInput[]
    by: RejudgingScalarFieldEnum[] | RejudgingScalarFieldEnum
    having?: rejudgingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RejudgingCountAggregateInputType | true
    _avg?: RejudgingAvgAggregateInputType
    _sum?: RejudgingSumAggregateInputType
    _min?: RejudgingMinAggregateInputType
    _max?: RejudgingMaxAggregateInputType
  }

  export type RejudgingGroupByOutputType = {
    rejudgingid: number
    userid_start: number | null
    userid_finish: number | null
    starttime: Decimal
    endtime: Decimal | null
    reason: string
    valid: boolean
    auto_apply: boolean
    repeat: number | null
    repeat_rejudgingid: number | null
    _count: RejudgingCountAggregateOutputType | null
    _avg: RejudgingAvgAggregateOutputType | null
    _sum: RejudgingSumAggregateOutputType | null
    _min: RejudgingMinAggregateOutputType | null
    _max: RejudgingMaxAggregateOutputType | null
  }

  type GetRejudgingGroupByPayload<T extends rejudgingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RejudgingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RejudgingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RejudgingGroupByOutputType[P]>
            : GetScalarType<T[P], RejudgingGroupByOutputType[P]>
        }
      >
    >


  export type rejudgingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    rejudgingid?: boolean
    userid_start?: boolean
    userid_finish?: boolean
    starttime?: boolean
    endtime?: boolean
    reason?: boolean
    valid?: boolean
    auto_apply?: boolean
    repeat?: boolean
    repeat_rejudgingid?: boolean
    judging?: boolean | rejudging$judgingArgs<ExtArgs>
    rejudging?: boolean | rejudging$rejudgingArgs<ExtArgs>
    other_rejudging?: boolean | rejudging$other_rejudgingArgs<ExtArgs>
    user_rejudging_userid_startTouser?: boolean | rejudging$user_rejudging_userid_startTouserArgs<ExtArgs>
    user_rejudging_userid_finishTouser?: boolean | rejudging$user_rejudging_userid_finishTouserArgs<ExtArgs>
    submission?: boolean | rejudging$submissionArgs<ExtArgs>
    _count?: boolean | RejudgingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rejudging"]>

  export type rejudgingSelectScalar = {
    rejudgingid?: boolean
    userid_start?: boolean
    userid_finish?: boolean
    starttime?: boolean
    endtime?: boolean
    reason?: boolean
    valid?: boolean
    auto_apply?: boolean
    repeat?: boolean
    repeat_rejudgingid?: boolean
  }

  export type rejudgingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    judging?: boolean | rejudging$judgingArgs<ExtArgs>
    rejudging?: boolean | rejudging$rejudgingArgs<ExtArgs>
    other_rejudging?: boolean | rejudging$other_rejudgingArgs<ExtArgs>
    user_rejudging_userid_startTouser?: boolean | rejudging$user_rejudging_userid_startTouserArgs<ExtArgs>
    user_rejudging_userid_finishTouser?: boolean | rejudging$user_rejudging_userid_finishTouserArgs<ExtArgs>
    submission?: boolean | rejudging$submissionArgs<ExtArgs>
    _count?: boolean | RejudgingCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $rejudgingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rejudging"
    objects: {
      judging: Prisma.$judgingPayload<ExtArgs>[]
      rejudging: Prisma.$rejudgingPayload<ExtArgs> | null
      other_rejudging: Prisma.$rejudgingPayload<ExtArgs>[]
      user_rejudging_userid_startTouser: Prisma.$userPayload<ExtArgs> | null
      user_rejudging_userid_finishTouser: Prisma.$userPayload<ExtArgs> | null
      submission: Prisma.$submissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      rejudgingid: number
      userid_start: number | null
      userid_finish: number | null
      starttime: Prisma.Decimal
      endtime: Prisma.Decimal | null
      reason: string
      valid: boolean
      auto_apply: boolean
      repeat: number | null
      repeat_rejudgingid: number | null
    }, ExtArgs["result"]["rejudging"]>
    composites: {}
  }


  type rejudgingGetPayload<S extends boolean | null | undefined | rejudgingDefaultArgs> = $Result.GetResult<Prisma.$rejudgingPayload, S>

  type rejudgingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rejudgingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RejudgingCountAggregateInputType | true
    }

  export interface rejudgingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rejudging'], meta: { name: 'rejudging' } }
    /**
     * Find zero or one Rejudging that matches the filter.
     * @param {rejudgingFindUniqueArgs} args - Arguments to find a Rejudging
     * @example
     * // Get one Rejudging
     * const rejudging = await prisma.rejudging.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rejudgingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, rejudgingFindUniqueArgs<ExtArgs>>
    ): Prisma__rejudgingClient<$Result.GetResult<Prisma.$rejudgingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Rejudging that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {rejudgingFindUniqueOrThrowArgs} args - Arguments to find a Rejudging
     * @example
     * // Get one Rejudging
     * const rejudging = await prisma.rejudging.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends rejudgingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rejudgingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__rejudgingClient<$Result.GetResult<Prisma.$rejudgingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Rejudging that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rejudgingFindFirstArgs} args - Arguments to find a Rejudging
     * @example
     * // Get one Rejudging
     * const rejudging = await prisma.rejudging.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rejudgingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, rejudgingFindFirstArgs<ExtArgs>>
    ): Prisma__rejudgingClient<$Result.GetResult<Prisma.$rejudgingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Rejudging that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rejudgingFindFirstOrThrowArgs} args - Arguments to find a Rejudging
     * @example
     * // Get one Rejudging
     * const rejudging = await prisma.rejudging.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends rejudgingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rejudgingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__rejudgingClient<$Result.GetResult<Prisma.$rejudgingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Rejudgings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rejudgingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rejudgings
     * const rejudgings = await prisma.rejudging.findMany()
     * 
     * // Get first 10 Rejudgings
     * const rejudgings = await prisma.rejudging.findMany({ take: 10 })
     * 
     * // Only select the `rejudgingid`
     * const rejudgingWithRejudgingidOnly = await prisma.rejudging.findMany({ select: { rejudgingid: true } })
     * 
    **/
    findMany<T extends rejudgingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rejudgingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rejudgingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Rejudging.
     * @param {rejudgingCreateArgs} args - Arguments to create a Rejudging.
     * @example
     * // Create one Rejudging
     * const Rejudging = await prisma.rejudging.create({
     *   data: {
     *     // ... data to create a Rejudging
     *   }
     * })
     * 
    **/
    create<T extends rejudgingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, rejudgingCreateArgs<ExtArgs>>
    ): Prisma__rejudgingClient<$Result.GetResult<Prisma.$rejudgingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Rejudgings.
     *     @param {rejudgingCreateManyArgs} args - Arguments to create many Rejudgings.
     *     @example
     *     // Create many Rejudgings
     *     const rejudging = await prisma.rejudging.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends rejudgingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rejudgingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rejudging.
     * @param {rejudgingDeleteArgs} args - Arguments to delete one Rejudging.
     * @example
     * // Delete one Rejudging
     * const Rejudging = await prisma.rejudging.delete({
     *   where: {
     *     // ... filter to delete one Rejudging
     *   }
     * })
     * 
    **/
    delete<T extends rejudgingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, rejudgingDeleteArgs<ExtArgs>>
    ): Prisma__rejudgingClient<$Result.GetResult<Prisma.$rejudgingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Rejudging.
     * @param {rejudgingUpdateArgs} args - Arguments to update one Rejudging.
     * @example
     * // Update one Rejudging
     * const rejudging = await prisma.rejudging.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rejudgingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, rejudgingUpdateArgs<ExtArgs>>
    ): Prisma__rejudgingClient<$Result.GetResult<Prisma.$rejudgingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Rejudgings.
     * @param {rejudgingDeleteManyArgs} args - Arguments to filter Rejudgings to delete.
     * @example
     * // Delete a few Rejudgings
     * const { count } = await prisma.rejudging.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rejudgingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rejudgingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rejudgings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rejudgingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rejudgings
     * const rejudging = await prisma.rejudging.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rejudgingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, rejudgingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rejudging.
     * @param {rejudgingUpsertArgs} args - Arguments to update or create a Rejudging.
     * @example
     * // Update or create a Rejudging
     * const rejudging = await prisma.rejudging.upsert({
     *   create: {
     *     // ... data to create a Rejudging
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rejudging we want to update
     *   }
     * })
    **/
    upsert<T extends rejudgingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, rejudgingUpsertArgs<ExtArgs>>
    ): Prisma__rejudgingClient<$Result.GetResult<Prisma.$rejudgingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Rejudgings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rejudgingCountArgs} args - Arguments to filter Rejudgings to count.
     * @example
     * // Count the number of Rejudgings
     * const count = await prisma.rejudging.count({
     *   where: {
     *     // ... the filter for the Rejudgings we want to count
     *   }
     * })
    **/
    count<T extends rejudgingCountArgs>(
      args?: Subset<T, rejudgingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RejudgingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rejudging.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RejudgingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RejudgingAggregateArgs>(args: Subset<T, RejudgingAggregateArgs>): Prisma.PrismaPromise<GetRejudgingAggregateType<T>>

    /**
     * Group by Rejudging.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rejudgingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rejudgingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rejudgingGroupByArgs['orderBy'] }
        : { orderBy?: rejudgingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rejudgingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRejudgingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rejudging model
   */
  readonly fields: rejudgingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rejudging.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rejudgingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    judging<T extends rejudging$judgingArgs<ExtArgs> = {}>(args?: Subset<T, rejudging$judgingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$judgingPayload<ExtArgs>, T, 'findMany'> | Null>;

    rejudging<T extends rejudging$rejudgingArgs<ExtArgs> = {}>(args?: Subset<T, rejudging$rejudgingArgs<ExtArgs>>): Prisma__rejudgingClient<$Result.GetResult<Prisma.$rejudgingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    other_rejudging<T extends rejudging$other_rejudgingArgs<ExtArgs> = {}>(args?: Subset<T, rejudging$other_rejudgingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rejudgingPayload<ExtArgs>, T, 'findMany'> | Null>;

    user_rejudging_userid_startTouser<T extends rejudging$user_rejudging_userid_startTouserArgs<ExtArgs> = {}>(args?: Subset<T, rejudging$user_rejudging_userid_startTouserArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    user_rejudging_userid_finishTouser<T extends rejudging$user_rejudging_userid_finishTouserArgs<ExtArgs> = {}>(args?: Subset<T, rejudging$user_rejudging_userid_finishTouserArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    submission<T extends rejudging$submissionArgs<ExtArgs> = {}>(args?: Subset<T, rejudging$submissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the rejudging model
   */ 
  interface rejudgingFieldRefs {
    readonly rejudgingid: FieldRef<"rejudging", 'Int'>
    readonly userid_start: FieldRef<"rejudging", 'Int'>
    readonly userid_finish: FieldRef<"rejudging", 'Int'>
    readonly starttime: FieldRef<"rejudging", 'Decimal'>
    readonly endtime: FieldRef<"rejudging", 'Decimal'>
    readonly reason: FieldRef<"rejudging", 'String'>
    readonly valid: FieldRef<"rejudging", 'Boolean'>
    readonly auto_apply: FieldRef<"rejudging", 'Boolean'>
    readonly repeat: FieldRef<"rejudging", 'Int'>
    readonly repeat_rejudgingid: FieldRef<"rejudging", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * rejudging findUnique
   */
  export type rejudgingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejudging
     */
    select?: rejudgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rejudgingInclude<ExtArgs> | null
    /**
     * Filter, which rejudging to fetch.
     */
    where: rejudgingWhereUniqueInput
  }


  /**
   * rejudging findUniqueOrThrow
   */
  export type rejudgingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejudging
     */
    select?: rejudgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rejudgingInclude<ExtArgs> | null
    /**
     * Filter, which rejudging to fetch.
     */
    where: rejudgingWhereUniqueInput
  }


  /**
   * rejudging findFirst
   */
  export type rejudgingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejudging
     */
    select?: rejudgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rejudgingInclude<ExtArgs> | null
    /**
     * Filter, which rejudging to fetch.
     */
    where?: rejudgingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rejudgings to fetch.
     */
    orderBy?: rejudgingOrderByWithRelationInput | rejudgingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rejudgings.
     */
    cursor?: rejudgingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rejudgings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rejudgings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rejudgings.
     */
    distinct?: RejudgingScalarFieldEnum | RejudgingScalarFieldEnum[]
  }


  /**
   * rejudging findFirstOrThrow
   */
  export type rejudgingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejudging
     */
    select?: rejudgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rejudgingInclude<ExtArgs> | null
    /**
     * Filter, which rejudging to fetch.
     */
    where?: rejudgingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rejudgings to fetch.
     */
    orderBy?: rejudgingOrderByWithRelationInput | rejudgingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rejudgings.
     */
    cursor?: rejudgingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rejudgings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rejudgings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rejudgings.
     */
    distinct?: RejudgingScalarFieldEnum | RejudgingScalarFieldEnum[]
  }


  /**
   * rejudging findMany
   */
  export type rejudgingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejudging
     */
    select?: rejudgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rejudgingInclude<ExtArgs> | null
    /**
     * Filter, which rejudgings to fetch.
     */
    where?: rejudgingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rejudgings to fetch.
     */
    orderBy?: rejudgingOrderByWithRelationInput | rejudgingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rejudgings.
     */
    cursor?: rejudgingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rejudgings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rejudgings.
     */
    skip?: number
    distinct?: RejudgingScalarFieldEnum | RejudgingScalarFieldEnum[]
  }


  /**
   * rejudging create
   */
  export type rejudgingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejudging
     */
    select?: rejudgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rejudgingInclude<ExtArgs> | null
    /**
     * The data needed to create a rejudging.
     */
    data: XOR<rejudgingCreateInput, rejudgingUncheckedCreateInput>
  }


  /**
   * rejudging createMany
   */
  export type rejudgingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rejudgings.
     */
    data: rejudgingCreateManyInput | rejudgingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * rejudging update
   */
  export type rejudgingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejudging
     */
    select?: rejudgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rejudgingInclude<ExtArgs> | null
    /**
     * The data needed to update a rejudging.
     */
    data: XOR<rejudgingUpdateInput, rejudgingUncheckedUpdateInput>
    /**
     * Choose, which rejudging to update.
     */
    where: rejudgingWhereUniqueInput
  }


  /**
   * rejudging updateMany
   */
  export type rejudgingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rejudgings.
     */
    data: XOR<rejudgingUpdateManyMutationInput, rejudgingUncheckedUpdateManyInput>
    /**
     * Filter which rejudgings to update
     */
    where?: rejudgingWhereInput
  }


  /**
   * rejudging upsert
   */
  export type rejudgingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejudging
     */
    select?: rejudgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rejudgingInclude<ExtArgs> | null
    /**
     * The filter to search for the rejudging to update in case it exists.
     */
    where: rejudgingWhereUniqueInput
    /**
     * In case the rejudging found by the `where` argument doesn't exist, create a new rejudging with this data.
     */
    create: XOR<rejudgingCreateInput, rejudgingUncheckedCreateInput>
    /**
     * In case the rejudging was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rejudgingUpdateInput, rejudgingUncheckedUpdateInput>
  }


  /**
   * rejudging delete
   */
  export type rejudgingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejudging
     */
    select?: rejudgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rejudgingInclude<ExtArgs> | null
    /**
     * Filter which rejudging to delete.
     */
    where: rejudgingWhereUniqueInput
  }


  /**
   * rejudging deleteMany
   */
  export type rejudgingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rejudgings to delete
     */
    where?: rejudgingWhereInput
  }


  /**
   * rejudging.judging
   */
  export type rejudging$judgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging
     */
    select?: judgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgingInclude<ExtArgs> | null
    where?: judgingWhereInput
    orderBy?: judgingOrderByWithRelationInput | judgingOrderByWithRelationInput[]
    cursor?: judgingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JudgingScalarFieldEnum | JudgingScalarFieldEnum[]
  }


  /**
   * rejudging.rejudging
   */
  export type rejudging$rejudgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejudging
     */
    select?: rejudgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rejudgingInclude<ExtArgs> | null
    where?: rejudgingWhereInput
  }


  /**
   * rejudging.other_rejudging
   */
  export type rejudging$other_rejudgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejudging
     */
    select?: rejudgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rejudgingInclude<ExtArgs> | null
    where?: rejudgingWhereInput
    orderBy?: rejudgingOrderByWithRelationInput | rejudgingOrderByWithRelationInput[]
    cursor?: rejudgingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RejudgingScalarFieldEnum | RejudgingScalarFieldEnum[]
  }


  /**
   * rejudging.user_rejudging_userid_startTouser
   */
  export type rejudging$user_rejudging_userid_startTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }


  /**
   * rejudging.user_rejudging_userid_finishTouser
   */
  export type rejudging$user_rejudging_userid_finishTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }


  /**
   * rejudging.submission
   */
  export type rejudging$submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    where?: submissionWhereInput
    orderBy?: submissionOrderByWithRelationInput | submissionOrderByWithRelationInput[]
    cursor?: submissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }


  /**
   * rejudging without action
   */
  export type rejudgingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejudging
     */
    select?: rejudgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rejudgingInclude<ExtArgs> | null
  }



  /**
   * Model removed_interval
   */

  export type AggregateRemoved_interval = {
    _count: Removed_intervalCountAggregateOutputType | null
    _avg: Removed_intervalAvgAggregateOutputType | null
    _sum: Removed_intervalSumAggregateOutputType | null
    _min: Removed_intervalMinAggregateOutputType | null
    _max: Removed_intervalMaxAggregateOutputType | null
  }

  export type Removed_intervalAvgAggregateOutputType = {
    intervalid: number | null
    cid: number | null
    starttime: Decimal | null
    endtime: Decimal | null
  }

  export type Removed_intervalSumAggregateOutputType = {
    intervalid: number | null
    cid: number | null
    starttime: Decimal | null
    endtime: Decimal | null
  }

  export type Removed_intervalMinAggregateOutputType = {
    intervalid: number | null
    cid: number | null
    starttime: Decimal | null
    endtime: Decimal | null
    starttime_string: string | null
    endtime_string: string | null
  }

  export type Removed_intervalMaxAggregateOutputType = {
    intervalid: number | null
    cid: number | null
    starttime: Decimal | null
    endtime: Decimal | null
    starttime_string: string | null
    endtime_string: string | null
  }

  export type Removed_intervalCountAggregateOutputType = {
    intervalid: number
    cid: number
    starttime: number
    endtime: number
    starttime_string: number
    endtime_string: number
    _all: number
  }


  export type Removed_intervalAvgAggregateInputType = {
    intervalid?: true
    cid?: true
    starttime?: true
    endtime?: true
  }

  export type Removed_intervalSumAggregateInputType = {
    intervalid?: true
    cid?: true
    starttime?: true
    endtime?: true
  }

  export type Removed_intervalMinAggregateInputType = {
    intervalid?: true
    cid?: true
    starttime?: true
    endtime?: true
    starttime_string?: true
    endtime_string?: true
  }

  export type Removed_intervalMaxAggregateInputType = {
    intervalid?: true
    cid?: true
    starttime?: true
    endtime?: true
    starttime_string?: true
    endtime_string?: true
  }

  export type Removed_intervalCountAggregateInputType = {
    intervalid?: true
    cid?: true
    starttime?: true
    endtime?: true
    starttime_string?: true
    endtime_string?: true
    _all?: true
  }

  export type Removed_intervalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which removed_interval to aggregate.
     */
    where?: removed_intervalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of removed_intervals to fetch.
     */
    orderBy?: removed_intervalOrderByWithRelationInput | removed_intervalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: removed_intervalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` removed_intervals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` removed_intervals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned removed_intervals
    **/
    _count?: true | Removed_intervalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Removed_intervalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Removed_intervalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Removed_intervalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Removed_intervalMaxAggregateInputType
  }

  export type GetRemoved_intervalAggregateType<T extends Removed_intervalAggregateArgs> = {
        [P in keyof T & keyof AggregateRemoved_interval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRemoved_interval[P]>
      : GetScalarType<T[P], AggregateRemoved_interval[P]>
  }




  export type removed_intervalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: removed_intervalWhereInput
    orderBy?: removed_intervalOrderByWithAggregationInput | removed_intervalOrderByWithAggregationInput[]
    by: Removed_intervalScalarFieldEnum[] | Removed_intervalScalarFieldEnum
    having?: removed_intervalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Removed_intervalCountAggregateInputType | true
    _avg?: Removed_intervalAvgAggregateInputType
    _sum?: Removed_intervalSumAggregateInputType
    _min?: Removed_intervalMinAggregateInputType
    _max?: Removed_intervalMaxAggregateInputType
  }

  export type Removed_intervalGroupByOutputType = {
    intervalid: number
    cid: number | null
    starttime: Decimal
    endtime: Decimal
    starttime_string: string
    endtime_string: string
    _count: Removed_intervalCountAggregateOutputType | null
    _avg: Removed_intervalAvgAggregateOutputType | null
    _sum: Removed_intervalSumAggregateOutputType | null
    _min: Removed_intervalMinAggregateOutputType | null
    _max: Removed_intervalMaxAggregateOutputType | null
  }

  type GetRemoved_intervalGroupByPayload<T extends removed_intervalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Removed_intervalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Removed_intervalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Removed_intervalGroupByOutputType[P]>
            : GetScalarType<T[P], Removed_intervalGroupByOutputType[P]>
        }
      >
    >


  export type removed_intervalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    intervalid?: boolean
    cid?: boolean
    starttime?: boolean
    endtime?: boolean
    starttime_string?: boolean
    endtime_string?: boolean
    contest?: boolean | removed_interval$contestArgs<ExtArgs>
  }, ExtArgs["result"]["removed_interval"]>

  export type removed_intervalSelectScalar = {
    intervalid?: boolean
    cid?: boolean
    starttime?: boolean
    endtime?: boolean
    starttime_string?: boolean
    endtime_string?: boolean
  }

  export type removed_intervalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contest?: boolean | removed_interval$contestArgs<ExtArgs>
  }


  export type $removed_intervalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "removed_interval"
    objects: {
      contest: Prisma.$contestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      intervalid: number
      cid: number | null
      starttime: Prisma.Decimal
      endtime: Prisma.Decimal
      starttime_string: string
      endtime_string: string
    }, ExtArgs["result"]["removed_interval"]>
    composites: {}
  }


  type removed_intervalGetPayload<S extends boolean | null | undefined | removed_intervalDefaultArgs> = $Result.GetResult<Prisma.$removed_intervalPayload, S>

  type removed_intervalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<removed_intervalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Removed_intervalCountAggregateInputType | true
    }

  export interface removed_intervalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['removed_interval'], meta: { name: 'removed_interval' } }
    /**
     * Find zero or one Removed_interval that matches the filter.
     * @param {removed_intervalFindUniqueArgs} args - Arguments to find a Removed_interval
     * @example
     * // Get one Removed_interval
     * const removed_interval = await prisma.removed_interval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends removed_intervalFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, removed_intervalFindUniqueArgs<ExtArgs>>
    ): Prisma__removed_intervalClient<$Result.GetResult<Prisma.$removed_intervalPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Removed_interval that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {removed_intervalFindUniqueOrThrowArgs} args - Arguments to find a Removed_interval
     * @example
     * // Get one Removed_interval
     * const removed_interval = await prisma.removed_interval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends removed_intervalFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, removed_intervalFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__removed_intervalClient<$Result.GetResult<Prisma.$removed_intervalPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Removed_interval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {removed_intervalFindFirstArgs} args - Arguments to find a Removed_interval
     * @example
     * // Get one Removed_interval
     * const removed_interval = await prisma.removed_interval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends removed_intervalFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, removed_intervalFindFirstArgs<ExtArgs>>
    ): Prisma__removed_intervalClient<$Result.GetResult<Prisma.$removed_intervalPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Removed_interval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {removed_intervalFindFirstOrThrowArgs} args - Arguments to find a Removed_interval
     * @example
     * // Get one Removed_interval
     * const removed_interval = await prisma.removed_interval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends removed_intervalFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, removed_intervalFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__removed_intervalClient<$Result.GetResult<Prisma.$removed_intervalPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Removed_intervals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {removed_intervalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Removed_intervals
     * const removed_intervals = await prisma.removed_interval.findMany()
     * 
     * // Get first 10 Removed_intervals
     * const removed_intervals = await prisma.removed_interval.findMany({ take: 10 })
     * 
     * // Only select the `intervalid`
     * const removed_intervalWithIntervalidOnly = await prisma.removed_interval.findMany({ select: { intervalid: true } })
     * 
    **/
    findMany<T extends removed_intervalFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, removed_intervalFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$removed_intervalPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Removed_interval.
     * @param {removed_intervalCreateArgs} args - Arguments to create a Removed_interval.
     * @example
     * // Create one Removed_interval
     * const Removed_interval = await prisma.removed_interval.create({
     *   data: {
     *     // ... data to create a Removed_interval
     *   }
     * })
     * 
    **/
    create<T extends removed_intervalCreateArgs<ExtArgs>>(
      args: SelectSubset<T, removed_intervalCreateArgs<ExtArgs>>
    ): Prisma__removed_intervalClient<$Result.GetResult<Prisma.$removed_intervalPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Removed_intervals.
     *     @param {removed_intervalCreateManyArgs} args - Arguments to create many Removed_intervals.
     *     @example
     *     // Create many Removed_intervals
     *     const removed_interval = await prisma.removed_interval.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends removed_intervalCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, removed_intervalCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Removed_interval.
     * @param {removed_intervalDeleteArgs} args - Arguments to delete one Removed_interval.
     * @example
     * // Delete one Removed_interval
     * const Removed_interval = await prisma.removed_interval.delete({
     *   where: {
     *     // ... filter to delete one Removed_interval
     *   }
     * })
     * 
    **/
    delete<T extends removed_intervalDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, removed_intervalDeleteArgs<ExtArgs>>
    ): Prisma__removed_intervalClient<$Result.GetResult<Prisma.$removed_intervalPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Removed_interval.
     * @param {removed_intervalUpdateArgs} args - Arguments to update one Removed_interval.
     * @example
     * // Update one Removed_interval
     * const removed_interval = await prisma.removed_interval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends removed_intervalUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, removed_intervalUpdateArgs<ExtArgs>>
    ): Prisma__removed_intervalClient<$Result.GetResult<Prisma.$removed_intervalPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Removed_intervals.
     * @param {removed_intervalDeleteManyArgs} args - Arguments to filter Removed_intervals to delete.
     * @example
     * // Delete a few Removed_intervals
     * const { count } = await prisma.removed_interval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends removed_intervalDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, removed_intervalDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Removed_intervals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {removed_intervalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Removed_intervals
     * const removed_interval = await prisma.removed_interval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends removed_intervalUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, removed_intervalUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Removed_interval.
     * @param {removed_intervalUpsertArgs} args - Arguments to update or create a Removed_interval.
     * @example
     * // Update or create a Removed_interval
     * const removed_interval = await prisma.removed_interval.upsert({
     *   create: {
     *     // ... data to create a Removed_interval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Removed_interval we want to update
     *   }
     * })
    **/
    upsert<T extends removed_intervalUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, removed_intervalUpsertArgs<ExtArgs>>
    ): Prisma__removed_intervalClient<$Result.GetResult<Prisma.$removed_intervalPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Removed_intervals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {removed_intervalCountArgs} args - Arguments to filter Removed_intervals to count.
     * @example
     * // Count the number of Removed_intervals
     * const count = await prisma.removed_interval.count({
     *   where: {
     *     // ... the filter for the Removed_intervals we want to count
     *   }
     * })
    **/
    count<T extends removed_intervalCountArgs>(
      args?: Subset<T, removed_intervalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Removed_intervalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Removed_interval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Removed_intervalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Removed_intervalAggregateArgs>(args: Subset<T, Removed_intervalAggregateArgs>): Prisma.PrismaPromise<GetRemoved_intervalAggregateType<T>>

    /**
     * Group by Removed_interval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {removed_intervalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends removed_intervalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: removed_intervalGroupByArgs['orderBy'] }
        : { orderBy?: removed_intervalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, removed_intervalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRemoved_intervalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the removed_interval model
   */
  readonly fields: removed_intervalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for removed_interval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__removed_intervalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contest<T extends removed_interval$contestArgs<ExtArgs> = {}>(args?: Subset<T, removed_interval$contestArgs<ExtArgs>>): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the removed_interval model
   */ 
  interface removed_intervalFieldRefs {
    readonly intervalid: FieldRef<"removed_interval", 'Int'>
    readonly cid: FieldRef<"removed_interval", 'Int'>
    readonly starttime: FieldRef<"removed_interval", 'Decimal'>
    readonly endtime: FieldRef<"removed_interval", 'Decimal'>
    readonly starttime_string: FieldRef<"removed_interval", 'String'>
    readonly endtime_string: FieldRef<"removed_interval", 'String'>
  }
    

  // Custom InputTypes

  /**
   * removed_interval findUnique
   */
  export type removed_intervalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the removed_interval
     */
    select?: removed_intervalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: removed_intervalInclude<ExtArgs> | null
    /**
     * Filter, which removed_interval to fetch.
     */
    where: removed_intervalWhereUniqueInput
  }


  /**
   * removed_interval findUniqueOrThrow
   */
  export type removed_intervalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the removed_interval
     */
    select?: removed_intervalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: removed_intervalInclude<ExtArgs> | null
    /**
     * Filter, which removed_interval to fetch.
     */
    where: removed_intervalWhereUniqueInput
  }


  /**
   * removed_interval findFirst
   */
  export type removed_intervalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the removed_interval
     */
    select?: removed_intervalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: removed_intervalInclude<ExtArgs> | null
    /**
     * Filter, which removed_interval to fetch.
     */
    where?: removed_intervalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of removed_intervals to fetch.
     */
    orderBy?: removed_intervalOrderByWithRelationInput | removed_intervalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for removed_intervals.
     */
    cursor?: removed_intervalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` removed_intervals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` removed_intervals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of removed_intervals.
     */
    distinct?: Removed_intervalScalarFieldEnum | Removed_intervalScalarFieldEnum[]
  }


  /**
   * removed_interval findFirstOrThrow
   */
  export type removed_intervalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the removed_interval
     */
    select?: removed_intervalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: removed_intervalInclude<ExtArgs> | null
    /**
     * Filter, which removed_interval to fetch.
     */
    where?: removed_intervalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of removed_intervals to fetch.
     */
    orderBy?: removed_intervalOrderByWithRelationInput | removed_intervalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for removed_intervals.
     */
    cursor?: removed_intervalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` removed_intervals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` removed_intervals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of removed_intervals.
     */
    distinct?: Removed_intervalScalarFieldEnum | Removed_intervalScalarFieldEnum[]
  }


  /**
   * removed_interval findMany
   */
  export type removed_intervalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the removed_interval
     */
    select?: removed_intervalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: removed_intervalInclude<ExtArgs> | null
    /**
     * Filter, which removed_intervals to fetch.
     */
    where?: removed_intervalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of removed_intervals to fetch.
     */
    orderBy?: removed_intervalOrderByWithRelationInput | removed_intervalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing removed_intervals.
     */
    cursor?: removed_intervalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` removed_intervals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` removed_intervals.
     */
    skip?: number
    distinct?: Removed_intervalScalarFieldEnum | Removed_intervalScalarFieldEnum[]
  }


  /**
   * removed_interval create
   */
  export type removed_intervalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the removed_interval
     */
    select?: removed_intervalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: removed_intervalInclude<ExtArgs> | null
    /**
     * The data needed to create a removed_interval.
     */
    data: XOR<removed_intervalCreateInput, removed_intervalUncheckedCreateInput>
  }


  /**
   * removed_interval createMany
   */
  export type removed_intervalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many removed_intervals.
     */
    data: removed_intervalCreateManyInput | removed_intervalCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * removed_interval update
   */
  export type removed_intervalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the removed_interval
     */
    select?: removed_intervalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: removed_intervalInclude<ExtArgs> | null
    /**
     * The data needed to update a removed_interval.
     */
    data: XOR<removed_intervalUpdateInput, removed_intervalUncheckedUpdateInput>
    /**
     * Choose, which removed_interval to update.
     */
    where: removed_intervalWhereUniqueInput
  }


  /**
   * removed_interval updateMany
   */
  export type removed_intervalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update removed_intervals.
     */
    data: XOR<removed_intervalUpdateManyMutationInput, removed_intervalUncheckedUpdateManyInput>
    /**
     * Filter which removed_intervals to update
     */
    where?: removed_intervalWhereInput
  }


  /**
   * removed_interval upsert
   */
  export type removed_intervalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the removed_interval
     */
    select?: removed_intervalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: removed_intervalInclude<ExtArgs> | null
    /**
     * The filter to search for the removed_interval to update in case it exists.
     */
    where: removed_intervalWhereUniqueInput
    /**
     * In case the removed_interval found by the `where` argument doesn't exist, create a new removed_interval with this data.
     */
    create: XOR<removed_intervalCreateInput, removed_intervalUncheckedCreateInput>
    /**
     * In case the removed_interval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<removed_intervalUpdateInput, removed_intervalUncheckedUpdateInput>
  }


  /**
   * removed_interval delete
   */
  export type removed_intervalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the removed_interval
     */
    select?: removed_intervalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: removed_intervalInclude<ExtArgs> | null
    /**
     * Filter which removed_interval to delete.
     */
    where: removed_intervalWhereUniqueInput
  }


  /**
   * removed_interval deleteMany
   */
  export type removed_intervalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which removed_intervals to delete
     */
    where?: removed_intervalWhereInput
  }


  /**
   * removed_interval.contest
   */
  export type removed_interval$contestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contest
     */
    select?: contestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestInclude<ExtArgs> | null
    where?: contestWhereInput
  }


  /**
   * removed_interval without action
   */
  export type removed_intervalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the removed_interval
     */
    select?: removed_intervalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: removed_intervalInclude<ExtArgs> | null
  }



  /**
   * Model role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    roleid: number | null
  }

  export type RoleSumAggregateOutputType = {
    roleid: number | null
  }

  export type RoleMinAggregateOutputType = {
    roleid: number | null
    role: string | null
    description: string | null
  }

  export type RoleMaxAggregateOutputType = {
    roleid: number | null
    role: string | null
    description: string | null
  }

  export type RoleCountAggregateOutputType = {
    roleid: number
    role: number
    description: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    roleid?: true
  }

  export type RoleSumAggregateInputType = {
    roleid?: true
  }

  export type RoleMinAggregateInputType = {
    roleid?: true
    role?: true
    description?: true
  }

  export type RoleMaxAggregateInputType = {
    roleid?: true
    role?: true
    description?: true
  }

  export type RoleCountAggregateInputType = {
    roleid?: true
    role?: true
    description?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role to aggregate.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type roleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roleWhereInput
    orderBy?: roleOrderByWithAggregationInput | roleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    roleid: number
    role: string
    description: string
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type roleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleid?: boolean
    role?: boolean
    description?: boolean
    userrole?: boolean | role$userroleArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type roleSelectScalar = {
    roleid?: boolean
    role?: boolean
    description?: boolean
  }

  export type roleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userrole?: boolean | role$userroleArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $rolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "role"
    objects: {
      userrole: Prisma.$userrolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      roleid: number
      role: string
      description: string
    }, ExtArgs["result"]["role"]>
    composites: {}
  }


  type roleGetPayload<S extends boolean | null | undefined | roleDefaultArgs> = $Result.GetResult<Prisma.$rolePayload, S>

  type roleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<roleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface roleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['role'], meta: { name: 'role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {roleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends roleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, roleFindUniqueArgs<ExtArgs>>
    ): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {roleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends roleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, roleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends roleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, roleFindFirstArgs<ExtArgs>>
    ): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends roleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, roleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `roleid`
     * const roleWithRoleidOnly = await prisma.role.findMany({ select: { roleid: true } })
     * 
    **/
    findMany<T extends roleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, roleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Role.
     * @param {roleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends roleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, roleCreateArgs<ExtArgs>>
    ): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Roles.
     *     @param {roleCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const role = await prisma.role.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends roleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, roleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {roleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends roleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, roleDeleteArgs<ExtArgs>>
    ): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Role.
     * @param {roleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends roleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, roleUpdateArgs<ExtArgs>>
    ): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {roleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends roleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, roleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends roleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, roleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {roleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends roleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, roleUpsertArgs<ExtArgs>>
    ): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends roleCountArgs>(
      args?: Subset<T, roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: roleGroupByArgs['orderBy'] }
        : { orderBy?: roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the role model
   */
  readonly fields: roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__roleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    userrole<T extends role$userroleArgs<ExtArgs> = {}>(args?: Subset<T, role$userroleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the role model
   */ 
  interface roleFieldRefs {
    readonly roleid: FieldRef<"role", 'Int'>
    readonly role: FieldRef<"role", 'String'>
    readonly description: FieldRef<"role", 'String'>
  }
    

  // Custom InputTypes

  /**
   * role findUnique
   */
  export type roleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }


  /**
   * role findUniqueOrThrow
   */
  export type roleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }


  /**
   * role findFirst
   */
  export type roleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }


  /**
   * role findFirstOrThrow
   */
  export type roleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }


  /**
   * role findMany
   */
  export type roleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }


  /**
   * role create
   */
  export type roleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The data needed to create a role.
     */
    data: XOR<roleCreateInput, roleUncheckedCreateInput>
  }


  /**
   * role createMany
   */
  export type roleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: roleCreateManyInput | roleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * role update
   */
  export type roleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The data needed to update a role.
     */
    data: XOR<roleUpdateInput, roleUncheckedUpdateInput>
    /**
     * Choose, which role to update.
     */
    where: roleWhereUniqueInput
  }


  /**
   * role updateMany
   */
  export type roleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: roleWhereInput
  }


  /**
   * role upsert
   */
  export type roleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The filter to search for the role to update in case it exists.
     */
    where: roleWhereUniqueInput
    /**
     * In case the role found by the `where` argument doesn't exist, create a new role with this data.
     */
    create: XOR<roleCreateInput, roleUncheckedCreateInput>
    /**
     * In case the role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roleUpdateInput, roleUncheckedUpdateInput>
  }


  /**
   * role delete
   */
  export type roleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter which role to delete.
     */
    where: roleWhereUniqueInput
  }


  /**
   * role deleteMany
   */
  export type roleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: roleWhereInput
  }


  /**
   * role.userrole
   */
  export type role$userroleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userroleInclude<ExtArgs> | null
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    cursor?: userroleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }


  /**
   * role without action
   */
  export type roleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: roleInclude<ExtArgs> | null
  }



  /**
   * Model scorecache
   */

  export type AggregateScorecache = {
    _count: ScorecacheCountAggregateOutputType | null
    _avg: ScorecacheAvgAggregateOutputType | null
    _sum: ScorecacheSumAggregateOutputType | null
    _min: ScorecacheMinAggregateOutputType | null
    _max: ScorecacheMaxAggregateOutputType | null
  }

  export type ScorecacheAvgAggregateOutputType = {
    cid: number | null
    teamid: number | null
    probid: number | null
    submissions_restricted: number | null
    pending_restricted: number | null
    solvetime_restricted: Decimal | null
    submissions_public: number | null
    pending_public: number | null
    solvetime_public: Decimal | null
  }

  export type ScorecacheSumAggregateOutputType = {
    cid: number | null
    teamid: number | null
    probid: number | null
    submissions_restricted: number | null
    pending_restricted: number | null
    solvetime_restricted: Decimal | null
    submissions_public: number | null
    pending_public: number | null
    solvetime_public: Decimal | null
  }

  export type ScorecacheMinAggregateOutputType = {
    cid: number | null
    teamid: number | null
    probid: number | null
    submissions_restricted: number | null
    pending_restricted: number | null
    solvetime_restricted: Decimal | null
    is_correct_restricted: boolean | null
    submissions_public: number | null
    pending_public: number | null
    solvetime_public: Decimal | null
    is_correct_public: boolean | null
    is_first_to_solve: boolean | null
  }

  export type ScorecacheMaxAggregateOutputType = {
    cid: number | null
    teamid: number | null
    probid: number | null
    submissions_restricted: number | null
    pending_restricted: number | null
    solvetime_restricted: Decimal | null
    is_correct_restricted: boolean | null
    submissions_public: number | null
    pending_public: number | null
    solvetime_public: Decimal | null
    is_correct_public: boolean | null
    is_first_to_solve: boolean | null
  }

  export type ScorecacheCountAggregateOutputType = {
    cid: number
    teamid: number
    probid: number
    submissions_restricted: number
    pending_restricted: number
    solvetime_restricted: number
    is_correct_restricted: number
    submissions_public: number
    pending_public: number
    solvetime_public: number
    is_correct_public: number
    is_first_to_solve: number
    _all: number
  }


  export type ScorecacheAvgAggregateInputType = {
    cid?: true
    teamid?: true
    probid?: true
    submissions_restricted?: true
    pending_restricted?: true
    solvetime_restricted?: true
    submissions_public?: true
    pending_public?: true
    solvetime_public?: true
  }

  export type ScorecacheSumAggregateInputType = {
    cid?: true
    teamid?: true
    probid?: true
    submissions_restricted?: true
    pending_restricted?: true
    solvetime_restricted?: true
    submissions_public?: true
    pending_public?: true
    solvetime_public?: true
  }

  export type ScorecacheMinAggregateInputType = {
    cid?: true
    teamid?: true
    probid?: true
    submissions_restricted?: true
    pending_restricted?: true
    solvetime_restricted?: true
    is_correct_restricted?: true
    submissions_public?: true
    pending_public?: true
    solvetime_public?: true
    is_correct_public?: true
    is_first_to_solve?: true
  }

  export type ScorecacheMaxAggregateInputType = {
    cid?: true
    teamid?: true
    probid?: true
    submissions_restricted?: true
    pending_restricted?: true
    solvetime_restricted?: true
    is_correct_restricted?: true
    submissions_public?: true
    pending_public?: true
    solvetime_public?: true
    is_correct_public?: true
    is_first_to_solve?: true
  }

  export type ScorecacheCountAggregateInputType = {
    cid?: true
    teamid?: true
    probid?: true
    submissions_restricted?: true
    pending_restricted?: true
    solvetime_restricted?: true
    is_correct_restricted?: true
    submissions_public?: true
    pending_public?: true
    solvetime_public?: true
    is_correct_public?: true
    is_first_to_solve?: true
    _all?: true
  }

  export type ScorecacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which scorecache to aggregate.
     */
    where?: scorecacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scorecaches to fetch.
     */
    orderBy?: scorecacheOrderByWithRelationInput | scorecacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: scorecacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scorecaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scorecaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned scorecaches
    **/
    _count?: true | ScorecacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScorecacheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScorecacheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScorecacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScorecacheMaxAggregateInputType
  }

  export type GetScorecacheAggregateType<T extends ScorecacheAggregateArgs> = {
        [P in keyof T & keyof AggregateScorecache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScorecache[P]>
      : GetScalarType<T[P], AggregateScorecache[P]>
  }




  export type scorecacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: scorecacheWhereInput
    orderBy?: scorecacheOrderByWithAggregationInput | scorecacheOrderByWithAggregationInput[]
    by: ScorecacheScalarFieldEnum[] | ScorecacheScalarFieldEnum
    having?: scorecacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScorecacheCountAggregateInputType | true
    _avg?: ScorecacheAvgAggregateInputType
    _sum?: ScorecacheSumAggregateInputType
    _min?: ScorecacheMinAggregateInputType
    _max?: ScorecacheMaxAggregateInputType
  }

  export type ScorecacheGroupByOutputType = {
    cid: number
    teamid: number
    probid: number
    submissions_restricted: number
    pending_restricted: number
    solvetime_restricted: Decimal
    is_correct_restricted: boolean
    submissions_public: number
    pending_public: number
    solvetime_public: Decimal
    is_correct_public: boolean
    is_first_to_solve: boolean
    _count: ScorecacheCountAggregateOutputType | null
    _avg: ScorecacheAvgAggregateOutputType | null
    _sum: ScorecacheSumAggregateOutputType | null
    _min: ScorecacheMinAggregateOutputType | null
    _max: ScorecacheMaxAggregateOutputType | null
  }

  type GetScorecacheGroupByPayload<T extends scorecacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScorecacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScorecacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScorecacheGroupByOutputType[P]>
            : GetScalarType<T[P], ScorecacheGroupByOutputType[P]>
        }
      >
    >


  export type scorecacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cid?: boolean
    teamid?: boolean
    probid?: boolean
    submissions_restricted?: boolean
    pending_restricted?: boolean
    solvetime_restricted?: boolean
    is_correct_restricted?: boolean
    submissions_public?: boolean
    pending_public?: boolean
    solvetime_public?: boolean
    is_correct_public?: boolean
    is_first_to_solve?: boolean
    contest?: boolean | contestDefaultArgs<ExtArgs>
    team?: boolean | teamDefaultArgs<ExtArgs>
    problem?: boolean | problemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scorecache"]>

  export type scorecacheSelectScalar = {
    cid?: boolean
    teamid?: boolean
    probid?: boolean
    submissions_restricted?: boolean
    pending_restricted?: boolean
    solvetime_restricted?: boolean
    is_correct_restricted?: boolean
    submissions_public?: boolean
    pending_public?: boolean
    solvetime_public?: boolean
    is_correct_public?: boolean
    is_first_to_solve?: boolean
  }

  export type scorecacheInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contest?: boolean | contestDefaultArgs<ExtArgs>
    team?: boolean | teamDefaultArgs<ExtArgs>
    problem?: boolean | problemDefaultArgs<ExtArgs>
  }


  export type $scorecachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "scorecache"
    objects: {
      contest: Prisma.$contestPayload<ExtArgs>
      team: Prisma.$teamPayload<ExtArgs>
      problem: Prisma.$problemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cid: number
      teamid: number
      probid: number
      submissions_restricted: number
      pending_restricted: number
      solvetime_restricted: Prisma.Decimal
      is_correct_restricted: boolean
      submissions_public: number
      pending_public: number
      solvetime_public: Prisma.Decimal
      is_correct_public: boolean
      is_first_to_solve: boolean
    }, ExtArgs["result"]["scorecache"]>
    composites: {}
  }


  type scorecacheGetPayload<S extends boolean | null | undefined | scorecacheDefaultArgs> = $Result.GetResult<Prisma.$scorecachePayload, S>

  type scorecacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<scorecacheFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScorecacheCountAggregateInputType | true
    }

  export interface scorecacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['scorecache'], meta: { name: 'scorecache' } }
    /**
     * Find zero or one Scorecache that matches the filter.
     * @param {scorecacheFindUniqueArgs} args - Arguments to find a Scorecache
     * @example
     * // Get one Scorecache
     * const scorecache = await prisma.scorecache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends scorecacheFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, scorecacheFindUniqueArgs<ExtArgs>>
    ): Prisma__scorecacheClient<$Result.GetResult<Prisma.$scorecachePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Scorecache that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {scorecacheFindUniqueOrThrowArgs} args - Arguments to find a Scorecache
     * @example
     * // Get one Scorecache
     * const scorecache = await prisma.scorecache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends scorecacheFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, scorecacheFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__scorecacheClient<$Result.GetResult<Prisma.$scorecachePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Scorecache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scorecacheFindFirstArgs} args - Arguments to find a Scorecache
     * @example
     * // Get one Scorecache
     * const scorecache = await prisma.scorecache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends scorecacheFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, scorecacheFindFirstArgs<ExtArgs>>
    ): Prisma__scorecacheClient<$Result.GetResult<Prisma.$scorecachePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Scorecache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scorecacheFindFirstOrThrowArgs} args - Arguments to find a Scorecache
     * @example
     * // Get one Scorecache
     * const scorecache = await prisma.scorecache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends scorecacheFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, scorecacheFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__scorecacheClient<$Result.GetResult<Prisma.$scorecachePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Scorecaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scorecacheFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scorecaches
     * const scorecaches = await prisma.scorecache.findMany()
     * 
     * // Get first 10 Scorecaches
     * const scorecaches = await prisma.scorecache.findMany({ take: 10 })
     * 
     * // Only select the `cid`
     * const scorecacheWithCidOnly = await prisma.scorecache.findMany({ select: { cid: true } })
     * 
    **/
    findMany<T extends scorecacheFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, scorecacheFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$scorecachePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Scorecache.
     * @param {scorecacheCreateArgs} args - Arguments to create a Scorecache.
     * @example
     * // Create one Scorecache
     * const Scorecache = await prisma.scorecache.create({
     *   data: {
     *     // ... data to create a Scorecache
     *   }
     * })
     * 
    **/
    create<T extends scorecacheCreateArgs<ExtArgs>>(
      args: SelectSubset<T, scorecacheCreateArgs<ExtArgs>>
    ): Prisma__scorecacheClient<$Result.GetResult<Prisma.$scorecachePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Scorecaches.
     *     @param {scorecacheCreateManyArgs} args - Arguments to create many Scorecaches.
     *     @example
     *     // Create many Scorecaches
     *     const scorecache = await prisma.scorecache.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends scorecacheCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, scorecacheCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Scorecache.
     * @param {scorecacheDeleteArgs} args - Arguments to delete one Scorecache.
     * @example
     * // Delete one Scorecache
     * const Scorecache = await prisma.scorecache.delete({
     *   where: {
     *     // ... filter to delete one Scorecache
     *   }
     * })
     * 
    **/
    delete<T extends scorecacheDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, scorecacheDeleteArgs<ExtArgs>>
    ): Prisma__scorecacheClient<$Result.GetResult<Prisma.$scorecachePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Scorecache.
     * @param {scorecacheUpdateArgs} args - Arguments to update one Scorecache.
     * @example
     * // Update one Scorecache
     * const scorecache = await prisma.scorecache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends scorecacheUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, scorecacheUpdateArgs<ExtArgs>>
    ): Prisma__scorecacheClient<$Result.GetResult<Prisma.$scorecachePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Scorecaches.
     * @param {scorecacheDeleteManyArgs} args - Arguments to filter Scorecaches to delete.
     * @example
     * // Delete a few Scorecaches
     * const { count } = await prisma.scorecache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends scorecacheDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, scorecacheDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scorecaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scorecacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scorecaches
     * const scorecache = await prisma.scorecache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends scorecacheUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, scorecacheUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Scorecache.
     * @param {scorecacheUpsertArgs} args - Arguments to update or create a Scorecache.
     * @example
     * // Update or create a Scorecache
     * const scorecache = await prisma.scorecache.upsert({
     *   create: {
     *     // ... data to create a Scorecache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Scorecache we want to update
     *   }
     * })
    **/
    upsert<T extends scorecacheUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, scorecacheUpsertArgs<ExtArgs>>
    ): Prisma__scorecacheClient<$Result.GetResult<Prisma.$scorecachePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Scorecaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scorecacheCountArgs} args - Arguments to filter Scorecaches to count.
     * @example
     * // Count the number of Scorecaches
     * const count = await prisma.scorecache.count({
     *   where: {
     *     // ... the filter for the Scorecaches we want to count
     *   }
     * })
    **/
    count<T extends scorecacheCountArgs>(
      args?: Subset<T, scorecacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScorecacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Scorecache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScorecacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScorecacheAggregateArgs>(args: Subset<T, ScorecacheAggregateArgs>): Prisma.PrismaPromise<GetScorecacheAggregateType<T>>

    /**
     * Group by Scorecache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scorecacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends scorecacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: scorecacheGroupByArgs['orderBy'] }
        : { orderBy?: scorecacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, scorecacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScorecacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the scorecache model
   */
  readonly fields: scorecacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for scorecache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__scorecacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contest<T extends contestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, contestDefaultArgs<ExtArgs>>): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    team<T extends teamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teamDefaultArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    problem<T extends problemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, problemDefaultArgs<ExtArgs>>): Prisma__problemClient<$Result.GetResult<Prisma.$problemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the scorecache model
   */ 
  interface scorecacheFieldRefs {
    readonly cid: FieldRef<"scorecache", 'Int'>
    readonly teamid: FieldRef<"scorecache", 'Int'>
    readonly probid: FieldRef<"scorecache", 'Int'>
    readonly submissions_restricted: FieldRef<"scorecache", 'Int'>
    readonly pending_restricted: FieldRef<"scorecache", 'Int'>
    readonly solvetime_restricted: FieldRef<"scorecache", 'Decimal'>
    readonly is_correct_restricted: FieldRef<"scorecache", 'Boolean'>
    readonly submissions_public: FieldRef<"scorecache", 'Int'>
    readonly pending_public: FieldRef<"scorecache", 'Int'>
    readonly solvetime_public: FieldRef<"scorecache", 'Decimal'>
    readonly is_correct_public: FieldRef<"scorecache", 'Boolean'>
    readonly is_first_to_solve: FieldRef<"scorecache", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * scorecache findUnique
   */
  export type scorecacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scorecache
     */
    select?: scorecacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: scorecacheInclude<ExtArgs> | null
    /**
     * Filter, which scorecache to fetch.
     */
    where: scorecacheWhereUniqueInput
  }


  /**
   * scorecache findUniqueOrThrow
   */
  export type scorecacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scorecache
     */
    select?: scorecacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: scorecacheInclude<ExtArgs> | null
    /**
     * Filter, which scorecache to fetch.
     */
    where: scorecacheWhereUniqueInput
  }


  /**
   * scorecache findFirst
   */
  export type scorecacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scorecache
     */
    select?: scorecacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: scorecacheInclude<ExtArgs> | null
    /**
     * Filter, which scorecache to fetch.
     */
    where?: scorecacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scorecaches to fetch.
     */
    orderBy?: scorecacheOrderByWithRelationInput | scorecacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for scorecaches.
     */
    cursor?: scorecacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scorecaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scorecaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of scorecaches.
     */
    distinct?: ScorecacheScalarFieldEnum | ScorecacheScalarFieldEnum[]
  }


  /**
   * scorecache findFirstOrThrow
   */
  export type scorecacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scorecache
     */
    select?: scorecacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: scorecacheInclude<ExtArgs> | null
    /**
     * Filter, which scorecache to fetch.
     */
    where?: scorecacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scorecaches to fetch.
     */
    orderBy?: scorecacheOrderByWithRelationInput | scorecacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for scorecaches.
     */
    cursor?: scorecacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scorecaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scorecaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of scorecaches.
     */
    distinct?: ScorecacheScalarFieldEnum | ScorecacheScalarFieldEnum[]
  }


  /**
   * scorecache findMany
   */
  export type scorecacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scorecache
     */
    select?: scorecacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: scorecacheInclude<ExtArgs> | null
    /**
     * Filter, which scorecaches to fetch.
     */
    where?: scorecacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scorecaches to fetch.
     */
    orderBy?: scorecacheOrderByWithRelationInput | scorecacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing scorecaches.
     */
    cursor?: scorecacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scorecaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scorecaches.
     */
    skip?: number
    distinct?: ScorecacheScalarFieldEnum | ScorecacheScalarFieldEnum[]
  }


  /**
   * scorecache create
   */
  export type scorecacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scorecache
     */
    select?: scorecacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: scorecacheInclude<ExtArgs> | null
    /**
     * The data needed to create a scorecache.
     */
    data: XOR<scorecacheCreateInput, scorecacheUncheckedCreateInput>
  }


  /**
   * scorecache createMany
   */
  export type scorecacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many scorecaches.
     */
    data: scorecacheCreateManyInput | scorecacheCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * scorecache update
   */
  export type scorecacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scorecache
     */
    select?: scorecacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: scorecacheInclude<ExtArgs> | null
    /**
     * The data needed to update a scorecache.
     */
    data: XOR<scorecacheUpdateInput, scorecacheUncheckedUpdateInput>
    /**
     * Choose, which scorecache to update.
     */
    where: scorecacheWhereUniqueInput
  }


  /**
   * scorecache updateMany
   */
  export type scorecacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update scorecaches.
     */
    data: XOR<scorecacheUpdateManyMutationInput, scorecacheUncheckedUpdateManyInput>
    /**
     * Filter which scorecaches to update
     */
    where?: scorecacheWhereInput
  }


  /**
   * scorecache upsert
   */
  export type scorecacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scorecache
     */
    select?: scorecacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: scorecacheInclude<ExtArgs> | null
    /**
     * The filter to search for the scorecache to update in case it exists.
     */
    where: scorecacheWhereUniqueInput
    /**
     * In case the scorecache found by the `where` argument doesn't exist, create a new scorecache with this data.
     */
    create: XOR<scorecacheCreateInput, scorecacheUncheckedCreateInput>
    /**
     * In case the scorecache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<scorecacheUpdateInput, scorecacheUncheckedUpdateInput>
  }


  /**
   * scorecache delete
   */
  export type scorecacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scorecache
     */
    select?: scorecacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: scorecacheInclude<ExtArgs> | null
    /**
     * Filter which scorecache to delete.
     */
    where: scorecacheWhereUniqueInput
  }


  /**
   * scorecache deleteMany
   */
  export type scorecacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which scorecaches to delete
     */
    where?: scorecacheWhereInput
  }


  /**
   * scorecache without action
   */
  export type scorecacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scorecache
     */
    select?: scorecacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: scorecacheInclude<ExtArgs> | null
  }



  /**
   * Model sessions
   */

  export type AggregateSessions = {
    _count: SessionsCountAggregateOutputType | null
    _avg: SessionsAvgAggregateOutputType | null
    _sum: SessionsSumAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  export type SessionsAvgAggregateOutputType = {
    sess_lifetime: number | null
    sess_time: number | null
  }

  export type SessionsSumAggregateOutputType = {
    sess_lifetime: number | null
    sess_time: number | null
  }

  export type SessionsMinAggregateOutputType = {
    sess_id: Buffer | null
    sess_data: Buffer | null
    sess_lifetime: number | null
    sess_time: number | null
  }

  export type SessionsMaxAggregateOutputType = {
    sess_id: Buffer | null
    sess_data: Buffer | null
    sess_lifetime: number | null
    sess_time: number | null
  }

  export type SessionsCountAggregateOutputType = {
    sess_id: number
    sess_data: number
    sess_lifetime: number
    sess_time: number
    _all: number
  }


  export type SessionsAvgAggregateInputType = {
    sess_lifetime?: true
    sess_time?: true
  }

  export type SessionsSumAggregateInputType = {
    sess_lifetime?: true
    sess_time?: true
  }

  export type SessionsMinAggregateInputType = {
    sess_id?: true
    sess_data?: true
    sess_lifetime?: true
    sess_time?: true
  }

  export type SessionsMaxAggregateInputType = {
    sess_id?: true
    sess_data?: true
    sess_lifetime?: true
    sess_time?: true
  }

  export type SessionsCountAggregateInputType = {
    sess_id?: true
    sess_data?: true
    sess_lifetime?: true
    sess_time?: true
    _all?: true
  }

  export type SessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to aggregate.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionsMaxAggregateInputType
  }

  export type GetSessionsAggregateType<T extends SessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions[P]>
      : GetScalarType<T[P], AggregateSessions[P]>
  }




  export type sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithAggregationInput | sessionsOrderByWithAggregationInput[]
    by: SessionsScalarFieldEnum[] | SessionsScalarFieldEnum
    having?: sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionsCountAggregateInputType | true
    _avg?: SessionsAvgAggregateInputType
    _sum?: SessionsSumAggregateInputType
    _min?: SessionsMinAggregateInputType
    _max?: SessionsMaxAggregateInputType
  }

  export type SessionsGroupByOutputType = {
    sess_id: Buffer
    sess_data: Buffer
    sess_lifetime: number
    sess_time: number
    _count: SessionsCountAggregateOutputType | null
    _avg: SessionsAvgAggregateOutputType | null
    _sum: SessionsSumAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  type GetSessionsGroupByPayload<T extends sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionsGroupByOutputType[P]>
            : GetScalarType<T[P], SessionsGroupByOutputType[P]>
        }
      >
    >


  export type sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sess_id?: boolean
    sess_data?: boolean
    sess_lifetime?: boolean
    sess_time?: boolean
  }, ExtArgs["result"]["sessions"]>

  export type sessionsSelectScalar = {
    sess_id?: boolean
    sess_data?: boolean
    sess_lifetime?: boolean
    sess_time?: boolean
  }


  export type $sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sessions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      sess_id: Buffer
      sess_data: Buffer
      sess_lifetime: number
      sess_time: number
    }, ExtArgs["result"]["sessions"]>
    composites: {}
  }


  type sessionsGetPayload<S extends boolean | null | undefined | sessionsDefaultArgs> = $Result.GetResult<Prisma.$sessionsPayload, S>

  type sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<sessionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionsCountAggregateInputType | true
    }

  export interface sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sessions'], meta: { name: 'sessions' } }
    /**
     * Find zero or one Sessions that matches the filter.
     * @param {sessionsFindUniqueArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sessionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, sessionsFindUniqueArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Sessions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sessionsFindUniqueOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sessionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sessionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionsFindFirstArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sessionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.sessions.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.sessions.findMany({ take: 10 })
     * 
     * // Only select the `sess_id`
     * const sessionsWithSess_idOnly = await prisma.sessions.findMany({ select: { sess_id: true } })
     * 
    **/
    findMany<T extends sessionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Sessions.
     * @param {sessionsCreateArgs} args - Arguments to create a Sessions.
     * @example
     * // Create one Sessions
     * const Sessions = await prisma.sessions.create({
     *   data: {
     *     // ... data to create a Sessions
     *   }
     * })
     * 
    **/
    create<T extends sessionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, sessionsCreateArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sessions.
     *     @param {sessionsCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const sessions = await prisma.sessions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sessionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sessions.
     * @param {sessionsDeleteArgs} args - Arguments to delete one Sessions.
     * @example
     * // Delete one Sessions
     * const Sessions = await prisma.sessions.delete({
     *   where: {
     *     // ... filter to delete one Sessions
     *   }
     * })
     * 
    **/
    delete<T extends sessionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, sessionsDeleteArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Sessions.
     * @param {sessionsUpdateArgs} args - Arguments to update one Sessions.
     * @example
     * // Update one Sessions
     * const sessions = await prisma.sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sessionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, sessionsUpdateArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {sessionsDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sessionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sessionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, sessionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sessions.
     * @param {sessionsUpsertArgs} args - Arguments to update or create a Sessions.
     * @example
     * // Update or create a Sessions
     * const sessions = await prisma.sessions.upsert({
     *   create: {
     *     // ... data to create a Sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions we want to update
     *   }
     * })
    **/
    upsert<T extends sessionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, sessionsUpsertArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.sessions.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionsCountArgs>(
      args?: Subset<T, sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionsAggregateArgs>(args: Subset<T, SessionsAggregateArgs>): Prisma.PrismaPromise<GetSessionsAggregateType<T>>

    /**
     * Group by Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionsGroupByArgs['orderBy'] }
        : { orderBy?: sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sessions model
   */
  readonly fields: sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the sessions model
   */ 
  interface sessionsFieldRefs {
    readonly sess_id: FieldRef<"sessions", 'Bytes'>
    readonly sess_data: FieldRef<"sessions", 'Bytes'>
    readonly sess_lifetime: FieldRef<"sessions", 'Int'>
    readonly sess_time: FieldRef<"sessions", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * sessions findUnique
   */
  export type sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }


  /**
   * sessions findUniqueOrThrow
   */
  export type sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }


  /**
   * sessions findFirst
   */
  export type sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }


  /**
   * sessions findFirstOrThrow
   */
  export type sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }


  /**
   * sessions findMany
   */
  export type sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }


  /**
   * sessions create
   */
  export type sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * The data needed to create a sessions.
     */
    data: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
  }


  /**
   * sessions createMany
   */
  export type sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionsCreateManyInput | sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * sessions update
   */
  export type sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * The data needed to update a sessions.
     */
    data: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
    /**
     * Choose, which sessions to update.
     */
    where: sessionsWhereUniqueInput
  }


  /**
   * sessions updateMany
   */
  export type sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionsWhereInput
  }


  /**
   * sessions upsert
   */
  export type sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * The filter to search for the sessions to update in case it exists.
     */
    where: sessionsWhereUniqueInput
    /**
     * In case the sessions found by the `where` argument doesn't exist, create a new sessions with this data.
     */
    create: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
    /**
     * In case the sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
  }


  /**
   * sessions delete
   */
  export type sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Filter which sessions to delete.
     */
    where: sessionsWhereUniqueInput
  }


  /**
   * sessions deleteMany
   */
  export type sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionsWhereInput
  }


  /**
   * sessions without action
   */
  export type sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
  }



  /**
   * Model submission
   */

  export type AggregateSubmission = {
    _count: SubmissionCountAggregateOutputType | null
    _avg: SubmissionAvgAggregateOutputType | null
    _sum: SubmissionSumAggregateOutputType | null
    _min: SubmissionMinAggregateOutputType | null
    _max: SubmissionMaxAggregateOutputType | null
  }

  export type SubmissionAvgAggregateOutputType = {
    submitid: number | null
    origsubmitid: number | null
    cid: number | null
    teamid: number | null
    userid: number | null
    probid: number | null
    submittime: Decimal | null
    rejudgingid: number | null
  }

  export type SubmissionSumAggregateOutputType = {
    submitid: number | null
    origsubmitid: number | null
    cid: number | null
    teamid: number | null
    userid: number | null
    probid: number | null
    submittime: Decimal | null
    rejudgingid: number | null
  }

  export type SubmissionMinAggregateOutputType = {
    submitid: number | null
    origsubmitid: number | null
    cid: number | null
    teamid: number | null
    userid: number | null
    probid: number | null
    langid: string | null
    submittime: Decimal | null
    valid: boolean | null
    rejudgingid: number | null
    expected_results: string | null
    externalid: string | null
    entry_point: string | null
  }

  export type SubmissionMaxAggregateOutputType = {
    submitid: number | null
    origsubmitid: number | null
    cid: number | null
    teamid: number | null
    userid: number | null
    probid: number | null
    langid: string | null
    submittime: Decimal | null
    valid: boolean | null
    rejudgingid: number | null
    expected_results: string | null
    externalid: string | null
    entry_point: string | null
  }

  export type SubmissionCountAggregateOutputType = {
    submitid: number
    origsubmitid: number
    cid: number
    teamid: number
    userid: number
    probid: number
    langid: number
    submittime: number
    valid: number
    rejudgingid: number
    expected_results: number
    externalid: number
    entry_point: number
    _all: number
  }


  export type SubmissionAvgAggregateInputType = {
    submitid?: true
    origsubmitid?: true
    cid?: true
    teamid?: true
    userid?: true
    probid?: true
    submittime?: true
    rejudgingid?: true
  }

  export type SubmissionSumAggregateInputType = {
    submitid?: true
    origsubmitid?: true
    cid?: true
    teamid?: true
    userid?: true
    probid?: true
    submittime?: true
    rejudgingid?: true
  }

  export type SubmissionMinAggregateInputType = {
    submitid?: true
    origsubmitid?: true
    cid?: true
    teamid?: true
    userid?: true
    probid?: true
    langid?: true
    submittime?: true
    valid?: true
    rejudgingid?: true
    expected_results?: true
    externalid?: true
    entry_point?: true
  }

  export type SubmissionMaxAggregateInputType = {
    submitid?: true
    origsubmitid?: true
    cid?: true
    teamid?: true
    userid?: true
    probid?: true
    langid?: true
    submittime?: true
    valid?: true
    rejudgingid?: true
    expected_results?: true
    externalid?: true
    entry_point?: true
  }

  export type SubmissionCountAggregateInputType = {
    submitid?: true
    origsubmitid?: true
    cid?: true
    teamid?: true
    userid?: true
    probid?: true
    langid?: true
    submittime?: true
    valid?: true
    rejudgingid?: true
    expected_results?: true
    externalid?: true
    entry_point?: true
    _all?: true
  }

  export type SubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which submission to aggregate.
     */
    where?: submissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of submissions to fetch.
     */
    orderBy?: submissionOrderByWithRelationInput | submissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: submissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned submissions
    **/
    _count?: true | SubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubmissionMaxAggregateInputType
  }

  export type GetSubmissionAggregateType<T extends SubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubmission[P]>
      : GetScalarType<T[P], AggregateSubmission[P]>
  }




  export type submissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: submissionWhereInput
    orderBy?: submissionOrderByWithAggregationInput | submissionOrderByWithAggregationInput[]
    by: SubmissionScalarFieldEnum[] | SubmissionScalarFieldEnum
    having?: submissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubmissionCountAggregateInputType | true
    _avg?: SubmissionAvgAggregateInputType
    _sum?: SubmissionSumAggregateInputType
    _min?: SubmissionMinAggregateInputType
    _max?: SubmissionMaxAggregateInputType
  }

  export type SubmissionGroupByOutputType = {
    submitid: number
    origsubmitid: number | null
    cid: number | null
    teamid: number | null
    userid: number | null
    probid: number | null
    langid: string | null
    submittime: Decimal
    valid: boolean
    rejudgingid: number | null
    expected_results: string | null
    externalid: string | null
    entry_point: string | null
    _count: SubmissionCountAggregateOutputType | null
    _avg: SubmissionAvgAggregateOutputType | null
    _sum: SubmissionSumAggregateOutputType | null
    _min: SubmissionMinAggregateOutputType | null
    _max: SubmissionMaxAggregateOutputType | null
  }

  type GetSubmissionGroupByPayload<T extends submissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], SubmissionGroupByOutputType[P]>
        }
      >
    >


  export type submissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    submitid?: boolean
    origsubmitid?: boolean
    cid?: boolean
    teamid?: boolean
    userid?: boolean
    probid?: boolean
    langid?: boolean
    submittime?: boolean
    valid?: boolean
    rejudgingid?: boolean
    expected_results?: boolean
    externalid?: boolean
    entry_point?: boolean
    balloon?: boolean | submission$balloonArgs<ExtArgs>
    external_judgement?: boolean | submission$external_judgementArgs<ExtArgs>
    judging?: boolean | submission$judgingArgs<ExtArgs>
    user?: boolean | submission$userArgs<ExtArgs>
    contest?: boolean | submission$contestArgs<ExtArgs>
    team?: boolean | submission$teamArgs<ExtArgs>
    problem?: boolean | submission$problemArgs<ExtArgs>
    language?: boolean | submission$languageArgs<ExtArgs>
    submission?: boolean | submission$submissionArgs<ExtArgs>
    other_submission?: boolean | submission$other_submissionArgs<ExtArgs>
    rejudging?: boolean | submission$rejudgingArgs<ExtArgs>
    contestproblem?: boolean | submission$contestproblemArgs<ExtArgs>
    submission_file?: boolean | submission$submission_fileArgs<ExtArgs>
    _count?: boolean | SubmissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submission"]>

  export type submissionSelectScalar = {
    submitid?: boolean
    origsubmitid?: boolean
    cid?: boolean
    teamid?: boolean
    userid?: boolean
    probid?: boolean
    langid?: boolean
    submittime?: boolean
    valid?: boolean
    rejudgingid?: boolean
    expected_results?: boolean
    externalid?: boolean
    entry_point?: boolean
  }

  export type submissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    balloon?: boolean | submission$balloonArgs<ExtArgs>
    external_judgement?: boolean | submission$external_judgementArgs<ExtArgs>
    judging?: boolean | submission$judgingArgs<ExtArgs>
    user?: boolean | submission$userArgs<ExtArgs>
    contest?: boolean | submission$contestArgs<ExtArgs>
    team?: boolean | submission$teamArgs<ExtArgs>
    problem?: boolean | submission$problemArgs<ExtArgs>
    language?: boolean | submission$languageArgs<ExtArgs>
    submission?: boolean | submission$submissionArgs<ExtArgs>
    other_submission?: boolean | submission$other_submissionArgs<ExtArgs>
    rejudging?: boolean | submission$rejudgingArgs<ExtArgs>
    contestproblem?: boolean | submission$contestproblemArgs<ExtArgs>
    submission_file?: boolean | submission$submission_fileArgs<ExtArgs>
    _count?: boolean | SubmissionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $submissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "submission"
    objects: {
      balloon: Prisma.$balloonPayload<ExtArgs>[]
      external_judgement: Prisma.$external_judgementPayload<ExtArgs>[]
      judging: Prisma.$judgingPayload<ExtArgs>[]
      user: Prisma.$userPayload<ExtArgs> | null
      contest: Prisma.$contestPayload<ExtArgs> | null
      team: Prisma.$teamPayload<ExtArgs> | null
      problem: Prisma.$problemPayload<ExtArgs> | null
      language: Prisma.$languagePayload<ExtArgs> | null
      submission: Prisma.$submissionPayload<ExtArgs> | null
      other_submission: Prisma.$submissionPayload<ExtArgs>[]
      rejudging: Prisma.$rejudgingPayload<ExtArgs> | null
      contestproblem: Prisma.$contestproblemPayload<ExtArgs> | null
      submission_file: Prisma.$submission_filePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      submitid: number
      origsubmitid: number | null
      cid: number | null
      teamid: number | null
      userid: number | null
      probid: number | null
      langid: string | null
      submittime: Prisma.Decimal
      valid: boolean
      rejudgingid: number | null
      expected_results: string | null
      externalid: string | null
      entry_point: string | null
    }, ExtArgs["result"]["submission"]>
    composites: {}
  }


  type submissionGetPayload<S extends boolean | null | undefined | submissionDefaultArgs> = $Result.GetResult<Prisma.$submissionPayload, S>

  type submissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<submissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubmissionCountAggregateInputType | true
    }

  export interface submissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['submission'], meta: { name: 'submission' } }
    /**
     * Find zero or one Submission that matches the filter.
     * @param {submissionFindUniqueArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends submissionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, submissionFindUniqueArgs<ExtArgs>>
    ): Prisma__submissionClient<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Submission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {submissionFindUniqueOrThrowArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends submissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, submissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__submissionClient<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Submission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {submissionFindFirstArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends submissionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, submissionFindFirstArgs<ExtArgs>>
    ): Prisma__submissionClient<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Submission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {submissionFindFirstOrThrowArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends submissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, submissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__submissionClient<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {submissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Submissions
     * const submissions = await prisma.submission.findMany()
     * 
     * // Get first 10 Submissions
     * const submissions = await prisma.submission.findMany({ take: 10 })
     * 
     * // Only select the `submitid`
     * const submissionWithSubmitidOnly = await prisma.submission.findMany({ select: { submitid: true } })
     * 
    **/
    findMany<T extends submissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, submissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Submission.
     * @param {submissionCreateArgs} args - Arguments to create a Submission.
     * @example
     * // Create one Submission
     * const Submission = await prisma.submission.create({
     *   data: {
     *     // ... data to create a Submission
     *   }
     * })
     * 
    **/
    create<T extends submissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, submissionCreateArgs<ExtArgs>>
    ): Prisma__submissionClient<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Submissions.
     *     @param {submissionCreateManyArgs} args - Arguments to create many Submissions.
     *     @example
     *     // Create many Submissions
     *     const submission = await prisma.submission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends submissionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, submissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Submission.
     * @param {submissionDeleteArgs} args - Arguments to delete one Submission.
     * @example
     * // Delete one Submission
     * const Submission = await prisma.submission.delete({
     *   where: {
     *     // ... filter to delete one Submission
     *   }
     * })
     * 
    **/
    delete<T extends submissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, submissionDeleteArgs<ExtArgs>>
    ): Prisma__submissionClient<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Submission.
     * @param {submissionUpdateArgs} args - Arguments to update one Submission.
     * @example
     * // Update one Submission
     * const submission = await prisma.submission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends submissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, submissionUpdateArgs<ExtArgs>>
    ): Prisma__submissionClient<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Submissions.
     * @param {submissionDeleteManyArgs} args - Arguments to filter Submissions to delete.
     * @example
     * // Delete a few Submissions
     * const { count } = await prisma.submission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends submissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, submissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {submissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Submissions
     * const submission = await prisma.submission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends submissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, submissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Submission.
     * @param {submissionUpsertArgs} args - Arguments to update or create a Submission.
     * @example
     * // Update or create a Submission
     * const submission = await prisma.submission.upsert({
     *   create: {
     *     // ... data to create a Submission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Submission we want to update
     *   }
     * })
    **/
    upsert<T extends submissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, submissionUpsertArgs<ExtArgs>>
    ): Prisma__submissionClient<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {submissionCountArgs} args - Arguments to filter Submissions to count.
     * @example
     * // Count the number of Submissions
     * const count = await prisma.submission.count({
     *   where: {
     *     // ... the filter for the Submissions we want to count
     *   }
     * })
    **/
    count<T extends submissionCountArgs>(
      args?: Subset<T, submissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubmissionAggregateArgs>(args: Subset<T, SubmissionAggregateArgs>): Prisma.PrismaPromise<GetSubmissionAggregateType<T>>

    /**
     * Group by Submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {submissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends submissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: submissionGroupByArgs['orderBy'] }
        : { orderBy?: submissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, submissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the submission model
   */
  readonly fields: submissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for submission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__submissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    balloon<T extends submission$balloonArgs<ExtArgs> = {}>(args?: Subset<T, submission$balloonArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$balloonPayload<ExtArgs>, T, 'findMany'> | Null>;

    external_judgement<T extends submission$external_judgementArgs<ExtArgs> = {}>(args?: Subset<T, submission$external_judgementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$external_judgementPayload<ExtArgs>, T, 'findMany'> | Null>;

    judging<T extends submission$judgingArgs<ExtArgs> = {}>(args?: Subset<T, submission$judgingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$judgingPayload<ExtArgs>, T, 'findMany'> | Null>;

    user<T extends submission$userArgs<ExtArgs> = {}>(args?: Subset<T, submission$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    contest<T extends submission$contestArgs<ExtArgs> = {}>(args?: Subset<T, submission$contestArgs<ExtArgs>>): Prisma__contestClient<$Result.GetResult<Prisma.$contestPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    team<T extends submission$teamArgs<ExtArgs> = {}>(args?: Subset<T, submission$teamArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    problem<T extends submission$problemArgs<ExtArgs> = {}>(args?: Subset<T, submission$problemArgs<ExtArgs>>): Prisma__problemClient<$Result.GetResult<Prisma.$problemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    language<T extends submission$languageArgs<ExtArgs> = {}>(args?: Subset<T, submission$languageArgs<ExtArgs>>): Prisma__languageClient<$Result.GetResult<Prisma.$languagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    submission<T extends submission$submissionArgs<ExtArgs> = {}>(args?: Subset<T, submission$submissionArgs<ExtArgs>>): Prisma__submissionClient<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    other_submission<T extends submission$other_submissionArgs<ExtArgs> = {}>(args?: Subset<T, submission$other_submissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'findMany'> | Null>;

    rejudging<T extends submission$rejudgingArgs<ExtArgs> = {}>(args?: Subset<T, submission$rejudgingArgs<ExtArgs>>): Prisma__rejudgingClient<$Result.GetResult<Prisma.$rejudgingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    contestproblem<T extends submission$contestproblemArgs<ExtArgs> = {}>(args?: Subset<T, submission$contestproblemArgs<ExtArgs>>): Prisma__contestproblemClient<$Result.GetResult<Prisma.$contestproblemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    submission_file<T extends submission$submission_fileArgs<ExtArgs> = {}>(args?: Subset<T, submission$submission_fileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$submission_filePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the submission model
   */ 
  interface submissionFieldRefs {
    readonly submitid: FieldRef<"submission", 'Int'>
    readonly origsubmitid: FieldRef<"submission", 'Int'>
    readonly cid: FieldRef<"submission", 'Int'>
    readonly teamid: FieldRef<"submission", 'Int'>
    readonly userid: FieldRef<"submission", 'Int'>
    readonly probid: FieldRef<"submission", 'Int'>
    readonly langid: FieldRef<"submission", 'String'>
    readonly submittime: FieldRef<"submission", 'Decimal'>
    readonly valid: FieldRef<"submission", 'Boolean'>
    readonly rejudgingid: FieldRef<"submission", 'Int'>
    readonly expected_results: FieldRef<"submission", 'String'>
    readonly externalid: FieldRef<"submission", 'String'>
    readonly entry_point: FieldRef<"submission", 'String'>
  }
    

  // Custom InputTypes

  /**
   * submission findUnique
   */
  export type submissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    /**
     * Filter, which submission to fetch.
     */
    where: submissionWhereUniqueInput
  }


  /**
   * submission findUniqueOrThrow
   */
  export type submissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    /**
     * Filter, which submission to fetch.
     */
    where: submissionWhereUniqueInput
  }


  /**
   * submission findFirst
   */
  export type submissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    /**
     * Filter, which submission to fetch.
     */
    where?: submissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of submissions to fetch.
     */
    orderBy?: submissionOrderByWithRelationInput | submissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for submissions.
     */
    cursor?: submissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of submissions.
     */
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }


  /**
   * submission findFirstOrThrow
   */
  export type submissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    /**
     * Filter, which submission to fetch.
     */
    where?: submissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of submissions to fetch.
     */
    orderBy?: submissionOrderByWithRelationInput | submissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for submissions.
     */
    cursor?: submissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of submissions.
     */
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }


  /**
   * submission findMany
   */
  export type submissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    /**
     * Filter, which submissions to fetch.
     */
    where?: submissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of submissions to fetch.
     */
    orderBy?: submissionOrderByWithRelationInput | submissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing submissions.
     */
    cursor?: submissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` submissions.
     */
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }


  /**
   * submission create
   */
  export type submissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    /**
     * The data needed to create a submission.
     */
    data: XOR<submissionCreateInput, submissionUncheckedCreateInput>
  }


  /**
   * submission createMany
   */
  export type submissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many submissions.
     */
    data: submissionCreateManyInput | submissionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * submission update
   */
  export type submissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    /**
     * The data needed to update a submission.
     */
    data: XOR<submissionUpdateInput, submissionUncheckedUpdateInput>
    /**
     * Choose, which submission to update.
     */
    where: submissionWhereUniqueInput
  }


  /**
   * submission updateMany
   */
  export type submissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update submissions.
     */
    data: XOR<submissionUpdateManyMutationInput, submissionUncheckedUpdateManyInput>
    /**
     * Filter which submissions to update
     */
    where?: submissionWhereInput
  }


  /**
   * submission upsert
   */
  export type submissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    /**
     * The filter to search for the submission to update in case it exists.
     */
    where: submissionWhereUniqueInput
    /**
     * In case the submission found by the `where` argument doesn't exist, create a new submission with this data.
     */
    create: XOR<submissionCreateInput, submissionUncheckedCreateInput>
    /**
     * In case the submission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<submissionUpdateInput, submissionUncheckedUpdateInput>
  }


  /**
   * submission delete
   */
  export type submissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    /**
     * Filter which submission to delete.
     */
    where: submissionWhereUniqueInput
  }


  /**
   * submission deleteMany
   */
  export type submissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which submissions to delete
     */
    where?: submissionWhereInput
  }


  /**
   * submission.balloon
   */
  export type submission$balloonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balloon
     */
    select?: balloonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: balloonInclude<ExtArgs> | null
    where?: balloonWhereInput
    orderBy?: balloonOrderByWithRelationInput | balloonOrderByWithRelationInput[]
    cursor?: balloonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BalloonScalarFieldEnum | BalloonScalarFieldEnum[]
  }


  /**
   * submission.external_judgement
   */
  export type submission$external_judgementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_judgement
     */
    select?: external_judgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_judgementInclude<ExtArgs> | null
    where?: external_judgementWhereInput
    orderBy?: external_judgementOrderByWithRelationInput | external_judgementOrderByWithRelationInput[]
    cursor?: external_judgementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: External_judgementScalarFieldEnum | External_judgementScalarFieldEnum[]
  }


  /**
   * submission.judging
   */
  export type submission$judgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging
     */
    select?: judgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judgingInclude<ExtArgs> | null
    where?: judgingWhereInput
    orderBy?: judgingOrderByWithRelationInput | judgingOrderByWithRelationInput[]
    cursor?: judgingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JudgingScalarFieldEnum | JudgingScalarFieldEnum[]
  }


  /**
   * submission.user
   */
  export type submission$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }


  /**
   * submission.contest
   */
  export type submission$contestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contest
     */
    select?: contestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestInclude<ExtArgs> | null
    where?: contestWhereInput
  }


  /**
   * submission.team
   */
  export type submission$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    where?: teamWhereInput
  }


  /**
   * submission.problem
   */
  export type submission$problemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem
     */
    select?: problemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problemInclude<ExtArgs> | null
    where?: problemWhereInput
  }


  /**
   * submission.language
   */
  export type submission$languageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: languageInclude<ExtArgs> | null
    where?: languageWhereInput
  }


  /**
   * submission.submission
   */
  export type submission$submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    where?: submissionWhereInput
  }


  /**
   * submission.other_submission
   */
  export type submission$other_submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    where?: submissionWhereInput
    orderBy?: submissionOrderByWithRelationInput | submissionOrderByWithRelationInput[]
    cursor?: submissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }


  /**
   * submission.rejudging
   */
  export type submission$rejudgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejudging
     */
    select?: rejudgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rejudgingInclude<ExtArgs> | null
    where?: rejudgingWhereInput
  }


  /**
   * submission.contestproblem
   */
  export type submission$contestproblemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestproblem
     */
    select?: contestproblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestproblemInclude<ExtArgs> | null
    where?: contestproblemWhereInput
  }


  /**
   * submission.submission_file
   */
  export type submission$submission_fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission_file
     */
    select?: submission_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submission_fileInclude<ExtArgs> | null
    where?: submission_fileWhereInput
    orderBy?: submission_fileOrderByWithRelationInput | submission_fileOrderByWithRelationInput[]
    cursor?: submission_fileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Submission_fileScalarFieldEnum | Submission_fileScalarFieldEnum[]
  }


  /**
   * submission without action
   */
  export type submissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
  }



  /**
   * Model submission_file
   */

  export type AggregateSubmission_file = {
    _count: Submission_fileCountAggregateOutputType | null
    _avg: Submission_fileAvgAggregateOutputType | null
    _sum: Submission_fileSumAggregateOutputType | null
    _min: Submission_fileMinAggregateOutputType | null
    _max: Submission_fileMaxAggregateOutputType | null
  }

  export type Submission_fileAvgAggregateOutputType = {
    submitfileid: number | null
    submitid: number | null
    ranknumber: number | null
  }

  export type Submission_fileSumAggregateOutputType = {
    submitfileid: number | null
    submitid: number | null
    ranknumber: number | null
  }

  export type Submission_fileMinAggregateOutputType = {
    submitfileid: number | null
    submitid: number | null
    sourcecode: Buffer | null
    filename: string | null
    ranknumber: number | null
  }

  export type Submission_fileMaxAggregateOutputType = {
    submitfileid: number | null
    submitid: number | null
    sourcecode: Buffer | null
    filename: string | null
    ranknumber: number | null
  }

  export type Submission_fileCountAggregateOutputType = {
    submitfileid: number
    submitid: number
    sourcecode: number
    filename: number
    ranknumber: number
    _all: number
  }


  export type Submission_fileAvgAggregateInputType = {
    submitfileid?: true
    submitid?: true
    ranknumber?: true
  }

  export type Submission_fileSumAggregateInputType = {
    submitfileid?: true
    submitid?: true
    ranknumber?: true
  }

  export type Submission_fileMinAggregateInputType = {
    submitfileid?: true
    submitid?: true
    sourcecode?: true
    filename?: true
    ranknumber?: true
  }

  export type Submission_fileMaxAggregateInputType = {
    submitfileid?: true
    submitid?: true
    sourcecode?: true
    filename?: true
    ranknumber?: true
  }

  export type Submission_fileCountAggregateInputType = {
    submitfileid?: true
    submitid?: true
    sourcecode?: true
    filename?: true
    ranknumber?: true
    _all?: true
  }

  export type Submission_fileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which submission_file to aggregate.
     */
    where?: submission_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of submission_files to fetch.
     */
    orderBy?: submission_fileOrderByWithRelationInput | submission_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: submission_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` submission_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` submission_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned submission_files
    **/
    _count?: true | Submission_fileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Submission_fileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Submission_fileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Submission_fileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Submission_fileMaxAggregateInputType
  }

  export type GetSubmission_fileAggregateType<T extends Submission_fileAggregateArgs> = {
        [P in keyof T & keyof AggregateSubmission_file]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubmission_file[P]>
      : GetScalarType<T[P], AggregateSubmission_file[P]>
  }




  export type submission_fileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: submission_fileWhereInput
    orderBy?: submission_fileOrderByWithAggregationInput | submission_fileOrderByWithAggregationInput[]
    by: Submission_fileScalarFieldEnum[] | Submission_fileScalarFieldEnum
    having?: submission_fileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Submission_fileCountAggregateInputType | true
    _avg?: Submission_fileAvgAggregateInputType
    _sum?: Submission_fileSumAggregateInputType
    _min?: Submission_fileMinAggregateInputType
    _max?: Submission_fileMaxAggregateInputType
  }

  export type Submission_fileGroupByOutputType = {
    submitfileid: number
    submitid: number | null
    sourcecode: Buffer
    filename: string
    ranknumber: number
    _count: Submission_fileCountAggregateOutputType | null
    _avg: Submission_fileAvgAggregateOutputType | null
    _sum: Submission_fileSumAggregateOutputType | null
    _min: Submission_fileMinAggregateOutputType | null
    _max: Submission_fileMaxAggregateOutputType | null
  }

  type GetSubmission_fileGroupByPayload<T extends submission_fileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Submission_fileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Submission_fileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Submission_fileGroupByOutputType[P]>
            : GetScalarType<T[P], Submission_fileGroupByOutputType[P]>
        }
      >
    >


  export type submission_fileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    submitfileid?: boolean
    submitid?: boolean
    sourcecode?: boolean
    filename?: boolean
    ranknumber?: boolean
    submission?: boolean | submission_file$submissionArgs<ExtArgs>
  }, ExtArgs["result"]["submission_file"]>

  export type submission_fileSelectScalar = {
    submitfileid?: boolean
    submitid?: boolean
    sourcecode?: boolean
    filename?: boolean
    ranknumber?: boolean
  }

  export type submission_fileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submission?: boolean | submission_file$submissionArgs<ExtArgs>
  }


  export type $submission_filePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "submission_file"
    objects: {
      submission: Prisma.$submissionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      submitfileid: number
      submitid: number | null
      sourcecode: Buffer
      filename: string
      ranknumber: number
    }, ExtArgs["result"]["submission_file"]>
    composites: {}
  }


  type submission_fileGetPayload<S extends boolean | null | undefined | submission_fileDefaultArgs> = $Result.GetResult<Prisma.$submission_filePayload, S>

  type submission_fileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<submission_fileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Submission_fileCountAggregateInputType | true
    }

  export interface submission_fileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['submission_file'], meta: { name: 'submission_file' } }
    /**
     * Find zero or one Submission_file that matches the filter.
     * @param {submission_fileFindUniqueArgs} args - Arguments to find a Submission_file
     * @example
     * // Get one Submission_file
     * const submission_file = await prisma.submission_file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends submission_fileFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, submission_fileFindUniqueArgs<ExtArgs>>
    ): Prisma__submission_fileClient<$Result.GetResult<Prisma.$submission_filePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Submission_file that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {submission_fileFindUniqueOrThrowArgs} args - Arguments to find a Submission_file
     * @example
     * // Get one Submission_file
     * const submission_file = await prisma.submission_file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends submission_fileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, submission_fileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__submission_fileClient<$Result.GetResult<Prisma.$submission_filePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Submission_file that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {submission_fileFindFirstArgs} args - Arguments to find a Submission_file
     * @example
     * // Get one Submission_file
     * const submission_file = await prisma.submission_file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends submission_fileFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, submission_fileFindFirstArgs<ExtArgs>>
    ): Prisma__submission_fileClient<$Result.GetResult<Prisma.$submission_filePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Submission_file that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {submission_fileFindFirstOrThrowArgs} args - Arguments to find a Submission_file
     * @example
     * // Get one Submission_file
     * const submission_file = await prisma.submission_file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends submission_fileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, submission_fileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__submission_fileClient<$Result.GetResult<Prisma.$submission_filePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Submission_files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {submission_fileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Submission_files
     * const submission_files = await prisma.submission_file.findMany()
     * 
     * // Get first 10 Submission_files
     * const submission_files = await prisma.submission_file.findMany({ take: 10 })
     * 
     * // Only select the `submitfileid`
     * const submission_fileWithSubmitfileidOnly = await prisma.submission_file.findMany({ select: { submitfileid: true } })
     * 
    **/
    findMany<T extends submission_fileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, submission_fileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$submission_filePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Submission_file.
     * @param {submission_fileCreateArgs} args - Arguments to create a Submission_file.
     * @example
     * // Create one Submission_file
     * const Submission_file = await prisma.submission_file.create({
     *   data: {
     *     // ... data to create a Submission_file
     *   }
     * })
     * 
    **/
    create<T extends submission_fileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, submission_fileCreateArgs<ExtArgs>>
    ): Prisma__submission_fileClient<$Result.GetResult<Prisma.$submission_filePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Submission_files.
     *     @param {submission_fileCreateManyArgs} args - Arguments to create many Submission_files.
     *     @example
     *     // Create many Submission_files
     *     const submission_file = await prisma.submission_file.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends submission_fileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, submission_fileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Submission_file.
     * @param {submission_fileDeleteArgs} args - Arguments to delete one Submission_file.
     * @example
     * // Delete one Submission_file
     * const Submission_file = await prisma.submission_file.delete({
     *   where: {
     *     // ... filter to delete one Submission_file
     *   }
     * })
     * 
    **/
    delete<T extends submission_fileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, submission_fileDeleteArgs<ExtArgs>>
    ): Prisma__submission_fileClient<$Result.GetResult<Prisma.$submission_filePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Submission_file.
     * @param {submission_fileUpdateArgs} args - Arguments to update one Submission_file.
     * @example
     * // Update one Submission_file
     * const submission_file = await prisma.submission_file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends submission_fileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, submission_fileUpdateArgs<ExtArgs>>
    ): Prisma__submission_fileClient<$Result.GetResult<Prisma.$submission_filePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Submission_files.
     * @param {submission_fileDeleteManyArgs} args - Arguments to filter Submission_files to delete.
     * @example
     * // Delete a few Submission_files
     * const { count } = await prisma.submission_file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends submission_fileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, submission_fileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Submission_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {submission_fileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Submission_files
     * const submission_file = await prisma.submission_file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends submission_fileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, submission_fileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Submission_file.
     * @param {submission_fileUpsertArgs} args - Arguments to update or create a Submission_file.
     * @example
     * // Update or create a Submission_file
     * const submission_file = await prisma.submission_file.upsert({
     *   create: {
     *     // ... data to create a Submission_file
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Submission_file we want to update
     *   }
     * })
    **/
    upsert<T extends submission_fileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, submission_fileUpsertArgs<ExtArgs>>
    ): Prisma__submission_fileClient<$Result.GetResult<Prisma.$submission_filePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Submission_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {submission_fileCountArgs} args - Arguments to filter Submission_files to count.
     * @example
     * // Count the number of Submission_files
     * const count = await prisma.submission_file.count({
     *   where: {
     *     // ... the filter for the Submission_files we want to count
     *   }
     * })
    **/
    count<T extends submission_fileCountArgs>(
      args?: Subset<T, submission_fileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Submission_fileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Submission_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Submission_fileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Submission_fileAggregateArgs>(args: Subset<T, Submission_fileAggregateArgs>): Prisma.PrismaPromise<GetSubmission_fileAggregateType<T>>

    /**
     * Group by Submission_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {submission_fileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends submission_fileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: submission_fileGroupByArgs['orderBy'] }
        : { orderBy?: submission_fileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, submission_fileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubmission_fileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the submission_file model
   */
  readonly fields: submission_fileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for submission_file.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__submission_fileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    submission<T extends submission_file$submissionArgs<ExtArgs> = {}>(args?: Subset<T, submission_file$submissionArgs<ExtArgs>>): Prisma__submissionClient<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the submission_file model
   */ 
  interface submission_fileFieldRefs {
    readonly submitfileid: FieldRef<"submission_file", 'Int'>
    readonly submitid: FieldRef<"submission_file", 'Int'>
    readonly sourcecode: FieldRef<"submission_file", 'Bytes'>
    readonly filename: FieldRef<"submission_file", 'String'>
    readonly ranknumber: FieldRef<"submission_file", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * submission_file findUnique
   */
  export type submission_fileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission_file
     */
    select?: submission_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submission_fileInclude<ExtArgs> | null
    /**
     * Filter, which submission_file to fetch.
     */
    where: submission_fileWhereUniqueInput
  }


  /**
   * submission_file findUniqueOrThrow
   */
  export type submission_fileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission_file
     */
    select?: submission_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submission_fileInclude<ExtArgs> | null
    /**
     * Filter, which submission_file to fetch.
     */
    where: submission_fileWhereUniqueInput
  }


  /**
   * submission_file findFirst
   */
  export type submission_fileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission_file
     */
    select?: submission_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submission_fileInclude<ExtArgs> | null
    /**
     * Filter, which submission_file to fetch.
     */
    where?: submission_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of submission_files to fetch.
     */
    orderBy?: submission_fileOrderByWithRelationInput | submission_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for submission_files.
     */
    cursor?: submission_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` submission_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` submission_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of submission_files.
     */
    distinct?: Submission_fileScalarFieldEnum | Submission_fileScalarFieldEnum[]
  }


  /**
   * submission_file findFirstOrThrow
   */
  export type submission_fileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission_file
     */
    select?: submission_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submission_fileInclude<ExtArgs> | null
    /**
     * Filter, which submission_file to fetch.
     */
    where?: submission_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of submission_files to fetch.
     */
    orderBy?: submission_fileOrderByWithRelationInput | submission_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for submission_files.
     */
    cursor?: submission_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` submission_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` submission_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of submission_files.
     */
    distinct?: Submission_fileScalarFieldEnum | Submission_fileScalarFieldEnum[]
  }


  /**
   * submission_file findMany
   */
  export type submission_fileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission_file
     */
    select?: submission_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submission_fileInclude<ExtArgs> | null
    /**
     * Filter, which submission_files to fetch.
     */
    where?: submission_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of submission_files to fetch.
     */
    orderBy?: submission_fileOrderByWithRelationInput | submission_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing submission_files.
     */
    cursor?: submission_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` submission_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` submission_files.
     */
    skip?: number
    distinct?: Submission_fileScalarFieldEnum | Submission_fileScalarFieldEnum[]
  }


  /**
   * submission_file create
   */
  export type submission_fileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission_file
     */
    select?: submission_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submission_fileInclude<ExtArgs> | null
    /**
     * The data needed to create a submission_file.
     */
    data: XOR<submission_fileCreateInput, submission_fileUncheckedCreateInput>
  }


  /**
   * submission_file createMany
   */
  export type submission_fileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many submission_files.
     */
    data: submission_fileCreateManyInput | submission_fileCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * submission_file update
   */
  export type submission_fileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission_file
     */
    select?: submission_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submission_fileInclude<ExtArgs> | null
    /**
     * The data needed to update a submission_file.
     */
    data: XOR<submission_fileUpdateInput, submission_fileUncheckedUpdateInput>
    /**
     * Choose, which submission_file to update.
     */
    where: submission_fileWhereUniqueInput
  }


  /**
   * submission_file updateMany
   */
  export type submission_fileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update submission_files.
     */
    data: XOR<submission_fileUpdateManyMutationInput, submission_fileUncheckedUpdateManyInput>
    /**
     * Filter which submission_files to update
     */
    where?: submission_fileWhereInput
  }


  /**
   * submission_file upsert
   */
  export type submission_fileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission_file
     */
    select?: submission_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submission_fileInclude<ExtArgs> | null
    /**
     * The filter to search for the submission_file to update in case it exists.
     */
    where: submission_fileWhereUniqueInput
    /**
     * In case the submission_file found by the `where` argument doesn't exist, create a new submission_file with this data.
     */
    create: XOR<submission_fileCreateInput, submission_fileUncheckedCreateInput>
    /**
     * In case the submission_file was found with the provided `where` argument, update it with this data.
     */
    update: XOR<submission_fileUpdateInput, submission_fileUncheckedUpdateInput>
  }


  /**
   * submission_file delete
   */
  export type submission_fileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission_file
     */
    select?: submission_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submission_fileInclude<ExtArgs> | null
    /**
     * Filter which submission_file to delete.
     */
    where: submission_fileWhereUniqueInput
  }


  /**
   * submission_file deleteMany
   */
  export type submission_fileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which submission_files to delete
     */
    where?: submission_fileWhereInput
  }


  /**
   * submission_file.submission
   */
  export type submission_file$submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    where?: submissionWhereInput
  }


  /**
   * submission_file without action
   */
  export type submission_fileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission_file
     */
    select?: submission_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submission_fileInclude<ExtArgs> | null
  }



  /**
   * Model team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    teamid: number | null
    categoryid: number | null
    affilid: number | null
    judging_last_started: Decimal | null
    penalty: number | null
  }

  export type TeamSumAggregateOutputType = {
    teamid: number | null
    categoryid: number | null
    affilid: number | null
    judging_last_started: Decimal | null
    penalty: number | null
  }

  export type TeamMinAggregateOutputType = {
    teamid: number | null
    externalid: string | null
    icpcid: string | null
    name: string | null
    display_name: string | null
    categoryid: number | null
    affilid: number | null
    enabled: boolean | null
    publicdescription: string | null
    room: string | null
    internalcomments: string | null
    judging_last_started: Decimal | null
    penalty: number | null
  }

  export type TeamMaxAggregateOutputType = {
    teamid: number | null
    externalid: string | null
    icpcid: string | null
    name: string | null
    display_name: string | null
    categoryid: number | null
    affilid: number | null
    enabled: boolean | null
    publicdescription: string | null
    room: string | null
    internalcomments: string | null
    judging_last_started: Decimal | null
    penalty: number | null
  }

  export type TeamCountAggregateOutputType = {
    teamid: number
    externalid: number
    icpcid: number
    name: number
    display_name: number
    categoryid: number
    affilid: number
    enabled: number
    publicdescription: number
    room: number
    internalcomments: number
    judging_last_started: number
    penalty: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    teamid?: true
    categoryid?: true
    affilid?: true
    judging_last_started?: true
    penalty?: true
  }

  export type TeamSumAggregateInputType = {
    teamid?: true
    categoryid?: true
    affilid?: true
    judging_last_started?: true
    penalty?: true
  }

  export type TeamMinAggregateInputType = {
    teamid?: true
    externalid?: true
    icpcid?: true
    name?: true
    display_name?: true
    categoryid?: true
    affilid?: true
    enabled?: true
    publicdescription?: true
    room?: true
    internalcomments?: true
    judging_last_started?: true
    penalty?: true
  }

  export type TeamMaxAggregateInputType = {
    teamid?: true
    externalid?: true
    icpcid?: true
    name?: true
    display_name?: true
    categoryid?: true
    affilid?: true
    enabled?: true
    publicdescription?: true
    room?: true
    internalcomments?: true
    judging_last_started?: true
    penalty?: true
  }

  export type TeamCountAggregateInputType = {
    teamid?: true
    externalid?: true
    icpcid?: true
    name?: true
    display_name?: true
    categoryid?: true
    affilid?: true
    enabled?: true
    publicdescription?: true
    room?: true
    internalcomments?: true
    judging_last_started?: true
    penalty?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team to aggregate.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type teamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamWhereInput
    orderBy?: teamOrderByWithAggregationInput | teamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: teamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    teamid: number
    externalid: string | null
    icpcid: string | null
    name: string
    display_name: string | null
    categoryid: number | null
    affilid: number | null
    enabled: boolean
    publicdescription: string | null
    room: string | null
    internalcomments: string | null
    judging_last_started: Decimal | null
    penalty: number
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends teamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type teamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teamid?: boolean
    externalid?: boolean
    icpcid?: boolean
    name?: boolean
    display_name?: boolean
    categoryid?: boolean
    affilid?: boolean
    enabled?: boolean
    publicdescription?: boolean
    room?: boolean
    internalcomments?: boolean
    judging_last_started?: boolean
    penalty?: boolean
    clarification_clarification_senderToteam?: boolean | team$clarification_clarification_senderToteamArgs<ExtArgs>
    clarification_clarification_recipientToteam?: boolean | team$clarification_clarification_recipientToteamArgs<ExtArgs>
    contestteam?: boolean | team$contestteamArgs<ExtArgs>
    queuetask?: boolean | team$queuetaskArgs<ExtArgs>
    rankcache?: boolean | team$rankcacheArgs<ExtArgs>
    scorecache?: boolean | team$scorecacheArgs<ExtArgs>
    submission?: boolean | team$submissionArgs<ExtArgs>
    team_category?: boolean | team$team_categoryArgs<ExtArgs>
    team_affiliation?: boolean | team$team_affiliationArgs<ExtArgs>
    team_unread?: boolean | team$team_unreadArgs<ExtArgs>
    user?: boolean | team$userArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type teamSelectScalar = {
    teamid?: boolean
    externalid?: boolean
    icpcid?: boolean
    name?: boolean
    display_name?: boolean
    categoryid?: boolean
    affilid?: boolean
    enabled?: boolean
    publicdescription?: boolean
    room?: boolean
    internalcomments?: boolean
    judging_last_started?: boolean
    penalty?: boolean
  }

  export type teamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clarification_clarification_senderToteam?: boolean | team$clarification_clarification_senderToteamArgs<ExtArgs>
    clarification_clarification_recipientToteam?: boolean | team$clarification_clarification_recipientToteamArgs<ExtArgs>
    contestteam?: boolean | team$contestteamArgs<ExtArgs>
    queuetask?: boolean | team$queuetaskArgs<ExtArgs>
    rankcache?: boolean | team$rankcacheArgs<ExtArgs>
    scorecache?: boolean | team$scorecacheArgs<ExtArgs>
    submission?: boolean | team$submissionArgs<ExtArgs>
    team_category?: boolean | team$team_categoryArgs<ExtArgs>
    team_affiliation?: boolean | team$team_affiliationArgs<ExtArgs>
    team_unread?: boolean | team$team_unreadArgs<ExtArgs>
    user?: boolean | team$userArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $teamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "team"
    objects: {
      clarification_clarification_senderToteam: Prisma.$clarificationPayload<ExtArgs>[]
      clarification_clarification_recipientToteam: Prisma.$clarificationPayload<ExtArgs>[]
      contestteam: Prisma.$contestteamPayload<ExtArgs>[]
      queuetask: Prisma.$queuetaskPayload<ExtArgs>[]
      rankcache: Prisma.$rankcachePayload<ExtArgs>[]
      scorecache: Prisma.$scorecachePayload<ExtArgs>[]
      submission: Prisma.$submissionPayload<ExtArgs>[]
      team_category: Prisma.$team_categoryPayload<ExtArgs> | null
      team_affiliation: Prisma.$team_affiliationPayload<ExtArgs> | null
      team_unread: Prisma.$team_unreadPayload<ExtArgs>[]
      user: Prisma.$userPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      teamid: number
      externalid: string | null
      icpcid: string | null
      name: string
      display_name: string | null
      categoryid: number | null
      affilid: number | null
      enabled: boolean
      publicdescription: string | null
      room: string | null
      internalcomments: string | null
      judging_last_started: Prisma.Decimal | null
      penalty: number
    }, ExtArgs["result"]["team"]>
    composites: {}
  }


  type teamGetPayload<S extends boolean | null | undefined | teamDefaultArgs> = $Result.GetResult<Prisma.$teamPayload, S>

  type teamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<teamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface teamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['team'], meta: { name: 'team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {teamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends teamFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, teamFindUniqueArgs<ExtArgs>>
    ): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Team that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {teamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends teamFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, teamFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends teamFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, teamFindFirstArgs<ExtArgs>>
    ): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends teamFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, teamFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `teamid`
     * const teamWithTeamidOnly = await prisma.team.findMany({ select: { teamid: true } })
     * 
    **/
    findMany<T extends teamFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, teamFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Team.
     * @param {teamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
    **/
    create<T extends teamCreateArgs<ExtArgs>>(
      args: SelectSubset<T, teamCreateArgs<ExtArgs>>
    ): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Teams.
     *     @param {teamCreateManyArgs} args - Arguments to create many Teams.
     *     @example
     *     // Create many Teams
     *     const team = await prisma.team.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends teamCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, teamCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team.
     * @param {teamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
    **/
    delete<T extends teamDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, teamDeleteArgs<ExtArgs>>
    ): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Team.
     * @param {teamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends teamUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, teamUpdateArgs<ExtArgs>>
    ): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Teams.
     * @param {teamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends teamDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, teamDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends teamUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, teamUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {teamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
    **/
    upsert<T extends teamUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, teamUpsertArgs<ExtArgs>>
    ): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends teamCountArgs>(
      args?: Subset<T, teamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teamGroupByArgs['orderBy'] }
        : { orderBy?: teamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the team model
   */
  readonly fields: teamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__teamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    clarification_clarification_senderToteam<T extends team$clarification_clarification_senderToteamArgs<ExtArgs> = {}>(args?: Subset<T, team$clarification_clarification_senderToteamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clarificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    clarification_clarification_recipientToteam<T extends team$clarification_clarification_recipientToteamArgs<ExtArgs> = {}>(args?: Subset<T, team$clarification_clarification_recipientToteamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clarificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    contestteam<T extends team$contestteamArgs<ExtArgs> = {}>(args?: Subset<T, team$contestteamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contestteamPayload<ExtArgs>, T, 'findMany'> | Null>;

    queuetask<T extends team$queuetaskArgs<ExtArgs> = {}>(args?: Subset<T, team$queuetaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$queuetaskPayload<ExtArgs>, T, 'findMany'> | Null>;

    rankcache<T extends team$rankcacheArgs<ExtArgs> = {}>(args?: Subset<T, team$rankcacheArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rankcachePayload<ExtArgs>, T, 'findMany'> | Null>;

    scorecache<T extends team$scorecacheArgs<ExtArgs> = {}>(args?: Subset<T, team$scorecacheArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$scorecachePayload<ExtArgs>, T, 'findMany'> | Null>;

    submission<T extends team$submissionArgs<ExtArgs> = {}>(args?: Subset<T, team$submissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'findMany'> | Null>;

    team_category<T extends team$team_categoryArgs<ExtArgs> = {}>(args?: Subset<T, team$team_categoryArgs<ExtArgs>>): Prisma__team_categoryClient<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    team_affiliation<T extends team$team_affiliationArgs<ExtArgs> = {}>(args?: Subset<T, team$team_affiliationArgs<ExtArgs>>): Prisma__team_affiliationClient<$Result.GetResult<Prisma.$team_affiliationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    team_unread<T extends team$team_unreadArgs<ExtArgs> = {}>(args?: Subset<T, team$team_unreadArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$team_unreadPayload<ExtArgs>, T, 'findMany'> | Null>;

    user<T extends team$userArgs<ExtArgs> = {}>(args?: Subset<T, team$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the team model
   */ 
  interface teamFieldRefs {
    readonly teamid: FieldRef<"team", 'Int'>
    readonly externalid: FieldRef<"team", 'String'>
    readonly icpcid: FieldRef<"team", 'String'>
    readonly name: FieldRef<"team", 'String'>
    readonly display_name: FieldRef<"team", 'String'>
    readonly categoryid: FieldRef<"team", 'Int'>
    readonly affilid: FieldRef<"team", 'Int'>
    readonly enabled: FieldRef<"team", 'Boolean'>
    readonly publicdescription: FieldRef<"team", 'String'>
    readonly room: FieldRef<"team", 'String'>
    readonly internalcomments: FieldRef<"team", 'String'>
    readonly judging_last_started: FieldRef<"team", 'Decimal'>
    readonly penalty: FieldRef<"team", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * team findUnique
   */
  export type teamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where: teamWhereUniqueInput
  }


  /**
   * team findUniqueOrThrow
   */
  export type teamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where: teamWhereUniqueInput
  }


  /**
   * team findFirst
   */
  export type teamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }


  /**
   * team findFirstOrThrow
   */
  export type teamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }


  /**
   * team findMany
   */
  export type teamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which teams to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }


  /**
   * team create
   */
  export type teamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * The data needed to create a team.
     */
    data: XOR<teamCreateInput, teamUncheckedCreateInput>
  }


  /**
   * team createMany
   */
  export type teamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teams.
     */
    data: teamCreateManyInput | teamCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * team update
   */
  export type teamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * The data needed to update a team.
     */
    data: XOR<teamUpdateInput, teamUncheckedUpdateInput>
    /**
     * Choose, which team to update.
     */
    where: teamWhereUniqueInput
  }


  /**
   * team updateMany
   */
  export type teamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teams.
     */
    data: XOR<teamUpdateManyMutationInput, teamUncheckedUpdateManyInput>
    /**
     * Filter which teams to update
     */
    where?: teamWhereInput
  }


  /**
   * team upsert
   */
  export type teamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * The filter to search for the team to update in case it exists.
     */
    where: teamWhereUniqueInput
    /**
     * In case the team found by the `where` argument doesn't exist, create a new team with this data.
     */
    create: XOR<teamCreateInput, teamUncheckedCreateInput>
    /**
     * In case the team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teamUpdateInput, teamUncheckedUpdateInput>
  }


  /**
   * team delete
   */
  export type teamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter which team to delete.
     */
    where: teamWhereUniqueInput
  }


  /**
   * team deleteMany
   */
  export type teamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teams to delete
     */
    where?: teamWhereInput
  }


  /**
   * team.clarification_clarification_senderToteam
   */
  export type team$clarification_clarification_senderToteamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clarification
     */
    select?: clarificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clarificationInclude<ExtArgs> | null
    where?: clarificationWhereInput
    orderBy?: clarificationOrderByWithRelationInput | clarificationOrderByWithRelationInput[]
    cursor?: clarificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClarificationScalarFieldEnum | ClarificationScalarFieldEnum[]
  }


  /**
   * team.clarification_clarification_recipientToteam
   */
  export type team$clarification_clarification_recipientToteamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clarification
     */
    select?: clarificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clarificationInclude<ExtArgs> | null
    where?: clarificationWhereInput
    orderBy?: clarificationOrderByWithRelationInput | clarificationOrderByWithRelationInput[]
    cursor?: clarificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClarificationScalarFieldEnum | ClarificationScalarFieldEnum[]
  }


  /**
   * team.contestteam
   */
  export type team$contestteamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteam
     */
    select?: contestteamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamInclude<ExtArgs> | null
    where?: contestteamWhereInput
    orderBy?: contestteamOrderByWithRelationInput | contestteamOrderByWithRelationInput[]
    cursor?: contestteamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestteamScalarFieldEnum | ContestteamScalarFieldEnum[]
  }


  /**
   * team.queuetask
   */
  export type team$queuetaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queuetask
     */
    select?: queuetaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: queuetaskInclude<ExtArgs> | null
    where?: queuetaskWhereInput
    orderBy?: queuetaskOrderByWithRelationInput | queuetaskOrderByWithRelationInput[]
    cursor?: queuetaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueuetaskScalarFieldEnum | QueuetaskScalarFieldEnum[]
  }


  /**
   * team.rankcache
   */
  export type team$rankcacheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rankcache
     */
    select?: rankcacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rankcacheInclude<ExtArgs> | null
    where?: rankcacheWhereInput
    orderBy?: rankcacheOrderByWithRelationInput | rankcacheOrderByWithRelationInput[]
    cursor?: rankcacheWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RankcacheScalarFieldEnum | RankcacheScalarFieldEnum[]
  }


  /**
   * team.scorecache
   */
  export type team$scorecacheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scorecache
     */
    select?: scorecacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: scorecacheInclude<ExtArgs> | null
    where?: scorecacheWhereInput
    orderBy?: scorecacheOrderByWithRelationInput | scorecacheOrderByWithRelationInput[]
    cursor?: scorecacheWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScorecacheScalarFieldEnum | ScorecacheScalarFieldEnum[]
  }


  /**
   * team.submission
   */
  export type team$submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    where?: submissionWhereInput
    orderBy?: submissionOrderByWithRelationInput | submissionOrderByWithRelationInput[]
    cursor?: submissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }


  /**
   * team.team_category
   */
  export type team$team_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_categoryInclude<ExtArgs> | null
    where?: team_categoryWhereInput
  }


  /**
   * team.team_affiliation
   */
  export type team$team_affiliationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_affiliation
     */
    select?: team_affiliationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_affiliationInclude<ExtArgs> | null
    where?: team_affiliationWhereInput
  }


  /**
   * team.team_unread
   */
  export type team$team_unreadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_unread
     */
    select?: team_unreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_unreadInclude<ExtArgs> | null
    where?: team_unreadWhereInput
    orderBy?: team_unreadOrderByWithRelationInput | team_unreadOrderByWithRelationInput[]
    cursor?: team_unreadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Team_unreadScalarFieldEnum | Team_unreadScalarFieldEnum[]
  }


  /**
   * team.user
   */
  export type team$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * team without action
   */
  export type teamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
  }



  /**
   * Model team_affiliation
   */

  export type AggregateTeam_affiliation = {
    _count: Team_affiliationCountAggregateOutputType | null
    _avg: Team_affiliationAvgAggregateOutputType | null
    _sum: Team_affiliationSumAggregateOutputType | null
    _min: Team_affiliationMinAggregateOutputType | null
    _max: Team_affiliationMaxAggregateOutputType | null
  }

  export type Team_affiliationAvgAggregateOutputType = {
    affilid: number | null
  }

  export type Team_affiliationSumAggregateOutputType = {
    affilid: number | null
  }

  export type Team_affiliationMinAggregateOutputType = {
    affilid: number | null
    externalid: string | null
    icpcid: string | null
    shortname: string | null
    name: string | null
    country: string | null
    internalcomments: string | null
  }

  export type Team_affiliationMaxAggregateOutputType = {
    affilid: number | null
    externalid: string | null
    icpcid: string | null
    shortname: string | null
    name: string | null
    country: string | null
    internalcomments: string | null
  }

  export type Team_affiliationCountAggregateOutputType = {
    affilid: number
    externalid: number
    icpcid: number
    shortname: number
    name: number
    country: number
    internalcomments: number
    _all: number
  }


  export type Team_affiliationAvgAggregateInputType = {
    affilid?: true
  }

  export type Team_affiliationSumAggregateInputType = {
    affilid?: true
  }

  export type Team_affiliationMinAggregateInputType = {
    affilid?: true
    externalid?: true
    icpcid?: true
    shortname?: true
    name?: true
    country?: true
    internalcomments?: true
  }

  export type Team_affiliationMaxAggregateInputType = {
    affilid?: true
    externalid?: true
    icpcid?: true
    shortname?: true
    name?: true
    country?: true
    internalcomments?: true
  }

  export type Team_affiliationCountAggregateInputType = {
    affilid?: true
    externalid?: true
    icpcid?: true
    shortname?: true
    name?: true
    country?: true
    internalcomments?: true
    _all?: true
  }

  export type Team_affiliationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_affiliation to aggregate.
     */
    where?: team_affiliationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_affiliations to fetch.
     */
    orderBy?: team_affiliationOrderByWithRelationInput | team_affiliationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: team_affiliationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_affiliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_affiliations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned team_affiliations
    **/
    _count?: true | Team_affiliationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Team_affiliationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Team_affiliationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Team_affiliationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Team_affiliationMaxAggregateInputType
  }

  export type GetTeam_affiliationAggregateType<T extends Team_affiliationAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam_affiliation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam_affiliation[P]>
      : GetScalarType<T[P], AggregateTeam_affiliation[P]>
  }




  export type team_affiliationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: team_affiliationWhereInput
    orderBy?: team_affiliationOrderByWithAggregationInput | team_affiliationOrderByWithAggregationInput[]
    by: Team_affiliationScalarFieldEnum[] | Team_affiliationScalarFieldEnum
    having?: team_affiliationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Team_affiliationCountAggregateInputType | true
    _avg?: Team_affiliationAvgAggregateInputType
    _sum?: Team_affiliationSumAggregateInputType
    _min?: Team_affiliationMinAggregateInputType
    _max?: Team_affiliationMaxAggregateInputType
  }

  export type Team_affiliationGroupByOutputType = {
    affilid: number
    externalid: string | null
    icpcid: string | null
    shortname: string
    name: string
    country: string | null
    internalcomments: string | null
    _count: Team_affiliationCountAggregateOutputType | null
    _avg: Team_affiliationAvgAggregateOutputType | null
    _sum: Team_affiliationSumAggregateOutputType | null
    _min: Team_affiliationMinAggregateOutputType | null
    _max: Team_affiliationMaxAggregateOutputType | null
  }

  type GetTeam_affiliationGroupByPayload<T extends team_affiliationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Team_affiliationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Team_affiliationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Team_affiliationGroupByOutputType[P]>
            : GetScalarType<T[P], Team_affiliationGroupByOutputType[P]>
        }
      >
    >


  export type team_affiliationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    affilid?: boolean
    externalid?: boolean
    icpcid?: boolean
    shortname?: boolean
    name?: boolean
    country?: boolean
    internalcomments?: boolean
    team?: boolean | team_affiliation$teamArgs<ExtArgs>
    _count?: boolean | Team_affiliationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team_affiliation"]>

  export type team_affiliationSelectScalar = {
    affilid?: boolean
    externalid?: boolean
    icpcid?: boolean
    shortname?: boolean
    name?: boolean
    country?: boolean
    internalcomments?: boolean
  }

  export type team_affiliationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | team_affiliation$teamArgs<ExtArgs>
    _count?: boolean | Team_affiliationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $team_affiliationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "team_affiliation"
    objects: {
      team: Prisma.$teamPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      affilid: number
      externalid: string | null
      icpcid: string | null
      shortname: string
      name: string
      country: string | null
      internalcomments: string | null
    }, ExtArgs["result"]["team_affiliation"]>
    composites: {}
  }


  type team_affiliationGetPayload<S extends boolean | null | undefined | team_affiliationDefaultArgs> = $Result.GetResult<Prisma.$team_affiliationPayload, S>

  type team_affiliationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<team_affiliationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Team_affiliationCountAggregateInputType | true
    }

  export interface team_affiliationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['team_affiliation'], meta: { name: 'team_affiliation' } }
    /**
     * Find zero or one Team_affiliation that matches the filter.
     * @param {team_affiliationFindUniqueArgs} args - Arguments to find a Team_affiliation
     * @example
     * // Get one Team_affiliation
     * const team_affiliation = await prisma.team_affiliation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends team_affiliationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, team_affiliationFindUniqueArgs<ExtArgs>>
    ): Prisma__team_affiliationClient<$Result.GetResult<Prisma.$team_affiliationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Team_affiliation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {team_affiliationFindUniqueOrThrowArgs} args - Arguments to find a Team_affiliation
     * @example
     * // Get one Team_affiliation
     * const team_affiliation = await prisma.team_affiliation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends team_affiliationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, team_affiliationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__team_affiliationClient<$Result.GetResult<Prisma.$team_affiliationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Team_affiliation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_affiliationFindFirstArgs} args - Arguments to find a Team_affiliation
     * @example
     * // Get one Team_affiliation
     * const team_affiliation = await prisma.team_affiliation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends team_affiliationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, team_affiliationFindFirstArgs<ExtArgs>>
    ): Prisma__team_affiliationClient<$Result.GetResult<Prisma.$team_affiliationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Team_affiliation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_affiliationFindFirstOrThrowArgs} args - Arguments to find a Team_affiliation
     * @example
     * // Get one Team_affiliation
     * const team_affiliation = await prisma.team_affiliation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends team_affiliationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, team_affiliationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__team_affiliationClient<$Result.GetResult<Prisma.$team_affiliationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Team_affiliations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_affiliationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Team_affiliations
     * const team_affiliations = await prisma.team_affiliation.findMany()
     * 
     * // Get first 10 Team_affiliations
     * const team_affiliations = await prisma.team_affiliation.findMany({ take: 10 })
     * 
     * // Only select the `affilid`
     * const team_affiliationWithAffilidOnly = await prisma.team_affiliation.findMany({ select: { affilid: true } })
     * 
    **/
    findMany<T extends team_affiliationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, team_affiliationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$team_affiliationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Team_affiliation.
     * @param {team_affiliationCreateArgs} args - Arguments to create a Team_affiliation.
     * @example
     * // Create one Team_affiliation
     * const Team_affiliation = await prisma.team_affiliation.create({
     *   data: {
     *     // ... data to create a Team_affiliation
     *   }
     * })
     * 
    **/
    create<T extends team_affiliationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, team_affiliationCreateArgs<ExtArgs>>
    ): Prisma__team_affiliationClient<$Result.GetResult<Prisma.$team_affiliationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Team_affiliations.
     *     @param {team_affiliationCreateManyArgs} args - Arguments to create many Team_affiliations.
     *     @example
     *     // Create many Team_affiliations
     *     const team_affiliation = await prisma.team_affiliation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends team_affiliationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, team_affiliationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team_affiliation.
     * @param {team_affiliationDeleteArgs} args - Arguments to delete one Team_affiliation.
     * @example
     * // Delete one Team_affiliation
     * const Team_affiliation = await prisma.team_affiliation.delete({
     *   where: {
     *     // ... filter to delete one Team_affiliation
     *   }
     * })
     * 
    **/
    delete<T extends team_affiliationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, team_affiliationDeleteArgs<ExtArgs>>
    ): Prisma__team_affiliationClient<$Result.GetResult<Prisma.$team_affiliationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Team_affiliation.
     * @param {team_affiliationUpdateArgs} args - Arguments to update one Team_affiliation.
     * @example
     * // Update one Team_affiliation
     * const team_affiliation = await prisma.team_affiliation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends team_affiliationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, team_affiliationUpdateArgs<ExtArgs>>
    ): Prisma__team_affiliationClient<$Result.GetResult<Prisma.$team_affiliationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Team_affiliations.
     * @param {team_affiliationDeleteManyArgs} args - Arguments to filter Team_affiliations to delete.
     * @example
     * // Delete a few Team_affiliations
     * const { count } = await prisma.team_affiliation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends team_affiliationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, team_affiliationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Team_affiliations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_affiliationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Team_affiliations
     * const team_affiliation = await prisma.team_affiliation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends team_affiliationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, team_affiliationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team_affiliation.
     * @param {team_affiliationUpsertArgs} args - Arguments to update or create a Team_affiliation.
     * @example
     * // Update or create a Team_affiliation
     * const team_affiliation = await prisma.team_affiliation.upsert({
     *   create: {
     *     // ... data to create a Team_affiliation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team_affiliation we want to update
     *   }
     * })
    **/
    upsert<T extends team_affiliationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, team_affiliationUpsertArgs<ExtArgs>>
    ): Prisma__team_affiliationClient<$Result.GetResult<Prisma.$team_affiliationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Team_affiliations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_affiliationCountArgs} args - Arguments to filter Team_affiliations to count.
     * @example
     * // Count the number of Team_affiliations
     * const count = await prisma.team_affiliation.count({
     *   where: {
     *     // ... the filter for the Team_affiliations we want to count
     *   }
     * })
    **/
    count<T extends team_affiliationCountArgs>(
      args?: Subset<T, team_affiliationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Team_affiliationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team_affiliation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Team_affiliationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Team_affiliationAggregateArgs>(args: Subset<T, Team_affiliationAggregateArgs>): Prisma.PrismaPromise<GetTeam_affiliationAggregateType<T>>

    /**
     * Group by Team_affiliation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_affiliationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends team_affiliationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: team_affiliationGroupByArgs['orderBy'] }
        : { orderBy?: team_affiliationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, team_affiliationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeam_affiliationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the team_affiliation model
   */
  readonly fields: team_affiliationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for team_affiliation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__team_affiliationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    team<T extends team_affiliation$teamArgs<ExtArgs> = {}>(args?: Subset<T, team_affiliation$teamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the team_affiliation model
   */ 
  interface team_affiliationFieldRefs {
    readonly affilid: FieldRef<"team_affiliation", 'Int'>
    readonly externalid: FieldRef<"team_affiliation", 'String'>
    readonly icpcid: FieldRef<"team_affiliation", 'String'>
    readonly shortname: FieldRef<"team_affiliation", 'String'>
    readonly name: FieldRef<"team_affiliation", 'String'>
    readonly country: FieldRef<"team_affiliation", 'String'>
    readonly internalcomments: FieldRef<"team_affiliation", 'String'>
  }
    

  // Custom InputTypes

  /**
   * team_affiliation findUnique
   */
  export type team_affiliationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_affiliation
     */
    select?: team_affiliationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_affiliationInclude<ExtArgs> | null
    /**
     * Filter, which team_affiliation to fetch.
     */
    where: team_affiliationWhereUniqueInput
  }


  /**
   * team_affiliation findUniqueOrThrow
   */
  export type team_affiliationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_affiliation
     */
    select?: team_affiliationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_affiliationInclude<ExtArgs> | null
    /**
     * Filter, which team_affiliation to fetch.
     */
    where: team_affiliationWhereUniqueInput
  }


  /**
   * team_affiliation findFirst
   */
  export type team_affiliationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_affiliation
     */
    select?: team_affiliationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_affiliationInclude<ExtArgs> | null
    /**
     * Filter, which team_affiliation to fetch.
     */
    where?: team_affiliationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_affiliations to fetch.
     */
    orderBy?: team_affiliationOrderByWithRelationInput | team_affiliationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_affiliations.
     */
    cursor?: team_affiliationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_affiliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_affiliations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_affiliations.
     */
    distinct?: Team_affiliationScalarFieldEnum | Team_affiliationScalarFieldEnum[]
  }


  /**
   * team_affiliation findFirstOrThrow
   */
  export type team_affiliationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_affiliation
     */
    select?: team_affiliationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_affiliationInclude<ExtArgs> | null
    /**
     * Filter, which team_affiliation to fetch.
     */
    where?: team_affiliationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_affiliations to fetch.
     */
    orderBy?: team_affiliationOrderByWithRelationInput | team_affiliationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_affiliations.
     */
    cursor?: team_affiliationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_affiliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_affiliations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_affiliations.
     */
    distinct?: Team_affiliationScalarFieldEnum | Team_affiliationScalarFieldEnum[]
  }


  /**
   * team_affiliation findMany
   */
  export type team_affiliationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_affiliation
     */
    select?: team_affiliationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_affiliationInclude<ExtArgs> | null
    /**
     * Filter, which team_affiliations to fetch.
     */
    where?: team_affiliationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_affiliations to fetch.
     */
    orderBy?: team_affiliationOrderByWithRelationInput | team_affiliationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing team_affiliations.
     */
    cursor?: team_affiliationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_affiliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_affiliations.
     */
    skip?: number
    distinct?: Team_affiliationScalarFieldEnum | Team_affiliationScalarFieldEnum[]
  }


  /**
   * team_affiliation create
   */
  export type team_affiliationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_affiliation
     */
    select?: team_affiliationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_affiliationInclude<ExtArgs> | null
    /**
     * The data needed to create a team_affiliation.
     */
    data: XOR<team_affiliationCreateInput, team_affiliationUncheckedCreateInput>
  }


  /**
   * team_affiliation createMany
   */
  export type team_affiliationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many team_affiliations.
     */
    data: team_affiliationCreateManyInput | team_affiliationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * team_affiliation update
   */
  export type team_affiliationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_affiliation
     */
    select?: team_affiliationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_affiliationInclude<ExtArgs> | null
    /**
     * The data needed to update a team_affiliation.
     */
    data: XOR<team_affiliationUpdateInput, team_affiliationUncheckedUpdateInput>
    /**
     * Choose, which team_affiliation to update.
     */
    where: team_affiliationWhereUniqueInput
  }


  /**
   * team_affiliation updateMany
   */
  export type team_affiliationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update team_affiliations.
     */
    data: XOR<team_affiliationUpdateManyMutationInput, team_affiliationUncheckedUpdateManyInput>
    /**
     * Filter which team_affiliations to update
     */
    where?: team_affiliationWhereInput
  }


  /**
   * team_affiliation upsert
   */
  export type team_affiliationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_affiliation
     */
    select?: team_affiliationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_affiliationInclude<ExtArgs> | null
    /**
     * The filter to search for the team_affiliation to update in case it exists.
     */
    where: team_affiliationWhereUniqueInput
    /**
     * In case the team_affiliation found by the `where` argument doesn't exist, create a new team_affiliation with this data.
     */
    create: XOR<team_affiliationCreateInput, team_affiliationUncheckedCreateInput>
    /**
     * In case the team_affiliation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<team_affiliationUpdateInput, team_affiliationUncheckedUpdateInput>
  }


  /**
   * team_affiliation delete
   */
  export type team_affiliationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_affiliation
     */
    select?: team_affiliationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_affiliationInclude<ExtArgs> | null
    /**
     * Filter which team_affiliation to delete.
     */
    where: team_affiliationWhereUniqueInput
  }


  /**
   * team_affiliation deleteMany
   */
  export type team_affiliationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_affiliations to delete
     */
    where?: team_affiliationWhereInput
  }


  /**
   * team_affiliation.team
   */
  export type team_affiliation$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    where?: teamWhereInput
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    cursor?: teamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }


  /**
   * team_affiliation without action
   */
  export type team_affiliationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_affiliation
     */
    select?: team_affiliationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_affiliationInclude<ExtArgs> | null
  }



  /**
   * Model team_category
   */

  export type AggregateTeam_category = {
    _count: Team_categoryCountAggregateOutputType | null
    _avg: Team_categoryAvgAggregateOutputType | null
    _sum: Team_categorySumAggregateOutputType | null
    _min: Team_categoryMinAggregateOutputType | null
    _max: Team_categoryMaxAggregateOutputType | null
  }

  export type Team_categoryAvgAggregateOutputType = {
    categoryid: number | null
  }

  export type Team_categorySumAggregateOutputType = {
    categoryid: number | null
  }

  export type Team_categoryMinAggregateOutputType = {
    categoryid: number | null
    externalid: string | null
    icpcid: string | null
    name: string | null
    sortorder: boolean | null
    color: string | null
    visible: boolean | null
    allow_self_registration: boolean | null
  }

  export type Team_categoryMaxAggregateOutputType = {
    categoryid: number | null
    externalid: string | null
    icpcid: string | null
    name: string | null
    sortorder: boolean | null
    color: string | null
    visible: boolean | null
    allow_self_registration: boolean | null
  }

  export type Team_categoryCountAggregateOutputType = {
    categoryid: number
    externalid: number
    icpcid: number
    name: number
    sortorder: number
    color: number
    visible: number
    allow_self_registration: number
    _all: number
  }


  export type Team_categoryAvgAggregateInputType = {
    categoryid?: true
  }

  export type Team_categorySumAggregateInputType = {
    categoryid?: true
  }

  export type Team_categoryMinAggregateInputType = {
    categoryid?: true
    externalid?: true
    icpcid?: true
    name?: true
    sortorder?: true
    color?: true
    visible?: true
    allow_self_registration?: true
  }

  export type Team_categoryMaxAggregateInputType = {
    categoryid?: true
    externalid?: true
    icpcid?: true
    name?: true
    sortorder?: true
    color?: true
    visible?: true
    allow_self_registration?: true
  }

  export type Team_categoryCountAggregateInputType = {
    categoryid?: true
    externalid?: true
    icpcid?: true
    name?: true
    sortorder?: true
    color?: true
    visible?: true
    allow_self_registration?: true
    _all?: true
  }

  export type Team_categoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_category to aggregate.
     */
    where?: team_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_categories to fetch.
     */
    orderBy?: team_categoryOrderByWithRelationInput | team_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: team_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned team_categories
    **/
    _count?: true | Team_categoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Team_categoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Team_categorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Team_categoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Team_categoryMaxAggregateInputType
  }

  export type GetTeam_categoryAggregateType<T extends Team_categoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam_category]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam_category[P]>
      : GetScalarType<T[P], AggregateTeam_category[P]>
  }




  export type team_categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: team_categoryWhereInput
    orderBy?: team_categoryOrderByWithAggregationInput | team_categoryOrderByWithAggregationInput[]
    by: Team_categoryScalarFieldEnum[] | Team_categoryScalarFieldEnum
    having?: team_categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Team_categoryCountAggregateInputType | true
    _avg?: Team_categoryAvgAggregateInputType
    _sum?: Team_categorySumAggregateInputType
    _min?: Team_categoryMinAggregateInputType
    _max?: Team_categoryMaxAggregateInputType
  }

  export type Team_categoryGroupByOutputType = {
    categoryid: number
    externalid: string | null
    icpcid: string | null
    name: string
    sortorder: boolean
    color: string | null
    visible: boolean
    allow_self_registration: boolean
    _count: Team_categoryCountAggregateOutputType | null
    _avg: Team_categoryAvgAggregateOutputType | null
    _sum: Team_categorySumAggregateOutputType | null
    _min: Team_categoryMinAggregateOutputType | null
    _max: Team_categoryMaxAggregateOutputType | null
  }

  type GetTeam_categoryGroupByPayload<T extends team_categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Team_categoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Team_categoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Team_categoryGroupByOutputType[P]>
            : GetScalarType<T[P], Team_categoryGroupByOutputType[P]>
        }
      >
    >


  export type team_categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    categoryid?: boolean
    externalid?: boolean
    icpcid?: boolean
    name?: boolean
    sortorder?: boolean
    color?: boolean
    visible?: boolean
    allow_self_registration?: boolean
    contestteamcategory?: boolean | team_category$contestteamcategoryArgs<ExtArgs>
    contestteamcategoryformedals?: boolean | team_category$contestteamcategoryformedalsArgs<ExtArgs>
    team?: boolean | team_category$teamArgs<ExtArgs>
    _count?: boolean | Team_categoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team_category"]>

  export type team_categorySelectScalar = {
    categoryid?: boolean
    externalid?: boolean
    icpcid?: boolean
    name?: boolean
    sortorder?: boolean
    color?: boolean
    visible?: boolean
    allow_self_registration?: boolean
  }

  export type team_categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contestteamcategory?: boolean | team_category$contestteamcategoryArgs<ExtArgs>
    contestteamcategoryformedals?: boolean | team_category$contestteamcategoryformedalsArgs<ExtArgs>
    team?: boolean | team_category$teamArgs<ExtArgs>
    _count?: boolean | Team_categoryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $team_categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "team_category"
    objects: {
      contestteamcategory: Prisma.$contestteamcategoryPayload<ExtArgs>[]
      contestteamcategoryformedals: Prisma.$contestteamcategoryformedalsPayload<ExtArgs>[]
      team: Prisma.$teamPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      categoryid: number
      externalid: string | null
      icpcid: string | null
      name: string
      sortorder: boolean
      color: string | null
      visible: boolean
      allow_self_registration: boolean
    }, ExtArgs["result"]["team_category"]>
    composites: {}
  }


  type team_categoryGetPayload<S extends boolean | null | undefined | team_categoryDefaultArgs> = $Result.GetResult<Prisma.$team_categoryPayload, S>

  type team_categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<team_categoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Team_categoryCountAggregateInputType | true
    }

  export interface team_categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['team_category'], meta: { name: 'team_category' } }
    /**
     * Find zero or one Team_category that matches the filter.
     * @param {team_categoryFindUniqueArgs} args - Arguments to find a Team_category
     * @example
     * // Get one Team_category
     * const team_category = await prisma.team_category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends team_categoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, team_categoryFindUniqueArgs<ExtArgs>>
    ): Prisma__team_categoryClient<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Team_category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {team_categoryFindUniqueOrThrowArgs} args - Arguments to find a Team_category
     * @example
     * // Get one Team_category
     * const team_category = await prisma.team_category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends team_categoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, team_categoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__team_categoryClient<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Team_category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_categoryFindFirstArgs} args - Arguments to find a Team_category
     * @example
     * // Get one Team_category
     * const team_category = await prisma.team_category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends team_categoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, team_categoryFindFirstArgs<ExtArgs>>
    ): Prisma__team_categoryClient<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Team_category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_categoryFindFirstOrThrowArgs} args - Arguments to find a Team_category
     * @example
     * // Get one Team_category
     * const team_category = await prisma.team_category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends team_categoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, team_categoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__team_categoryClient<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Team_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_categoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Team_categories
     * const team_categories = await prisma.team_category.findMany()
     * 
     * // Get first 10 Team_categories
     * const team_categories = await prisma.team_category.findMany({ take: 10 })
     * 
     * // Only select the `categoryid`
     * const team_categoryWithCategoryidOnly = await prisma.team_category.findMany({ select: { categoryid: true } })
     * 
    **/
    findMany<T extends team_categoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, team_categoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Team_category.
     * @param {team_categoryCreateArgs} args - Arguments to create a Team_category.
     * @example
     * // Create one Team_category
     * const Team_category = await prisma.team_category.create({
     *   data: {
     *     // ... data to create a Team_category
     *   }
     * })
     * 
    **/
    create<T extends team_categoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, team_categoryCreateArgs<ExtArgs>>
    ): Prisma__team_categoryClient<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Team_categories.
     *     @param {team_categoryCreateManyArgs} args - Arguments to create many Team_categories.
     *     @example
     *     // Create many Team_categories
     *     const team_category = await prisma.team_category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends team_categoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, team_categoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team_category.
     * @param {team_categoryDeleteArgs} args - Arguments to delete one Team_category.
     * @example
     * // Delete one Team_category
     * const Team_category = await prisma.team_category.delete({
     *   where: {
     *     // ... filter to delete one Team_category
     *   }
     * })
     * 
    **/
    delete<T extends team_categoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, team_categoryDeleteArgs<ExtArgs>>
    ): Prisma__team_categoryClient<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Team_category.
     * @param {team_categoryUpdateArgs} args - Arguments to update one Team_category.
     * @example
     * // Update one Team_category
     * const team_category = await prisma.team_category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends team_categoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, team_categoryUpdateArgs<ExtArgs>>
    ): Prisma__team_categoryClient<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Team_categories.
     * @param {team_categoryDeleteManyArgs} args - Arguments to filter Team_categories to delete.
     * @example
     * // Delete a few Team_categories
     * const { count } = await prisma.team_category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends team_categoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, team_categoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Team_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Team_categories
     * const team_category = await prisma.team_category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends team_categoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, team_categoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team_category.
     * @param {team_categoryUpsertArgs} args - Arguments to update or create a Team_category.
     * @example
     * // Update or create a Team_category
     * const team_category = await prisma.team_category.upsert({
     *   create: {
     *     // ... data to create a Team_category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team_category we want to update
     *   }
     * })
    **/
    upsert<T extends team_categoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, team_categoryUpsertArgs<ExtArgs>>
    ): Prisma__team_categoryClient<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Team_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_categoryCountArgs} args - Arguments to filter Team_categories to count.
     * @example
     * // Count the number of Team_categories
     * const count = await prisma.team_category.count({
     *   where: {
     *     // ... the filter for the Team_categories we want to count
     *   }
     * })
    **/
    count<T extends team_categoryCountArgs>(
      args?: Subset<T, team_categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Team_categoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Team_categoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Team_categoryAggregateArgs>(args: Subset<T, Team_categoryAggregateArgs>): Prisma.PrismaPromise<GetTeam_categoryAggregateType<T>>

    /**
     * Group by Team_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends team_categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: team_categoryGroupByArgs['orderBy'] }
        : { orderBy?: team_categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, team_categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeam_categoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the team_category model
   */
  readonly fields: team_categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for team_category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__team_categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contestteamcategory<T extends team_category$contestteamcategoryArgs<ExtArgs> = {}>(args?: Subset<T, team_category$contestteamcategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contestteamcategoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    contestteamcategoryformedals<T extends team_category$contestteamcategoryformedalsArgs<ExtArgs> = {}>(args?: Subset<T, team_category$contestteamcategoryformedalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contestteamcategoryformedalsPayload<ExtArgs>, T, 'findMany'> | Null>;

    team<T extends team_category$teamArgs<ExtArgs> = {}>(args?: Subset<T, team_category$teamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the team_category model
   */ 
  interface team_categoryFieldRefs {
    readonly categoryid: FieldRef<"team_category", 'Int'>
    readonly externalid: FieldRef<"team_category", 'String'>
    readonly icpcid: FieldRef<"team_category", 'String'>
    readonly name: FieldRef<"team_category", 'String'>
    readonly sortorder: FieldRef<"team_category", 'Boolean'>
    readonly color: FieldRef<"team_category", 'String'>
    readonly visible: FieldRef<"team_category", 'Boolean'>
    readonly allow_self_registration: FieldRef<"team_category", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * team_category findUnique
   */
  export type team_categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_categoryInclude<ExtArgs> | null
    /**
     * Filter, which team_category to fetch.
     */
    where: team_categoryWhereUniqueInput
  }


  /**
   * team_category findUniqueOrThrow
   */
  export type team_categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_categoryInclude<ExtArgs> | null
    /**
     * Filter, which team_category to fetch.
     */
    where: team_categoryWhereUniqueInput
  }


  /**
   * team_category findFirst
   */
  export type team_categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_categoryInclude<ExtArgs> | null
    /**
     * Filter, which team_category to fetch.
     */
    where?: team_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_categories to fetch.
     */
    orderBy?: team_categoryOrderByWithRelationInput | team_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_categories.
     */
    cursor?: team_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_categories.
     */
    distinct?: Team_categoryScalarFieldEnum | Team_categoryScalarFieldEnum[]
  }


  /**
   * team_category findFirstOrThrow
   */
  export type team_categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_categoryInclude<ExtArgs> | null
    /**
     * Filter, which team_category to fetch.
     */
    where?: team_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_categories to fetch.
     */
    orderBy?: team_categoryOrderByWithRelationInput | team_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_categories.
     */
    cursor?: team_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_categories.
     */
    distinct?: Team_categoryScalarFieldEnum | Team_categoryScalarFieldEnum[]
  }


  /**
   * team_category findMany
   */
  export type team_categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_categoryInclude<ExtArgs> | null
    /**
     * Filter, which team_categories to fetch.
     */
    where?: team_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_categories to fetch.
     */
    orderBy?: team_categoryOrderByWithRelationInput | team_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing team_categories.
     */
    cursor?: team_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_categories.
     */
    skip?: number
    distinct?: Team_categoryScalarFieldEnum | Team_categoryScalarFieldEnum[]
  }


  /**
   * team_category create
   */
  export type team_categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a team_category.
     */
    data: XOR<team_categoryCreateInput, team_categoryUncheckedCreateInput>
  }


  /**
   * team_category createMany
   */
  export type team_categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many team_categories.
     */
    data: team_categoryCreateManyInput | team_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * team_category update
   */
  export type team_categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a team_category.
     */
    data: XOR<team_categoryUpdateInput, team_categoryUncheckedUpdateInput>
    /**
     * Choose, which team_category to update.
     */
    where: team_categoryWhereUniqueInput
  }


  /**
   * team_category updateMany
   */
  export type team_categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update team_categories.
     */
    data: XOR<team_categoryUpdateManyMutationInput, team_categoryUncheckedUpdateManyInput>
    /**
     * Filter which team_categories to update
     */
    where?: team_categoryWhereInput
  }


  /**
   * team_category upsert
   */
  export type team_categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the team_category to update in case it exists.
     */
    where: team_categoryWhereUniqueInput
    /**
     * In case the team_category found by the `where` argument doesn't exist, create a new team_category with this data.
     */
    create: XOR<team_categoryCreateInput, team_categoryUncheckedCreateInput>
    /**
     * In case the team_category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<team_categoryUpdateInput, team_categoryUncheckedUpdateInput>
  }


  /**
   * team_category delete
   */
  export type team_categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_categoryInclude<ExtArgs> | null
    /**
     * Filter which team_category to delete.
     */
    where: team_categoryWhereUniqueInput
  }


  /**
   * team_category deleteMany
   */
  export type team_categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_categories to delete
     */
    where?: team_categoryWhereInput
  }


  /**
   * team_category.contestteamcategory
   */
  export type team_category$contestteamcategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategory
     */
    select?: contestteamcategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryInclude<ExtArgs> | null
    where?: contestteamcategoryWhereInput
    orderBy?: contestteamcategoryOrderByWithRelationInput | contestteamcategoryOrderByWithRelationInput[]
    cursor?: contestteamcategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestteamcategoryScalarFieldEnum | ContestteamcategoryScalarFieldEnum[]
  }


  /**
   * team_category.contestteamcategoryformedals
   */
  export type team_category$contestteamcategoryformedalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contestteamcategoryformedals
     */
    select?: contestteamcategoryformedalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: contestteamcategoryformedalsInclude<ExtArgs> | null
    where?: contestteamcategoryformedalsWhereInput
    orderBy?: contestteamcategoryformedalsOrderByWithRelationInput | contestteamcategoryformedalsOrderByWithRelationInput[]
    cursor?: contestteamcategoryformedalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestteamcategoryformedalsScalarFieldEnum | ContestteamcategoryformedalsScalarFieldEnum[]
  }


  /**
   * team_category.team
   */
  export type team_category$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    where?: teamWhereInput
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    cursor?: teamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }


  /**
   * team_category without action
   */
  export type team_categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_categoryInclude<ExtArgs> | null
  }



  /**
   * Model team_unread
   */

  export type AggregateTeam_unread = {
    _count: Team_unreadCountAggregateOutputType | null
    _avg: Team_unreadAvgAggregateOutputType | null
    _sum: Team_unreadSumAggregateOutputType | null
    _min: Team_unreadMinAggregateOutputType | null
    _max: Team_unreadMaxAggregateOutputType | null
  }

  export type Team_unreadAvgAggregateOutputType = {
    teamid: number | null
    mesgid: number | null
  }

  export type Team_unreadSumAggregateOutputType = {
    teamid: number | null
    mesgid: number | null
  }

  export type Team_unreadMinAggregateOutputType = {
    teamid: number | null
    mesgid: number | null
  }

  export type Team_unreadMaxAggregateOutputType = {
    teamid: number | null
    mesgid: number | null
  }

  export type Team_unreadCountAggregateOutputType = {
    teamid: number
    mesgid: number
    _all: number
  }


  export type Team_unreadAvgAggregateInputType = {
    teamid?: true
    mesgid?: true
  }

  export type Team_unreadSumAggregateInputType = {
    teamid?: true
    mesgid?: true
  }

  export type Team_unreadMinAggregateInputType = {
    teamid?: true
    mesgid?: true
  }

  export type Team_unreadMaxAggregateInputType = {
    teamid?: true
    mesgid?: true
  }

  export type Team_unreadCountAggregateInputType = {
    teamid?: true
    mesgid?: true
    _all?: true
  }

  export type Team_unreadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_unread to aggregate.
     */
    where?: team_unreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_unreads to fetch.
     */
    orderBy?: team_unreadOrderByWithRelationInput | team_unreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: team_unreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_unreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_unreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned team_unreads
    **/
    _count?: true | Team_unreadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Team_unreadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Team_unreadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Team_unreadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Team_unreadMaxAggregateInputType
  }

  export type GetTeam_unreadAggregateType<T extends Team_unreadAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam_unread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam_unread[P]>
      : GetScalarType<T[P], AggregateTeam_unread[P]>
  }




  export type team_unreadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: team_unreadWhereInput
    orderBy?: team_unreadOrderByWithAggregationInput | team_unreadOrderByWithAggregationInput[]
    by: Team_unreadScalarFieldEnum[] | Team_unreadScalarFieldEnum
    having?: team_unreadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Team_unreadCountAggregateInputType | true
    _avg?: Team_unreadAvgAggregateInputType
    _sum?: Team_unreadSumAggregateInputType
    _min?: Team_unreadMinAggregateInputType
    _max?: Team_unreadMaxAggregateInputType
  }

  export type Team_unreadGroupByOutputType = {
    teamid: number
    mesgid: number
    _count: Team_unreadCountAggregateOutputType | null
    _avg: Team_unreadAvgAggregateOutputType | null
    _sum: Team_unreadSumAggregateOutputType | null
    _min: Team_unreadMinAggregateOutputType | null
    _max: Team_unreadMaxAggregateOutputType | null
  }

  type GetTeam_unreadGroupByPayload<T extends team_unreadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Team_unreadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Team_unreadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Team_unreadGroupByOutputType[P]>
            : GetScalarType<T[P], Team_unreadGroupByOutputType[P]>
        }
      >
    >


  export type team_unreadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teamid?: boolean
    mesgid?: boolean
    team?: boolean | teamDefaultArgs<ExtArgs>
    clarification?: boolean | clarificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team_unread"]>

  export type team_unreadSelectScalar = {
    teamid?: boolean
    mesgid?: boolean
  }

  export type team_unreadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | teamDefaultArgs<ExtArgs>
    clarification?: boolean | clarificationDefaultArgs<ExtArgs>
  }


  export type $team_unreadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "team_unread"
    objects: {
      team: Prisma.$teamPayload<ExtArgs>
      clarification: Prisma.$clarificationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      teamid: number
      mesgid: number
    }, ExtArgs["result"]["team_unread"]>
    composites: {}
  }


  type team_unreadGetPayload<S extends boolean | null | undefined | team_unreadDefaultArgs> = $Result.GetResult<Prisma.$team_unreadPayload, S>

  type team_unreadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<team_unreadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Team_unreadCountAggregateInputType | true
    }

  export interface team_unreadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['team_unread'], meta: { name: 'team_unread' } }
    /**
     * Find zero or one Team_unread that matches the filter.
     * @param {team_unreadFindUniqueArgs} args - Arguments to find a Team_unread
     * @example
     * // Get one Team_unread
     * const team_unread = await prisma.team_unread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends team_unreadFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, team_unreadFindUniqueArgs<ExtArgs>>
    ): Prisma__team_unreadClient<$Result.GetResult<Prisma.$team_unreadPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Team_unread that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {team_unreadFindUniqueOrThrowArgs} args - Arguments to find a Team_unread
     * @example
     * // Get one Team_unread
     * const team_unread = await prisma.team_unread.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends team_unreadFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, team_unreadFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__team_unreadClient<$Result.GetResult<Prisma.$team_unreadPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Team_unread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_unreadFindFirstArgs} args - Arguments to find a Team_unread
     * @example
     * // Get one Team_unread
     * const team_unread = await prisma.team_unread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends team_unreadFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, team_unreadFindFirstArgs<ExtArgs>>
    ): Prisma__team_unreadClient<$Result.GetResult<Prisma.$team_unreadPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Team_unread that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_unreadFindFirstOrThrowArgs} args - Arguments to find a Team_unread
     * @example
     * // Get one Team_unread
     * const team_unread = await prisma.team_unread.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends team_unreadFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, team_unreadFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__team_unreadClient<$Result.GetResult<Prisma.$team_unreadPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Team_unreads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_unreadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Team_unreads
     * const team_unreads = await prisma.team_unread.findMany()
     * 
     * // Get first 10 Team_unreads
     * const team_unreads = await prisma.team_unread.findMany({ take: 10 })
     * 
     * // Only select the `teamid`
     * const team_unreadWithTeamidOnly = await prisma.team_unread.findMany({ select: { teamid: true } })
     * 
    **/
    findMany<T extends team_unreadFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, team_unreadFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$team_unreadPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Team_unread.
     * @param {team_unreadCreateArgs} args - Arguments to create a Team_unread.
     * @example
     * // Create one Team_unread
     * const Team_unread = await prisma.team_unread.create({
     *   data: {
     *     // ... data to create a Team_unread
     *   }
     * })
     * 
    **/
    create<T extends team_unreadCreateArgs<ExtArgs>>(
      args: SelectSubset<T, team_unreadCreateArgs<ExtArgs>>
    ): Prisma__team_unreadClient<$Result.GetResult<Prisma.$team_unreadPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Team_unreads.
     *     @param {team_unreadCreateManyArgs} args - Arguments to create many Team_unreads.
     *     @example
     *     // Create many Team_unreads
     *     const team_unread = await prisma.team_unread.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends team_unreadCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, team_unreadCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team_unread.
     * @param {team_unreadDeleteArgs} args - Arguments to delete one Team_unread.
     * @example
     * // Delete one Team_unread
     * const Team_unread = await prisma.team_unread.delete({
     *   where: {
     *     // ... filter to delete one Team_unread
     *   }
     * })
     * 
    **/
    delete<T extends team_unreadDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, team_unreadDeleteArgs<ExtArgs>>
    ): Prisma__team_unreadClient<$Result.GetResult<Prisma.$team_unreadPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Team_unread.
     * @param {team_unreadUpdateArgs} args - Arguments to update one Team_unread.
     * @example
     * // Update one Team_unread
     * const team_unread = await prisma.team_unread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends team_unreadUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, team_unreadUpdateArgs<ExtArgs>>
    ): Prisma__team_unreadClient<$Result.GetResult<Prisma.$team_unreadPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Team_unreads.
     * @param {team_unreadDeleteManyArgs} args - Arguments to filter Team_unreads to delete.
     * @example
     * // Delete a few Team_unreads
     * const { count } = await prisma.team_unread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends team_unreadDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, team_unreadDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Team_unreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_unreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Team_unreads
     * const team_unread = await prisma.team_unread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends team_unreadUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, team_unreadUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team_unread.
     * @param {team_unreadUpsertArgs} args - Arguments to update or create a Team_unread.
     * @example
     * // Update or create a Team_unread
     * const team_unread = await prisma.team_unread.upsert({
     *   create: {
     *     // ... data to create a Team_unread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team_unread we want to update
     *   }
     * })
    **/
    upsert<T extends team_unreadUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, team_unreadUpsertArgs<ExtArgs>>
    ): Prisma__team_unreadClient<$Result.GetResult<Prisma.$team_unreadPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Team_unreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_unreadCountArgs} args - Arguments to filter Team_unreads to count.
     * @example
     * // Count the number of Team_unreads
     * const count = await prisma.team_unread.count({
     *   where: {
     *     // ... the filter for the Team_unreads we want to count
     *   }
     * })
    **/
    count<T extends team_unreadCountArgs>(
      args?: Subset<T, team_unreadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Team_unreadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team_unread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Team_unreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Team_unreadAggregateArgs>(args: Subset<T, Team_unreadAggregateArgs>): Prisma.PrismaPromise<GetTeam_unreadAggregateType<T>>

    /**
     * Group by Team_unread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_unreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends team_unreadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: team_unreadGroupByArgs['orderBy'] }
        : { orderBy?: team_unreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, team_unreadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeam_unreadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the team_unread model
   */
  readonly fields: team_unreadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for team_unread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__team_unreadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    team<T extends teamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teamDefaultArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    clarification<T extends clarificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clarificationDefaultArgs<ExtArgs>>): Prisma__clarificationClient<$Result.GetResult<Prisma.$clarificationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the team_unread model
   */ 
  interface team_unreadFieldRefs {
    readonly teamid: FieldRef<"team_unread", 'Int'>
    readonly mesgid: FieldRef<"team_unread", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * team_unread findUnique
   */
  export type team_unreadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_unread
     */
    select?: team_unreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_unreadInclude<ExtArgs> | null
    /**
     * Filter, which team_unread to fetch.
     */
    where: team_unreadWhereUniqueInput
  }


  /**
   * team_unread findUniqueOrThrow
   */
  export type team_unreadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_unread
     */
    select?: team_unreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_unreadInclude<ExtArgs> | null
    /**
     * Filter, which team_unread to fetch.
     */
    where: team_unreadWhereUniqueInput
  }


  /**
   * team_unread findFirst
   */
  export type team_unreadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_unread
     */
    select?: team_unreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_unreadInclude<ExtArgs> | null
    /**
     * Filter, which team_unread to fetch.
     */
    where?: team_unreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_unreads to fetch.
     */
    orderBy?: team_unreadOrderByWithRelationInput | team_unreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_unreads.
     */
    cursor?: team_unreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_unreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_unreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_unreads.
     */
    distinct?: Team_unreadScalarFieldEnum | Team_unreadScalarFieldEnum[]
  }


  /**
   * team_unread findFirstOrThrow
   */
  export type team_unreadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_unread
     */
    select?: team_unreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_unreadInclude<ExtArgs> | null
    /**
     * Filter, which team_unread to fetch.
     */
    where?: team_unreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_unreads to fetch.
     */
    orderBy?: team_unreadOrderByWithRelationInput | team_unreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_unreads.
     */
    cursor?: team_unreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_unreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_unreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_unreads.
     */
    distinct?: Team_unreadScalarFieldEnum | Team_unreadScalarFieldEnum[]
  }


  /**
   * team_unread findMany
   */
  export type team_unreadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_unread
     */
    select?: team_unreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_unreadInclude<ExtArgs> | null
    /**
     * Filter, which team_unreads to fetch.
     */
    where?: team_unreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_unreads to fetch.
     */
    orderBy?: team_unreadOrderByWithRelationInput | team_unreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing team_unreads.
     */
    cursor?: team_unreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_unreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_unreads.
     */
    skip?: number
    distinct?: Team_unreadScalarFieldEnum | Team_unreadScalarFieldEnum[]
  }


  /**
   * team_unread create
   */
  export type team_unreadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_unread
     */
    select?: team_unreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_unreadInclude<ExtArgs> | null
    /**
     * The data needed to create a team_unread.
     */
    data: XOR<team_unreadCreateInput, team_unreadUncheckedCreateInput>
  }


  /**
   * team_unread createMany
   */
  export type team_unreadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many team_unreads.
     */
    data: team_unreadCreateManyInput | team_unreadCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * team_unread update
   */
  export type team_unreadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_unread
     */
    select?: team_unreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_unreadInclude<ExtArgs> | null
    /**
     * The data needed to update a team_unread.
     */
    data: XOR<team_unreadUpdateInput, team_unreadUncheckedUpdateInput>
    /**
     * Choose, which team_unread to update.
     */
    where: team_unreadWhereUniqueInput
  }


  /**
   * team_unread updateMany
   */
  export type team_unreadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update team_unreads.
     */
    data: XOR<team_unreadUpdateManyMutationInput, team_unreadUncheckedUpdateManyInput>
    /**
     * Filter which team_unreads to update
     */
    where?: team_unreadWhereInput
  }


  /**
   * team_unread upsert
   */
  export type team_unreadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_unread
     */
    select?: team_unreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_unreadInclude<ExtArgs> | null
    /**
     * The filter to search for the team_unread to update in case it exists.
     */
    where: team_unreadWhereUniqueInput
    /**
     * In case the team_unread found by the `where` argument doesn't exist, create a new team_unread with this data.
     */
    create: XOR<team_unreadCreateInput, team_unreadUncheckedCreateInput>
    /**
     * In case the team_unread was found with the provided `where` argument, update it with this data.
     */
    update: XOR<team_unreadUpdateInput, team_unreadUncheckedUpdateInput>
  }


  /**
   * team_unread delete
   */
  export type team_unreadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_unread
     */
    select?: team_unreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_unreadInclude<ExtArgs> | null
    /**
     * Filter which team_unread to delete.
     */
    where: team_unreadWhereUniqueInput
  }


  /**
   * team_unread deleteMany
   */
  export type team_unreadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_unreads to delete
     */
    where?: team_unreadWhereInput
  }


  /**
   * team_unread without action
   */
  export type team_unreadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_unread
     */
    select?: team_unreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_unreadInclude<ExtArgs> | null
  }



  /**
   * Model testcase
   */

  export type AggregateTestcase = {
    _count: TestcaseCountAggregateOutputType | null
    _avg: TestcaseAvgAggregateOutputType | null
    _sum: TestcaseSumAggregateOutputType | null
    _min: TestcaseMinAggregateOutputType | null
    _max: TestcaseMaxAggregateOutputType | null
  }

  export type TestcaseAvgAggregateOutputType = {
    testcaseid: number | null
    probid: number | null
    ranknumber: number | null
  }

  export type TestcaseSumAggregateOutputType = {
    testcaseid: number | null
    probid: number | null
    ranknumber: number | null
  }

  export type TestcaseMinAggregateOutputType = {
    testcaseid: number | null
    md5sum_input: string | null
    md5sum_output: string | null
    probid: number | null
    ranknumber: number | null
    description: Buffer | null
    image_type: string | null
    sample: boolean | null
    orig_input_filename: string | null
    deleted: boolean | null
  }

  export type TestcaseMaxAggregateOutputType = {
    testcaseid: number | null
    md5sum_input: string | null
    md5sum_output: string | null
    probid: number | null
    ranknumber: number | null
    description: Buffer | null
    image_type: string | null
    sample: boolean | null
    orig_input_filename: string | null
    deleted: boolean | null
  }

  export type TestcaseCountAggregateOutputType = {
    testcaseid: number
    md5sum_input: number
    md5sum_output: number
    probid: number
    ranknumber: number
    description: number
    image_type: number
    sample: number
    orig_input_filename: number
    deleted: number
    _all: number
  }


  export type TestcaseAvgAggregateInputType = {
    testcaseid?: true
    probid?: true
    ranknumber?: true
  }

  export type TestcaseSumAggregateInputType = {
    testcaseid?: true
    probid?: true
    ranknumber?: true
  }

  export type TestcaseMinAggregateInputType = {
    testcaseid?: true
    md5sum_input?: true
    md5sum_output?: true
    probid?: true
    ranknumber?: true
    description?: true
    image_type?: true
    sample?: true
    orig_input_filename?: true
    deleted?: true
  }

  export type TestcaseMaxAggregateInputType = {
    testcaseid?: true
    md5sum_input?: true
    md5sum_output?: true
    probid?: true
    ranknumber?: true
    description?: true
    image_type?: true
    sample?: true
    orig_input_filename?: true
    deleted?: true
  }

  export type TestcaseCountAggregateInputType = {
    testcaseid?: true
    md5sum_input?: true
    md5sum_output?: true
    probid?: true
    ranknumber?: true
    description?: true
    image_type?: true
    sample?: true
    orig_input_filename?: true
    deleted?: true
    _all?: true
  }

  export type TestcaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testcase to aggregate.
     */
    where?: testcaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testcases to fetch.
     */
    orderBy?: testcaseOrderByWithRelationInput | testcaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: testcaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testcases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testcases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned testcases
    **/
    _count?: true | TestcaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestcaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestcaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestcaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestcaseMaxAggregateInputType
  }

  export type GetTestcaseAggregateType<T extends TestcaseAggregateArgs> = {
        [P in keyof T & keyof AggregateTestcase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestcase[P]>
      : GetScalarType<T[P], AggregateTestcase[P]>
  }




  export type testcaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: testcaseWhereInput
    orderBy?: testcaseOrderByWithAggregationInput | testcaseOrderByWithAggregationInput[]
    by: TestcaseScalarFieldEnum[] | TestcaseScalarFieldEnum
    having?: testcaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestcaseCountAggregateInputType | true
    _avg?: TestcaseAvgAggregateInputType
    _sum?: TestcaseSumAggregateInputType
    _min?: TestcaseMinAggregateInputType
    _max?: TestcaseMaxAggregateInputType
  }

  export type TestcaseGroupByOutputType = {
    testcaseid: number
    md5sum_input: string | null
    md5sum_output: string | null
    probid: number | null
    ranknumber: number
    description: Buffer | null
    image_type: string | null
    sample: boolean
    orig_input_filename: string | null
    deleted: boolean
    _count: TestcaseCountAggregateOutputType | null
    _avg: TestcaseAvgAggregateOutputType | null
    _sum: TestcaseSumAggregateOutputType | null
    _min: TestcaseMinAggregateOutputType | null
    _max: TestcaseMaxAggregateOutputType | null
  }

  type GetTestcaseGroupByPayload<T extends testcaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestcaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestcaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestcaseGroupByOutputType[P]>
            : GetScalarType<T[P], TestcaseGroupByOutputType[P]>
        }
      >
    >


  export type testcaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    testcaseid?: boolean
    md5sum_input?: boolean
    md5sum_output?: boolean
    probid?: boolean
    ranknumber?: boolean
    description?: boolean
    image_type?: boolean
    sample?: boolean
    orig_input_filename?: boolean
    deleted?: boolean
    external_run?: boolean | testcase$external_runArgs<ExtArgs>
    judging_run?: boolean | testcase$judging_runArgs<ExtArgs>
    problem?: boolean | testcase$problemArgs<ExtArgs>
    testcase_content?: boolean | testcase$testcase_contentArgs<ExtArgs>
    _count?: boolean | TestcaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testcase"]>

  export type testcaseSelectScalar = {
    testcaseid?: boolean
    md5sum_input?: boolean
    md5sum_output?: boolean
    probid?: boolean
    ranknumber?: boolean
    description?: boolean
    image_type?: boolean
    sample?: boolean
    orig_input_filename?: boolean
    deleted?: boolean
  }

  export type testcaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    external_run?: boolean | testcase$external_runArgs<ExtArgs>
    judging_run?: boolean | testcase$judging_runArgs<ExtArgs>
    problem?: boolean | testcase$problemArgs<ExtArgs>
    testcase_content?: boolean | testcase$testcase_contentArgs<ExtArgs>
    _count?: boolean | TestcaseCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $testcasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "testcase"
    objects: {
      external_run: Prisma.$external_runPayload<ExtArgs>[]
      judging_run: Prisma.$judging_runPayload<ExtArgs>[]
      problem: Prisma.$problemPayload<ExtArgs> | null
      testcase_content: Prisma.$testcase_contentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      testcaseid: number
      md5sum_input: string | null
      md5sum_output: string | null
      probid: number | null
      ranknumber: number
      description: Buffer | null
      image_type: string | null
      sample: boolean
      orig_input_filename: string | null
      deleted: boolean
    }, ExtArgs["result"]["testcase"]>
    composites: {}
  }


  type testcaseGetPayload<S extends boolean | null | undefined | testcaseDefaultArgs> = $Result.GetResult<Prisma.$testcasePayload, S>

  type testcaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<testcaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TestcaseCountAggregateInputType | true
    }

  export interface testcaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['testcase'], meta: { name: 'testcase' } }
    /**
     * Find zero or one Testcase that matches the filter.
     * @param {testcaseFindUniqueArgs} args - Arguments to find a Testcase
     * @example
     * // Get one Testcase
     * const testcase = await prisma.testcase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends testcaseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, testcaseFindUniqueArgs<ExtArgs>>
    ): Prisma__testcaseClient<$Result.GetResult<Prisma.$testcasePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Testcase that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {testcaseFindUniqueOrThrowArgs} args - Arguments to find a Testcase
     * @example
     * // Get one Testcase
     * const testcase = await prisma.testcase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends testcaseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, testcaseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__testcaseClient<$Result.GetResult<Prisma.$testcasePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Testcase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testcaseFindFirstArgs} args - Arguments to find a Testcase
     * @example
     * // Get one Testcase
     * const testcase = await prisma.testcase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends testcaseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, testcaseFindFirstArgs<ExtArgs>>
    ): Prisma__testcaseClient<$Result.GetResult<Prisma.$testcasePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Testcase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testcaseFindFirstOrThrowArgs} args - Arguments to find a Testcase
     * @example
     * // Get one Testcase
     * const testcase = await prisma.testcase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends testcaseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, testcaseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__testcaseClient<$Result.GetResult<Prisma.$testcasePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Testcases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testcaseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testcases
     * const testcases = await prisma.testcase.findMany()
     * 
     * // Get first 10 Testcases
     * const testcases = await prisma.testcase.findMany({ take: 10 })
     * 
     * // Only select the `testcaseid`
     * const testcaseWithTestcaseidOnly = await prisma.testcase.findMany({ select: { testcaseid: true } })
     * 
    **/
    findMany<T extends testcaseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, testcaseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$testcasePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Testcase.
     * @param {testcaseCreateArgs} args - Arguments to create a Testcase.
     * @example
     * // Create one Testcase
     * const Testcase = await prisma.testcase.create({
     *   data: {
     *     // ... data to create a Testcase
     *   }
     * })
     * 
    **/
    create<T extends testcaseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, testcaseCreateArgs<ExtArgs>>
    ): Prisma__testcaseClient<$Result.GetResult<Prisma.$testcasePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Testcases.
     *     @param {testcaseCreateManyArgs} args - Arguments to create many Testcases.
     *     @example
     *     // Create many Testcases
     *     const testcase = await prisma.testcase.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends testcaseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, testcaseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Testcase.
     * @param {testcaseDeleteArgs} args - Arguments to delete one Testcase.
     * @example
     * // Delete one Testcase
     * const Testcase = await prisma.testcase.delete({
     *   where: {
     *     // ... filter to delete one Testcase
     *   }
     * })
     * 
    **/
    delete<T extends testcaseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, testcaseDeleteArgs<ExtArgs>>
    ): Prisma__testcaseClient<$Result.GetResult<Prisma.$testcasePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Testcase.
     * @param {testcaseUpdateArgs} args - Arguments to update one Testcase.
     * @example
     * // Update one Testcase
     * const testcase = await prisma.testcase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends testcaseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, testcaseUpdateArgs<ExtArgs>>
    ): Prisma__testcaseClient<$Result.GetResult<Prisma.$testcasePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Testcases.
     * @param {testcaseDeleteManyArgs} args - Arguments to filter Testcases to delete.
     * @example
     * // Delete a few Testcases
     * const { count } = await prisma.testcase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends testcaseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, testcaseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testcases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testcaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testcases
     * const testcase = await prisma.testcase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends testcaseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, testcaseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Testcase.
     * @param {testcaseUpsertArgs} args - Arguments to update or create a Testcase.
     * @example
     * // Update or create a Testcase
     * const testcase = await prisma.testcase.upsert({
     *   create: {
     *     // ... data to create a Testcase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testcase we want to update
     *   }
     * })
    **/
    upsert<T extends testcaseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, testcaseUpsertArgs<ExtArgs>>
    ): Prisma__testcaseClient<$Result.GetResult<Prisma.$testcasePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Testcases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testcaseCountArgs} args - Arguments to filter Testcases to count.
     * @example
     * // Count the number of Testcases
     * const count = await prisma.testcase.count({
     *   where: {
     *     // ... the filter for the Testcases we want to count
     *   }
     * })
    **/
    count<T extends testcaseCountArgs>(
      args?: Subset<T, testcaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestcaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testcase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestcaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestcaseAggregateArgs>(args: Subset<T, TestcaseAggregateArgs>): Prisma.PrismaPromise<GetTestcaseAggregateType<T>>

    /**
     * Group by Testcase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testcaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends testcaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: testcaseGroupByArgs['orderBy'] }
        : { orderBy?: testcaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, testcaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestcaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the testcase model
   */
  readonly fields: testcaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for testcase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__testcaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    external_run<T extends testcase$external_runArgs<ExtArgs> = {}>(args?: Subset<T, testcase$external_runArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$external_runPayload<ExtArgs>, T, 'findMany'> | Null>;

    judging_run<T extends testcase$judging_runArgs<ExtArgs> = {}>(args?: Subset<T, testcase$judging_runArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$judging_runPayload<ExtArgs>, T, 'findMany'> | Null>;

    problem<T extends testcase$problemArgs<ExtArgs> = {}>(args?: Subset<T, testcase$problemArgs<ExtArgs>>): Prisma__problemClient<$Result.GetResult<Prisma.$problemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    testcase_content<T extends testcase$testcase_contentArgs<ExtArgs> = {}>(args?: Subset<T, testcase$testcase_contentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$testcase_contentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the testcase model
   */ 
  interface testcaseFieldRefs {
    readonly testcaseid: FieldRef<"testcase", 'Int'>
    readonly md5sum_input: FieldRef<"testcase", 'String'>
    readonly md5sum_output: FieldRef<"testcase", 'String'>
    readonly probid: FieldRef<"testcase", 'Int'>
    readonly ranknumber: FieldRef<"testcase", 'Int'>
    readonly description: FieldRef<"testcase", 'Bytes'>
    readonly image_type: FieldRef<"testcase", 'String'>
    readonly sample: FieldRef<"testcase", 'Boolean'>
    readonly orig_input_filename: FieldRef<"testcase", 'String'>
    readonly deleted: FieldRef<"testcase", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * testcase findUnique
   */
  export type testcaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase
     */
    select?: testcaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcaseInclude<ExtArgs> | null
    /**
     * Filter, which testcase to fetch.
     */
    where: testcaseWhereUniqueInput
  }


  /**
   * testcase findUniqueOrThrow
   */
  export type testcaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase
     */
    select?: testcaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcaseInclude<ExtArgs> | null
    /**
     * Filter, which testcase to fetch.
     */
    where: testcaseWhereUniqueInput
  }


  /**
   * testcase findFirst
   */
  export type testcaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase
     */
    select?: testcaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcaseInclude<ExtArgs> | null
    /**
     * Filter, which testcase to fetch.
     */
    where?: testcaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testcases to fetch.
     */
    orderBy?: testcaseOrderByWithRelationInput | testcaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testcases.
     */
    cursor?: testcaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testcases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testcases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testcases.
     */
    distinct?: TestcaseScalarFieldEnum | TestcaseScalarFieldEnum[]
  }


  /**
   * testcase findFirstOrThrow
   */
  export type testcaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase
     */
    select?: testcaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcaseInclude<ExtArgs> | null
    /**
     * Filter, which testcase to fetch.
     */
    where?: testcaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testcases to fetch.
     */
    orderBy?: testcaseOrderByWithRelationInput | testcaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testcases.
     */
    cursor?: testcaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testcases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testcases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testcases.
     */
    distinct?: TestcaseScalarFieldEnum | TestcaseScalarFieldEnum[]
  }


  /**
   * testcase findMany
   */
  export type testcaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase
     */
    select?: testcaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcaseInclude<ExtArgs> | null
    /**
     * Filter, which testcases to fetch.
     */
    where?: testcaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testcases to fetch.
     */
    orderBy?: testcaseOrderByWithRelationInput | testcaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing testcases.
     */
    cursor?: testcaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testcases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testcases.
     */
    skip?: number
    distinct?: TestcaseScalarFieldEnum | TestcaseScalarFieldEnum[]
  }


  /**
   * testcase create
   */
  export type testcaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase
     */
    select?: testcaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcaseInclude<ExtArgs> | null
    /**
     * The data needed to create a testcase.
     */
    data: XOR<testcaseCreateInput, testcaseUncheckedCreateInput>
  }


  /**
   * testcase createMany
   */
  export type testcaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many testcases.
     */
    data: testcaseCreateManyInput | testcaseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * testcase update
   */
  export type testcaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase
     */
    select?: testcaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcaseInclude<ExtArgs> | null
    /**
     * The data needed to update a testcase.
     */
    data: XOR<testcaseUpdateInput, testcaseUncheckedUpdateInput>
    /**
     * Choose, which testcase to update.
     */
    where: testcaseWhereUniqueInput
  }


  /**
   * testcase updateMany
   */
  export type testcaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update testcases.
     */
    data: XOR<testcaseUpdateManyMutationInput, testcaseUncheckedUpdateManyInput>
    /**
     * Filter which testcases to update
     */
    where?: testcaseWhereInput
  }


  /**
   * testcase upsert
   */
  export type testcaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase
     */
    select?: testcaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcaseInclude<ExtArgs> | null
    /**
     * The filter to search for the testcase to update in case it exists.
     */
    where: testcaseWhereUniqueInput
    /**
     * In case the testcase found by the `where` argument doesn't exist, create a new testcase with this data.
     */
    create: XOR<testcaseCreateInput, testcaseUncheckedCreateInput>
    /**
     * In case the testcase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<testcaseUpdateInput, testcaseUncheckedUpdateInput>
  }


  /**
   * testcase delete
   */
  export type testcaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase
     */
    select?: testcaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcaseInclude<ExtArgs> | null
    /**
     * Filter which testcase to delete.
     */
    where: testcaseWhereUniqueInput
  }


  /**
   * testcase deleteMany
   */
  export type testcaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testcases to delete
     */
    where?: testcaseWhereInput
  }


  /**
   * testcase.external_run
   */
  export type testcase$external_runArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the external_run
     */
    select?: external_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: external_runInclude<ExtArgs> | null
    where?: external_runWhereInput
    orderBy?: external_runOrderByWithRelationInput | external_runOrderByWithRelationInput[]
    cursor?: external_runWhereUniqueInput
    take?: number
    skip?: number
    distinct?: External_runScalarFieldEnum | External_runScalarFieldEnum[]
  }


  /**
   * testcase.judging_run
   */
  export type testcase$judging_runArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the judging_run
     */
    select?: judging_runSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: judging_runInclude<ExtArgs> | null
    where?: judging_runWhereInput
    orderBy?: judging_runOrderByWithRelationInput | judging_runOrderByWithRelationInput[]
    cursor?: judging_runWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Judging_runScalarFieldEnum | Judging_runScalarFieldEnum[]
  }


  /**
   * testcase.problem
   */
  export type testcase$problemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem
     */
    select?: problemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: problemInclude<ExtArgs> | null
    where?: problemWhereInput
  }


  /**
   * testcase.testcase_content
   */
  export type testcase$testcase_contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase_content
     */
    select?: testcase_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcase_contentInclude<ExtArgs> | null
    where?: testcase_contentWhereInput
    orderBy?: testcase_contentOrderByWithRelationInput | testcase_contentOrderByWithRelationInput[]
    cursor?: testcase_contentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Testcase_contentScalarFieldEnum | Testcase_contentScalarFieldEnum[]
  }


  /**
   * testcase without action
   */
  export type testcaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase
     */
    select?: testcaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcaseInclude<ExtArgs> | null
  }



  /**
   * Model testcase_content
   */

  export type AggregateTestcase_content = {
    _count: Testcase_contentCountAggregateOutputType | null
    _avg: Testcase_contentAvgAggregateOutputType | null
    _sum: Testcase_contentSumAggregateOutputType | null
    _min: Testcase_contentMinAggregateOutputType | null
    _max: Testcase_contentMaxAggregateOutputType | null
  }

  export type Testcase_contentAvgAggregateOutputType = {
    testcaseid: number | null
    tc_contentid: number | null
  }

  export type Testcase_contentSumAggregateOutputType = {
    testcaseid: number | null
    tc_contentid: number | null
  }

  export type Testcase_contentMinAggregateOutputType = {
    testcaseid: number | null
    input: Buffer | null
    output: Buffer | null
    image: Buffer | null
    image_thumb: Buffer | null
    tc_contentid: number | null
  }

  export type Testcase_contentMaxAggregateOutputType = {
    testcaseid: number | null
    input: Buffer | null
    output: Buffer | null
    image: Buffer | null
    image_thumb: Buffer | null
    tc_contentid: number | null
  }

  export type Testcase_contentCountAggregateOutputType = {
    testcaseid: number
    input: number
    output: number
    image: number
    image_thumb: number
    tc_contentid: number
    _all: number
  }


  export type Testcase_contentAvgAggregateInputType = {
    testcaseid?: true
    tc_contentid?: true
  }

  export type Testcase_contentSumAggregateInputType = {
    testcaseid?: true
    tc_contentid?: true
  }

  export type Testcase_contentMinAggregateInputType = {
    testcaseid?: true
    input?: true
    output?: true
    image?: true
    image_thumb?: true
    tc_contentid?: true
  }

  export type Testcase_contentMaxAggregateInputType = {
    testcaseid?: true
    input?: true
    output?: true
    image?: true
    image_thumb?: true
    tc_contentid?: true
  }

  export type Testcase_contentCountAggregateInputType = {
    testcaseid?: true
    input?: true
    output?: true
    image?: true
    image_thumb?: true
    tc_contentid?: true
    _all?: true
  }

  export type Testcase_contentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testcase_content to aggregate.
     */
    where?: testcase_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testcase_contents to fetch.
     */
    orderBy?: testcase_contentOrderByWithRelationInput | testcase_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: testcase_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testcase_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testcase_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned testcase_contents
    **/
    _count?: true | Testcase_contentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Testcase_contentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Testcase_contentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Testcase_contentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Testcase_contentMaxAggregateInputType
  }

  export type GetTestcase_contentAggregateType<T extends Testcase_contentAggregateArgs> = {
        [P in keyof T & keyof AggregateTestcase_content]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestcase_content[P]>
      : GetScalarType<T[P], AggregateTestcase_content[P]>
  }




  export type testcase_contentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: testcase_contentWhereInput
    orderBy?: testcase_contentOrderByWithAggregationInput | testcase_contentOrderByWithAggregationInput[]
    by: Testcase_contentScalarFieldEnum[] | Testcase_contentScalarFieldEnum
    having?: testcase_contentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Testcase_contentCountAggregateInputType | true
    _avg?: Testcase_contentAvgAggregateInputType
    _sum?: Testcase_contentSumAggregateInputType
    _min?: Testcase_contentMinAggregateInputType
    _max?: Testcase_contentMaxAggregateInputType
  }

  export type Testcase_contentGroupByOutputType = {
    testcaseid: number | null
    input: Buffer | null
    output: Buffer | null
    image: Buffer | null
    image_thumb: Buffer | null
    tc_contentid: number
    _count: Testcase_contentCountAggregateOutputType | null
    _avg: Testcase_contentAvgAggregateOutputType | null
    _sum: Testcase_contentSumAggregateOutputType | null
    _min: Testcase_contentMinAggregateOutputType | null
    _max: Testcase_contentMaxAggregateOutputType | null
  }

  type GetTestcase_contentGroupByPayload<T extends testcase_contentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Testcase_contentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Testcase_contentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Testcase_contentGroupByOutputType[P]>
            : GetScalarType<T[P], Testcase_contentGroupByOutputType[P]>
        }
      >
    >


  export type testcase_contentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    testcaseid?: boolean
    input?: boolean
    output?: boolean
    image?: boolean
    image_thumb?: boolean
    tc_contentid?: boolean
    testcase?: boolean | testcase_content$testcaseArgs<ExtArgs>
  }, ExtArgs["result"]["testcase_content"]>

  export type testcase_contentSelectScalar = {
    testcaseid?: boolean
    input?: boolean
    output?: boolean
    image?: boolean
    image_thumb?: boolean
    tc_contentid?: boolean
  }

  export type testcase_contentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testcase?: boolean | testcase_content$testcaseArgs<ExtArgs>
  }


  export type $testcase_contentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "testcase_content"
    objects: {
      testcase: Prisma.$testcasePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      testcaseid: number | null
      input: Buffer | null
      output: Buffer | null
      image: Buffer | null
      image_thumb: Buffer | null
      tc_contentid: number
    }, ExtArgs["result"]["testcase_content"]>
    composites: {}
  }


  type testcase_contentGetPayload<S extends boolean | null | undefined | testcase_contentDefaultArgs> = $Result.GetResult<Prisma.$testcase_contentPayload, S>

  type testcase_contentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<testcase_contentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Testcase_contentCountAggregateInputType | true
    }

  export interface testcase_contentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['testcase_content'], meta: { name: 'testcase_content' } }
    /**
     * Find zero or one Testcase_content that matches the filter.
     * @param {testcase_contentFindUniqueArgs} args - Arguments to find a Testcase_content
     * @example
     * // Get one Testcase_content
     * const testcase_content = await prisma.testcase_content.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends testcase_contentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, testcase_contentFindUniqueArgs<ExtArgs>>
    ): Prisma__testcase_contentClient<$Result.GetResult<Prisma.$testcase_contentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Testcase_content that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {testcase_contentFindUniqueOrThrowArgs} args - Arguments to find a Testcase_content
     * @example
     * // Get one Testcase_content
     * const testcase_content = await prisma.testcase_content.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends testcase_contentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, testcase_contentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__testcase_contentClient<$Result.GetResult<Prisma.$testcase_contentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Testcase_content that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testcase_contentFindFirstArgs} args - Arguments to find a Testcase_content
     * @example
     * // Get one Testcase_content
     * const testcase_content = await prisma.testcase_content.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends testcase_contentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, testcase_contentFindFirstArgs<ExtArgs>>
    ): Prisma__testcase_contentClient<$Result.GetResult<Prisma.$testcase_contentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Testcase_content that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testcase_contentFindFirstOrThrowArgs} args - Arguments to find a Testcase_content
     * @example
     * // Get one Testcase_content
     * const testcase_content = await prisma.testcase_content.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends testcase_contentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, testcase_contentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__testcase_contentClient<$Result.GetResult<Prisma.$testcase_contentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Testcase_contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testcase_contentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testcase_contents
     * const testcase_contents = await prisma.testcase_content.findMany()
     * 
     * // Get first 10 Testcase_contents
     * const testcase_contents = await prisma.testcase_content.findMany({ take: 10 })
     * 
     * // Only select the `testcaseid`
     * const testcase_contentWithTestcaseidOnly = await prisma.testcase_content.findMany({ select: { testcaseid: true } })
     * 
    **/
    findMany<T extends testcase_contentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, testcase_contentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$testcase_contentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Testcase_content.
     * @param {testcase_contentCreateArgs} args - Arguments to create a Testcase_content.
     * @example
     * // Create one Testcase_content
     * const Testcase_content = await prisma.testcase_content.create({
     *   data: {
     *     // ... data to create a Testcase_content
     *   }
     * })
     * 
    **/
    create<T extends testcase_contentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, testcase_contentCreateArgs<ExtArgs>>
    ): Prisma__testcase_contentClient<$Result.GetResult<Prisma.$testcase_contentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Testcase_contents.
     *     @param {testcase_contentCreateManyArgs} args - Arguments to create many Testcase_contents.
     *     @example
     *     // Create many Testcase_contents
     *     const testcase_content = await prisma.testcase_content.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends testcase_contentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, testcase_contentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Testcase_content.
     * @param {testcase_contentDeleteArgs} args - Arguments to delete one Testcase_content.
     * @example
     * // Delete one Testcase_content
     * const Testcase_content = await prisma.testcase_content.delete({
     *   where: {
     *     // ... filter to delete one Testcase_content
     *   }
     * })
     * 
    **/
    delete<T extends testcase_contentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, testcase_contentDeleteArgs<ExtArgs>>
    ): Prisma__testcase_contentClient<$Result.GetResult<Prisma.$testcase_contentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Testcase_content.
     * @param {testcase_contentUpdateArgs} args - Arguments to update one Testcase_content.
     * @example
     * // Update one Testcase_content
     * const testcase_content = await prisma.testcase_content.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends testcase_contentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, testcase_contentUpdateArgs<ExtArgs>>
    ): Prisma__testcase_contentClient<$Result.GetResult<Prisma.$testcase_contentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Testcase_contents.
     * @param {testcase_contentDeleteManyArgs} args - Arguments to filter Testcase_contents to delete.
     * @example
     * // Delete a few Testcase_contents
     * const { count } = await prisma.testcase_content.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends testcase_contentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, testcase_contentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testcase_contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testcase_contentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testcase_contents
     * const testcase_content = await prisma.testcase_content.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends testcase_contentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, testcase_contentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Testcase_content.
     * @param {testcase_contentUpsertArgs} args - Arguments to update or create a Testcase_content.
     * @example
     * // Update or create a Testcase_content
     * const testcase_content = await prisma.testcase_content.upsert({
     *   create: {
     *     // ... data to create a Testcase_content
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testcase_content we want to update
     *   }
     * })
    **/
    upsert<T extends testcase_contentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, testcase_contentUpsertArgs<ExtArgs>>
    ): Prisma__testcase_contentClient<$Result.GetResult<Prisma.$testcase_contentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Testcase_contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testcase_contentCountArgs} args - Arguments to filter Testcase_contents to count.
     * @example
     * // Count the number of Testcase_contents
     * const count = await prisma.testcase_content.count({
     *   where: {
     *     // ... the filter for the Testcase_contents we want to count
     *   }
     * })
    **/
    count<T extends testcase_contentCountArgs>(
      args?: Subset<T, testcase_contentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Testcase_contentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testcase_content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Testcase_contentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Testcase_contentAggregateArgs>(args: Subset<T, Testcase_contentAggregateArgs>): Prisma.PrismaPromise<GetTestcase_contentAggregateType<T>>

    /**
     * Group by Testcase_content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testcase_contentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends testcase_contentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: testcase_contentGroupByArgs['orderBy'] }
        : { orderBy?: testcase_contentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, testcase_contentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestcase_contentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the testcase_content model
   */
  readonly fields: testcase_contentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for testcase_content.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__testcase_contentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    testcase<T extends testcase_content$testcaseArgs<ExtArgs> = {}>(args?: Subset<T, testcase_content$testcaseArgs<ExtArgs>>): Prisma__testcaseClient<$Result.GetResult<Prisma.$testcasePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the testcase_content model
   */ 
  interface testcase_contentFieldRefs {
    readonly testcaseid: FieldRef<"testcase_content", 'Int'>
    readonly input: FieldRef<"testcase_content", 'Bytes'>
    readonly output: FieldRef<"testcase_content", 'Bytes'>
    readonly image: FieldRef<"testcase_content", 'Bytes'>
    readonly image_thumb: FieldRef<"testcase_content", 'Bytes'>
    readonly tc_contentid: FieldRef<"testcase_content", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * testcase_content findUnique
   */
  export type testcase_contentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase_content
     */
    select?: testcase_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcase_contentInclude<ExtArgs> | null
    /**
     * Filter, which testcase_content to fetch.
     */
    where: testcase_contentWhereUniqueInput
  }


  /**
   * testcase_content findUniqueOrThrow
   */
  export type testcase_contentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase_content
     */
    select?: testcase_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcase_contentInclude<ExtArgs> | null
    /**
     * Filter, which testcase_content to fetch.
     */
    where: testcase_contentWhereUniqueInput
  }


  /**
   * testcase_content findFirst
   */
  export type testcase_contentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase_content
     */
    select?: testcase_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcase_contentInclude<ExtArgs> | null
    /**
     * Filter, which testcase_content to fetch.
     */
    where?: testcase_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testcase_contents to fetch.
     */
    orderBy?: testcase_contentOrderByWithRelationInput | testcase_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testcase_contents.
     */
    cursor?: testcase_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testcase_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testcase_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testcase_contents.
     */
    distinct?: Testcase_contentScalarFieldEnum | Testcase_contentScalarFieldEnum[]
  }


  /**
   * testcase_content findFirstOrThrow
   */
  export type testcase_contentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase_content
     */
    select?: testcase_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcase_contentInclude<ExtArgs> | null
    /**
     * Filter, which testcase_content to fetch.
     */
    where?: testcase_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testcase_contents to fetch.
     */
    orderBy?: testcase_contentOrderByWithRelationInput | testcase_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testcase_contents.
     */
    cursor?: testcase_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testcase_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testcase_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testcase_contents.
     */
    distinct?: Testcase_contentScalarFieldEnum | Testcase_contentScalarFieldEnum[]
  }


  /**
   * testcase_content findMany
   */
  export type testcase_contentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase_content
     */
    select?: testcase_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcase_contentInclude<ExtArgs> | null
    /**
     * Filter, which testcase_contents to fetch.
     */
    where?: testcase_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testcase_contents to fetch.
     */
    orderBy?: testcase_contentOrderByWithRelationInput | testcase_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing testcase_contents.
     */
    cursor?: testcase_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testcase_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testcase_contents.
     */
    skip?: number
    distinct?: Testcase_contentScalarFieldEnum | Testcase_contentScalarFieldEnum[]
  }


  /**
   * testcase_content create
   */
  export type testcase_contentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase_content
     */
    select?: testcase_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcase_contentInclude<ExtArgs> | null
    /**
     * The data needed to create a testcase_content.
     */
    data?: XOR<testcase_contentCreateInput, testcase_contentUncheckedCreateInput>
  }


  /**
   * testcase_content createMany
   */
  export type testcase_contentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many testcase_contents.
     */
    data: testcase_contentCreateManyInput | testcase_contentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * testcase_content update
   */
  export type testcase_contentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase_content
     */
    select?: testcase_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcase_contentInclude<ExtArgs> | null
    /**
     * The data needed to update a testcase_content.
     */
    data: XOR<testcase_contentUpdateInput, testcase_contentUncheckedUpdateInput>
    /**
     * Choose, which testcase_content to update.
     */
    where: testcase_contentWhereUniqueInput
  }


  /**
   * testcase_content updateMany
   */
  export type testcase_contentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update testcase_contents.
     */
    data: XOR<testcase_contentUpdateManyMutationInput, testcase_contentUncheckedUpdateManyInput>
    /**
     * Filter which testcase_contents to update
     */
    where?: testcase_contentWhereInput
  }


  /**
   * testcase_content upsert
   */
  export type testcase_contentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase_content
     */
    select?: testcase_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcase_contentInclude<ExtArgs> | null
    /**
     * The filter to search for the testcase_content to update in case it exists.
     */
    where: testcase_contentWhereUniqueInput
    /**
     * In case the testcase_content found by the `where` argument doesn't exist, create a new testcase_content with this data.
     */
    create: XOR<testcase_contentCreateInput, testcase_contentUncheckedCreateInput>
    /**
     * In case the testcase_content was found with the provided `where` argument, update it with this data.
     */
    update: XOR<testcase_contentUpdateInput, testcase_contentUncheckedUpdateInput>
  }


  /**
   * testcase_content delete
   */
  export type testcase_contentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase_content
     */
    select?: testcase_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcase_contentInclude<ExtArgs> | null
    /**
     * Filter which testcase_content to delete.
     */
    where: testcase_contentWhereUniqueInput
  }


  /**
   * testcase_content deleteMany
   */
  export type testcase_contentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testcase_contents to delete
     */
    where?: testcase_contentWhereInput
  }


  /**
   * testcase_content.testcase
   */
  export type testcase_content$testcaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase
     */
    select?: testcaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcaseInclude<ExtArgs> | null
    where?: testcaseWhereInput
  }


  /**
   * testcase_content without action
   */
  export type testcase_contentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testcase_content
     */
    select?: testcase_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: testcase_contentInclude<ExtArgs> | null
  }



  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    userid: number | null
    last_login: Decimal | null
    last_api_login: Decimal | null
    first_login: Decimal | null
    teamid: number | null
  }

  export type UserSumAggregateOutputType = {
    userid: number | null
    last_login: Decimal | null
    last_api_login: Decimal | null
    first_login: Decimal | null
    teamid: number | null
  }

  export type UserMinAggregateOutputType = {
    userid: number | null
    externalid: string | null
    username: string | null
    name: string | null
    email: string | null
    last_login: Decimal | null
    last_api_login: Decimal | null
    first_login: Decimal | null
    last_ip_address: string | null
    password: string | null
    ip_address: string | null
    enabled: boolean | null
    teamid: number | null
  }

  export type UserMaxAggregateOutputType = {
    userid: number | null
    externalid: string | null
    username: string | null
    name: string | null
    email: string | null
    last_login: Decimal | null
    last_api_login: Decimal | null
    first_login: Decimal | null
    last_ip_address: string | null
    password: string | null
    ip_address: string | null
    enabled: boolean | null
    teamid: number | null
  }

  export type UserCountAggregateOutputType = {
    userid: number
    externalid: number
    username: number
    name: number
    email: number
    last_login: number
    last_api_login: number
    first_login: number
    last_ip_address: number
    password: number
    ip_address: number
    enabled: number
    teamid: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    userid?: true
    last_login?: true
    last_api_login?: true
    first_login?: true
    teamid?: true
  }

  export type UserSumAggregateInputType = {
    userid?: true
    last_login?: true
    last_api_login?: true
    first_login?: true
    teamid?: true
  }

  export type UserMinAggregateInputType = {
    userid?: true
    externalid?: true
    username?: true
    name?: true
    email?: true
    last_login?: true
    last_api_login?: true
    first_login?: true
    last_ip_address?: true
    password?: true
    ip_address?: true
    enabled?: true
    teamid?: true
  }

  export type UserMaxAggregateInputType = {
    userid?: true
    externalid?: true
    username?: true
    name?: true
    email?: true
    last_login?: true
    last_api_login?: true
    first_login?: true
    last_ip_address?: true
    password?: true
    ip_address?: true
    enabled?: true
    teamid?: true
  }

  export type UserCountAggregateInputType = {
    userid?: true
    externalid?: true
    username?: true
    name?: true
    email?: true
    last_login?: true
    last_api_login?: true
    first_login?: true
    last_ip_address?: true
    password?: true
    ip_address?: true
    enabled?: true
    teamid?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    userid: number
    externalid: string | null
    username: string
    name: string
    email: string | null
    last_login: Decimal | null
    last_api_login: Decimal | null
    first_login: Decimal | null
    last_ip_address: string | null
    password: string | null
    ip_address: string | null
    enabled: boolean
    teamid: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    externalid?: boolean
    username?: boolean
    name?: boolean
    email?: boolean
    last_login?: boolean
    last_api_login?: boolean
    first_login?: boolean
    last_ip_address?: boolean
    password?: boolean
    ip_address?: boolean
    enabled?: boolean
    teamid?: boolean
    immutable_executable?: boolean | user$immutable_executableArgs<ExtArgs>
    rejudging_rejudging_userid_startTouser?: boolean | user$rejudging_rejudging_userid_startTouserArgs<ExtArgs>
    rejudging_rejudging_userid_finishTouser?: boolean | user$rejudging_rejudging_userid_finishTouserArgs<ExtArgs>
    submission?: boolean | user$submissionArgs<ExtArgs>
    team?: boolean | user$teamArgs<ExtArgs>
    userrole?: boolean | user$userroleArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    userid?: boolean
    externalid?: boolean
    username?: boolean
    name?: boolean
    email?: boolean
    last_login?: boolean
    last_api_login?: boolean
    first_login?: boolean
    last_ip_address?: boolean
    password?: boolean
    ip_address?: boolean
    enabled?: boolean
    teamid?: boolean
  }

  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    immutable_executable?: boolean | user$immutable_executableArgs<ExtArgs>
    rejudging_rejudging_userid_startTouser?: boolean | user$rejudging_rejudging_userid_startTouserArgs<ExtArgs>
    rejudging_rejudging_userid_finishTouser?: boolean | user$rejudging_rejudging_userid_finishTouserArgs<ExtArgs>
    submission?: boolean | user$submissionArgs<ExtArgs>
    team?: boolean | user$teamArgs<ExtArgs>
    userrole?: boolean | user$userroleArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      immutable_executable: Prisma.$immutable_executablePayload<ExtArgs>[]
      rejudging_rejudging_userid_startTouser: Prisma.$rejudgingPayload<ExtArgs>[]
      rejudging_rejudging_userid_finishTouser: Prisma.$rejudgingPayload<ExtArgs>[]
      submission: Prisma.$submissionPayload<ExtArgs>[]
      team: Prisma.$teamPayload<ExtArgs> | null
      userrole: Prisma.$userrolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      userid: number
      externalid: string | null
      username: string
      name: string
      email: string | null
      last_login: Prisma.Decimal | null
      last_api_login: Prisma.Decimal | null
      first_login: Prisma.Decimal | null
      last_ip_address: string | null
      password: string | null
      ip_address: string | null
      enabled: boolean
      teamid: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `userid`
     * const userWithUseridOnly = await prisma.user.findMany({ select: { userid: true } })
     * 
    **/
    findMany<T extends userFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userCreateArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {userCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userDeleteArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userUpsertArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    immutable_executable<T extends user$immutable_executableArgs<ExtArgs> = {}>(args?: Subset<T, user$immutable_executableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$immutable_executablePayload<ExtArgs>, T, 'findMany'> | Null>;

    rejudging_rejudging_userid_startTouser<T extends user$rejudging_rejudging_userid_startTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$rejudging_rejudging_userid_startTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rejudgingPayload<ExtArgs>, T, 'findMany'> | Null>;

    rejudging_rejudging_userid_finishTouser<T extends user$rejudging_rejudging_userid_finishTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$rejudging_rejudging_userid_finishTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rejudgingPayload<ExtArgs>, T, 'findMany'> | Null>;

    submission<T extends user$submissionArgs<ExtArgs> = {}>(args?: Subset<T, user$submissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$submissionPayload<ExtArgs>, T, 'findMany'> | Null>;

    team<T extends user$teamArgs<ExtArgs> = {}>(args?: Subset<T, user$teamArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    userrole<T extends user$userroleArgs<ExtArgs> = {}>(args?: Subset<T, user$userroleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the user model
   */ 
  interface userFieldRefs {
    readonly userid: FieldRef<"user", 'Int'>
    readonly externalid: FieldRef<"user", 'String'>
    readonly username: FieldRef<"user", 'String'>
    readonly name: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly last_login: FieldRef<"user", 'Decimal'>
    readonly last_api_login: FieldRef<"user", 'Decimal'>
    readonly first_login: FieldRef<"user", 'Decimal'>
    readonly last_ip_address: FieldRef<"user", 'String'>
    readonly password: FieldRef<"user", 'String'>
    readonly ip_address: FieldRef<"user", 'String'>
    readonly enabled: FieldRef<"user", 'Boolean'>
    readonly teamid: FieldRef<"user", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }


  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }


  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }


  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }


  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }


  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }


  /**
   * user.immutable_executable
   */
  export type user$immutable_executableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the immutable_executable
     */
    select?: immutable_executableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: immutable_executableInclude<ExtArgs> | null
    where?: immutable_executableWhereInput
    orderBy?: immutable_executableOrderByWithRelationInput | immutable_executableOrderByWithRelationInput[]
    cursor?: immutable_executableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Immutable_executableScalarFieldEnum | Immutable_executableScalarFieldEnum[]
  }


  /**
   * user.rejudging_rejudging_userid_startTouser
   */
  export type user$rejudging_rejudging_userid_startTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejudging
     */
    select?: rejudgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rejudgingInclude<ExtArgs> | null
    where?: rejudgingWhereInput
    orderBy?: rejudgingOrderByWithRelationInput | rejudgingOrderByWithRelationInput[]
    cursor?: rejudgingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RejudgingScalarFieldEnum | RejudgingScalarFieldEnum[]
  }


  /**
   * user.rejudging_rejudging_userid_finishTouser
   */
  export type user$rejudging_rejudging_userid_finishTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejudging
     */
    select?: rejudgingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rejudgingInclude<ExtArgs> | null
    where?: rejudgingWhereInput
    orderBy?: rejudgingOrderByWithRelationInput | rejudgingOrderByWithRelationInput[]
    cursor?: rejudgingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RejudgingScalarFieldEnum | RejudgingScalarFieldEnum[]
  }


  /**
   * user.submission
   */
  export type user$submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submission
     */
    select?: submissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: submissionInclude<ExtArgs> | null
    where?: submissionWhereInput
    orderBy?: submissionOrderByWithRelationInput | submissionOrderByWithRelationInput[]
    cursor?: submissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }


  /**
   * user.team
   */
  export type user$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    where?: teamWhereInput
  }


  /**
   * user.userrole
   */
  export type user$userroleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userroleInclude<ExtArgs> | null
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    cursor?: userroleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }


  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
  }



  /**
   * Model userrole
   */

  export type AggregateUserrole = {
    _count: UserroleCountAggregateOutputType | null
    _avg: UserroleAvgAggregateOutputType | null
    _sum: UserroleSumAggregateOutputType | null
    _min: UserroleMinAggregateOutputType | null
    _max: UserroleMaxAggregateOutputType | null
  }

  export type UserroleAvgAggregateOutputType = {
    userid: number | null
    roleid: number | null
  }

  export type UserroleSumAggregateOutputType = {
    userid: number | null
    roleid: number | null
  }

  export type UserroleMinAggregateOutputType = {
    userid: number | null
    roleid: number | null
  }

  export type UserroleMaxAggregateOutputType = {
    userid: number | null
    roleid: number | null
  }

  export type UserroleCountAggregateOutputType = {
    userid: number
    roleid: number
    _all: number
  }


  export type UserroleAvgAggregateInputType = {
    userid?: true
    roleid?: true
  }

  export type UserroleSumAggregateInputType = {
    userid?: true
    roleid?: true
  }

  export type UserroleMinAggregateInputType = {
    userid?: true
    roleid?: true
  }

  export type UserroleMaxAggregateInputType = {
    userid?: true
    roleid?: true
  }

  export type UserroleCountAggregateInputType = {
    userid?: true
    roleid?: true
    _all?: true
  }

  export type UserroleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userrole to aggregate.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userroles
    **/
    _count?: true | UserroleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserroleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserroleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserroleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserroleMaxAggregateInputType
  }

  export type GetUserroleAggregateType<T extends UserroleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserrole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserrole[P]>
      : GetScalarType<T[P], AggregateUserrole[P]>
  }




  export type userroleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithAggregationInput | userroleOrderByWithAggregationInput[]
    by: UserroleScalarFieldEnum[] | UserroleScalarFieldEnum
    having?: userroleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserroleCountAggregateInputType | true
    _avg?: UserroleAvgAggregateInputType
    _sum?: UserroleSumAggregateInputType
    _min?: UserroleMinAggregateInputType
    _max?: UserroleMaxAggregateInputType
  }

  export type UserroleGroupByOutputType = {
    userid: number
    roleid: number
    _count: UserroleCountAggregateOutputType | null
    _avg: UserroleAvgAggregateOutputType | null
    _sum: UserroleSumAggregateOutputType | null
    _min: UserroleMinAggregateOutputType | null
    _max: UserroleMaxAggregateOutputType | null
  }

  type GetUserroleGroupByPayload<T extends userroleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserroleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserroleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserroleGroupByOutputType[P]>
            : GetScalarType<T[P], UserroleGroupByOutputType[P]>
        }
      >
    >


  export type userroleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    roleid?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userrole"]>

  export type userroleSelectScalar = {
    userid?: boolean
    roleid?: boolean
  }

  export type userroleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
  }


  export type $userrolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userrole"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      role: Prisma.$rolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userid: number
      roleid: number
    }, ExtArgs["result"]["userrole"]>
    composites: {}
  }


  type userroleGetPayload<S extends boolean | null | undefined | userroleDefaultArgs> = $Result.GetResult<Prisma.$userrolePayload, S>

  type userroleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<userroleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserroleCountAggregateInputType | true
    }

  export interface userroleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userrole'], meta: { name: 'userrole' } }
    /**
     * Find zero or one Userrole that matches the filter.
     * @param {userroleFindUniqueArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userroleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, userroleFindUniqueArgs<ExtArgs>>
    ): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Userrole that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userroleFindUniqueOrThrowArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userroleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userroleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Userrole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindFirstArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userroleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, userroleFindFirstArgs<ExtArgs>>
    ): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Userrole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindFirstOrThrowArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userroleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userroleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Userroles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userroles
     * const userroles = await prisma.userrole.findMany()
     * 
     * // Get first 10 Userroles
     * const userroles = await prisma.userrole.findMany({ take: 10 })
     * 
     * // Only select the `userid`
     * const userroleWithUseridOnly = await prisma.userrole.findMany({ select: { userid: true } })
     * 
    **/
    findMany<T extends userroleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userroleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Userrole.
     * @param {userroleCreateArgs} args - Arguments to create a Userrole.
     * @example
     * // Create one Userrole
     * const Userrole = await prisma.userrole.create({
     *   data: {
     *     // ... data to create a Userrole
     *   }
     * })
     * 
    **/
    create<T extends userroleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userroleCreateArgs<ExtArgs>>
    ): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Userroles.
     *     @param {userroleCreateManyArgs} args - Arguments to create many Userroles.
     *     @example
     *     // Create many Userroles
     *     const userrole = await prisma.userrole.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userroleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userroleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Userrole.
     * @param {userroleDeleteArgs} args - Arguments to delete one Userrole.
     * @example
     * // Delete one Userrole
     * const Userrole = await prisma.userrole.delete({
     *   where: {
     *     // ... filter to delete one Userrole
     *   }
     * })
     * 
    **/
    delete<T extends userroleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userroleDeleteArgs<ExtArgs>>
    ): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Userrole.
     * @param {userroleUpdateArgs} args - Arguments to update one Userrole.
     * @example
     * // Update one Userrole
     * const userrole = await prisma.userrole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userroleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userroleUpdateArgs<ExtArgs>>
    ): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Userroles.
     * @param {userroleDeleteManyArgs} args - Arguments to filter Userroles to delete.
     * @example
     * // Delete a few Userroles
     * const { count } = await prisma.userrole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userroleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userroleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userroles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userroles
     * const userrole = await prisma.userrole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userroleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userroleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Userrole.
     * @param {userroleUpsertArgs} args - Arguments to update or create a Userrole.
     * @example
     * // Update or create a Userrole
     * const userrole = await prisma.userrole.upsert({
     *   create: {
     *     // ... data to create a Userrole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userrole we want to update
     *   }
     * })
    **/
    upsert<T extends userroleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userroleUpsertArgs<ExtArgs>>
    ): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Userroles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleCountArgs} args - Arguments to filter Userroles to count.
     * @example
     * // Count the number of Userroles
     * const count = await prisma.userrole.count({
     *   where: {
     *     // ... the filter for the Userroles we want to count
     *   }
     * })
    **/
    count<T extends userroleCountArgs>(
      args?: Subset<T, userroleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserroleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userrole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserroleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserroleAggregateArgs>(args: Subset<T, UserroleAggregateArgs>): Prisma.PrismaPromise<GetUserroleAggregateType<T>>

    /**
     * Group by Userrole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userroleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userroleGroupByArgs['orderBy'] }
        : { orderBy?: userroleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userroleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserroleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userrole model
   */
  readonly fields: userroleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userrole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userroleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    role<T extends roleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roleDefaultArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the userrole model
   */ 
  interface userroleFieldRefs {
    readonly userid: FieldRef<"userrole", 'Int'>
    readonly roleid: FieldRef<"userrole", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * userrole findUnique
   */
  export type userroleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where: userroleWhereUniqueInput
  }


  /**
   * userrole findUniqueOrThrow
   */
  export type userroleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where: userroleWhereUniqueInput
  }


  /**
   * userrole findFirst
   */
  export type userroleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userroles.
     */
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }


  /**
   * userrole findFirstOrThrow
   */
  export type userroleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userroles.
     */
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }


  /**
   * userrole findMany
   */
  export type userroleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userroles to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }


  /**
   * userrole create
   */
  export type userroleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The data needed to create a userrole.
     */
    data: XOR<userroleCreateInput, userroleUncheckedCreateInput>
  }


  /**
   * userrole createMany
   */
  export type userroleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userroles.
     */
    data: userroleCreateManyInput | userroleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * userrole update
   */
  export type userroleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The data needed to update a userrole.
     */
    data: XOR<userroleUpdateInput, userroleUncheckedUpdateInput>
    /**
     * Choose, which userrole to update.
     */
    where: userroleWhereUniqueInput
  }


  /**
   * userrole updateMany
   */
  export type userroleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userroles.
     */
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyInput>
    /**
     * Filter which userroles to update
     */
    where?: userroleWhereInput
  }


  /**
   * userrole upsert
   */
  export type userroleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The filter to search for the userrole to update in case it exists.
     */
    where: userroleWhereUniqueInput
    /**
     * In case the userrole found by the `where` argument doesn't exist, create a new userrole with this data.
     */
    create: XOR<userroleCreateInput, userroleUncheckedCreateInput>
    /**
     * In case the userrole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userroleUpdateInput, userroleUncheckedUpdateInput>
  }


  /**
   * userrole delete
   */
  export type userroleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter which userrole to delete.
     */
    where: userroleWhereUniqueInput
  }


  /**
   * userrole deleteMany
   */
  export type userroleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userroles to delete
     */
    where?: userroleWhereInput
  }


  /**
   * userrole without action
   */
  export type userroleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userroleInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AuditlogScalarFieldEnum: {
    logid: 'logid',
    logtime: 'logtime',
    cid: 'cid',
    user: 'user',
    datatype: 'datatype',
    dataid: 'dataid',
    action: 'action',
    extrainfo: 'extrainfo'
  };

  export type AuditlogScalarFieldEnum = (typeof AuditlogScalarFieldEnum)[keyof typeof AuditlogScalarFieldEnum]


  export const BalloonScalarFieldEnum: {
    balloonid: 'balloonid',
    submitid: 'submitid',
    done: 'done'
  };

  export type BalloonScalarFieldEnum = (typeof BalloonScalarFieldEnum)[keyof typeof BalloonScalarFieldEnum]


  export const ClarificationScalarFieldEnum: {
    clarid: 'clarid',
    externalid: 'externalid',
    cid: 'cid',
    respid: 'respid',
    submittime: 'submittime',
    sender: 'sender',
    recipient: 'recipient',
    jury_member: 'jury_member',
    probid: 'probid',
    category: 'category',
    queue: 'queue',
    body: 'body',
    answered: 'answered'
  };

  export type ClarificationScalarFieldEnum = (typeof ClarificationScalarFieldEnum)[keyof typeof ClarificationScalarFieldEnum]


  export const ConfigurationScalarFieldEnum: {
    configid: 'configid',
    name: 'name',
    value: 'value'
  };

  export type ConfigurationScalarFieldEnum = (typeof ConfigurationScalarFieldEnum)[keyof typeof ConfigurationScalarFieldEnum]


  export const ContestScalarFieldEnum: {
    cid: 'cid',
    externalid: 'externalid',
    name: 'name',
    shortname: 'shortname',
    activatetime: 'activatetime',
    starttime: 'starttime',
    freezetime: 'freezetime',
    endtime: 'endtime',
    unfreezetime: 'unfreezetime',
    deactivatetime: 'deactivatetime',
    activatetime_string: 'activatetime_string',
    starttime_string: 'starttime_string',
    freezetime_string: 'freezetime_string',
    endtime_string: 'endtime_string',
    unfreezetime_string: 'unfreezetime_string',
    deactivatetime_string: 'deactivatetime_string',
    finalizetime: 'finalizetime',
    finalizecomment: 'finalizecomment',
    b: 'b',
    enabled: 'enabled',
    starttime_enabled: 'starttime_enabled',
    process_balloons: 'process_balloons',
    public: 'public',
    open_to_all_teams: 'open_to_all_teams',
    medals_enabled: 'medals_enabled',
    gold_medals: 'gold_medals',
    silver_medals: 'silver_medals',
    bronze_medals: 'bronze_medals',
    is_locked: 'is_locked',
    allow_submit: 'allow_submit',
    warning_message: 'warning_message'
  };

  export type ContestScalarFieldEnum = (typeof ContestScalarFieldEnum)[keyof typeof ContestScalarFieldEnum]


  export const ContestproblemScalarFieldEnum: {
    cid: 'cid',
    probid: 'probid',
    shortname: 'shortname',
    points: 'points',
    allow_submit: 'allow_submit',
    allow_judge: 'allow_judge',
    color: 'color',
    lazy_eval_results: 'lazy_eval_results'
  };

  export type ContestproblemScalarFieldEnum = (typeof ContestproblemScalarFieldEnum)[keyof typeof ContestproblemScalarFieldEnum]


  export const ContestteamScalarFieldEnum: {
    cid: 'cid',
    teamid: 'teamid'
  };

  export type ContestteamScalarFieldEnum = (typeof ContestteamScalarFieldEnum)[keyof typeof ContestteamScalarFieldEnum]


  export const ContestteamcategoryScalarFieldEnum: {
    cid: 'cid',
    categoryid: 'categoryid'
  };

  export type ContestteamcategoryScalarFieldEnum = (typeof ContestteamcategoryScalarFieldEnum)[keyof typeof ContestteamcategoryScalarFieldEnum]


  export const ContestteamcategoryformedalsScalarFieldEnum: {
    cid: 'cid',
    categoryid: 'categoryid'
  };

  export type ContestteamcategoryformedalsScalarFieldEnum = (typeof ContestteamcategoryformedalsScalarFieldEnum)[keyof typeof ContestteamcategoryformedalsScalarFieldEnum]


  export const Debug_packageScalarFieldEnum: {
    debug_package_id: 'debug_package_id',
    judgingid: 'judgingid',
    judgehostid: 'judgehostid',
    filename: 'filename'
  };

  export type Debug_packageScalarFieldEnum = (typeof Debug_packageScalarFieldEnum)[keyof typeof Debug_packageScalarFieldEnum]


  export const Doctrine_migration_versionsScalarFieldEnum: {
    version: 'version',
    executed_at: 'executed_at',
    execution_time: 'execution_time'
  };

  export type Doctrine_migration_versionsScalarFieldEnum = (typeof Doctrine_migration_versionsScalarFieldEnum)[keyof typeof Doctrine_migration_versionsScalarFieldEnum]


  export const EventScalarFieldEnum: {
    eventid: 'eventid',
    eventtime: 'eventtime',
    cid: 'cid',
    endpointtype: 'endpointtype',
    endpointid: 'endpointid',
    action: 'action',
    content: 'content'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const ExecutableScalarFieldEnum: {
    execid: 'execid',
    description: 'description',
    type: 'type',
    immutable_execid: 'immutable_execid'
  };

  export type ExecutableScalarFieldEnum = (typeof ExecutableScalarFieldEnum)[keyof typeof ExecutableScalarFieldEnum]


  export const Executable_fileScalarFieldEnum: {
    execfileid: 'execfileid',
    immutable_execid: 'immutable_execid',
    filename: 'filename',
    ranknumber: 'ranknumber',
    file_content: 'file_content',
    hash: 'hash',
    is_executable: 'is_executable'
  };

  export type Executable_fileScalarFieldEnum = (typeof Executable_fileScalarFieldEnum)[keyof typeof Executable_fileScalarFieldEnum]


  export const External_contest_sourceScalarFieldEnum: {
    extsourceid: 'extsourceid',
    cid: 'cid',
    type: 'type',
    source: 'source',
    username: 'username',
    password: 'password',
    last_event_id: 'last_event_id',
    last_poll_time: 'last_poll_time'
  };

  export type External_contest_sourceScalarFieldEnum = (typeof External_contest_sourceScalarFieldEnum)[keyof typeof External_contest_sourceScalarFieldEnum]


  export const External_judgementScalarFieldEnum: {
    extjudgementid: 'extjudgementid',
    externalid: 'externalid',
    cid: 'cid',
    submitid: 'submitid',
    result: 'result',
    verified: 'verified',
    jury_member: 'jury_member',
    verify_comment: 'verify_comment',
    starttime: 'starttime',
    endtime: 'endtime',
    valid: 'valid'
  };

  export type External_judgementScalarFieldEnum = (typeof External_judgementScalarFieldEnum)[keyof typeof External_judgementScalarFieldEnum]


  export const External_runScalarFieldEnum: {
    extrunid: 'extrunid',
    extjudgementid: 'extjudgementid',
    testcaseid: 'testcaseid',
    externalid: 'externalid',
    cid: 'cid',
    result: 'result',
    endtime: 'endtime',
    runtime: 'runtime'
  };

  export type External_runScalarFieldEnum = (typeof External_runScalarFieldEnum)[keyof typeof External_runScalarFieldEnum]


  export const External_source_warningScalarFieldEnum: {
    extwarningid: 'extwarningid',
    extsourceid: 'extsourceid',
    last_event_id: 'last_event_id',
    time: 'time',
    entity_type: 'entity_type',
    entity_id: 'entity_id',
    type: 'type',
    hash: 'hash',
    content: 'content'
  };

  export type External_source_warningScalarFieldEnum = (typeof External_source_warningScalarFieldEnum)[keyof typeof External_source_warningScalarFieldEnum]


  export const Immutable_executableScalarFieldEnum: {
    immutable_execid: 'immutable_execid',
    userid: 'userid',
    hash: 'hash'
  };

  export type Immutable_executableScalarFieldEnum = (typeof Immutable_executableScalarFieldEnum)[keyof typeof Immutable_executableScalarFieldEnum]


  export const Internal_errorScalarFieldEnum: {
    errorid: 'errorid',
    judgingid: 'judgingid',
    cid: 'cid',
    description: 'description',
    judgehostlog: 'judgehostlog',
    time: 'time',
    disabled: 'disabled',
    status: 'status'
  };

  export type Internal_errorScalarFieldEnum = (typeof Internal_errorScalarFieldEnum)[keyof typeof Internal_errorScalarFieldEnum]


  export const JudgehostScalarFieldEnum: {
    judgehostid: 'judgehostid',
    hostname: 'hostname',
    enabled: 'enabled',
    polltime: 'polltime',
    hidden: 'hidden'
  };

  export type JudgehostScalarFieldEnum = (typeof JudgehostScalarFieldEnum)[keyof typeof JudgehostScalarFieldEnum]


  export const JudgetaskScalarFieldEnum: {
    judgetaskid: 'judgetaskid',
    judgehostid: 'judgehostid',
    type: 'type',
    priority: 'priority',
    jobid: 'jobid',
    submitid: 'submitid',
    compile_script_id: 'compile_script_id',
    run_script_id: 'run_script_id',
    compare_script_id: 'compare_script_id',
    testcase_id: 'testcase_id',
    compile_config: 'compile_config',
    run_config: 'run_config',
    compare_config: 'compare_config',
    valid: 'valid',
    starttime: 'starttime',
    uuid: 'uuid',
    testcase_hash: 'testcase_hash'
  };

  export type JudgetaskScalarFieldEnum = (typeof JudgetaskScalarFieldEnum)[keyof typeof JudgetaskScalarFieldEnum]


  export const JudgingScalarFieldEnum: {
    judgingid: 'judgingid',
    cid: 'cid',
    submitid: 'submitid',
    starttime: 'starttime',
    endtime: 'endtime',
    result: 'result',
    verified: 'verified',
    jury_member: 'jury_member',
    verify_comment: 'verify_comment',
    valid: 'valid',
    output_compile: 'output_compile',
    seen: 'seen',
    rejudgingid: 'rejudgingid',
    prevjudgingid: 'prevjudgingid',
    judge_completely: 'judge_completely',
    errorid: 'errorid',
    uuid: 'uuid',
    metadata: 'metadata'
  };

  export type JudgingScalarFieldEnum = (typeof JudgingScalarFieldEnum)[keyof typeof JudgingScalarFieldEnum]


  export const Judging_runScalarFieldEnum: {
    runid: 'runid',
    judgingid: 'judgingid',
    testcaseid: 'testcaseid',
    runresult: 'runresult',
    runtime: 'runtime',
    endtime: 'endtime',
    judgetaskid: 'judgetaskid'
  };

  export type Judging_runScalarFieldEnum = (typeof Judging_runScalarFieldEnum)[keyof typeof Judging_runScalarFieldEnum]


  export const Judging_run_outputScalarFieldEnum: {
    runid: 'runid',
    output_run: 'output_run',
    output_diff: 'output_diff',
    output_error: 'output_error',
    output_system: 'output_system',
    metadata: 'metadata'
  };

  export type Judging_run_outputScalarFieldEnum = (typeof Judging_run_outputScalarFieldEnum)[keyof typeof Judging_run_outputScalarFieldEnum]


  export const LanguageScalarFieldEnum: {
    langid: 'langid',
    externalid: 'externalid',
    name: 'name',
    extensions: 'extensions',
    require_entry_point: 'require_entry_point',
    entry_point_description: 'entry_point_description',
    allow_submit: 'allow_submit',
    allow_judge: 'allow_judge',
    time_factor: 'time_factor',
    compile_script: 'compile_script',
    filter_compiler_files: 'filter_compiler_files'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const ProblemScalarFieldEnum: {
    probid: 'probid',
    externalid: 'externalid',
    name: 'name',
    timelimit: 'timelimit',
    memlimit: 'memlimit',
    outputlimit: 'outputlimit',
    special_run: 'special_run',
    special_compare: 'special_compare',
    special_compare_args: 'special_compare_args',
    combined_run_compare: 'combined_run_compare',
    problemtext: 'problemtext',
    problemtext_type: 'problemtext_type'
  };

  export type ProblemScalarFieldEnum = (typeof ProblemScalarFieldEnum)[keyof typeof ProblemScalarFieldEnum]


  export const Problem_attachmentScalarFieldEnum: {
    attachmentid: 'attachmentid',
    probid: 'probid',
    name: 'name',
    type: 'type'
  };

  export type Problem_attachmentScalarFieldEnum = (typeof Problem_attachmentScalarFieldEnum)[keyof typeof Problem_attachmentScalarFieldEnum]


  export const Problem_attachment_contentScalarFieldEnum: {
    attachmentid: 'attachmentid',
    content: 'content'
  };

  export type Problem_attachment_contentScalarFieldEnum = (typeof Problem_attachment_contentScalarFieldEnum)[keyof typeof Problem_attachment_contentScalarFieldEnum]


  export const QueuetaskScalarFieldEnum: {
    queuetaskid: 'queuetaskid',
    teamid: 'teamid',
    jobid: 'jobid',
    priority: 'priority',
    teampriority: 'teampriority',
    starttime: 'starttime'
  };

  export type QueuetaskScalarFieldEnum = (typeof QueuetaskScalarFieldEnum)[keyof typeof QueuetaskScalarFieldEnum]


  export const RankcacheScalarFieldEnum: {
    cid: 'cid',
    teamid: 'teamid',
    points_restricted: 'points_restricted',
    totaltime_restricted: 'totaltime_restricted',
    points_public: 'points_public',
    totaltime_public: 'totaltime_public'
  };

  export type RankcacheScalarFieldEnum = (typeof RankcacheScalarFieldEnum)[keyof typeof RankcacheScalarFieldEnum]


  export const RejudgingScalarFieldEnum: {
    rejudgingid: 'rejudgingid',
    userid_start: 'userid_start',
    userid_finish: 'userid_finish',
    starttime: 'starttime',
    endtime: 'endtime',
    reason: 'reason',
    valid: 'valid',
    auto_apply: 'auto_apply',
    repeat: 'repeat',
    repeat_rejudgingid: 'repeat_rejudgingid'
  };

  export type RejudgingScalarFieldEnum = (typeof RejudgingScalarFieldEnum)[keyof typeof RejudgingScalarFieldEnum]


  export const Removed_intervalScalarFieldEnum: {
    intervalid: 'intervalid',
    cid: 'cid',
    starttime: 'starttime',
    endtime: 'endtime',
    starttime_string: 'starttime_string',
    endtime_string: 'endtime_string'
  };

  export type Removed_intervalScalarFieldEnum = (typeof Removed_intervalScalarFieldEnum)[keyof typeof Removed_intervalScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    roleid: 'roleid',
    role: 'role',
    description: 'description'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const ScorecacheScalarFieldEnum: {
    cid: 'cid',
    teamid: 'teamid',
    probid: 'probid',
    submissions_restricted: 'submissions_restricted',
    pending_restricted: 'pending_restricted',
    solvetime_restricted: 'solvetime_restricted',
    is_correct_restricted: 'is_correct_restricted',
    submissions_public: 'submissions_public',
    pending_public: 'pending_public',
    solvetime_public: 'solvetime_public',
    is_correct_public: 'is_correct_public',
    is_first_to_solve: 'is_first_to_solve'
  };

  export type ScorecacheScalarFieldEnum = (typeof ScorecacheScalarFieldEnum)[keyof typeof ScorecacheScalarFieldEnum]


  export const SessionsScalarFieldEnum: {
    sess_id: 'sess_id',
    sess_data: 'sess_data',
    sess_lifetime: 'sess_lifetime',
    sess_time: 'sess_time'
  };

  export type SessionsScalarFieldEnum = (typeof SessionsScalarFieldEnum)[keyof typeof SessionsScalarFieldEnum]


  export const SubmissionScalarFieldEnum: {
    submitid: 'submitid',
    origsubmitid: 'origsubmitid',
    cid: 'cid',
    teamid: 'teamid',
    userid: 'userid',
    probid: 'probid',
    langid: 'langid',
    submittime: 'submittime',
    valid: 'valid',
    rejudgingid: 'rejudgingid',
    expected_results: 'expected_results',
    externalid: 'externalid',
    entry_point: 'entry_point'
  };

  export type SubmissionScalarFieldEnum = (typeof SubmissionScalarFieldEnum)[keyof typeof SubmissionScalarFieldEnum]


  export const Submission_fileScalarFieldEnum: {
    submitfileid: 'submitfileid',
    submitid: 'submitid',
    sourcecode: 'sourcecode',
    filename: 'filename',
    ranknumber: 'ranknumber'
  };

  export type Submission_fileScalarFieldEnum = (typeof Submission_fileScalarFieldEnum)[keyof typeof Submission_fileScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    teamid: 'teamid',
    externalid: 'externalid',
    icpcid: 'icpcid',
    name: 'name',
    display_name: 'display_name',
    categoryid: 'categoryid',
    affilid: 'affilid',
    enabled: 'enabled',
    publicdescription: 'publicdescription',
    room: 'room',
    internalcomments: 'internalcomments',
    judging_last_started: 'judging_last_started',
    penalty: 'penalty'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const Team_affiliationScalarFieldEnum: {
    affilid: 'affilid',
    externalid: 'externalid',
    icpcid: 'icpcid',
    shortname: 'shortname',
    name: 'name',
    country: 'country',
    internalcomments: 'internalcomments'
  };

  export type Team_affiliationScalarFieldEnum = (typeof Team_affiliationScalarFieldEnum)[keyof typeof Team_affiliationScalarFieldEnum]


  export const Team_categoryScalarFieldEnum: {
    categoryid: 'categoryid',
    externalid: 'externalid',
    icpcid: 'icpcid',
    name: 'name',
    sortorder: 'sortorder',
    color: 'color',
    visible: 'visible',
    allow_self_registration: 'allow_self_registration'
  };

  export type Team_categoryScalarFieldEnum = (typeof Team_categoryScalarFieldEnum)[keyof typeof Team_categoryScalarFieldEnum]


  export const Team_unreadScalarFieldEnum: {
    teamid: 'teamid',
    mesgid: 'mesgid'
  };

  export type Team_unreadScalarFieldEnum = (typeof Team_unreadScalarFieldEnum)[keyof typeof Team_unreadScalarFieldEnum]


  export const TestcaseScalarFieldEnum: {
    testcaseid: 'testcaseid',
    md5sum_input: 'md5sum_input',
    md5sum_output: 'md5sum_output',
    probid: 'probid',
    ranknumber: 'ranknumber',
    description: 'description',
    image_type: 'image_type',
    sample: 'sample',
    orig_input_filename: 'orig_input_filename',
    deleted: 'deleted'
  };

  export type TestcaseScalarFieldEnum = (typeof TestcaseScalarFieldEnum)[keyof typeof TestcaseScalarFieldEnum]


  export const Testcase_contentScalarFieldEnum: {
    testcaseid: 'testcaseid',
    input: 'input',
    output: 'output',
    image: 'image',
    image_thumb: 'image_thumb',
    tc_contentid: 'tc_contentid'
  };

  export type Testcase_contentScalarFieldEnum = (typeof Testcase_contentScalarFieldEnum)[keyof typeof Testcase_contentScalarFieldEnum]


  export const UserScalarFieldEnum: {
    userid: 'userid',
    externalid: 'externalid',
    username: 'username',
    name: 'name',
    email: 'email',
    last_login: 'last_login',
    last_api_login: 'last_api_login',
    first_login: 'first_login',
    last_ip_address: 'last_ip_address',
    password: 'password',
    ip_address: 'ip_address',
    enabled: 'enabled',
    teamid: 'teamid'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserroleScalarFieldEnum: {
    userid: 'userid',
    roleid: 'roleid'
  };

  export type UserroleScalarFieldEnum = (typeof UserroleScalarFieldEnum)[keyof typeof UserroleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'internal_error_status'
   */
  export type Enuminternal_error_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'internal_error_status'>
    


  /**
   * Reference to a field of type 'judgetask_type'
   */
  export type Enumjudgetask_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'judgetask_type'>
    
  /**
   * Deep Input Types
   */


  export type auditlogWhereInput = {
    AND?: auditlogWhereInput | auditlogWhereInput[]
    OR?: auditlogWhereInput[]
    NOT?: auditlogWhereInput | auditlogWhereInput[]
    logid?: IntFilter<"auditlog"> | number
    logtime?: DecimalFilter<"auditlog"> | Decimal | DecimalJsLike | number | string
    cid?: IntNullableFilter<"auditlog"> | number | null
    user?: StringNullableFilter<"auditlog"> | string | null
    datatype?: StringFilter<"auditlog"> | string
    dataid?: StringNullableFilter<"auditlog"> | string | null
    action?: StringFilter<"auditlog"> | string
    extrainfo?: StringNullableFilter<"auditlog"> | string | null
  }

  export type auditlogOrderByWithRelationInput = {
    logid?: SortOrder
    logtime?: SortOrder
    cid?: SortOrderInput | SortOrder
    user?: SortOrderInput | SortOrder
    datatype?: SortOrder
    dataid?: SortOrderInput | SortOrder
    action?: SortOrder
    extrainfo?: SortOrderInput | SortOrder
  }

  export type auditlogWhereUniqueInput = Prisma.AtLeast<{
    logid?: number
    AND?: auditlogWhereInput | auditlogWhereInput[]
    OR?: auditlogWhereInput[]
    NOT?: auditlogWhereInput | auditlogWhereInput[]
    logtime?: DecimalFilter<"auditlog"> | Decimal | DecimalJsLike | number | string
    cid?: IntNullableFilter<"auditlog"> | number | null
    user?: StringNullableFilter<"auditlog"> | string | null
    datatype?: StringFilter<"auditlog"> | string
    dataid?: StringNullableFilter<"auditlog"> | string | null
    action?: StringFilter<"auditlog"> | string
    extrainfo?: StringNullableFilter<"auditlog"> | string | null
  }, "logid">

  export type auditlogOrderByWithAggregationInput = {
    logid?: SortOrder
    logtime?: SortOrder
    cid?: SortOrderInput | SortOrder
    user?: SortOrderInput | SortOrder
    datatype?: SortOrder
    dataid?: SortOrderInput | SortOrder
    action?: SortOrder
    extrainfo?: SortOrderInput | SortOrder
    _count?: auditlogCountOrderByAggregateInput
    _avg?: auditlogAvgOrderByAggregateInput
    _max?: auditlogMaxOrderByAggregateInput
    _min?: auditlogMinOrderByAggregateInput
    _sum?: auditlogSumOrderByAggregateInput
  }

  export type auditlogScalarWhereWithAggregatesInput = {
    AND?: auditlogScalarWhereWithAggregatesInput | auditlogScalarWhereWithAggregatesInput[]
    OR?: auditlogScalarWhereWithAggregatesInput[]
    NOT?: auditlogScalarWhereWithAggregatesInput | auditlogScalarWhereWithAggregatesInput[]
    logid?: IntWithAggregatesFilter<"auditlog"> | number
    logtime?: DecimalWithAggregatesFilter<"auditlog"> | Decimal | DecimalJsLike | number | string
    cid?: IntNullableWithAggregatesFilter<"auditlog"> | number | null
    user?: StringNullableWithAggregatesFilter<"auditlog"> | string | null
    datatype?: StringWithAggregatesFilter<"auditlog"> | string
    dataid?: StringNullableWithAggregatesFilter<"auditlog"> | string | null
    action?: StringWithAggregatesFilter<"auditlog"> | string
    extrainfo?: StringNullableWithAggregatesFilter<"auditlog"> | string | null
  }

  export type balloonWhereInput = {
    AND?: balloonWhereInput | balloonWhereInput[]
    OR?: balloonWhereInput[]
    NOT?: balloonWhereInput | balloonWhereInput[]
    balloonid?: IntFilter<"balloon"> | number
    submitid?: IntNullableFilter<"balloon"> | number | null
    done?: BoolFilter<"balloon"> | boolean
    submission?: XOR<SubmissionNullableRelationFilter, submissionWhereInput> | null
  }

  export type balloonOrderByWithRelationInput = {
    balloonid?: SortOrder
    submitid?: SortOrderInput | SortOrder
    done?: SortOrder
    submission?: submissionOrderByWithRelationInput
  }

  export type balloonWhereUniqueInput = Prisma.AtLeast<{
    balloonid?: number
    AND?: balloonWhereInput | balloonWhereInput[]
    OR?: balloonWhereInput[]
    NOT?: balloonWhereInput | balloonWhereInput[]
    submitid?: IntNullableFilter<"balloon"> | number | null
    done?: BoolFilter<"balloon"> | boolean
    submission?: XOR<SubmissionNullableRelationFilter, submissionWhereInput> | null
  }, "balloonid">

  export type balloonOrderByWithAggregationInput = {
    balloonid?: SortOrder
    submitid?: SortOrderInput | SortOrder
    done?: SortOrder
    _count?: balloonCountOrderByAggregateInput
    _avg?: balloonAvgOrderByAggregateInput
    _max?: balloonMaxOrderByAggregateInput
    _min?: balloonMinOrderByAggregateInput
    _sum?: balloonSumOrderByAggregateInput
  }

  export type balloonScalarWhereWithAggregatesInput = {
    AND?: balloonScalarWhereWithAggregatesInput | balloonScalarWhereWithAggregatesInput[]
    OR?: balloonScalarWhereWithAggregatesInput[]
    NOT?: balloonScalarWhereWithAggregatesInput | balloonScalarWhereWithAggregatesInput[]
    balloonid?: IntWithAggregatesFilter<"balloon"> | number
    submitid?: IntNullableWithAggregatesFilter<"balloon"> | number | null
    done?: BoolWithAggregatesFilter<"balloon"> | boolean
  }

  export type clarificationWhereInput = {
    AND?: clarificationWhereInput | clarificationWhereInput[]
    OR?: clarificationWhereInput[]
    NOT?: clarificationWhereInput | clarificationWhereInput[]
    clarid?: IntFilter<"clarification"> | number
    externalid?: StringNullableFilter<"clarification"> | string | null
    cid?: IntNullableFilter<"clarification"> | number | null
    respid?: IntNullableFilter<"clarification"> | number | null
    submittime?: DecimalFilter<"clarification"> | Decimal | DecimalJsLike | number | string
    sender?: IntNullableFilter<"clarification"> | number | null
    recipient?: IntNullableFilter<"clarification"> | number | null
    jury_member?: StringNullableFilter<"clarification"> | string | null
    probid?: IntNullableFilter<"clarification"> | number | null
    category?: StringNullableFilter<"clarification"> | string | null
    queue?: StringNullableFilter<"clarification"> | string | null
    body?: StringFilter<"clarification"> | string
    answered?: BoolFilter<"clarification"> | boolean
    contest?: XOR<ContestNullableRelationFilter, contestWhereInput> | null
    clarification?: XOR<ClarificationNullableRelationFilter, clarificationWhereInput> | null
    other_clarification?: ClarificationListRelationFilter
    problem?: XOR<ProblemNullableRelationFilter, problemWhereInput> | null
    team_clarification_senderToteam?: XOR<TeamNullableRelationFilter, teamWhereInput> | null
    team_clarification_recipientToteam?: XOR<TeamNullableRelationFilter, teamWhereInput> | null
    team_unread?: Team_unreadListRelationFilter
  }

  export type clarificationOrderByWithRelationInput = {
    clarid?: SortOrder
    externalid?: SortOrderInput | SortOrder
    cid?: SortOrderInput | SortOrder
    respid?: SortOrderInput | SortOrder
    submittime?: SortOrder
    sender?: SortOrderInput | SortOrder
    recipient?: SortOrderInput | SortOrder
    jury_member?: SortOrderInput | SortOrder
    probid?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    queue?: SortOrderInput | SortOrder
    body?: SortOrder
    answered?: SortOrder
    contest?: contestOrderByWithRelationInput
    clarification?: clarificationOrderByWithRelationInput
    other_clarification?: clarificationOrderByRelationAggregateInput
    problem?: problemOrderByWithRelationInput
    team_clarification_senderToteam?: teamOrderByWithRelationInput
    team_clarification_recipientToteam?: teamOrderByWithRelationInput
    team_unread?: team_unreadOrderByRelationAggregateInput
  }

  export type clarificationWhereUniqueInput = Prisma.AtLeast<{
    clarid?: number
    cid_externalid?: clarificationCidExternalidCompoundUniqueInput
    AND?: clarificationWhereInput | clarificationWhereInput[]
    OR?: clarificationWhereInput[]
    NOT?: clarificationWhereInput | clarificationWhereInput[]
    externalid?: StringNullableFilter<"clarification"> | string | null
    cid?: IntNullableFilter<"clarification"> | number | null
    respid?: IntNullableFilter<"clarification"> | number | null
    submittime?: DecimalFilter<"clarification"> | Decimal | DecimalJsLike | number | string
    sender?: IntNullableFilter<"clarification"> | number | null
    recipient?: IntNullableFilter<"clarification"> | number | null
    jury_member?: StringNullableFilter<"clarification"> | string | null
    probid?: IntNullableFilter<"clarification"> | number | null
    category?: StringNullableFilter<"clarification"> | string | null
    queue?: StringNullableFilter<"clarification"> | string | null
    body?: StringFilter<"clarification"> | string
    answered?: BoolFilter<"clarification"> | boolean
    contest?: XOR<ContestNullableRelationFilter, contestWhereInput> | null
    clarification?: XOR<ClarificationNullableRelationFilter, clarificationWhereInput> | null
    other_clarification?: ClarificationListRelationFilter
    problem?: XOR<ProblemNullableRelationFilter, problemWhereInput> | null
    team_clarification_senderToteam?: XOR<TeamNullableRelationFilter, teamWhereInput> | null
    team_clarification_recipientToteam?: XOR<TeamNullableRelationFilter, teamWhereInput> | null
    team_unread?: Team_unreadListRelationFilter
  }, "clarid" | "cid_externalid">

  export type clarificationOrderByWithAggregationInput = {
    clarid?: SortOrder
    externalid?: SortOrderInput | SortOrder
    cid?: SortOrderInput | SortOrder
    respid?: SortOrderInput | SortOrder
    submittime?: SortOrder
    sender?: SortOrderInput | SortOrder
    recipient?: SortOrderInput | SortOrder
    jury_member?: SortOrderInput | SortOrder
    probid?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    queue?: SortOrderInput | SortOrder
    body?: SortOrder
    answered?: SortOrder
    _count?: clarificationCountOrderByAggregateInput
    _avg?: clarificationAvgOrderByAggregateInput
    _max?: clarificationMaxOrderByAggregateInput
    _min?: clarificationMinOrderByAggregateInput
    _sum?: clarificationSumOrderByAggregateInput
  }

  export type clarificationScalarWhereWithAggregatesInput = {
    AND?: clarificationScalarWhereWithAggregatesInput | clarificationScalarWhereWithAggregatesInput[]
    OR?: clarificationScalarWhereWithAggregatesInput[]
    NOT?: clarificationScalarWhereWithAggregatesInput | clarificationScalarWhereWithAggregatesInput[]
    clarid?: IntWithAggregatesFilter<"clarification"> | number
    externalid?: StringNullableWithAggregatesFilter<"clarification"> | string | null
    cid?: IntNullableWithAggregatesFilter<"clarification"> | number | null
    respid?: IntNullableWithAggregatesFilter<"clarification"> | number | null
    submittime?: DecimalWithAggregatesFilter<"clarification"> | Decimal | DecimalJsLike | number | string
    sender?: IntNullableWithAggregatesFilter<"clarification"> | number | null
    recipient?: IntNullableWithAggregatesFilter<"clarification"> | number | null
    jury_member?: StringNullableWithAggregatesFilter<"clarification"> | string | null
    probid?: IntNullableWithAggregatesFilter<"clarification"> | number | null
    category?: StringNullableWithAggregatesFilter<"clarification"> | string | null
    queue?: StringNullableWithAggregatesFilter<"clarification"> | string | null
    body?: StringWithAggregatesFilter<"clarification"> | string
    answered?: BoolWithAggregatesFilter<"clarification"> | boolean
  }

  export type configurationWhereInput = {
    AND?: configurationWhereInput | configurationWhereInput[]
    OR?: configurationWhereInput[]
    NOT?: configurationWhereInput | configurationWhereInput[]
    configid?: IntFilter<"configuration"> | number
    name?: StringFilter<"configuration"> | string
    value?: StringFilter<"configuration"> | string
  }

  export type configurationOrderByWithRelationInput = {
    configid?: SortOrder
    name?: SortOrder
    value?: SortOrder
  }

  export type configurationWhereUniqueInput = Prisma.AtLeast<{
    configid?: number
    name?: string
    AND?: configurationWhereInput | configurationWhereInput[]
    OR?: configurationWhereInput[]
    NOT?: configurationWhereInput | configurationWhereInput[]
    value?: StringFilter<"configuration"> | string
  }, "configid" | "name">

  export type configurationOrderByWithAggregationInput = {
    configid?: SortOrder
    name?: SortOrder
    value?: SortOrder
    _count?: configurationCountOrderByAggregateInput
    _avg?: configurationAvgOrderByAggregateInput
    _max?: configurationMaxOrderByAggregateInput
    _min?: configurationMinOrderByAggregateInput
    _sum?: configurationSumOrderByAggregateInput
  }

  export type configurationScalarWhereWithAggregatesInput = {
    AND?: configurationScalarWhereWithAggregatesInput | configurationScalarWhereWithAggregatesInput[]
    OR?: configurationScalarWhereWithAggregatesInput[]
    NOT?: configurationScalarWhereWithAggregatesInput | configurationScalarWhereWithAggregatesInput[]
    configid?: IntWithAggregatesFilter<"configuration"> | number
    name?: StringWithAggregatesFilter<"configuration"> | string
    value?: StringWithAggregatesFilter<"configuration"> | string
  }

  export type contestWhereInput = {
    AND?: contestWhereInput | contestWhereInput[]
    OR?: contestWhereInput[]
    NOT?: contestWhereInput | contestWhereInput[]
    cid?: IntFilter<"contest"> | number
    externalid?: StringNullableFilter<"contest"> | string | null
    name?: StringFilter<"contest"> | string
    shortname?: StringFilter<"contest"> | string
    activatetime?: DecimalFilter<"contest"> | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFilter<"contest"> | Decimal | DecimalJsLike | number | string
    freezetime?: DecimalNullableFilter<"contest"> | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFilter<"contest"> | Decimal | DecimalJsLike | number | string
    unfreezetime?: DecimalNullableFilter<"contest"> | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: DecimalNullableFilter<"contest"> | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFilter<"contest"> | string
    starttime_string?: StringFilter<"contest"> | string
    freezetime_string?: StringNullableFilter<"contest"> | string | null
    endtime_string?: StringFilter<"contest"> | string
    unfreezetime_string?: StringNullableFilter<"contest"> | string | null
    deactivatetime_string?: StringNullableFilter<"contest"> | string | null
    finalizetime?: DecimalNullableFilter<"contest"> | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: StringNullableFilter<"contest"> | string | null
    b?: IntFilter<"contest"> | number
    enabled?: BoolFilter<"contest"> | boolean
    starttime_enabled?: BoolFilter<"contest"> | boolean
    process_balloons?: BoolFilter<"contest"> | boolean
    public?: BoolFilter<"contest"> | boolean
    open_to_all_teams?: BoolFilter<"contest"> | boolean
    medals_enabled?: BoolFilter<"contest"> | boolean
    gold_medals?: IntFilter<"contest"> | number
    silver_medals?: IntFilter<"contest"> | number
    bronze_medals?: IntFilter<"contest"> | number
    is_locked?: BoolFilter<"contest"> | boolean
    allow_submit?: BoolFilter<"contest"> | boolean
    warning_message?: StringNullableFilter<"contest"> | string | null
    clarification?: ClarificationListRelationFilter
    contestproblem?: ContestproblemListRelationFilter
    contestteam?: ContestteamListRelationFilter
    contestteamcategory?: ContestteamcategoryListRelationFilter
    contestteamcategoryformedals?: ContestteamcategoryformedalsListRelationFilter
    event?: EventListRelationFilter
    external_contest_source?: XOR<External_contest_sourceNullableRelationFilter, external_contest_sourceWhereInput> | null
    external_judgement?: External_judgementListRelationFilter
    external_run?: External_runListRelationFilter
    internal_error?: Internal_errorListRelationFilter
    judging?: JudgingListRelationFilter
    rankcache?: RankcacheListRelationFilter
    removed_interval?: Removed_intervalListRelationFilter
    scorecache?: ScorecacheListRelationFilter
    submission?: SubmissionListRelationFilter
  }

  export type contestOrderByWithRelationInput = {
    cid?: SortOrder
    externalid?: SortOrderInput | SortOrder
    name?: SortOrder
    shortname?: SortOrder
    activatetime?: SortOrder
    starttime?: SortOrder
    freezetime?: SortOrderInput | SortOrder
    endtime?: SortOrder
    unfreezetime?: SortOrderInput | SortOrder
    deactivatetime?: SortOrderInput | SortOrder
    activatetime_string?: SortOrder
    starttime_string?: SortOrder
    freezetime_string?: SortOrderInput | SortOrder
    endtime_string?: SortOrder
    unfreezetime_string?: SortOrderInput | SortOrder
    deactivatetime_string?: SortOrderInput | SortOrder
    finalizetime?: SortOrderInput | SortOrder
    finalizecomment?: SortOrderInput | SortOrder
    b?: SortOrder
    enabled?: SortOrder
    starttime_enabled?: SortOrder
    process_balloons?: SortOrder
    public?: SortOrder
    open_to_all_teams?: SortOrder
    medals_enabled?: SortOrder
    gold_medals?: SortOrder
    silver_medals?: SortOrder
    bronze_medals?: SortOrder
    is_locked?: SortOrder
    allow_submit?: SortOrder
    warning_message?: SortOrderInput | SortOrder
    clarification?: clarificationOrderByRelationAggregateInput
    contestproblem?: contestproblemOrderByRelationAggregateInput
    contestteam?: contestteamOrderByRelationAggregateInput
    contestteamcategory?: contestteamcategoryOrderByRelationAggregateInput
    contestteamcategoryformedals?: contestteamcategoryformedalsOrderByRelationAggregateInput
    event?: eventOrderByRelationAggregateInput
    external_contest_source?: external_contest_sourceOrderByWithRelationInput
    external_judgement?: external_judgementOrderByRelationAggregateInput
    external_run?: external_runOrderByRelationAggregateInput
    internal_error?: internal_errorOrderByRelationAggregateInput
    judging?: judgingOrderByRelationAggregateInput
    rankcache?: rankcacheOrderByRelationAggregateInput
    removed_interval?: removed_intervalOrderByRelationAggregateInput
    scorecache?: scorecacheOrderByRelationAggregateInput
    submission?: submissionOrderByRelationAggregateInput
  }

  export type contestWhereUniqueInput = Prisma.AtLeast<{
    cid?: number
    externalid?: string
    shortname?: string
    AND?: contestWhereInput | contestWhereInput[]
    OR?: contestWhereInput[]
    NOT?: contestWhereInput | contestWhereInput[]
    name?: StringFilter<"contest"> | string
    activatetime?: DecimalFilter<"contest"> | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFilter<"contest"> | Decimal | DecimalJsLike | number | string
    freezetime?: DecimalNullableFilter<"contest"> | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFilter<"contest"> | Decimal | DecimalJsLike | number | string
    unfreezetime?: DecimalNullableFilter<"contest"> | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: DecimalNullableFilter<"contest"> | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFilter<"contest"> | string
    starttime_string?: StringFilter<"contest"> | string
    freezetime_string?: StringNullableFilter<"contest"> | string | null
    endtime_string?: StringFilter<"contest"> | string
    unfreezetime_string?: StringNullableFilter<"contest"> | string | null
    deactivatetime_string?: StringNullableFilter<"contest"> | string | null
    finalizetime?: DecimalNullableFilter<"contest"> | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: StringNullableFilter<"contest"> | string | null
    b?: IntFilter<"contest"> | number
    enabled?: BoolFilter<"contest"> | boolean
    starttime_enabled?: BoolFilter<"contest"> | boolean
    process_balloons?: BoolFilter<"contest"> | boolean
    public?: BoolFilter<"contest"> | boolean
    open_to_all_teams?: BoolFilter<"contest"> | boolean
    medals_enabled?: BoolFilter<"contest"> | boolean
    gold_medals?: IntFilter<"contest"> | number
    silver_medals?: IntFilter<"contest"> | number
    bronze_medals?: IntFilter<"contest"> | number
    is_locked?: BoolFilter<"contest"> | boolean
    allow_submit?: BoolFilter<"contest"> | boolean
    warning_message?: StringNullableFilter<"contest"> | string | null
    clarification?: ClarificationListRelationFilter
    contestproblem?: ContestproblemListRelationFilter
    contestteam?: ContestteamListRelationFilter
    contestteamcategory?: ContestteamcategoryListRelationFilter
    contestteamcategoryformedals?: ContestteamcategoryformedalsListRelationFilter
    event?: EventListRelationFilter
    external_contest_source?: XOR<External_contest_sourceNullableRelationFilter, external_contest_sourceWhereInput> | null
    external_judgement?: External_judgementListRelationFilter
    external_run?: External_runListRelationFilter
    internal_error?: Internal_errorListRelationFilter
    judging?: JudgingListRelationFilter
    rankcache?: RankcacheListRelationFilter
    removed_interval?: Removed_intervalListRelationFilter
    scorecache?: ScorecacheListRelationFilter
    submission?: SubmissionListRelationFilter
  }, "cid" | "externalid" | "shortname">

  export type contestOrderByWithAggregationInput = {
    cid?: SortOrder
    externalid?: SortOrderInput | SortOrder
    name?: SortOrder
    shortname?: SortOrder
    activatetime?: SortOrder
    starttime?: SortOrder
    freezetime?: SortOrderInput | SortOrder
    endtime?: SortOrder
    unfreezetime?: SortOrderInput | SortOrder
    deactivatetime?: SortOrderInput | SortOrder
    activatetime_string?: SortOrder
    starttime_string?: SortOrder
    freezetime_string?: SortOrderInput | SortOrder
    endtime_string?: SortOrder
    unfreezetime_string?: SortOrderInput | SortOrder
    deactivatetime_string?: SortOrderInput | SortOrder
    finalizetime?: SortOrderInput | SortOrder
    finalizecomment?: SortOrderInput | SortOrder
    b?: SortOrder
    enabled?: SortOrder
    starttime_enabled?: SortOrder
    process_balloons?: SortOrder
    public?: SortOrder
    open_to_all_teams?: SortOrder
    medals_enabled?: SortOrder
    gold_medals?: SortOrder
    silver_medals?: SortOrder
    bronze_medals?: SortOrder
    is_locked?: SortOrder
    allow_submit?: SortOrder
    warning_message?: SortOrderInput | SortOrder
    _count?: contestCountOrderByAggregateInput
    _avg?: contestAvgOrderByAggregateInput
    _max?: contestMaxOrderByAggregateInput
    _min?: contestMinOrderByAggregateInput
    _sum?: contestSumOrderByAggregateInput
  }

  export type contestScalarWhereWithAggregatesInput = {
    AND?: contestScalarWhereWithAggregatesInput | contestScalarWhereWithAggregatesInput[]
    OR?: contestScalarWhereWithAggregatesInput[]
    NOT?: contestScalarWhereWithAggregatesInput | contestScalarWhereWithAggregatesInput[]
    cid?: IntWithAggregatesFilter<"contest"> | number
    externalid?: StringNullableWithAggregatesFilter<"contest"> | string | null
    name?: StringWithAggregatesFilter<"contest"> | string
    shortname?: StringWithAggregatesFilter<"contest"> | string
    activatetime?: DecimalWithAggregatesFilter<"contest"> | Decimal | DecimalJsLike | number | string
    starttime?: DecimalWithAggregatesFilter<"contest"> | Decimal | DecimalJsLike | number | string
    freezetime?: DecimalNullableWithAggregatesFilter<"contest"> | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalWithAggregatesFilter<"contest"> | Decimal | DecimalJsLike | number | string
    unfreezetime?: DecimalNullableWithAggregatesFilter<"contest"> | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: DecimalNullableWithAggregatesFilter<"contest"> | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringWithAggregatesFilter<"contest"> | string
    starttime_string?: StringWithAggregatesFilter<"contest"> | string
    freezetime_string?: StringNullableWithAggregatesFilter<"contest"> | string | null
    endtime_string?: StringWithAggregatesFilter<"contest"> | string
    unfreezetime_string?: StringNullableWithAggregatesFilter<"contest"> | string | null
    deactivatetime_string?: StringNullableWithAggregatesFilter<"contest"> | string | null
    finalizetime?: DecimalNullableWithAggregatesFilter<"contest"> | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: StringNullableWithAggregatesFilter<"contest"> | string | null
    b?: IntWithAggregatesFilter<"contest"> | number
    enabled?: BoolWithAggregatesFilter<"contest"> | boolean
    starttime_enabled?: BoolWithAggregatesFilter<"contest"> | boolean
    process_balloons?: BoolWithAggregatesFilter<"contest"> | boolean
    public?: BoolWithAggregatesFilter<"contest"> | boolean
    open_to_all_teams?: BoolWithAggregatesFilter<"contest"> | boolean
    medals_enabled?: BoolWithAggregatesFilter<"contest"> | boolean
    gold_medals?: IntWithAggregatesFilter<"contest"> | number
    silver_medals?: IntWithAggregatesFilter<"contest"> | number
    bronze_medals?: IntWithAggregatesFilter<"contest"> | number
    is_locked?: BoolWithAggregatesFilter<"contest"> | boolean
    allow_submit?: BoolWithAggregatesFilter<"contest"> | boolean
    warning_message?: StringNullableWithAggregatesFilter<"contest"> | string | null
  }

  export type contestproblemWhereInput = {
    AND?: contestproblemWhereInput | contestproblemWhereInput[]
    OR?: contestproblemWhereInput[]
    NOT?: contestproblemWhereInput | contestproblemWhereInput[]
    cid?: IntFilter<"contestproblem"> | number
    probid?: IntFilter<"contestproblem"> | number
    shortname?: StringFilter<"contestproblem"> | string
    points?: IntFilter<"contestproblem"> | number
    allow_submit?: BoolFilter<"contestproblem"> | boolean
    allow_judge?: BoolFilter<"contestproblem"> | boolean
    color?: StringNullableFilter<"contestproblem"> | string | null
    lazy_eval_results?: IntNullableFilter<"contestproblem"> | number | null
    contest?: XOR<ContestRelationFilter, contestWhereInput>
    problem?: XOR<ProblemRelationFilter, problemWhereInput>
    submission?: SubmissionListRelationFilter
  }

  export type contestproblemOrderByWithRelationInput = {
    cid?: SortOrder
    probid?: SortOrder
    shortname?: SortOrder
    points?: SortOrder
    allow_submit?: SortOrder
    allow_judge?: SortOrder
    color?: SortOrderInput | SortOrder
    lazy_eval_results?: SortOrderInput | SortOrder
    contest?: contestOrderByWithRelationInput
    problem?: problemOrderByWithRelationInput
    submission?: submissionOrderByRelationAggregateInput
  }

  export type contestproblemWhereUniqueInput = Prisma.AtLeast<{
    cid_shortname?: contestproblemCidShortnameCompoundUniqueInput
    cid_probid?: contestproblemCidProbidCompoundUniqueInput
    AND?: contestproblemWhereInput | contestproblemWhereInput[]
    OR?: contestproblemWhereInput[]
    NOT?: contestproblemWhereInput | contestproblemWhereInput[]
    cid?: IntFilter<"contestproblem"> | number
    probid?: IntFilter<"contestproblem"> | number
    shortname?: StringFilter<"contestproblem"> | string
    points?: IntFilter<"contestproblem"> | number
    allow_submit?: BoolFilter<"contestproblem"> | boolean
    allow_judge?: BoolFilter<"contestproblem"> | boolean
    color?: StringNullableFilter<"contestproblem"> | string | null
    lazy_eval_results?: IntNullableFilter<"contestproblem"> | number | null
    contest?: XOR<ContestRelationFilter, contestWhereInput>
    problem?: XOR<ProblemRelationFilter, problemWhereInput>
    submission?: SubmissionListRelationFilter
  }, "cid_probid" | "cid_shortname">

  export type contestproblemOrderByWithAggregationInput = {
    cid?: SortOrder
    probid?: SortOrder
    shortname?: SortOrder
    points?: SortOrder
    allow_submit?: SortOrder
    allow_judge?: SortOrder
    color?: SortOrderInput | SortOrder
    lazy_eval_results?: SortOrderInput | SortOrder
    _count?: contestproblemCountOrderByAggregateInput
    _avg?: contestproblemAvgOrderByAggregateInput
    _max?: contestproblemMaxOrderByAggregateInput
    _min?: contestproblemMinOrderByAggregateInput
    _sum?: contestproblemSumOrderByAggregateInput
  }

  export type contestproblemScalarWhereWithAggregatesInput = {
    AND?: contestproblemScalarWhereWithAggregatesInput | contestproblemScalarWhereWithAggregatesInput[]
    OR?: contestproblemScalarWhereWithAggregatesInput[]
    NOT?: contestproblemScalarWhereWithAggregatesInput | contestproblemScalarWhereWithAggregatesInput[]
    cid?: IntWithAggregatesFilter<"contestproblem"> | number
    probid?: IntWithAggregatesFilter<"contestproblem"> | number
    shortname?: StringWithAggregatesFilter<"contestproblem"> | string
    points?: IntWithAggregatesFilter<"contestproblem"> | number
    allow_submit?: BoolWithAggregatesFilter<"contestproblem"> | boolean
    allow_judge?: BoolWithAggregatesFilter<"contestproblem"> | boolean
    color?: StringNullableWithAggregatesFilter<"contestproblem"> | string | null
    lazy_eval_results?: IntNullableWithAggregatesFilter<"contestproblem"> | number | null
  }

  export type contestteamWhereInput = {
    AND?: contestteamWhereInput | contestteamWhereInput[]
    OR?: contestteamWhereInput[]
    NOT?: contestteamWhereInput | contestteamWhereInput[]
    cid?: IntFilter<"contestteam"> | number
    teamid?: IntFilter<"contestteam"> | number
    contest?: XOR<ContestRelationFilter, contestWhereInput>
    team?: XOR<TeamRelationFilter, teamWhereInput>
  }

  export type contestteamOrderByWithRelationInput = {
    cid?: SortOrder
    teamid?: SortOrder
    contest?: contestOrderByWithRelationInput
    team?: teamOrderByWithRelationInput
  }

  export type contestteamWhereUniqueInput = Prisma.AtLeast<{
    cid_teamid?: contestteamCidTeamidCompoundUniqueInput
    AND?: contestteamWhereInput | contestteamWhereInput[]
    OR?: contestteamWhereInput[]
    NOT?: contestteamWhereInput | contestteamWhereInput[]
    cid?: IntFilter<"contestteam"> | number
    teamid?: IntFilter<"contestteam"> | number
    contest?: XOR<ContestRelationFilter, contestWhereInput>
    team?: XOR<TeamRelationFilter, teamWhereInput>
  }, "cid_teamid">

  export type contestteamOrderByWithAggregationInput = {
    cid?: SortOrder
    teamid?: SortOrder
    _count?: contestteamCountOrderByAggregateInput
    _avg?: contestteamAvgOrderByAggregateInput
    _max?: contestteamMaxOrderByAggregateInput
    _min?: contestteamMinOrderByAggregateInput
    _sum?: contestteamSumOrderByAggregateInput
  }

  export type contestteamScalarWhereWithAggregatesInput = {
    AND?: contestteamScalarWhereWithAggregatesInput | contestteamScalarWhereWithAggregatesInput[]
    OR?: contestteamScalarWhereWithAggregatesInput[]
    NOT?: contestteamScalarWhereWithAggregatesInput | contestteamScalarWhereWithAggregatesInput[]
    cid?: IntWithAggregatesFilter<"contestteam"> | number
    teamid?: IntWithAggregatesFilter<"contestteam"> | number
  }

  export type contestteamcategoryWhereInput = {
    AND?: contestteamcategoryWhereInput | contestteamcategoryWhereInput[]
    OR?: contestteamcategoryWhereInput[]
    NOT?: contestteamcategoryWhereInput | contestteamcategoryWhereInput[]
    cid?: IntFilter<"contestteamcategory"> | number
    categoryid?: IntFilter<"contestteamcategory"> | number
    contest?: XOR<ContestRelationFilter, contestWhereInput>
    team_category?: XOR<Team_categoryRelationFilter, team_categoryWhereInput>
  }

  export type contestteamcategoryOrderByWithRelationInput = {
    cid?: SortOrder
    categoryid?: SortOrder
    contest?: contestOrderByWithRelationInput
    team_category?: team_categoryOrderByWithRelationInput
  }

  export type contestteamcategoryWhereUniqueInput = Prisma.AtLeast<{
    cid_categoryid?: contestteamcategoryCidCategoryidCompoundUniqueInput
    AND?: contestteamcategoryWhereInput | contestteamcategoryWhereInput[]
    OR?: contestteamcategoryWhereInput[]
    NOT?: contestteamcategoryWhereInput | contestteamcategoryWhereInput[]
    cid?: IntFilter<"contestteamcategory"> | number
    categoryid?: IntFilter<"contestteamcategory"> | number
    contest?: XOR<ContestRelationFilter, contestWhereInput>
    team_category?: XOR<Team_categoryRelationFilter, team_categoryWhereInput>
  }, "cid_categoryid">

  export type contestteamcategoryOrderByWithAggregationInput = {
    cid?: SortOrder
    categoryid?: SortOrder
    _count?: contestteamcategoryCountOrderByAggregateInput
    _avg?: contestteamcategoryAvgOrderByAggregateInput
    _max?: contestteamcategoryMaxOrderByAggregateInput
    _min?: contestteamcategoryMinOrderByAggregateInput
    _sum?: contestteamcategorySumOrderByAggregateInput
  }

  export type contestteamcategoryScalarWhereWithAggregatesInput = {
    AND?: contestteamcategoryScalarWhereWithAggregatesInput | contestteamcategoryScalarWhereWithAggregatesInput[]
    OR?: contestteamcategoryScalarWhereWithAggregatesInput[]
    NOT?: contestteamcategoryScalarWhereWithAggregatesInput | contestteamcategoryScalarWhereWithAggregatesInput[]
    cid?: IntWithAggregatesFilter<"contestteamcategory"> | number
    categoryid?: IntWithAggregatesFilter<"contestteamcategory"> | number
  }

  export type contestteamcategoryformedalsWhereInput = {
    AND?: contestteamcategoryformedalsWhereInput | contestteamcategoryformedalsWhereInput[]
    OR?: contestteamcategoryformedalsWhereInput[]
    NOT?: contestteamcategoryformedalsWhereInput | contestteamcategoryformedalsWhereInput[]
    cid?: IntFilter<"contestteamcategoryformedals"> | number
    categoryid?: IntFilter<"contestteamcategoryformedals"> | number
    contest?: XOR<ContestRelationFilter, contestWhereInput>
    team_category?: XOR<Team_categoryRelationFilter, team_categoryWhereInput>
  }

  export type contestteamcategoryformedalsOrderByWithRelationInput = {
    cid?: SortOrder
    categoryid?: SortOrder
    contest?: contestOrderByWithRelationInput
    team_category?: team_categoryOrderByWithRelationInput
  }

  export type contestteamcategoryformedalsWhereUniqueInput = Prisma.AtLeast<{
    cid_categoryid?: contestteamcategoryformedalsCidCategoryidCompoundUniqueInput
    AND?: contestteamcategoryformedalsWhereInput | contestteamcategoryformedalsWhereInput[]
    OR?: contestteamcategoryformedalsWhereInput[]
    NOT?: contestteamcategoryformedalsWhereInput | contestteamcategoryformedalsWhereInput[]
    cid?: IntFilter<"contestteamcategoryformedals"> | number
    categoryid?: IntFilter<"contestteamcategoryformedals"> | number
    contest?: XOR<ContestRelationFilter, contestWhereInput>
    team_category?: XOR<Team_categoryRelationFilter, team_categoryWhereInput>
  }, "cid_categoryid">

  export type contestteamcategoryformedalsOrderByWithAggregationInput = {
    cid?: SortOrder
    categoryid?: SortOrder
    _count?: contestteamcategoryformedalsCountOrderByAggregateInput
    _avg?: contestteamcategoryformedalsAvgOrderByAggregateInput
    _max?: contestteamcategoryformedalsMaxOrderByAggregateInput
    _min?: contestteamcategoryformedalsMinOrderByAggregateInput
    _sum?: contestteamcategoryformedalsSumOrderByAggregateInput
  }

  export type contestteamcategoryformedalsScalarWhereWithAggregatesInput = {
    AND?: contestteamcategoryformedalsScalarWhereWithAggregatesInput | contestteamcategoryformedalsScalarWhereWithAggregatesInput[]
    OR?: contestteamcategoryformedalsScalarWhereWithAggregatesInput[]
    NOT?: contestteamcategoryformedalsScalarWhereWithAggregatesInput | contestteamcategoryformedalsScalarWhereWithAggregatesInput[]
    cid?: IntWithAggregatesFilter<"contestteamcategoryformedals"> | number
    categoryid?: IntWithAggregatesFilter<"contestteamcategoryformedals"> | number
  }

  export type debug_packageWhereInput = {
    AND?: debug_packageWhereInput | debug_packageWhereInput[]
    OR?: debug_packageWhereInput[]
    NOT?: debug_packageWhereInput | debug_packageWhereInput[]
    debug_package_id?: IntFilter<"debug_package"> | number
    judgingid?: IntNullableFilter<"debug_package"> | number | null
    judgehostid?: IntNullableFilter<"debug_package"> | number | null
    filename?: StringFilter<"debug_package"> | string
    judging?: XOR<JudgingNullableRelationFilter, judgingWhereInput> | null
    judgehost?: XOR<JudgehostNullableRelationFilter, judgehostWhereInput> | null
  }

  export type debug_packageOrderByWithRelationInput = {
    debug_package_id?: SortOrder
    judgingid?: SortOrderInput | SortOrder
    judgehostid?: SortOrderInput | SortOrder
    filename?: SortOrder
    judging?: judgingOrderByWithRelationInput
    judgehost?: judgehostOrderByWithRelationInput
  }

  export type debug_packageWhereUniqueInput = Prisma.AtLeast<{
    debug_package_id?: number
    AND?: debug_packageWhereInput | debug_packageWhereInput[]
    OR?: debug_packageWhereInput[]
    NOT?: debug_packageWhereInput | debug_packageWhereInput[]
    judgingid?: IntNullableFilter<"debug_package"> | number | null
    judgehostid?: IntNullableFilter<"debug_package"> | number | null
    filename?: StringFilter<"debug_package"> | string
    judging?: XOR<JudgingNullableRelationFilter, judgingWhereInput> | null
    judgehost?: XOR<JudgehostNullableRelationFilter, judgehostWhereInput> | null
  }, "debug_package_id">

  export type debug_packageOrderByWithAggregationInput = {
    debug_package_id?: SortOrder
    judgingid?: SortOrderInput | SortOrder
    judgehostid?: SortOrderInput | SortOrder
    filename?: SortOrder
    _count?: debug_packageCountOrderByAggregateInput
    _avg?: debug_packageAvgOrderByAggregateInput
    _max?: debug_packageMaxOrderByAggregateInput
    _min?: debug_packageMinOrderByAggregateInput
    _sum?: debug_packageSumOrderByAggregateInput
  }

  export type debug_packageScalarWhereWithAggregatesInput = {
    AND?: debug_packageScalarWhereWithAggregatesInput | debug_packageScalarWhereWithAggregatesInput[]
    OR?: debug_packageScalarWhereWithAggregatesInput[]
    NOT?: debug_packageScalarWhereWithAggregatesInput | debug_packageScalarWhereWithAggregatesInput[]
    debug_package_id?: IntWithAggregatesFilter<"debug_package"> | number
    judgingid?: IntNullableWithAggregatesFilter<"debug_package"> | number | null
    judgehostid?: IntNullableWithAggregatesFilter<"debug_package"> | number | null
    filename?: StringWithAggregatesFilter<"debug_package"> | string
  }

  export type doctrine_migration_versionsWhereInput = {
    AND?: doctrine_migration_versionsWhereInput | doctrine_migration_versionsWhereInput[]
    OR?: doctrine_migration_versionsWhereInput[]
    NOT?: doctrine_migration_versionsWhereInput | doctrine_migration_versionsWhereInput[]
    version?: StringFilter<"doctrine_migration_versions"> | string
    executed_at?: DateTimeNullableFilter<"doctrine_migration_versions"> | Date | string | null
    execution_time?: IntNullableFilter<"doctrine_migration_versions"> | number | null
  }

  export type doctrine_migration_versionsOrderByWithRelationInput = {
    version?: SortOrder
    executed_at?: SortOrderInput | SortOrder
    execution_time?: SortOrderInput | SortOrder
  }

  export type doctrine_migration_versionsWhereUniqueInput = Prisma.AtLeast<{
    version?: string
    AND?: doctrine_migration_versionsWhereInput | doctrine_migration_versionsWhereInput[]
    OR?: doctrine_migration_versionsWhereInput[]
    NOT?: doctrine_migration_versionsWhereInput | doctrine_migration_versionsWhereInput[]
    executed_at?: DateTimeNullableFilter<"doctrine_migration_versions"> | Date | string | null
    execution_time?: IntNullableFilter<"doctrine_migration_versions"> | number | null
  }, "version">

  export type doctrine_migration_versionsOrderByWithAggregationInput = {
    version?: SortOrder
    executed_at?: SortOrderInput | SortOrder
    execution_time?: SortOrderInput | SortOrder
    _count?: doctrine_migration_versionsCountOrderByAggregateInput
    _avg?: doctrine_migration_versionsAvgOrderByAggregateInput
    _max?: doctrine_migration_versionsMaxOrderByAggregateInput
    _min?: doctrine_migration_versionsMinOrderByAggregateInput
    _sum?: doctrine_migration_versionsSumOrderByAggregateInput
  }

  export type doctrine_migration_versionsScalarWhereWithAggregatesInput = {
    AND?: doctrine_migration_versionsScalarWhereWithAggregatesInput | doctrine_migration_versionsScalarWhereWithAggregatesInput[]
    OR?: doctrine_migration_versionsScalarWhereWithAggregatesInput[]
    NOT?: doctrine_migration_versionsScalarWhereWithAggregatesInput | doctrine_migration_versionsScalarWhereWithAggregatesInput[]
    version?: StringWithAggregatesFilter<"doctrine_migration_versions"> | string
    executed_at?: DateTimeNullableWithAggregatesFilter<"doctrine_migration_versions"> | Date | string | null
    execution_time?: IntNullableWithAggregatesFilter<"doctrine_migration_versions"> | number | null
  }

  export type eventWhereInput = {
    AND?: eventWhereInput | eventWhereInput[]
    OR?: eventWhereInput[]
    NOT?: eventWhereInput | eventWhereInput[]
    eventid?: IntFilter<"event"> | number
    eventtime?: DecimalFilter<"event"> | Decimal | DecimalJsLike | number | string
    cid?: IntNullableFilter<"event"> | number | null
    endpointtype?: StringFilter<"event"> | string
    endpointid?: StringFilter<"event"> | string
    action?: StringFilter<"event"> | string
    content?: BytesFilter<"event"> | Buffer
    contest?: XOR<ContestNullableRelationFilter, contestWhereInput> | null
  }

  export type eventOrderByWithRelationInput = {
    eventid?: SortOrder
    eventtime?: SortOrder
    cid?: SortOrderInput | SortOrder
    endpointtype?: SortOrder
    endpointid?: SortOrder
    action?: SortOrder
    content?: SortOrder
    contest?: contestOrderByWithRelationInput
  }

  export type eventWhereUniqueInput = Prisma.AtLeast<{
    eventid?: number
    AND?: eventWhereInput | eventWhereInput[]
    OR?: eventWhereInput[]
    NOT?: eventWhereInput | eventWhereInput[]
    eventtime?: DecimalFilter<"event"> | Decimal | DecimalJsLike | number | string
    cid?: IntNullableFilter<"event"> | number | null
    endpointtype?: StringFilter<"event"> | string
    endpointid?: StringFilter<"event"> | string
    action?: StringFilter<"event"> | string
    content?: BytesFilter<"event"> | Buffer
    contest?: XOR<ContestNullableRelationFilter, contestWhereInput> | null
  }, "eventid">

  export type eventOrderByWithAggregationInput = {
    eventid?: SortOrder
    eventtime?: SortOrder
    cid?: SortOrderInput | SortOrder
    endpointtype?: SortOrder
    endpointid?: SortOrder
    action?: SortOrder
    content?: SortOrder
    _count?: eventCountOrderByAggregateInput
    _avg?: eventAvgOrderByAggregateInput
    _max?: eventMaxOrderByAggregateInput
    _min?: eventMinOrderByAggregateInput
    _sum?: eventSumOrderByAggregateInput
  }

  export type eventScalarWhereWithAggregatesInput = {
    AND?: eventScalarWhereWithAggregatesInput | eventScalarWhereWithAggregatesInput[]
    OR?: eventScalarWhereWithAggregatesInput[]
    NOT?: eventScalarWhereWithAggregatesInput | eventScalarWhereWithAggregatesInput[]
    eventid?: IntWithAggregatesFilter<"event"> | number
    eventtime?: DecimalWithAggregatesFilter<"event"> | Decimal | DecimalJsLike | number | string
    cid?: IntNullableWithAggregatesFilter<"event"> | number | null
    endpointtype?: StringWithAggregatesFilter<"event"> | string
    endpointid?: StringWithAggregatesFilter<"event"> | string
    action?: StringWithAggregatesFilter<"event"> | string
    content?: BytesWithAggregatesFilter<"event"> | Buffer
  }

  export type executableWhereInput = {
    AND?: executableWhereInput | executableWhereInput[]
    OR?: executableWhereInput[]
    NOT?: executableWhereInput | executableWhereInput[]
    execid?: StringFilter<"executable"> | string
    description?: StringNullableFilter<"executable"> | string | null
    type?: StringFilter<"executable"> | string
    immutable_execid?: IntNullableFilter<"executable"> | number | null
    immutable_executable?: XOR<Immutable_executableNullableRelationFilter, immutable_executableWhereInput> | null
    language?: LanguageListRelationFilter
    problem_problem_special_runToexecutable?: ProblemListRelationFilter
    problem_problem_special_compareToexecutable?: ProblemListRelationFilter
  }

  export type executableOrderByWithRelationInput = {
    execid?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    immutable_execid?: SortOrderInput | SortOrder
    immutable_executable?: immutable_executableOrderByWithRelationInput
    language?: languageOrderByRelationAggregateInput
    problem_problem_special_runToexecutable?: problemOrderByRelationAggregateInput
    problem_problem_special_compareToexecutable?: problemOrderByRelationAggregateInput
  }

  export type executableWhereUniqueInput = Prisma.AtLeast<{
    execid?: string
    immutable_execid?: number
    AND?: executableWhereInput | executableWhereInput[]
    OR?: executableWhereInput[]
    NOT?: executableWhereInput | executableWhereInput[]
    description?: StringNullableFilter<"executable"> | string | null
    type?: StringFilter<"executable"> | string
    immutable_executable?: XOR<Immutable_executableNullableRelationFilter, immutable_executableWhereInput> | null
    language?: LanguageListRelationFilter
    problem_problem_special_runToexecutable?: ProblemListRelationFilter
    problem_problem_special_compareToexecutable?: ProblemListRelationFilter
  }, "execid" | "immutable_execid">

  export type executableOrderByWithAggregationInput = {
    execid?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    immutable_execid?: SortOrderInput | SortOrder
    _count?: executableCountOrderByAggregateInput
    _avg?: executableAvgOrderByAggregateInput
    _max?: executableMaxOrderByAggregateInput
    _min?: executableMinOrderByAggregateInput
    _sum?: executableSumOrderByAggregateInput
  }

  export type executableScalarWhereWithAggregatesInput = {
    AND?: executableScalarWhereWithAggregatesInput | executableScalarWhereWithAggregatesInput[]
    OR?: executableScalarWhereWithAggregatesInput[]
    NOT?: executableScalarWhereWithAggregatesInput | executableScalarWhereWithAggregatesInput[]
    execid?: StringWithAggregatesFilter<"executable"> | string
    description?: StringNullableWithAggregatesFilter<"executable"> | string | null
    type?: StringWithAggregatesFilter<"executable"> | string
    immutable_execid?: IntNullableWithAggregatesFilter<"executable"> | number | null
  }

  export type executable_fileWhereInput = {
    AND?: executable_fileWhereInput | executable_fileWhereInput[]
    OR?: executable_fileWhereInput[]
    NOT?: executable_fileWhereInput | executable_fileWhereInput[]
    execfileid?: IntFilter<"executable_file"> | number
    immutable_execid?: IntNullableFilter<"executable_file"> | number | null
    filename?: StringFilter<"executable_file"> | string
    ranknumber?: IntFilter<"executable_file"> | number
    file_content?: BytesFilter<"executable_file"> | Buffer
    hash?: StringNullableFilter<"executable_file"> | string | null
    is_executable?: BoolFilter<"executable_file"> | boolean
    immutable_executable?: XOR<Immutable_executableNullableRelationFilter, immutable_executableWhereInput> | null
  }

  export type executable_fileOrderByWithRelationInput = {
    execfileid?: SortOrder
    immutable_execid?: SortOrderInput | SortOrder
    filename?: SortOrder
    ranknumber?: SortOrder
    file_content?: SortOrder
    hash?: SortOrderInput | SortOrder
    is_executable?: SortOrder
    immutable_executable?: immutable_executableOrderByWithRelationInput
  }

  export type executable_fileWhereUniqueInput = Prisma.AtLeast<{
    execfileid?: number
    immutable_execid_filename?: executable_fileImmutable_execidFilenameCompoundUniqueInput
    immutable_execid_ranknumber?: executable_fileImmutable_execidRanknumberCompoundUniqueInput
    AND?: executable_fileWhereInput | executable_fileWhereInput[]
    OR?: executable_fileWhereInput[]
    NOT?: executable_fileWhereInput | executable_fileWhereInput[]
    immutable_execid?: IntNullableFilter<"executable_file"> | number | null
    filename?: StringFilter<"executable_file"> | string
    ranknumber?: IntFilter<"executable_file"> | number
    file_content?: BytesFilter<"executable_file"> | Buffer
    hash?: StringNullableFilter<"executable_file"> | string | null
    is_executable?: BoolFilter<"executable_file"> | boolean
    immutable_executable?: XOR<Immutable_executableNullableRelationFilter, immutable_executableWhereInput> | null
  }, "execfileid" | "immutable_execid_filename" | "immutable_execid_ranknumber">

  export type executable_fileOrderByWithAggregationInput = {
    execfileid?: SortOrder
    immutable_execid?: SortOrderInput | SortOrder
    filename?: SortOrder
    ranknumber?: SortOrder
    file_content?: SortOrder
    hash?: SortOrderInput | SortOrder
    is_executable?: SortOrder
    _count?: executable_fileCountOrderByAggregateInput
    _avg?: executable_fileAvgOrderByAggregateInput
    _max?: executable_fileMaxOrderByAggregateInput
    _min?: executable_fileMinOrderByAggregateInput
    _sum?: executable_fileSumOrderByAggregateInput
  }

  export type executable_fileScalarWhereWithAggregatesInput = {
    AND?: executable_fileScalarWhereWithAggregatesInput | executable_fileScalarWhereWithAggregatesInput[]
    OR?: executable_fileScalarWhereWithAggregatesInput[]
    NOT?: executable_fileScalarWhereWithAggregatesInput | executable_fileScalarWhereWithAggregatesInput[]
    execfileid?: IntWithAggregatesFilter<"executable_file"> | number
    immutable_execid?: IntNullableWithAggregatesFilter<"executable_file"> | number | null
    filename?: StringWithAggregatesFilter<"executable_file"> | string
    ranknumber?: IntWithAggregatesFilter<"executable_file"> | number
    file_content?: BytesWithAggregatesFilter<"executable_file"> | Buffer
    hash?: StringNullableWithAggregatesFilter<"executable_file"> | string | null
    is_executable?: BoolWithAggregatesFilter<"executable_file"> | boolean
  }

  export type external_contest_sourceWhereInput = {
    AND?: external_contest_sourceWhereInput | external_contest_sourceWhereInput[]
    OR?: external_contest_sourceWhereInput[]
    NOT?: external_contest_sourceWhereInput | external_contest_sourceWhereInput[]
    extsourceid?: IntFilter<"external_contest_source"> | number
    cid?: IntNullableFilter<"external_contest_source"> | number | null
    type?: StringFilter<"external_contest_source"> | string
    source?: StringFilter<"external_contest_source"> | string
    username?: StringNullableFilter<"external_contest_source"> | string | null
    password?: StringNullableFilter<"external_contest_source"> | string | null
    last_event_id?: StringNullableFilter<"external_contest_source"> | string | null
    last_poll_time?: DecimalNullableFilter<"external_contest_source"> | Decimal | DecimalJsLike | number | string | null
    contest?: XOR<ContestNullableRelationFilter, contestWhereInput> | null
    external_source_warning?: External_source_warningListRelationFilter
  }

  export type external_contest_sourceOrderByWithRelationInput = {
    extsourceid?: SortOrder
    cid?: SortOrderInput | SortOrder
    type?: SortOrder
    source?: SortOrder
    username?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    last_event_id?: SortOrderInput | SortOrder
    last_poll_time?: SortOrderInput | SortOrder
    contest?: contestOrderByWithRelationInput
    external_source_warning?: external_source_warningOrderByRelationAggregateInput
  }

  export type external_contest_sourceWhereUniqueInput = Prisma.AtLeast<{
    extsourceid?: number
    cid?: number
    AND?: external_contest_sourceWhereInput | external_contest_sourceWhereInput[]
    OR?: external_contest_sourceWhereInput[]
    NOT?: external_contest_sourceWhereInput | external_contest_sourceWhereInput[]
    type?: StringFilter<"external_contest_source"> | string
    source?: StringFilter<"external_contest_source"> | string
    username?: StringNullableFilter<"external_contest_source"> | string | null
    password?: StringNullableFilter<"external_contest_source"> | string | null
    last_event_id?: StringNullableFilter<"external_contest_source"> | string | null
    last_poll_time?: DecimalNullableFilter<"external_contest_source"> | Decimal | DecimalJsLike | number | string | null
    contest?: XOR<ContestNullableRelationFilter, contestWhereInput> | null
    external_source_warning?: External_source_warningListRelationFilter
  }, "extsourceid" | "cid">

  export type external_contest_sourceOrderByWithAggregationInput = {
    extsourceid?: SortOrder
    cid?: SortOrderInput | SortOrder
    type?: SortOrder
    source?: SortOrder
    username?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    last_event_id?: SortOrderInput | SortOrder
    last_poll_time?: SortOrderInput | SortOrder
    _count?: external_contest_sourceCountOrderByAggregateInput
    _avg?: external_contest_sourceAvgOrderByAggregateInput
    _max?: external_contest_sourceMaxOrderByAggregateInput
    _min?: external_contest_sourceMinOrderByAggregateInput
    _sum?: external_contest_sourceSumOrderByAggregateInput
  }

  export type external_contest_sourceScalarWhereWithAggregatesInput = {
    AND?: external_contest_sourceScalarWhereWithAggregatesInput | external_contest_sourceScalarWhereWithAggregatesInput[]
    OR?: external_contest_sourceScalarWhereWithAggregatesInput[]
    NOT?: external_contest_sourceScalarWhereWithAggregatesInput | external_contest_sourceScalarWhereWithAggregatesInput[]
    extsourceid?: IntWithAggregatesFilter<"external_contest_source"> | number
    cid?: IntNullableWithAggregatesFilter<"external_contest_source"> | number | null
    type?: StringWithAggregatesFilter<"external_contest_source"> | string
    source?: StringWithAggregatesFilter<"external_contest_source"> | string
    username?: StringNullableWithAggregatesFilter<"external_contest_source"> | string | null
    password?: StringNullableWithAggregatesFilter<"external_contest_source"> | string | null
    last_event_id?: StringNullableWithAggregatesFilter<"external_contest_source"> | string | null
    last_poll_time?: DecimalNullableWithAggregatesFilter<"external_contest_source"> | Decimal | DecimalJsLike | number | string | null
  }

  export type external_judgementWhereInput = {
    AND?: external_judgementWhereInput | external_judgementWhereInput[]
    OR?: external_judgementWhereInput[]
    NOT?: external_judgementWhereInput | external_judgementWhereInput[]
    extjudgementid?: IntFilter<"external_judgement"> | number
    externalid?: StringNullableFilter<"external_judgement"> | string | null
    cid?: IntNullableFilter<"external_judgement"> | number | null
    submitid?: IntNullableFilter<"external_judgement"> | number | null
    result?: StringNullableFilter<"external_judgement"> | string | null
    verified?: BoolFilter<"external_judgement"> | boolean
    jury_member?: StringNullableFilter<"external_judgement"> | string | null
    verify_comment?: StringNullableFilter<"external_judgement"> | string | null
    starttime?: DecimalFilter<"external_judgement"> | Decimal | DecimalJsLike | number | string
    endtime?: DecimalNullableFilter<"external_judgement"> | Decimal | DecimalJsLike | number | string | null
    valid?: BoolFilter<"external_judgement"> | boolean
    submission?: XOR<SubmissionNullableRelationFilter, submissionWhereInput> | null
    contest?: XOR<ContestNullableRelationFilter, contestWhereInput> | null
    external_run?: External_runListRelationFilter
  }

  export type external_judgementOrderByWithRelationInput = {
    extjudgementid?: SortOrder
    externalid?: SortOrderInput | SortOrder
    cid?: SortOrderInput | SortOrder
    submitid?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    verified?: SortOrder
    jury_member?: SortOrderInput | SortOrder
    verify_comment?: SortOrderInput | SortOrder
    starttime?: SortOrder
    endtime?: SortOrderInput | SortOrder
    valid?: SortOrder
    submission?: submissionOrderByWithRelationInput
    contest?: contestOrderByWithRelationInput
    external_run?: external_runOrderByRelationAggregateInput
  }

  export type external_judgementWhereUniqueInput = Prisma.AtLeast<{
    extjudgementid?: number
    cid_externalid?: external_judgementCidExternalidCompoundUniqueInput
    AND?: external_judgementWhereInput | external_judgementWhereInput[]
    OR?: external_judgementWhereInput[]
    NOT?: external_judgementWhereInput | external_judgementWhereInput[]
    externalid?: StringNullableFilter<"external_judgement"> | string | null
    cid?: IntNullableFilter<"external_judgement"> | number | null
    submitid?: IntNullableFilter<"external_judgement"> | number | null
    result?: StringNullableFilter<"external_judgement"> | string | null
    verified?: BoolFilter<"external_judgement"> | boolean
    jury_member?: StringNullableFilter<"external_judgement"> | string | null
    verify_comment?: StringNullableFilter<"external_judgement"> | string | null
    starttime?: DecimalFilter<"external_judgement"> | Decimal | DecimalJsLike | number | string
    endtime?: DecimalNullableFilter<"external_judgement"> | Decimal | DecimalJsLike | number | string | null
    valid?: BoolFilter<"external_judgement"> | boolean
    submission?: XOR<SubmissionNullableRelationFilter, submissionWhereInput> | null
    contest?: XOR<ContestNullableRelationFilter, contestWhereInput> | null
    external_run?: External_runListRelationFilter
  }, "extjudgementid" | "cid_externalid">

  export type external_judgementOrderByWithAggregationInput = {
    extjudgementid?: SortOrder
    externalid?: SortOrderInput | SortOrder
    cid?: SortOrderInput | SortOrder
    submitid?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    verified?: SortOrder
    jury_member?: SortOrderInput | SortOrder
    verify_comment?: SortOrderInput | SortOrder
    starttime?: SortOrder
    endtime?: SortOrderInput | SortOrder
    valid?: SortOrder
    _count?: external_judgementCountOrderByAggregateInput
    _avg?: external_judgementAvgOrderByAggregateInput
    _max?: external_judgementMaxOrderByAggregateInput
    _min?: external_judgementMinOrderByAggregateInput
    _sum?: external_judgementSumOrderByAggregateInput
  }

  export type external_judgementScalarWhereWithAggregatesInput = {
    AND?: external_judgementScalarWhereWithAggregatesInput | external_judgementScalarWhereWithAggregatesInput[]
    OR?: external_judgementScalarWhereWithAggregatesInput[]
    NOT?: external_judgementScalarWhereWithAggregatesInput | external_judgementScalarWhereWithAggregatesInput[]
    extjudgementid?: IntWithAggregatesFilter<"external_judgement"> | number
    externalid?: StringNullableWithAggregatesFilter<"external_judgement"> | string | null
    cid?: IntNullableWithAggregatesFilter<"external_judgement"> | number | null
    submitid?: IntNullableWithAggregatesFilter<"external_judgement"> | number | null
    result?: StringNullableWithAggregatesFilter<"external_judgement"> | string | null
    verified?: BoolWithAggregatesFilter<"external_judgement"> | boolean
    jury_member?: StringNullableWithAggregatesFilter<"external_judgement"> | string | null
    verify_comment?: StringNullableWithAggregatesFilter<"external_judgement"> | string | null
    starttime?: DecimalWithAggregatesFilter<"external_judgement"> | Decimal | DecimalJsLike | number | string
    endtime?: DecimalNullableWithAggregatesFilter<"external_judgement"> | Decimal | DecimalJsLike | number | string | null
    valid?: BoolWithAggregatesFilter<"external_judgement"> | boolean
  }

  export type external_runWhereInput = {
    AND?: external_runWhereInput | external_runWhereInput[]
    OR?: external_runWhereInput[]
    NOT?: external_runWhereInput | external_runWhereInput[]
    extrunid?: IntFilter<"external_run"> | number
    extjudgementid?: IntNullableFilter<"external_run"> | number | null
    testcaseid?: IntNullableFilter<"external_run"> | number | null
    externalid?: StringNullableFilter<"external_run"> | string | null
    cid?: IntNullableFilter<"external_run"> | number | null
    result?: StringFilter<"external_run"> | string
    endtime?: DecimalFilter<"external_run"> | Decimal | DecimalJsLike | number | string
    runtime?: FloatFilter<"external_run"> | number
    external_judgement?: XOR<External_judgementNullableRelationFilter, external_judgementWhereInput> | null
    testcase?: XOR<TestcaseNullableRelationFilter, testcaseWhereInput> | null
    contest?: XOR<ContestNullableRelationFilter, contestWhereInput> | null
  }

  export type external_runOrderByWithRelationInput = {
    extrunid?: SortOrder
    extjudgementid?: SortOrderInput | SortOrder
    testcaseid?: SortOrderInput | SortOrder
    externalid?: SortOrderInput | SortOrder
    cid?: SortOrderInput | SortOrder
    result?: SortOrder
    endtime?: SortOrder
    runtime?: SortOrder
    external_judgement?: external_judgementOrderByWithRelationInput
    testcase?: testcaseOrderByWithRelationInput
    contest?: contestOrderByWithRelationInput
  }

  export type external_runWhereUniqueInput = Prisma.AtLeast<{
    extrunid?: number
    cid_externalid?: external_runCidExternalidCompoundUniqueInput
    AND?: external_runWhereInput | external_runWhereInput[]
    OR?: external_runWhereInput[]
    NOT?: external_runWhereInput | external_runWhereInput[]
    extjudgementid?: IntNullableFilter<"external_run"> | number | null
    testcaseid?: IntNullableFilter<"external_run"> | number | null
    externalid?: StringNullableFilter<"external_run"> | string | null
    cid?: IntNullableFilter<"external_run"> | number | null
    result?: StringFilter<"external_run"> | string
    endtime?: DecimalFilter<"external_run"> | Decimal | DecimalJsLike | number | string
    runtime?: FloatFilter<"external_run"> | number
    external_judgement?: XOR<External_judgementNullableRelationFilter, external_judgementWhereInput> | null
    testcase?: XOR<TestcaseNullableRelationFilter, testcaseWhereInput> | null
    contest?: XOR<ContestNullableRelationFilter, contestWhereInput> | null
  }, "extrunid" | "cid_externalid">

  export type external_runOrderByWithAggregationInput = {
    extrunid?: SortOrder
    extjudgementid?: SortOrderInput | SortOrder
    testcaseid?: SortOrderInput | SortOrder
    externalid?: SortOrderInput | SortOrder
    cid?: SortOrderInput | SortOrder
    result?: SortOrder
    endtime?: SortOrder
    runtime?: SortOrder
    _count?: external_runCountOrderByAggregateInput
    _avg?: external_runAvgOrderByAggregateInput
    _max?: external_runMaxOrderByAggregateInput
    _min?: external_runMinOrderByAggregateInput
    _sum?: external_runSumOrderByAggregateInput
  }

  export type external_runScalarWhereWithAggregatesInput = {
    AND?: external_runScalarWhereWithAggregatesInput | external_runScalarWhereWithAggregatesInput[]
    OR?: external_runScalarWhereWithAggregatesInput[]
    NOT?: external_runScalarWhereWithAggregatesInput | external_runScalarWhereWithAggregatesInput[]
    extrunid?: IntWithAggregatesFilter<"external_run"> | number
    extjudgementid?: IntNullableWithAggregatesFilter<"external_run"> | number | null
    testcaseid?: IntNullableWithAggregatesFilter<"external_run"> | number | null
    externalid?: StringNullableWithAggregatesFilter<"external_run"> | string | null
    cid?: IntNullableWithAggregatesFilter<"external_run"> | number | null
    result?: StringWithAggregatesFilter<"external_run"> | string
    endtime?: DecimalWithAggregatesFilter<"external_run"> | Decimal | DecimalJsLike | number | string
    runtime?: FloatWithAggregatesFilter<"external_run"> | number
  }

  export type external_source_warningWhereInput = {
    AND?: external_source_warningWhereInput | external_source_warningWhereInput[]
    OR?: external_source_warningWhereInput[]
    NOT?: external_source_warningWhereInput | external_source_warningWhereInput[]
    extwarningid?: IntFilter<"external_source_warning"> | number
    extsourceid?: IntNullableFilter<"external_source_warning"> | number | null
    last_event_id?: StringNullableFilter<"external_source_warning"> | string | null
    time?: DecimalFilter<"external_source_warning"> | Decimal | DecimalJsLike | number | string
    entity_type?: StringFilter<"external_source_warning"> | string
    entity_id?: StringFilter<"external_source_warning"> | string
    type?: StringFilter<"external_source_warning"> | string
    hash?: StringFilter<"external_source_warning"> | string
    content?: StringFilter<"external_source_warning"> | string
    external_contest_source?: XOR<External_contest_sourceNullableRelationFilter, external_contest_sourceWhereInput> | null
  }

  export type external_source_warningOrderByWithRelationInput = {
    extwarningid?: SortOrder
    extsourceid?: SortOrderInput | SortOrder
    last_event_id?: SortOrderInput | SortOrder
    time?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    type?: SortOrder
    hash?: SortOrder
    content?: SortOrder
    external_contest_source?: external_contest_sourceOrderByWithRelationInput
  }

  export type external_source_warningWhereUniqueInput = Prisma.AtLeast<{
    extwarningid?: number
    extsourceid_hash?: external_source_warningExtsourceidHashCompoundUniqueInput
    AND?: external_source_warningWhereInput | external_source_warningWhereInput[]
    OR?: external_source_warningWhereInput[]
    NOT?: external_source_warningWhereInput | external_source_warningWhereInput[]
    extsourceid?: IntNullableFilter<"external_source_warning"> | number | null
    last_event_id?: StringNullableFilter<"external_source_warning"> | string | null
    time?: DecimalFilter<"external_source_warning"> | Decimal | DecimalJsLike | number | string
    entity_type?: StringFilter<"external_source_warning"> | string
    entity_id?: StringFilter<"external_source_warning"> | string
    type?: StringFilter<"external_source_warning"> | string
    hash?: StringFilter<"external_source_warning"> | string
    content?: StringFilter<"external_source_warning"> | string
    external_contest_source?: XOR<External_contest_sourceNullableRelationFilter, external_contest_sourceWhereInput> | null
  }, "extwarningid" | "extsourceid_hash">

  export type external_source_warningOrderByWithAggregationInput = {
    extwarningid?: SortOrder
    extsourceid?: SortOrderInput | SortOrder
    last_event_id?: SortOrderInput | SortOrder
    time?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    type?: SortOrder
    hash?: SortOrder
    content?: SortOrder
    _count?: external_source_warningCountOrderByAggregateInput
    _avg?: external_source_warningAvgOrderByAggregateInput
    _max?: external_source_warningMaxOrderByAggregateInput
    _min?: external_source_warningMinOrderByAggregateInput
    _sum?: external_source_warningSumOrderByAggregateInput
  }

  export type external_source_warningScalarWhereWithAggregatesInput = {
    AND?: external_source_warningScalarWhereWithAggregatesInput | external_source_warningScalarWhereWithAggregatesInput[]
    OR?: external_source_warningScalarWhereWithAggregatesInput[]
    NOT?: external_source_warningScalarWhereWithAggregatesInput | external_source_warningScalarWhereWithAggregatesInput[]
    extwarningid?: IntWithAggregatesFilter<"external_source_warning"> | number
    extsourceid?: IntNullableWithAggregatesFilter<"external_source_warning"> | number | null
    last_event_id?: StringNullableWithAggregatesFilter<"external_source_warning"> | string | null
    time?: DecimalWithAggregatesFilter<"external_source_warning"> | Decimal | DecimalJsLike | number | string
    entity_type?: StringWithAggregatesFilter<"external_source_warning"> | string
    entity_id?: StringWithAggregatesFilter<"external_source_warning"> | string
    type?: StringWithAggregatesFilter<"external_source_warning"> | string
    hash?: StringWithAggregatesFilter<"external_source_warning"> | string
    content?: StringWithAggregatesFilter<"external_source_warning"> | string
  }

  export type immutable_executableWhereInput = {
    AND?: immutable_executableWhereInput | immutable_executableWhereInput[]
    OR?: immutable_executableWhereInput[]
    NOT?: immutable_executableWhereInput | immutable_executableWhereInput[]
    immutable_execid?: IntFilter<"immutable_executable"> | number
    userid?: IntNullableFilter<"immutable_executable"> | number | null
    hash?: StringNullableFilter<"immutable_executable"> | string | null
    executable?: XOR<ExecutableNullableRelationFilter, executableWhereInput> | null
    executable_file?: Executable_fileListRelationFilter
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }

  export type immutable_executableOrderByWithRelationInput = {
    immutable_execid?: SortOrder
    userid?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    executable?: executableOrderByWithRelationInput
    executable_file?: executable_fileOrderByRelationAggregateInput
    user?: userOrderByWithRelationInput
  }

  export type immutable_executableWhereUniqueInput = Prisma.AtLeast<{
    immutable_execid?: number
    AND?: immutable_executableWhereInput | immutable_executableWhereInput[]
    OR?: immutable_executableWhereInput[]
    NOT?: immutable_executableWhereInput | immutable_executableWhereInput[]
    userid?: IntNullableFilter<"immutable_executable"> | number | null
    hash?: StringNullableFilter<"immutable_executable"> | string | null
    executable?: XOR<ExecutableNullableRelationFilter, executableWhereInput> | null
    executable_file?: Executable_fileListRelationFilter
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }, "immutable_execid">

  export type immutable_executableOrderByWithAggregationInput = {
    immutable_execid?: SortOrder
    userid?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    _count?: immutable_executableCountOrderByAggregateInput
    _avg?: immutable_executableAvgOrderByAggregateInput
    _max?: immutable_executableMaxOrderByAggregateInput
    _min?: immutable_executableMinOrderByAggregateInput
    _sum?: immutable_executableSumOrderByAggregateInput
  }

  export type immutable_executableScalarWhereWithAggregatesInput = {
    AND?: immutable_executableScalarWhereWithAggregatesInput | immutable_executableScalarWhereWithAggregatesInput[]
    OR?: immutable_executableScalarWhereWithAggregatesInput[]
    NOT?: immutable_executableScalarWhereWithAggregatesInput | immutable_executableScalarWhereWithAggregatesInput[]
    immutable_execid?: IntWithAggregatesFilter<"immutable_executable"> | number
    userid?: IntNullableWithAggregatesFilter<"immutable_executable"> | number | null
    hash?: StringNullableWithAggregatesFilter<"immutable_executable"> | string | null
  }

  export type internal_errorWhereInput = {
    AND?: internal_errorWhereInput | internal_errorWhereInput[]
    OR?: internal_errorWhereInput[]
    NOT?: internal_errorWhereInput | internal_errorWhereInput[]
    errorid?: IntFilter<"internal_error"> | number
    judgingid?: IntNullableFilter<"internal_error"> | number | null
    cid?: IntNullableFilter<"internal_error"> | number | null
    description?: StringFilter<"internal_error"> | string
    judgehostlog?: StringFilter<"internal_error"> | string
    time?: DecimalFilter<"internal_error"> | Decimal | DecimalJsLike | number | string
    disabled?: StringFilter<"internal_error"> | string
    status?: Enuminternal_error_statusFilter<"internal_error"> | $Enums.internal_error_status
    judging_internal_error_judgingidTojudging?: XOR<JudgingNullableRelationFilter, judgingWhereInput> | null
    contest?: XOR<ContestNullableRelationFilter, contestWhereInput> | null
    judging_judging_erroridTointernal_error?: JudgingListRelationFilter
  }

  export type internal_errorOrderByWithRelationInput = {
    errorid?: SortOrder
    judgingid?: SortOrderInput | SortOrder
    cid?: SortOrderInput | SortOrder
    description?: SortOrder
    judgehostlog?: SortOrder
    time?: SortOrder
    disabled?: SortOrder
    status?: SortOrder
    judging_internal_error_judgingidTojudging?: judgingOrderByWithRelationInput
    contest?: contestOrderByWithRelationInput
    judging_judging_erroridTointernal_error?: judgingOrderByRelationAggregateInput
  }

  export type internal_errorWhereUniqueInput = Prisma.AtLeast<{
    errorid?: number
    AND?: internal_errorWhereInput | internal_errorWhereInput[]
    OR?: internal_errorWhereInput[]
    NOT?: internal_errorWhereInput | internal_errorWhereInput[]
    judgingid?: IntNullableFilter<"internal_error"> | number | null
    cid?: IntNullableFilter<"internal_error"> | number | null
    description?: StringFilter<"internal_error"> | string
    judgehostlog?: StringFilter<"internal_error"> | string
    time?: DecimalFilter<"internal_error"> | Decimal | DecimalJsLike | number | string
    disabled?: StringFilter<"internal_error"> | string
    status?: Enuminternal_error_statusFilter<"internal_error"> | $Enums.internal_error_status
    judging_internal_error_judgingidTojudging?: XOR<JudgingNullableRelationFilter, judgingWhereInput> | null
    contest?: XOR<ContestNullableRelationFilter, contestWhereInput> | null
    judging_judging_erroridTointernal_error?: JudgingListRelationFilter
  }, "errorid">

  export type internal_errorOrderByWithAggregationInput = {
    errorid?: SortOrder
    judgingid?: SortOrderInput | SortOrder
    cid?: SortOrderInput | SortOrder
    description?: SortOrder
    judgehostlog?: SortOrder
    time?: SortOrder
    disabled?: SortOrder
    status?: SortOrder
    _count?: internal_errorCountOrderByAggregateInput
    _avg?: internal_errorAvgOrderByAggregateInput
    _max?: internal_errorMaxOrderByAggregateInput
    _min?: internal_errorMinOrderByAggregateInput
    _sum?: internal_errorSumOrderByAggregateInput
  }

  export type internal_errorScalarWhereWithAggregatesInput = {
    AND?: internal_errorScalarWhereWithAggregatesInput | internal_errorScalarWhereWithAggregatesInput[]
    OR?: internal_errorScalarWhereWithAggregatesInput[]
    NOT?: internal_errorScalarWhereWithAggregatesInput | internal_errorScalarWhereWithAggregatesInput[]
    errorid?: IntWithAggregatesFilter<"internal_error"> | number
    judgingid?: IntNullableWithAggregatesFilter<"internal_error"> | number | null
    cid?: IntNullableWithAggregatesFilter<"internal_error"> | number | null
    description?: StringWithAggregatesFilter<"internal_error"> | string
    judgehostlog?: StringWithAggregatesFilter<"internal_error"> | string
    time?: DecimalWithAggregatesFilter<"internal_error"> | Decimal | DecimalJsLike | number | string
    disabled?: StringWithAggregatesFilter<"internal_error"> | string
    status?: Enuminternal_error_statusWithAggregatesFilter<"internal_error"> | $Enums.internal_error_status
  }

  export type judgehostWhereInput = {
    AND?: judgehostWhereInput | judgehostWhereInput[]
    OR?: judgehostWhereInput[]
    NOT?: judgehostWhereInput | judgehostWhereInput[]
    judgehostid?: IntFilter<"judgehost"> | number
    hostname?: StringFilter<"judgehost"> | string
    enabled?: BoolFilter<"judgehost"> | boolean
    polltime?: DecimalNullableFilter<"judgehost"> | Decimal | DecimalJsLike | number | string | null
    hidden?: BoolFilter<"judgehost"> | boolean
    debug_package?: Debug_packageListRelationFilter
    judgetask?: JudgetaskListRelationFilter
  }

  export type judgehostOrderByWithRelationInput = {
    judgehostid?: SortOrder
    hostname?: SortOrder
    enabled?: SortOrder
    polltime?: SortOrderInput | SortOrder
    hidden?: SortOrder
    debug_package?: debug_packageOrderByRelationAggregateInput
    judgetask?: judgetaskOrderByRelationAggregateInput
  }

  export type judgehostWhereUniqueInput = Prisma.AtLeast<{
    judgehostid?: number
    hostname?: string
    AND?: judgehostWhereInput | judgehostWhereInput[]
    OR?: judgehostWhereInput[]
    NOT?: judgehostWhereInput | judgehostWhereInput[]
    enabled?: BoolFilter<"judgehost"> | boolean
    polltime?: DecimalNullableFilter<"judgehost"> | Decimal | DecimalJsLike | number | string | null
    hidden?: BoolFilter<"judgehost"> | boolean
    debug_package?: Debug_packageListRelationFilter
    judgetask?: JudgetaskListRelationFilter
  }, "judgehostid" | "hostname">

  export type judgehostOrderByWithAggregationInput = {
    judgehostid?: SortOrder
    hostname?: SortOrder
    enabled?: SortOrder
    polltime?: SortOrderInput | SortOrder
    hidden?: SortOrder
    _count?: judgehostCountOrderByAggregateInput
    _avg?: judgehostAvgOrderByAggregateInput
    _max?: judgehostMaxOrderByAggregateInput
    _min?: judgehostMinOrderByAggregateInput
    _sum?: judgehostSumOrderByAggregateInput
  }

  export type judgehostScalarWhereWithAggregatesInput = {
    AND?: judgehostScalarWhereWithAggregatesInput | judgehostScalarWhereWithAggregatesInput[]
    OR?: judgehostScalarWhereWithAggregatesInput[]
    NOT?: judgehostScalarWhereWithAggregatesInput | judgehostScalarWhereWithAggregatesInput[]
    judgehostid?: IntWithAggregatesFilter<"judgehost"> | number
    hostname?: StringWithAggregatesFilter<"judgehost"> | string
    enabled?: BoolWithAggregatesFilter<"judgehost"> | boolean
    polltime?: DecimalNullableWithAggregatesFilter<"judgehost"> | Decimal | DecimalJsLike | number | string | null
    hidden?: BoolWithAggregatesFilter<"judgehost"> | boolean
  }

  export type judgetaskWhereInput = {
    AND?: judgetaskWhereInput | judgetaskWhereInput[]
    OR?: judgetaskWhereInput[]
    NOT?: judgetaskWhereInput | judgetaskWhereInput[]
    judgetaskid?: IntFilter<"judgetask"> | number
    judgehostid?: IntNullableFilter<"judgetask"> | number | null
    type?: Enumjudgetask_typeFilter<"judgetask"> | $Enums.judgetask_type
    priority?: IntFilter<"judgetask"> | number
    jobid?: IntNullableFilter<"judgetask"> | number | null
    submitid?: IntNullableFilter<"judgetask"> | number | null
    compile_script_id?: IntNullableFilter<"judgetask"> | number | null
    run_script_id?: IntNullableFilter<"judgetask"> | number | null
    compare_script_id?: IntNullableFilter<"judgetask"> | number | null
    testcase_id?: IntNullableFilter<"judgetask"> | number | null
    compile_config?: StringNullableFilter<"judgetask"> | string | null
    run_config?: StringNullableFilter<"judgetask"> | string | null
    compare_config?: StringNullableFilter<"judgetask"> | string | null
    valid?: BoolFilter<"judgetask"> | boolean
    starttime?: DecimalNullableFilter<"judgetask"> | Decimal | DecimalJsLike | number | string | null
    uuid?: StringNullableFilter<"judgetask"> | string | null
    testcase_hash?: StringNullableFilter<"judgetask"> | string | null
    judgehost?: XOR<JudgehostNullableRelationFilter, judgehostWhereInput> | null
    judging_run?: Judging_runListRelationFilter
  }

  export type judgetaskOrderByWithRelationInput = {
    judgetaskid?: SortOrder
    judgehostid?: SortOrderInput | SortOrder
    type?: SortOrder
    priority?: SortOrder
    jobid?: SortOrderInput | SortOrder
    submitid?: SortOrderInput | SortOrder
    compile_script_id?: SortOrderInput | SortOrder
    run_script_id?: SortOrderInput | SortOrder
    compare_script_id?: SortOrderInput | SortOrder
    testcase_id?: SortOrderInput | SortOrder
    compile_config?: SortOrderInput | SortOrder
    run_config?: SortOrderInput | SortOrder
    compare_config?: SortOrderInput | SortOrder
    valid?: SortOrder
    starttime?: SortOrderInput | SortOrder
    uuid?: SortOrderInput | SortOrder
    testcase_hash?: SortOrderInput | SortOrder
    judgehost?: judgehostOrderByWithRelationInput
    judging_run?: judging_runOrderByRelationAggregateInput
  }

  export type judgetaskWhereUniqueInput = Prisma.AtLeast<{
    judgetaskid?: number
    AND?: judgetaskWhereInput | judgetaskWhereInput[]
    OR?: judgetaskWhereInput[]
    NOT?: judgetaskWhereInput | judgetaskWhereInput[]
    judgehostid?: IntNullableFilter<"judgetask"> | number | null
    type?: Enumjudgetask_typeFilter<"judgetask"> | $Enums.judgetask_type
    priority?: IntFilter<"judgetask"> | number
    jobid?: IntNullableFilter<"judgetask"> | number | null
    submitid?: IntNullableFilter<"judgetask"> | number | null
    compile_script_id?: IntNullableFilter<"judgetask"> | number | null
    run_script_id?: IntNullableFilter<"judgetask"> | number | null
    compare_script_id?: IntNullableFilter<"judgetask"> | number | null
    testcase_id?: IntNullableFilter<"judgetask"> | number | null
    compile_config?: StringNullableFilter<"judgetask"> | string | null
    run_config?: StringNullableFilter<"judgetask"> | string | null
    compare_config?: StringNullableFilter<"judgetask"> | string | null
    valid?: BoolFilter<"judgetask"> | boolean
    starttime?: DecimalNullableFilter<"judgetask"> | Decimal | DecimalJsLike | number | string | null
    uuid?: StringNullableFilter<"judgetask"> | string | null
    testcase_hash?: StringNullableFilter<"judgetask"> | string | null
    judgehost?: XOR<JudgehostNullableRelationFilter, judgehostWhereInput> | null
    judging_run?: Judging_runListRelationFilter
  }, "judgetaskid">

  export type judgetaskOrderByWithAggregationInput = {
    judgetaskid?: SortOrder
    judgehostid?: SortOrderInput | SortOrder
    type?: SortOrder
    priority?: SortOrder
    jobid?: SortOrderInput | SortOrder
    submitid?: SortOrderInput | SortOrder
    compile_script_id?: SortOrderInput | SortOrder
    run_script_id?: SortOrderInput | SortOrder
    compare_script_id?: SortOrderInput | SortOrder
    testcase_id?: SortOrderInput | SortOrder
    compile_config?: SortOrderInput | SortOrder
    run_config?: SortOrderInput | SortOrder
    compare_config?: SortOrderInput | SortOrder
    valid?: SortOrder
    starttime?: SortOrderInput | SortOrder
    uuid?: SortOrderInput | SortOrder
    testcase_hash?: SortOrderInput | SortOrder
    _count?: judgetaskCountOrderByAggregateInput
    _avg?: judgetaskAvgOrderByAggregateInput
    _max?: judgetaskMaxOrderByAggregateInput
    _min?: judgetaskMinOrderByAggregateInput
    _sum?: judgetaskSumOrderByAggregateInput
  }

  export type judgetaskScalarWhereWithAggregatesInput = {
    AND?: judgetaskScalarWhereWithAggregatesInput | judgetaskScalarWhereWithAggregatesInput[]
    OR?: judgetaskScalarWhereWithAggregatesInput[]
    NOT?: judgetaskScalarWhereWithAggregatesInput | judgetaskScalarWhereWithAggregatesInput[]
    judgetaskid?: IntWithAggregatesFilter<"judgetask"> | number
    judgehostid?: IntNullableWithAggregatesFilter<"judgetask"> | number | null
    type?: Enumjudgetask_typeWithAggregatesFilter<"judgetask"> | $Enums.judgetask_type
    priority?: IntWithAggregatesFilter<"judgetask"> | number
    jobid?: IntNullableWithAggregatesFilter<"judgetask"> | number | null
    submitid?: IntNullableWithAggregatesFilter<"judgetask"> | number | null
    compile_script_id?: IntNullableWithAggregatesFilter<"judgetask"> | number | null
    run_script_id?: IntNullableWithAggregatesFilter<"judgetask"> | number | null
    compare_script_id?: IntNullableWithAggregatesFilter<"judgetask"> | number | null
    testcase_id?: IntNullableWithAggregatesFilter<"judgetask"> | number | null
    compile_config?: StringNullableWithAggregatesFilter<"judgetask"> | string | null
    run_config?: StringNullableWithAggregatesFilter<"judgetask"> | string | null
    compare_config?: StringNullableWithAggregatesFilter<"judgetask"> | string | null
    valid?: BoolWithAggregatesFilter<"judgetask"> | boolean
    starttime?: DecimalNullableWithAggregatesFilter<"judgetask"> | Decimal | DecimalJsLike | number | string | null
    uuid?: StringNullableWithAggregatesFilter<"judgetask"> | string | null
    testcase_hash?: StringNullableWithAggregatesFilter<"judgetask"> | string | null
  }

  export type judgingWhereInput = {
    AND?: judgingWhereInput | judgingWhereInput[]
    OR?: judgingWhereInput[]
    NOT?: judgingWhereInput | judgingWhereInput[]
    judgingid?: IntFilter<"judging"> | number
    cid?: IntNullableFilter<"judging"> | number | null
    submitid?: IntNullableFilter<"judging"> | number | null
    starttime?: DecimalNullableFilter<"judging"> | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalNullableFilter<"judging"> | Decimal | DecimalJsLike | number | string | null
    result?: StringNullableFilter<"judging"> | string | null
    verified?: BoolFilter<"judging"> | boolean
    jury_member?: StringNullableFilter<"judging"> | string | null
    verify_comment?: StringNullableFilter<"judging"> | string | null
    valid?: BoolFilter<"judging"> | boolean
    output_compile?: BytesNullableFilter<"judging"> | Buffer | null
    seen?: BoolFilter<"judging"> | boolean
    rejudgingid?: IntNullableFilter<"judging"> | number | null
    prevjudgingid?: IntNullableFilter<"judging"> | number | null
    judge_completely?: BoolFilter<"judging"> | boolean
    errorid?: IntNullableFilter<"judging"> | number | null
    uuid?: StringFilter<"judging"> | string
    metadata?: BytesNullableFilter<"judging"> | Buffer | null
    debug_package?: Debug_packageListRelationFilter
    internal_error_internal_error_judgingidTojudging?: Internal_errorListRelationFilter
    internal_error_judging_erroridTointernal_error?: XOR<Internal_errorNullableRelationFilter, internal_errorWhereInput> | null
    contest?: XOR<ContestNullableRelationFilter, contestWhereInput> | null
    submission?: XOR<SubmissionNullableRelationFilter, submissionWhereInput> | null
    rejudging?: XOR<RejudgingNullableRelationFilter, rejudgingWhereInput> | null
    judging?: XOR<JudgingNullableRelationFilter, judgingWhereInput> | null
    other_judging?: JudgingListRelationFilter
    judging_run?: Judging_runListRelationFilter
  }

  export type judgingOrderByWithRelationInput = {
    judgingid?: SortOrder
    cid?: SortOrderInput | SortOrder
    submitid?: SortOrderInput | SortOrder
    starttime?: SortOrderInput | SortOrder
    endtime?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    verified?: SortOrder
    jury_member?: SortOrderInput | SortOrder
    verify_comment?: SortOrderInput | SortOrder
    valid?: SortOrder
    output_compile?: SortOrderInput | SortOrder
    seen?: SortOrder
    rejudgingid?: SortOrderInput | SortOrder
    prevjudgingid?: SortOrderInput | SortOrder
    judge_completely?: SortOrder
    errorid?: SortOrderInput | SortOrder
    uuid?: SortOrder
    metadata?: SortOrderInput | SortOrder
    debug_package?: debug_packageOrderByRelationAggregateInput
    internal_error_internal_error_judgingidTojudging?: internal_errorOrderByRelationAggregateInput
    internal_error_judging_erroridTointernal_error?: internal_errorOrderByWithRelationInput
    contest?: contestOrderByWithRelationInput
    submission?: submissionOrderByWithRelationInput
    rejudging?: rejudgingOrderByWithRelationInput
    judging?: judgingOrderByWithRelationInput
    other_judging?: judgingOrderByRelationAggregateInput
    judging_run?: judging_runOrderByRelationAggregateInput
  }

  export type judgingWhereUniqueInput = Prisma.AtLeast<{
    judgingid?: number
    AND?: judgingWhereInput | judgingWhereInput[]
    OR?: judgingWhereInput[]
    NOT?: judgingWhereInput | judgingWhereInput[]
    cid?: IntNullableFilter<"judging"> | number | null
    submitid?: IntNullableFilter<"judging"> | number | null
    starttime?: DecimalNullableFilter<"judging"> | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalNullableFilter<"judging"> | Decimal | DecimalJsLike | number | string | null
    result?: StringNullableFilter<"judging"> | string | null
    verified?: BoolFilter<"judging"> | boolean
    jury_member?: StringNullableFilter<"judging"> | string | null
    verify_comment?: StringNullableFilter<"judging"> | string | null
    valid?: BoolFilter<"judging"> | boolean
    output_compile?: BytesNullableFilter<"judging"> | Buffer | null
    seen?: BoolFilter<"judging"> | boolean
    rejudgingid?: IntNullableFilter<"judging"> | number | null
    prevjudgingid?: IntNullableFilter<"judging"> | number | null
    judge_completely?: BoolFilter<"judging"> | boolean
    errorid?: IntNullableFilter<"judging"> | number | null
    uuid?: StringFilter<"judging"> | string
    metadata?: BytesNullableFilter<"judging"> | Buffer | null
    debug_package?: Debug_packageListRelationFilter
    internal_error_internal_error_judgingidTojudging?: Internal_errorListRelationFilter
    internal_error_judging_erroridTointernal_error?: XOR<Internal_errorNullableRelationFilter, internal_errorWhereInput> | null
    contest?: XOR<ContestNullableRelationFilter, contestWhereInput> | null
    submission?: XOR<SubmissionNullableRelationFilter, submissionWhereInput> | null
    rejudging?: XOR<RejudgingNullableRelationFilter, rejudgingWhereInput> | null
    judging?: XOR<JudgingNullableRelationFilter, judgingWhereInput> | null
    other_judging?: JudgingListRelationFilter
    judging_run?: Judging_runListRelationFilter
  }, "judgingid">

  export type judgingOrderByWithAggregationInput = {
    judgingid?: SortOrder
    cid?: SortOrderInput | SortOrder
    submitid?: SortOrderInput | SortOrder
    starttime?: SortOrderInput | SortOrder
    endtime?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    verified?: SortOrder
    jury_member?: SortOrderInput | SortOrder
    verify_comment?: SortOrderInput | SortOrder
    valid?: SortOrder
    output_compile?: SortOrderInput | SortOrder
    seen?: SortOrder
    rejudgingid?: SortOrderInput | SortOrder
    prevjudgingid?: SortOrderInput | SortOrder
    judge_completely?: SortOrder
    errorid?: SortOrderInput | SortOrder
    uuid?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: judgingCountOrderByAggregateInput
    _avg?: judgingAvgOrderByAggregateInput
    _max?: judgingMaxOrderByAggregateInput
    _min?: judgingMinOrderByAggregateInput
    _sum?: judgingSumOrderByAggregateInput
  }

  export type judgingScalarWhereWithAggregatesInput = {
    AND?: judgingScalarWhereWithAggregatesInput | judgingScalarWhereWithAggregatesInput[]
    OR?: judgingScalarWhereWithAggregatesInput[]
    NOT?: judgingScalarWhereWithAggregatesInput | judgingScalarWhereWithAggregatesInput[]
    judgingid?: IntWithAggregatesFilter<"judging"> | number
    cid?: IntNullableWithAggregatesFilter<"judging"> | number | null
    submitid?: IntNullableWithAggregatesFilter<"judging"> | number | null
    starttime?: DecimalNullableWithAggregatesFilter<"judging"> | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalNullableWithAggregatesFilter<"judging"> | Decimal | DecimalJsLike | number | string | null
    result?: StringNullableWithAggregatesFilter<"judging"> | string | null
    verified?: BoolWithAggregatesFilter<"judging"> | boolean
    jury_member?: StringNullableWithAggregatesFilter<"judging"> | string | null
    verify_comment?: StringNullableWithAggregatesFilter<"judging"> | string | null
    valid?: BoolWithAggregatesFilter<"judging"> | boolean
    output_compile?: BytesNullableWithAggregatesFilter<"judging"> | Buffer | null
    seen?: BoolWithAggregatesFilter<"judging"> | boolean
    rejudgingid?: IntNullableWithAggregatesFilter<"judging"> | number | null
    prevjudgingid?: IntNullableWithAggregatesFilter<"judging"> | number | null
    judge_completely?: BoolWithAggregatesFilter<"judging"> | boolean
    errorid?: IntNullableWithAggregatesFilter<"judging"> | number | null
    uuid?: StringWithAggregatesFilter<"judging"> | string
    metadata?: BytesNullableWithAggregatesFilter<"judging"> | Buffer | null
  }

  export type judging_runWhereInput = {
    AND?: judging_runWhereInput | judging_runWhereInput[]
    OR?: judging_runWhereInput[]
    NOT?: judging_runWhereInput | judging_runWhereInput[]
    runid?: IntFilter<"judging_run"> | number
    judgingid?: IntNullableFilter<"judging_run"> | number | null
    testcaseid?: IntNullableFilter<"judging_run"> | number | null
    runresult?: StringNullableFilter<"judging_run"> | string | null
    runtime?: FloatNullableFilter<"judging_run"> | number | null
    endtime?: DecimalNullableFilter<"judging_run"> | Decimal | DecimalJsLike | number | string | null
    judgetaskid?: IntNullableFilter<"judging_run"> | number | null
    judgetask?: XOR<JudgetaskNullableRelationFilter, judgetaskWhereInput> | null
    testcase?: XOR<TestcaseNullableRelationFilter, testcaseWhereInput> | null
    judging?: XOR<JudgingNullableRelationFilter, judgingWhereInput> | null
    judging_run_output?: XOR<Judging_run_outputNullableRelationFilter, judging_run_outputWhereInput> | null
  }

  export type judging_runOrderByWithRelationInput = {
    runid?: SortOrder
    judgingid?: SortOrderInput | SortOrder
    testcaseid?: SortOrderInput | SortOrder
    runresult?: SortOrderInput | SortOrder
    runtime?: SortOrderInput | SortOrder
    endtime?: SortOrderInput | SortOrder
    judgetaskid?: SortOrderInput | SortOrder
    judgetask?: judgetaskOrderByWithRelationInput
    testcase?: testcaseOrderByWithRelationInput
    judging?: judgingOrderByWithRelationInput
    judging_run_output?: judging_run_outputOrderByWithRelationInput
  }

  export type judging_runWhereUniqueInput = Prisma.AtLeast<{
    runid?: number
    judgingid_testcaseid?: judging_runJudgingidTestcaseidCompoundUniqueInput
    AND?: judging_runWhereInput | judging_runWhereInput[]
    OR?: judging_runWhereInput[]
    NOT?: judging_runWhereInput | judging_runWhereInput[]
    judgingid?: IntNullableFilter<"judging_run"> | number | null
    testcaseid?: IntNullableFilter<"judging_run"> | number | null
    runresult?: StringNullableFilter<"judging_run"> | string | null
    runtime?: FloatNullableFilter<"judging_run"> | number | null
    endtime?: DecimalNullableFilter<"judging_run"> | Decimal | DecimalJsLike | number | string | null
    judgetaskid?: IntNullableFilter<"judging_run"> | number | null
    judgetask?: XOR<JudgetaskNullableRelationFilter, judgetaskWhereInput> | null
    testcase?: XOR<TestcaseNullableRelationFilter, testcaseWhereInput> | null
    judging?: XOR<JudgingNullableRelationFilter, judgingWhereInput> | null
    judging_run_output?: XOR<Judging_run_outputNullableRelationFilter, judging_run_outputWhereInput> | null
  }, "runid" | "judgingid_testcaseid">

  export type judging_runOrderByWithAggregationInput = {
    runid?: SortOrder
    judgingid?: SortOrderInput | SortOrder
    testcaseid?: SortOrderInput | SortOrder
    runresult?: SortOrderInput | SortOrder
    runtime?: SortOrderInput | SortOrder
    endtime?: SortOrderInput | SortOrder
    judgetaskid?: SortOrderInput | SortOrder
    _count?: judging_runCountOrderByAggregateInput
    _avg?: judging_runAvgOrderByAggregateInput
    _max?: judging_runMaxOrderByAggregateInput
    _min?: judging_runMinOrderByAggregateInput
    _sum?: judging_runSumOrderByAggregateInput
  }

  export type judging_runScalarWhereWithAggregatesInput = {
    AND?: judging_runScalarWhereWithAggregatesInput | judging_runScalarWhereWithAggregatesInput[]
    OR?: judging_runScalarWhereWithAggregatesInput[]
    NOT?: judging_runScalarWhereWithAggregatesInput | judging_runScalarWhereWithAggregatesInput[]
    runid?: IntWithAggregatesFilter<"judging_run"> | number
    judgingid?: IntNullableWithAggregatesFilter<"judging_run"> | number | null
    testcaseid?: IntNullableWithAggregatesFilter<"judging_run"> | number | null
    runresult?: StringNullableWithAggregatesFilter<"judging_run"> | string | null
    runtime?: FloatNullableWithAggregatesFilter<"judging_run"> | number | null
    endtime?: DecimalNullableWithAggregatesFilter<"judging_run"> | Decimal | DecimalJsLike | number | string | null
    judgetaskid?: IntNullableWithAggregatesFilter<"judging_run"> | number | null
  }

  export type judging_run_outputWhereInput = {
    AND?: judging_run_outputWhereInput | judging_run_outputWhereInput[]
    OR?: judging_run_outputWhereInput[]
    NOT?: judging_run_outputWhereInput | judging_run_outputWhereInput[]
    runid?: IntFilter<"judging_run_output"> | number
    output_run?: BytesNullableFilter<"judging_run_output"> | Buffer | null
    output_diff?: BytesNullableFilter<"judging_run_output"> | Buffer | null
    output_error?: BytesNullableFilter<"judging_run_output"> | Buffer | null
    output_system?: BytesNullableFilter<"judging_run_output"> | Buffer | null
    metadata?: BytesNullableFilter<"judging_run_output"> | Buffer | null
    judging_run?: XOR<Judging_runRelationFilter, judging_runWhereInput>
  }

  export type judging_run_outputOrderByWithRelationInput = {
    runid?: SortOrder
    output_run?: SortOrderInput | SortOrder
    output_diff?: SortOrderInput | SortOrder
    output_error?: SortOrderInput | SortOrder
    output_system?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    judging_run?: judging_runOrderByWithRelationInput
  }

  export type judging_run_outputWhereUniqueInput = Prisma.AtLeast<{
    runid?: number
    AND?: judging_run_outputWhereInput | judging_run_outputWhereInput[]
    OR?: judging_run_outputWhereInput[]
    NOT?: judging_run_outputWhereInput | judging_run_outputWhereInput[]
    output_run?: BytesNullableFilter<"judging_run_output"> | Buffer | null
    output_diff?: BytesNullableFilter<"judging_run_output"> | Buffer | null
    output_error?: BytesNullableFilter<"judging_run_output"> | Buffer | null
    output_system?: BytesNullableFilter<"judging_run_output"> | Buffer | null
    metadata?: BytesNullableFilter<"judging_run_output"> | Buffer | null
    judging_run?: XOR<Judging_runRelationFilter, judging_runWhereInput>
  }, "runid">

  export type judging_run_outputOrderByWithAggregationInput = {
    runid?: SortOrder
    output_run?: SortOrderInput | SortOrder
    output_diff?: SortOrderInput | SortOrder
    output_error?: SortOrderInput | SortOrder
    output_system?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: judging_run_outputCountOrderByAggregateInput
    _avg?: judging_run_outputAvgOrderByAggregateInput
    _max?: judging_run_outputMaxOrderByAggregateInput
    _min?: judging_run_outputMinOrderByAggregateInput
    _sum?: judging_run_outputSumOrderByAggregateInput
  }

  export type judging_run_outputScalarWhereWithAggregatesInput = {
    AND?: judging_run_outputScalarWhereWithAggregatesInput | judging_run_outputScalarWhereWithAggregatesInput[]
    OR?: judging_run_outputScalarWhereWithAggregatesInput[]
    NOT?: judging_run_outputScalarWhereWithAggregatesInput | judging_run_outputScalarWhereWithAggregatesInput[]
    runid?: IntWithAggregatesFilter<"judging_run_output"> | number
    output_run?: BytesNullableWithAggregatesFilter<"judging_run_output"> | Buffer | null
    output_diff?: BytesNullableWithAggregatesFilter<"judging_run_output"> | Buffer | null
    output_error?: BytesNullableWithAggregatesFilter<"judging_run_output"> | Buffer | null
    output_system?: BytesNullableWithAggregatesFilter<"judging_run_output"> | Buffer | null
    metadata?: BytesNullableWithAggregatesFilter<"judging_run_output"> | Buffer | null
  }

  export type languageWhereInput = {
    AND?: languageWhereInput | languageWhereInput[]
    OR?: languageWhereInput[]
    NOT?: languageWhereInput | languageWhereInput[]
    langid?: StringFilter<"language"> | string
    externalid?: StringNullableFilter<"language"> | string | null
    name?: StringFilter<"language"> | string
    extensions?: StringNullableFilter<"language"> | string | null
    require_entry_point?: BoolFilter<"language"> | boolean
    entry_point_description?: StringNullableFilter<"language"> | string | null
    allow_submit?: BoolFilter<"language"> | boolean
    allow_judge?: BoolFilter<"language"> | boolean
    time_factor?: FloatFilter<"language"> | number
    compile_script?: StringNullableFilter<"language"> | string | null
    filter_compiler_files?: BoolFilter<"language"> | boolean
    executable?: XOR<ExecutableNullableRelationFilter, executableWhereInput> | null
    submission?: SubmissionListRelationFilter
  }

  export type languageOrderByWithRelationInput = {
    langid?: SortOrder
    externalid?: SortOrderInput | SortOrder
    name?: SortOrder
    extensions?: SortOrderInput | SortOrder
    require_entry_point?: SortOrder
    entry_point_description?: SortOrderInput | SortOrder
    allow_submit?: SortOrder
    allow_judge?: SortOrder
    time_factor?: SortOrder
    compile_script?: SortOrderInput | SortOrder
    filter_compiler_files?: SortOrder
    executable?: executableOrderByWithRelationInput
    submission?: submissionOrderByRelationAggregateInput
  }

  export type languageWhereUniqueInput = Prisma.AtLeast<{
    langid?: string
    externalid?: string
    AND?: languageWhereInput | languageWhereInput[]
    OR?: languageWhereInput[]
    NOT?: languageWhereInput | languageWhereInput[]
    name?: StringFilter<"language"> | string
    extensions?: StringNullableFilter<"language"> | string | null
    require_entry_point?: BoolFilter<"language"> | boolean
    entry_point_description?: StringNullableFilter<"language"> | string | null
    allow_submit?: BoolFilter<"language"> | boolean
    allow_judge?: BoolFilter<"language"> | boolean
    time_factor?: FloatFilter<"language"> | number
    compile_script?: StringNullableFilter<"language"> | string | null
    filter_compiler_files?: BoolFilter<"language"> | boolean
    executable?: XOR<ExecutableNullableRelationFilter, executableWhereInput> | null
    submission?: SubmissionListRelationFilter
  }, "langid" | "externalid">

  export type languageOrderByWithAggregationInput = {
    langid?: SortOrder
    externalid?: SortOrderInput | SortOrder
    name?: SortOrder
    extensions?: SortOrderInput | SortOrder
    require_entry_point?: SortOrder
    entry_point_description?: SortOrderInput | SortOrder
    allow_submit?: SortOrder
    allow_judge?: SortOrder
    time_factor?: SortOrder
    compile_script?: SortOrderInput | SortOrder
    filter_compiler_files?: SortOrder
    _count?: languageCountOrderByAggregateInput
    _avg?: languageAvgOrderByAggregateInput
    _max?: languageMaxOrderByAggregateInput
    _min?: languageMinOrderByAggregateInput
    _sum?: languageSumOrderByAggregateInput
  }

  export type languageScalarWhereWithAggregatesInput = {
    AND?: languageScalarWhereWithAggregatesInput | languageScalarWhereWithAggregatesInput[]
    OR?: languageScalarWhereWithAggregatesInput[]
    NOT?: languageScalarWhereWithAggregatesInput | languageScalarWhereWithAggregatesInput[]
    langid?: StringWithAggregatesFilter<"language"> | string
    externalid?: StringNullableWithAggregatesFilter<"language"> | string | null
    name?: StringWithAggregatesFilter<"language"> | string
    extensions?: StringNullableWithAggregatesFilter<"language"> | string | null
    require_entry_point?: BoolWithAggregatesFilter<"language"> | boolean
    entry_point_description?: StringNullableWithAggregatesFilter<"language"> | string | null
    allow_submit?: BoolWithAggregatesFilter<"language"> | boolean
    allow_judge?: BoolWithAggregatesFilter<"language"> | boolean
    time_factor?: FloatWithAggregatesFilter<"language"> | number
    compile_script?: StringNullableWithAggregatesFilter<"language"> | string | null
    filter_compiler_files?: BoolWithAggregatesFilter<"language"> | boolean
  }

  export type problemWhereInput = {
    AND?: problemWhereInput | problemWhereInput[]
    OR?: problemWhereInput[]
    NOT?: problemWhereInput | problemWhereInput[]
    probid?: IntFilter<"problem"> | number
    externalid?: StringNullableFilter<"problem"> | string | null
    name?: StringFilter<"problem"> | string
    timelimit?: FloatFilter<"problem"> | number
    memlimit?: IntNullableFilter<"problem"> | number | null
    outputlimit?: IntNullableFilter<"problem"> | number | null
    special_run?: StringNullableFilter<"problem"> | string | null
    special_compare?: StringNullableFilter<"problem"> | string | null
    special_compare_args?: StringNullableFilter<"problem"> | string | null
    combined_run_compare?: BoolFilter<"problem"> | boolean
    problemtext?: BytesNullableFilter<"problem"> | Buffer | null
    problemtext_type?: StringNullableFilter<"problem"> | string | null
    clarification?: ClarificationListRelationFilter
    contestproblem?: ContestproblemListRelationFilter
    executable_problem_special_runToexecutable?: XOR<ExecutableNullableRelationFilter, executableWhereInput> | null
    executable_problem_special_compareToexecutable?: XOR<ExecutableNullableRelationFilter, executableWhereInput> | null
    problem_attachment?: Problem_attachmentListRelationFilter
    scorecache?: ScorecacheListRelationFilter
    submission?: SubmissionListRelationFilter
    testcase?: TestcaseListRelationFilter
  }

  export type problemOrderByWithRelationInput = {
    probid?: SortOrder
    externalid?: SortOrderInput | SortOrder
    name?: SortOrder
    timelimit?: SortOrder
    memlimit?: SortOrderInput | SortOrder
    outputlimit?: SortOrderInput | SortOrder
    special_run?: SortOrderInput | SortOrder
    special_compare?: SortOrderInput | SortOrder
    special_compare_args?: SortOrderInput | SortOrder
    combined_run_compare?: SortOrder
    problemtext?: SortOrderInput | SortOrder
    problemtext_type?: SortOrderInput | SortOrder
    clarification?: clarificationOrderByRelationAggregateInput
    contestproblem?: contestproblemOrderByRelationAggregateInput
    executable_problem_special_runToexecutable?: executableOrderByWithRelationInput
    executable_problem_special_compareToexecutable?: executableOrderByWithRelationInput
    problem_attachment?: problem_attachmentOrderByRelationAggregateInput
    scorecache?: scorecacheOrderByRelationAggregateInput
    submission?: submissionOrderByRelationAggregateInput
    testcase?: testcaseOrderByRelationAggregateInput
  }

  export type problemWhereUniqueInput = Prisma.AtLeast<{
    probid?: number
    externalid?: string
    AND?: problemWhereInput | problemWhereInput[]
    OR?: problemWhereInput[]
    NOT?: problemWhereInput | problemWhereInput[]
    name?: StringFilter<"problem"> | string
    timelimit?: FloatFilter<"problem"> | number
    memlimit?: IntNullableFilter<"problem"> | number | null
    outputlimit?: IntNullableFilter<"problem"> | number | null
    special_run?: StringNullableFilter<"problem"> | string | null
    special_compare?: StringNullableFilter<"problem"> | string | null
    special_compare_args?: StringNullableFilter<"problem"> | string | null
    combined_run_compare?: BoolFilter<"problem"> | boolean
    problemtext?: BytesNullableFilter<"problem"> | Buffer | null
    problemtext_type?: StringNullableFilter<"problem"> | string | null
    clarification?: ClarificationListRelationFilter
    contestproblem?: ContestproblemListRelationFilter
    executable_problem_special_runToexecutable?: XOR<ExecutableNullableRelationFilter, executableWhereInput> | null
    executable_problem_special_compareToexecutable?: XOR<ExecutableNullableRelationFilter, executableWhereInput> | null
    problem_attachment?: Problem_attachmentListRelationFilter
    scorecache?: ScorecacheListRelationFilter
    submission?: SubmissionListRelationFilter
    testcase?: TestcaseListRelationFilter
  }, "probid" | "externalid">

  export type problemOrderByWithAggregationInput = {
    probid?: SortOrder
    externalid?: SortOrderInput | SortOrder
    name?: SortOrder
    timelimit?: SortOrder
    memlimit?: SortOrderInput | SortOrder
    outputlimit?: SortOrderInput | SortOrder
    special_run?: SortOrderInput | SortOrder
    special_compare?: SortOrderInput | SortOrder
    special_compare_args?: SortOrderInput | SortOrder
    combined_run_compare?: SortOrder
    problemtext?: SortOrderInput | SortOrder
    problemtext_type?: SortOrderInput | SortOrder
    _count?: problemCountOrderByAggregateInput
    _avg?: problemAvgOrderByAggregateInput
    _max?: problemMaxOrderByAggregateInput
    _min?: problemMinOrderByAggregateInput
    _sum?: problemSumOrderByAggregateInput
  }

  export type problemScalarWhereWithAggregatesInput = {
    AND?: problemScalarWhereWithAggregatesInput | problemScalarWhereWithAggregatesInput[]
    OR?: problemScalarWhereWithAggregatesInput[]
    NOT?: problemScalarWhereWithAggregatesInput | problemScalarWhereWithAggregatesInput[]
    probid?: IntWithAggregatesFilter<"problem"> | number
    externalid?: StringNullableWithAggregatesFilter<"problem"> | string | null
    name?: StringWithAggregatesFilter<"problem"> | string
    timelimit?: FloatWithAggregatesFilter<"problem"> | number
    memlimit?: IntNullableWithAggregatesFilter<"problem"> | number | null
    outputlimit?: IntNullableWithAggregatesFilter<"problem"> | number | null
    special_run?: StringNullableWithAggregatesFilter<"problem"> | string | null
    special_compare?: StringNullableWithAggregatesFilter<"problem"> | string | null
    special_compare_args?: StringNullableWithAggregatesFilter<"problem"> | string | null
    combined_run_compare?: BoolWithAggregatesFilter<"problem"> | boolean
    problemtext?: BytesNullableWithAggregatesFilter<"problem"> | Buffer | null
    problemtext_type?: StringNullableWithAggregatesFilter<"problem"> | string | null
  }

  export type problem_attachmentWhereInput = {
    AND?: problem_attachmentWhereInput | problem_attachmentWhereInput[]
    OR?: problem_attachmentWhereInput[]
    NOT?: problem_attachmentWhereInput | problem_attachmentWhereInput[]
    attachmentid?: IntFilter<"problem_attachment"> | number
    probid?: IntNullableFilter<"problem_attachment"> | number | null
    name?: StringFilter<"problem_attachment"> | string
    type?: StringFilter<"problem_attachment"> | string
    problem?: XOR<ProblemNullableRelationFilter, problemWhereInput> | null
    problem_attachment_content?: XOR<Problem_attachment_contentNullableRelationFilter, problem_attachment_contentWhereInput> | null
  }

  export type problem_attachmentOrderByWithRelationInput = {
    attachmentid?: SortOrder
    probid?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    problem?: problemOrderByWithRelationInput
    problem_attachment_content?: problem_attachment_contentOrderByWithRelationInput
  }

  export type problem_attachmentWhereUniqueInput = Prisma.AtLeast<{
    attachmentid?: number
    AND?: problem_attachmentWhereInput | problem_attachmentWhereInput[]
    OR?: problem_attachmentWhereInput[]
    NOT?: problem_attachmentWhereInput | problem_attachmentWhereInput[]
    probid?: IntNullableFilter<"problem_attachment"> | number | null
    name?: StringFilter<"problem_attachment"> | string
    type?: StringFilter<"problem_attachment"> | string
    problem?: XOR<ProblemNullableRelationFilter, problemWhereInput> | null
    problem_attachment_content?: XOR<Problem_attachment_contentNullableRelationFilter, problem_attachment_contentWhereInput> | null
  }, "attachmentid">

  export type problem_attachmentOrderByWithAggregationInput = {
    attachmentid?: SortOrder
    probid?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    _count?: problem_attachmentCountOrderByAggregateInput
    _avg?: problem_attachmentAvgOrderByAggregateInput
    _max?: problem_attachmentMaxOrderByAggregateInput
    _min?: problem_attachmentMinOrderByAggregateInput
    _sum?: problem_attachmentSumOrderByAggregateInput
  }

  export type problem_attachmentScalarWhereWithAggregatesInput = {
    AND?: problem_attachmentScalarWhereWithAggregatesInput | problem_attachmentScalarWhereWithAggregatesInput[]
    OR?: problem_attachmentScalarWhereWithAggregatesInput[]
    NOT?: problem_attachmentScalarWhereWithAggregatesInput | problem_attachmentScalarWhereWithAggregatesInput[]
    attachmentid?: IntWithAggregatesFilter<"problem_attachment"> | number
    probid?: IntNullableWithAggregatesFilter<"problem_attachment"> | number | null
    name?: StringWithAggregatesFilter<"problem_attachment"> | string
    type?: StringWithAggregatesFilter<"problem_attachment"> | string
  }

  export type problem_attachment_contentWhereInput = {
    AND?: problem_attachment_contentWhereInput | problem_attachment_contentWhereInput[]
    OR?: problem_attachment_contentWhereInput[]
    NOT?: problem_attachment_contentWhereInput | problem_attachment_contentWhereInput[]
    attachmentid?: IntFilter<"problem_attachment_content"> | number
    content?: BytesFilter<"problem_attachment_content"> | Buffer
    problem_attachment?: XOR<Problem_attachmentRelationFilter, problem_attachmentWhereInput>
  }

  export type problem_attachment_contentOrderByWithRelationInput = {
    attachmentid?: SortOrder
    content?: SortOrder
    problem_attachment?: problem_attachmentOrderByWithRelationInput
  }

  export type problem_attachment_contentWhereUniqueInput = Prisma.AtLeast<{
    attachmentid?: number
    AND?: problem_attachment_contentWhereInput | problem_attachment_contentWhereInput[]
    OR?: problem_attachment_contentWhereInput[]
    NOT?: problem_attachment_contentWhereInput | problem_attachment_contentWhereInput[]
    content?: BytesFilter<"problem_attachment_content"> | Buffer
    problem_attachment?: XOR<Problem_attachmentRelationFilter, problem_attachmentWhereInput>
  }, "attachmentid">

  export type problem_attachment_contentOrderByWithAggregationInput = {
    attachmentid?: SortOrder
    content?: SortOrder
    _count?: problem_attachment_contentCountOrderByAggregateInput
    _avg?: problem_attachment_contentAvgOrderByAggregateInput
    _max?: problem_attachment_contentMaxOrderByAggregateInput
    _min?: problem_attachment_contentMinOrderByAggregateInput
    _sum?: problem_attachment_contentSumOrderByAggregateInput
  }

  export type problem_attachment_contentScalarWhereWithAggregatesInput = {
    AND?: problem_attachment_contentScalarWhereWithAggregatesInput | problem_attachment_contentScalarWhereWithAggregatesInput[]
    OR?: problem_attachment_contentScalarWhereWithAggregatesInput[]
    NOT?: problem_attachment_contentScalarWhereWithAggregatesInput | problem_attachment_contentScalarWhereWithAggregatesInput[]
    attachmentid?: IntWithAggregatesFilter<"problem_attachment_content"> | number
    content?: BytesWithAggregatesFilter<"problem_attachment_content"> | Buffer
  }

  export type queuetaskWhereInput = {
    AND?: queuetaskWhereInput | queuetaskWhereInput[]
    OR?: queuetaskWhereInput[]
    NOT?: queuetaskWhereInput | queuetaskWhereInput[]
    queuetaskid?: IntFilter<"queuetask"> | number
    teamid?: IntNullableFilter<"queuetask"> | number | null
    jobid?: IntNullableFilter<"queuetask"> | number | null
    priority?: IntFilter<"queuetask"> | number
    teampriority?: IntFilter<"queuetask"> | number
    starttime?: DecimalNullableFilter<"queuetask"> | Decimal | DecimalJsLike | number | string | null
    team?: XOR<TeamNullableRelationFilter, teamWhereInput> | null
  }

  export type queuetaskOrderByWithRelationInput = {
    queuetaskid?: SortOrder
    teamid?: SortOrderInput | SortOrder
    jobid?: SortOrderInput | SortOrder
    priority?: SortOrder
    teampriority?: SortOrder
    starttime?: SortOrderInput | SortOrder
    team?: teamOrderByWithRelationInput
  }

  export type queuetaskWhereUniqueInput = Prisma.AtLeast<{
    queuetaskid?: number
    AND?: queuetaskWhereInput | queuetaskWhereInput[]
    OR?: queuetaskWhereInput[]
    NOT?: queuetaskWhereInput | queuetaskWhereInput[]
    teamid?: IntNullableFilter<"queuetask"> | number | null
    jobid?: IntNullableFilter<"queuetask"> | number | null
    priority?: IntFilter<"queuetask"> | number
    teampriority?: IntFilter<"queuetask"> | number
    starttime?: DecimalNullableFilter<"queuetask"> | Decimal | DecimalJsLike | number | string | null
    team?: XOR<TeamNullableRelationFilter, teamWhereInput> | null
  }, "queuetaskid">

  export type queuetaskOrderByWithAggregationInput = {
    queuetaskid?: SortOrder
    teamid?: SortOrderInput | SortOrder
    jobid?: SortOrderInput | SortOrder
    priority?: SortOrder
    teampriority?: SortOrder
    starttime?: SortOrderInput | SortOrder
    _count?: queuetaskCountOrderByAggregateInput
    _avg?: queuetaskAvgOrderByAggregateInput
    _max?: queuetaskMaxOrderByAggregateInput
    _min?: queuetaskMinOrderByAggregateInput
    _sum?: queuetaskSumOrderByAggregateInput
  }

  export type queuetaskScalarWhereWithAggregatesInput = {
    AND?: queuetaskScalarWhereWithAggregatesInput | queuetaskScalarWhereWithAggregatesInput[]
    OR?: queuetaskScalarWhereWithAggregatesInput[]
    NOT?: queuetaskScalarWhereWithAggregatesInput | queuetaskScalarWhereWithAggregatesInput[]
    queuetaskid?: IntWithAggregatesFilter<"queuetask"> | number
    teamid?: IntNullableWithAggregatesFilter<"queuetask"> | number | null
    jobid?: IntNullableWithAggregatesFilter<"queuetask"> | number | null
    priority?: IntWithAggregatesFilter<"queuetask"> | number
    teampriority?: IntWithAggregatesFilter<"queuetask"> | number
    starttime?: DecimalNullableWithAggregatesFilter<"queuetask"> | Decimal | DecimalJsLike | number | string | null
  }

  export type rankcacheWhereInput = {
    AND?: rankcacheWhereInput | rankcacheWhereInput[]
    OR?: rankcacheWhereInput[]
    NOT?: rankcacheWhereInput | rankcacheWhereInput[]
    cid?: IntFilter<"rankcache"> | number
    teamid?: IntFilter<"rankcache"> | number
    points_restricted?: IntFilter<"rankcache"> | number
    totaltime_restricted?: IntFilter<"rankcache"> | number
    points_public?: IntFilter<"rankcache"> | number
    totaltime_public?: IntFilter<"rankcache"> | number
    contest?: XOR<ContestRelationFilter, contestWhereInput>
    team?: XOR<TeamRelationFilter, teamWhereInput>
  }

  export type rankcacheOrderByWithRelationInput = {
    cid?: SortOrder
    teamid?: SortOrder
    points_restricted?: SortOrder
    totaltime_restricted?: SortOrder
    points_public?: SortOrder
    totaltime_public?: SortOrder
    contest?: contestOrderByWithRelationInput
    team?: teamOrderByWithRelationInput
  }

  export type rankcacheWhereUniqueInput = Prisma.AtLeast<{
    cid_teamid?: rankcacheCidTeamidCompoundUniqueInput
    AND?: rankcacheWhereInput | rankcacheWhereInput[]
    OR?: rankcacheWhereInput[]
    NOT?: rankcacheWhereInput | rankcacheWhereInput[]
    cid?: IntFilter<"rankcache"> | number
    teamid?: IntFilter<"rankcache"> | number
    points_restricted?: IntFilter<"rankcache"> | number
    totaltime_restricted?: IntFilter<"rankcache"> | number
    points_public?: IntFilter<"rankcache"> | number
    totaltime_public?: IntFilter<"rankcache"> | number
    contest?: XOR<ContestRelationFilter, contestWhereInput>
    team?: XOR<TeamRelationFilter, teamWhereInput>
  }, "cid_teamid">

  export type rankcacheOrderByWithAggregationInput = {
    cid?: SortOrder
    teamid?: SortOrder
    points_restricted?: SortOrder
    totaltime_restricted?: SortOrder
    points_public?: SortOrder
    totaltime_public?: SortOrder
    _count?: rankcacheCountOrderByAggregateInput
    _avg?: rankcacheAvgOrderByAggregateInput
    _max?: rankcacheMaxOrderByAggregateInput
    _min?: rankcacheMinOrderByAggregateInput
    _sum?: rankcacheSumOrderByAggregateInput
  }

  export type rankcacheScalarWhereWithAggregatesInput = {
    AND?: rankcacheScalarWhereWithAggregatesInput | rankcacheScalarWhereWithAggregatesInput[]
    OR?: rankcacheScalarWhereWithAggregatesInput[]
    NOT?: rankcacheScalarWhereWithAggregatesInput | rankcacheScalarWhereWithAggregatesInput[]
    cid?: IntWithAggregatesFilter<"rankcache"> | number
    teamid?: IntWithAggregatesFilter<"rankcache"> | number
    points_restricted?: IntWithAggregatesFilter<"rankcache"> | number
    totaltime_restricted?: IntWithAggregatesFilter<"rankcache"> | number
    points_public?: IntWithAggregatesFilter<"rankcache"> | number
    totaltime_public?: IntWithAggregatesFilter<"rankcache"> | number
  }

  export type rejudgingWhereInput = {
    AND?: rejudgingWhereInput | rejudgingWhereInput[]
    OR?: rejudgingWhereInput[]
    NOT?: rejudgingWhereInput | rejudgingWhereInput[]
    rejudgingid?: IntFilter<"rejudging"> | number
    userid_start?: IntNullableFilter<"rejudging"> | number | null
    userid_finish?: IntNullableFilter<"rejudging"> | number | null
    starttime?: DecimalFilter<"rejudging"> | Decimal | DecimalJsLike | number | string
    endtime?: DecimalNullableFilter<"rejudging"> | Decimal | DecimalJsLike | number | string | null
    reason?: StringFilter<"rejudging"> | string
    valid?: BoolFilter<"rejudging"> | boolean
    auto_apply?: BoolFilter<"rejudging"> | boolean
    repeat?: IntNullableFilter<"rejudging"> | number | null
    repeat_rejudgingid?: IntNullableFilter<"rejudging"> | number | null
    judging?: JudgingListRelationFilter
    rejudging?: XOR<RejudgingNullableRelationFilter, rejudgingWhereInput> | null
    other_rejudging?: RejudgingListRelationFilter
    user_rejudging_userid_startTouser?: XOR<UserNullableRelationFilter, userWhereInput> | null
    user_rejudging_userid_finishTouser?: XOR<UserNullableRelationFilter, userWhereInput> | null
    submission?: SubmissionListRelationFilter
  }

  export type rejudgingOrderByWithRelationInput = {
    rejudgingid?: SortOrder
    userid_start?: SortOrderInput | SortOrder
    userid_finish?: SortOrderInput | SortOrder
    starttime?: SortOrder
    endtime?: SortOrderInput | SortOrder
    reason?: SortOrder
    valid?: SortOrder
    auto_apply?: SortOrder
    repeat?: SortOrderInput | SortOrder
    repeat_rejudgingid?: SortOrderInput | SortOrder
    judging?: judgingOrderByRelationAggregateInput
    rejudging?: rejudgingOrderByWithRelationInput
    other_rejudging?: rejudgingOrderByRelationAggregateInput
    user_rejudging_userid_startTouser?: userOrderByWithRelationInput
    user_rejudging_userid_finishTouser?: userOrderByWithRelationInput
    submission?: submissionOrderByRelationAggregateInput
  }

  export type rejudgingWhereUniqueInput = Prisma.AtLeast<{
    rejudgingid?: number
    AND?: rejudgingWhereInput | rejudgingWhereInput[]
    OR?: rejudgingWhereInput[]
    NOT?: rejudgingWhereInput | rejudgingWhereInput[]
    userid_start?: IntNullableFilter<"rejudging"> | number | null
    userid_finish?: IntNullableFilter<"rejudging"> | number | null
    starttime?: DecimalFilter<"rejudging"> | Decimal | DecimalJsLike | number | string
    endtime?: DecimalNullableFilter<"rejudging"> | Decimal | DecimalJsLike | number | string | null
    reason?: StringFilter<"rejudging"> | string
    valid?: BoolFilter<"rejudging"> | boolean
    auto_apply?: BoolFilter<"rejudging"> | boolean
    repeat?: IntNullableFilter<"rejudging"> | number | null
    repeat_rejudgingid?: IntNullableFilter<"rejudging"> | number | null
    judging?: JudgingListRelationFilter
    rejudging?: XOR<RejudgingNullableRelationFilter, rejudgingWhereInput> | null
    other_rejudging?: RejudgingListRelationFilter
    user_rejudging_userid_startTouser?: XOR<UserNullableRelationFilter, userWhereInput> | null
    user_rejudging_userid_finishTouser?: XOR<UserNullableRelationFilter, userWhereInput> | null
    submission?: SubmissionListRelationFilter
  }, "rejudgingid">

  export type rejudgingOrderByWithAggregationInput = {
    rejudgingid?: SortOrder
    userid_start?: SortOrderInput | SortOrder
    userid_finish?: SortOrderInput | SortOrder
    starttime?: SortOrder
    endtime?: SortOrderInput | SortOrder
    reason?: SortOrder
    valid?: SortOrder
    auto_apply?: SortOrder
    repeat?: SortOrderInput | SortOrder
    repeat_rejudgingid?: SortOrderInput | SortOrder
    _count?: rejudgingCountOrderByAggregateInput
    _avg?: rejudgingAvgOrderByAggregateInput
    _max?: rejudgingMaxOrderByAggregateInput
    _min?: rejudgingMinOrderByAggregateInput
    _sum?: rejudgingSumOrderByAggregateInput
  }

  export type rejudgingScalarWhereWithAggregatesInput = {
    AND?: rejudgingScalarWhereWithAggregatesInput | rejudgingScalarWhereWithAggregatesInput[]
    OR?: rejudgingScalarWhereWithAggregatesInput[]
    NOT?: rejudgingScalarWhereWithAggregatesInput | rejudgingScalarWhereWithAggregatesInput[]
    rejudgingid?: IntWithAggregatesFilter<"rejudging"> | number
    userid_start?: IntNullableWithAggregatesFilter<"rejudging"> | number | null
    userid_finish?: IntNullableWithAggregatesFilter<"rejudging"> | number | null
    starttime?: DecimalWithAggregatesFilter<"rejudging"> | Decimal | DecimalJsLike | number | string
    endtime?: DecimalNullableWithAggregatesFilter<"rejudging"> | Decimal | DecimalJsLike | number | string | null
    reason?: StringWithAggregatesFilter<"rejudging"> | string
    valid?: BoolWithAggregatesFilter<"rejudging"> | boolean
    auto_apply?: BoolWithAggregatesFilter<"rejudging"> | boolean
    repeat?: IntNullableWithAggregatesFilter<"rejudging"> | number | null
    repeat_rejudgingid?: IntNullableWithAggregatesFilter<"rejudging"> | number | null
  }

  export type removed_intervalWhereInput = {
    AND?: removed_intervalWhereInput | removed_intervalWhereInput[]
    OR?: removed_intervalWhereInput[]
    NOT?: removed_intervalWhereInput | removed_intervalWhereInput[]
    intervalid?: IntFilter<"removed_interval"> | number
    cid?: IntNullableFilter<"removed_interval"> | number | null
    starttime?: DecimalFilter<"removed_interval"> | Decimal | DecimalJsLike | number | string
    endtime?: DecimalFilter<"removed_interval"> | Decimal | DecimalJsLike | number | string
    starttime_string?: StringFilter<"removed_interval"> | string
    endtime_string?: StringFilter<"removed_interval"> | string
    contest?: XOR<ContestNullableRelationFilter, contestWhereInput> | null
  }

  export type removed_intervalOrderByWithRelationInput = {
    intervalid?: SortOrder
    cid?: SortOrderInput | SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
    starttime_string?: SortOrder
    endtime_string?: SortOrder
    contest?: contestOrderByWithRelationInput
  }

  export type removed_intervalWhereUniqueInput = Prisma.AtLeast<{
    intervalid?: number
    AND?: removed_intervalWhereInput | removed_intervalWhereInput[]
    OR?: removed_intervalWhereInput[]
    NOT?: removed_intervalWhereInput | removed_intervalWhereInput[]
    cid?: IntNullableFilter<"removed_interval"> | number | null
    starttime?: DecimalFilter<"removed_interval"> | Decimal | DecimalJsLike | number | string
    endtime?: DecimalFilter<"removed_interval"> | Decimal | DecimalJsLike | number | string
    starttime_string?: StringFilter<"removed_interval"> | string
    endtime_string?: StringFilter<"removed_interval"> | string
    contest?: XOR<ContestNullableRelationFilter, contestWhereInput> | null
  }, "intervalid">

  export type removed_intervalOrderByWithAggregationInput = {
    intervalid?: SortOrder
    cid?: SortOrderInput | SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
    starttime_string?: SortOrder
    endtime_string?: SortOrder
    _count?: removed_intervalCountOrderByAggregateInput
    _avg?: removed_intervalAvgOrderByAggregateInput
    _max?: removed_intervalMaxOrderByAggregateInput
    _min?: removed_intervalMinOrderByAggregateInput
    _sum?: removed_intervalSumOrderByAggregateInput
  }

  export type removed_intervalScalarWhereWithAggregatesInput = {
    AND?: removed_intervalScalarWhereWithAggregatesInput | removed_intervalScalarWhereWithAggregatesInput[]
    OR?: removed_intervalScalarWhereWithAggregatesInput[]
    NOT?: removed_intervalScalarWhereWithAggregatesInput | removed_intervalScalarWhereWithAggregatesInput[]
    intervalid?: IntWithAggregatesFilter<"removed_interval"> | number
    cid?: IntNullableWithAggregatesFilter<"removed_interval"> | number | null
    starttime?: DecimalWithAggregatesFilter<"removed_interval"> | Decimal | DecimalJsLike | number | string
    endtime?: DecimalWithAggregatesFilter<"removed_interval"> | Decimal | DecimalJsLike | number | string
    starttime_string?: StringWithAggregatesFilter<"removed_interval"> | string
    endtime_string?: StringWithAggregatesFilter<"removed_interval"> | string
  }

  export type roleWhereInput = {
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    roleid?: IntFilter<"role"> | number
    role?: StringFilter<"role"> | string
    description?: StringFilter<"role"> | string
    userrole?: UserroleListRelationFilter
  }

  export type roleOrderByWithRelationInput = {
    roleid?: SortOrder
    role?: SortOrder
    description?: SortOrder
    userrole?: userroleOrderByRelationAggregateInput
  }

  export type roleWhereUniqueInput = Prisma.AtLeast<{
    roleid?: number
    role?: string
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    description?: StringFilter<"role"> | string
    userrole?: UserroleListRelationFilter
  }, "roleid" | "role">

  export type roleOrderByWithAggregationInput = {
    roleid?: SortOrder
    role?: SortOrder
    description?: SortOrder
    _count?: roleCountOrderByAggregateInput
    _avg?: roleAvgOrderByAggregateInput
    _max?: roleMaxOrderByAggregateInput
    _min?: roleMinOrderByAggregateInput
    _sum?: roleSumOrderByAggregateInput
  }

  export type roleScalarWhereWithAggregatesInput = {
    AND?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    OR?: roleScalarWhereWithAggregatesInput[]
    NOT?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    roleid?: IntWithAggregatesFilter<"role"> | number
    role?: StringWithAggregatesFilter<"role"> | string
    description?: StringWithAggregatesFilter<"role"> | string
  }

  export type scorecacheWhereInput = {
    AND?: scorecacheWhereInput | scorecacheWhereInput[]
    OR?: scorecacheWhereInput[]
    NOT?: scorecacheWhereInput | scorecacheWhereInput[]
    cid?: IntFilter<"scorecache"> | number
    teamid?: IntFilter<"scorecache"> | number
    probid?: IntFilter<"scorecache"> | number
    submissions_restricted?: IntFilter<"scorecache"> | number
    pending_restricted?: IntFilter<"scorecache"> | number
    solvetime_restricted?: DecimalFilter<"scorecache"> | Decimal | DecimalJsLike | number | string
    is_correct_restricted?: BoolFilter<"scorecache"> | boolean
    submissions_public?: IntFilter<"scorecache"> | number
    pending_public?: IntFilter<"scorecache"> | number
    solvetime_public?: DecimalFilter<"scorecache"> | Decimal | DecimalJsLike | number | string
    is_correct_public?: BoolFilter<"scorecache"> | boolean
    is_first_to_solve?: BoolFilter<"scorecache"> | boolean
    contest?: XOR<ContestRelationFilter, contestWhereInput>
    team?: XOR<TeamRelationFilter, teamWhereInput>
    problem?: XOR<ProblemRelationFilter, problemWhereInput>
  }

  export type scorecacheOrderByWithRelationInput = {
    cid?: SortOrder
    teamid?: SortOrder
    probid?: SortOrder
    submissions_restricted?: SortOrder
    pending_restricted?: SortOrder
    solvetime_restricted?: SortOrder
    is_correct_restricted?: SortOrder
    submissions_public?: SortOrder
    pending_public?: SortOrder
    solvetime_public?: SortOrder
    is_correct_public?: SortOrder
    is_first_to_solve?: SortOrder
    contest?: contestOrderByWithRelationInput
    team?: teamOrderByWithRelationInput
    problem?: problemOrderByWithRelationInput
  }

  export type scorecacheWhereUniqueInput = Prisma.AtLeast<{
    cid_teamid_probid?: scorecacheCidTeamidProbidCompoundUniqueInput
    AND?: scorecacheWhereInput | scorecacheWhereInput[]
    OR?: scorecacheWhereInput[]
    NOT?: scorecacheWhereInput | scorecacheWhereInput[]
    cid?: IntFilter<"scorecache"> | number
    teamid?: IntFilter<"scorecache"> | number
    probid?: IntFilter<"scorecache"> | number
    submissions_restricted?: IntFilter<"scorecache"> | number
    pending_restricted?: IntFilter<"scorecache"> | number
    solvetime_restricted?: DecimalFilter<"scorecache"> | Decimal | DecimalJsLike | number | string
    is_correct_restricted?: BoolFilter<"scorecache"> | boolean
    submissions_public?: IntFilter<"scorecache"> | number
    pending_public?: IntFilter<"scorecache"> | number
    solvetime_public?: DecimalFilter<"scorecache"> | Decimal | DecimalJsLike | number | string
    is_correct_public?: BoolFilter<"scorecache"> | boolean
    is_first_to_solve?: BoolFilter<"scorecache"> | boolean
    contest?: XOR<ContestRelationFilter, contestWhereInput>
    team?: XOR<TeamRelationFilter, teamWhereInput>
    problem?: XOR<ProblemRelationFilter, problemWhereInput>
  }, "cid_teamid_probid">

  export type scorecacheOrderByWithAggregationInput = {
    cid?: SortOrder
    teamid?: SortOrder
    probid?: SortOrder
    submissions_restricted?: SortOrder
    pending_restricted?: SortOrder
    solvetime_restricted?: SortOrder
    is_correct_restricted?: SortOrder
    submissions_public?: SortOrder
    pending_public?: SortOrder
    solvetime_public?: SortOrder
    is_correct_public?: SortOrder
    is_first_to_solve?: SortOrder
    _count?: scorecacheCountOrderByAggregateInput
    _avg?: scorecacheAvgOrderByAggregateInput
    _max?: scorecacheMaxOrderByAggregateInput
    _min?: scorecacheMinOrderByAggregateInput
    _sum?: scorecacheSumOrderByAggregateInput
  }

  export type scorecacheScalarWhereWithAggregatesInput = {
    AND?: scorecacheScalarWhereWithAggregatesInput | scorecacheScalarWhereWithAggregatesInput[]
    OR?: scorecacheScalarWhereWithAggregatesInput[]
    NOT?: scorecacheScalarWhereWithAggregatesInput | scorecacheScalarWhereWithAggregatesInput[]
    cid?: IntWithAggregatesFilter<"scorecache"> | number
    teamid?: IntWithAggregatesFilter<"scorecache"> | number
    probid?: IntWithAggregatesFilter<"scorecache"> | number
    submissions_restricted?: IntWithAggregatesFilter<"scorecache"> | number
    pending_restricted?: IntWithAggregatesFilter<"scorecache"> | number
    solvetime_restricted?: DecimalWithAggregatesFilter<"scorecache"> | Decimal | DecimalJsLike | number | string
    is_correct_restricted?: BoolWithAggregatesFilter<"scorecache"> | boolean
    submissions_public?: IntWithAggregatesFilter<"scorecache"> | number
    pending_public?: IntWithAggregatesFilter<"scorecache"> | number
    solvetime_public?: DecimalWithAggregatesFilter<"scorecache"> | Decimal | DecimalJsLike | number | string
    is_correct_public?: BoolWithAggregatesFilter<"scorecache"> | boolean
    is_first_to_solve?: BoolWithAggregatesFilter<"scorecache"> | boolean
  }

  export type sessionsWhereInput = {
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    sess_id?: BytesFilter<"sessions"> | Buffer
    sess_data?: BytesFilter<"sessions"> | Buffer
    sess_lifetime?: IntFilter<"sessions"> | number
    sess_time?: IntFilter<"sessions"> | number
  }

  export type sessionsOrderByWithRelationInput = {
    sess_id?: SortOrder
    sess_data?: SortOrder
    sess_lifetime?: SortOrder
    sess_time?: SortOrder
  }

  export type sessionsWhereUniqueInput = Prisma.AtLeast<{
    sess_id?: Buffer
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    sess_data?: BytesFilter<"sessions"> | Buffer
    sess_lifetime?: IntFilter<"sessions"> | number
    sess_time?: IntFilter<"sessions"> | number
  }, "sess_id">

  export type sessionsOrderByWithAggregationInput = {
    sess_id?: SortOrder
    sess_data?: SortOrder
    sess_lifetime?: SortOrder
    sess_time?: SortOrder
    _count?: sessionsCountOrderByAggregateInput
    _avg?: sessionsAvgOrderByAggregateInput
    _max?: sessionsMaxOrderByAggregateInput
    _min?: sessionsMinOrderByAggregateInput
    _sum?: sessionsSumOrderByAggregateInput
  }

  export type sessionsScalarWhereWithAggregatesInput = {
    AND?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    OR?: sessionsScalarWhereWithAggregatesInput[]
    NOT?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    sess_id?: BytesWithAggregatesFilter<"sessions"> | Buffer
    sess_data?: BytesWithAggregatesFilter<"sessions"> | Buffer
    sess_lifetime?: IntWithAggregatesFilter<"sessions"> | number
    sess_time?: IntWithAggregatesFilter<"sessions"> | number
  }

  export type submissionWhereInput = {
    AND?: submissionWhereInput | submissionWhereInput[]
    OR?: submissionWhereInput[]
    NOT?: submissionWhereInput | submissionWhereInput[]
    submitid?: IntFilter<"submission"> | number
    origsubmitid?: IntNullableFilter<"submission"> | number | null
    cid?: IntNullableFilter<"submission"> | number | null
    teamid?: IntNullableFilter<"submission"> | number | null
    userid?: IntNullableFilter<"submission"> | number | null
    probid?: IntNullableFilter<"submission"> | number | null
    langid?: StringNullableFilter<"submission"> | string | null
    submittime?: DecimalFilter<"submission"> | Decimal | DecimalJsLike | number | string
    valid?: BoolFilter<"submission"> | boolean
    rejudgingid?: IntNullableFilter<"submission"> | number | null
    expected_results?: StringNullableFilter<"submission"> | string | null
    externalid?: StringNullableFilter<"submission"> | string | null
    entry_point?: StringNullableFilter<"submission"> | string | null
    balloon?: BalloonListRelationFilter
    external_judgement?: External_judgementListRelationFilter
    judging?: JudgingListRelationFilter
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
    contest?: XOR<ContestNullableRelationFilter, contestWhereInput> | null
    team?: XOR<TeamNullableRelationFilter, teamWhereInput> | null
    problem?: XOR<ProblemNullableRelationFilter, problemWhereInput> | null
    language?: XOR<LanguageNullableRelationFilter, languageWhereInput> | null
    submission?: XOR<SubmissionNullableRelationFilter, submissionWhereInput> | null
    other_submission?: SubmissionListRelationFilter
    rejudging?: XOR<RejudgingNullableRelationFilter, rejudgingWhereInput> | null
    contestproblem?: XOR<ContestproblemNullableRelationFilter, contestproblemWhereInput> | null
    submission_file?: Submission_fileListRelationFilter
  }

  export type submissionOrderByWithRelationInput = {
    submitid?: SortOrder
    origsubmitid?: SortOrderInput | SortOrder
    cid?: SortOrderInput | SortOrder
    teamid?: SortOrderInput | SortOrder
    userid?: SortOrderInput | SortOrder
    probid?: SortOrderInput | SortOrder
    langid?: SortOrderInput | SortOrder
    submittime?: SortOrder
    valid?: SortOrder
    rejudgingid?: SortOrderInput | SortOrder
    expected_results?: SortOrderInput | SortOrder
    externalid?: SortOrderInput | SortOrder
    entry_point?: SortOrderInput | SortOrder
    balloon?: balloonOrderByRelationAggregateInput
    external_judgement?: external_judgementOrderByRelationAggregateInput
    judging?: judgingOrderByRelationAggregateInput
    user?: userOrderByWithRelationInput
    contest?: contestOrderByWithRelationInput
    team?: teamOrderByWithRelationInput
    problem?: problemOrderByWithRelationInput
    language?: languageOrderByWithRelationInput
    submission?: submissionOrderByWithRelationInput
    other_submission?: submissionOrderByRelationAggregateInput
    rejudging?: rejudgingOrderByWithRelationInput
    contestproblem?: contestproblemOrderByWithRelationInput
    submission_file?: submission_fileOrderByRelationAggregateInput
  }

  export type submissionWhereUniqueInput = Prisma.AtLeast<{
    submitid?: number
    cid_externalid?: submissionCidExternalidCompoundUniqueInput
    AND?: submissionWhereInput | submissionWhereInput[]
    OR?: submissionWhereInput[]
    NOT?: submissionWhereInput | submissionWhereInput[]
    origsubmitid?: IntNullableFilter<"submission"> | number | null
    cid?: IntNullableFilter<"submission"> | number | null
    teamid?: IntNullableFilter<"submission"> | number | null
    userid?: IntNullableFilter<"submission"> | number | null
    probid?: IntNullableFilter<"submission"> | number | null
    langid?: StringNullableFilter<"submission"> | string | null
    submittime?: DecimalFilter<"submission"> | Decimal | DecimalJsLike | number | string
    valid?: BoolFilter<"submission"> | boolean
    rejudgingid?: IntNullableFilter<"submission"> | number | null
    expected_results?: StringNullableFilter<"submission"> | string | null
    externalid?: StringNullableFilter<"submission"> | string | null
    entry_point?: StringNullableFilter<"submission"> | string | null
    balloon?: BalloonListRelationFilter
    external_judgement?: External_judgementListRelationFilter
    judging?: JudgingListRelationFilter
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
    contest?: XOR<ContestNullableRelationFilter, contestWhereInput> | null
    team?: XOR<TeamNullableRelationFilter, teamWhereInput> | null
    problem?: XOR<ProblemNullableRelationFilter, problemWhereInput> | null
    language?: XOR<LanguageNullableRelationFilter, languageWhereInput> | null
    submission?: XOR<SubmissionNullableRelationFilter, submissionWhereInput> | null
    other_submission?: SubmissionListRelationFilter
    rejudging?: XOR<RejudgingNullableRelationFilter, rejudgingWhereInput> | null
    contestproblem?: XOR<ContestproblemNullableRelationFilter, contestproblemWhereInput> | null
    submission_file?: Submission_fileListRelationFilter
  }, "submitid" | "cid_externalid">

  export type submissionOrderByWithAggregationInput = {
    submitid?: SortOrder
    origsubmitid?: SortOrderInput | SortOrder
    cid?: SortOrderInput | SortOrder
    teamid?: SortOrderInput | SortOrder
    userid?: SortOrderInput | SortOrder
    probid?: SortOrderInput | SortOrder
    langid?: SortOrderInput | SortOrder
    submittime?: SortOrder
    valid?: SortOrder
    rejudgingid?: SortOrderInput | SortOrder
    expected_results?: SortOrderInput | SortOrder
    externalid?: SortOrderInput | SortOrder
    entry_point?: SortOrderInput | SortOrder
    _count?: submissionCountOrderByAggregateInput
    _avg?: submissionAvgOrderByAggregateInput
    _max?: submissionMaxOrderByAggregateInput
    _min?: submissionMinOrderByAggregateInput
    _sum?: submissionSumOrderByAggregateInput
  }

  export type submissionScalarWhereWithAggregatesInput = {
    AND?: submissionScalarWhereWithAggregatesInput | submissionScalarWhereWithAggregatesInput[]
    OR?: submissionScalarWhereWithAggregatesInput[]
    NOT?: submissionScalarWhereWithAggregatesInput | submissionScalarWhereWithAggregatesInput[]
    submitid?: IntWithAggregatesFilter<"submission"> | number
    origsubmitid?: IntNullableWithAggregatesFilter<"submission"> | number | null
    cid?: IntNullableWithAggregatesFilter<"submission"> | number | null
    teamid?: IntNullableWithAggregatesFilter<"submission"> | number | null
    userid?: IntNullableWithAggregatesFilter<"submission"> | number | null
    probid?: IntNullableWithAggregatesFilter<"submission"> | number | null
    langid?: StringNullableWithAggregatesFilter<"submission"> | string | null
    submittime?: DecimalWithAggregatesFilter<"submission"> | Decimal | DecimalJsLike | number | string
    valid?: BoolWithAggregatesFilter<"submission"> | boolean
    rejudgingid?: IntNullableWithAggregatesFilter<"submission"> | number | null
    expected_results?: StringNullableWithAggregatesFilter<"submission"> | string | null
    externalid?: StringNullableWithAggregatesFilter<"submission"> | string | null
    entry_point?: StringNullableWithAggregatesFilter<"submission"> | string | null
  }

  export type submission_fileWhereInput = {
    AND?: submission_fileWhereInput | submission_fileWhereInput[]
    OR?: submission_fileWhereInput[]
    NOT?: submission_fileWhereInput | submission_fileWhereInput[]
    submitfileid?: IntFilter<"submission_file"> | number
    submitid?: IntNullableFilter<"submission_file"> | number | null
    sourcecode?: BytesFilter<"submission_file"> | Buffer
    filename?: StringFilter<"submission_file"> | string
    ranknumber?: IntFilter<"submission_file"> | number
    submission?: XOR<SubmissionNullableRelationFilter, submissionWhereInput> | null
  }

  export type submission_fileOrderByWithRelationInput = {
    submitfileid?: SortOrder
    submitid?: SortOrderInput | SortOrder
    sourcecode?: SortOrder
    filename?: SortOrder
    ranknumber?: SortOrder
    submission?: submissionOrderByWithRelationInput
  }

  export type submission_fileWhereUniqueInput = Prisma.AtLeast<{
    submitfileid?: number
    submitid_filename?: submission_fileSubmitidFilenameCompoundUniqueInput
    submitid_ranknumber?: submission_fileSubmitidRanknumberCompoundUniqueInput
    AND?: submission_fileWhereInput | submission_fileWhereInput[]
    OR?: submission_fileWhereInput[]
    NOT?: submission_fileWhereInput | submission_fileWhereInput[]
    submitid?: IntNullableFilter<"submission_file"> | number | null
    sourcecode?: BytesFilter<"submission_file"> | Buffer
    filename?: StringFilter<"submission_file"> | string
    ranknumber?: IntFilter<"submission_file"> | number
    submission?: XOR<SubmissionNullableRelationFilter, submissionWhereInput> | null
  }, "submitfileid" | "submitid_filename" | "submitid_ranknumber">

  export type submission_fileOrderByWithAggregationInput = {
    submitfileid?: SortOrder
    submitid?: SortOrderInput | SortOrder
    sourcecode?: SortOrder
    filename?: SortOrder
    ranknumber?: SortOrder
    _count?: submission_fileCountOrderByAggregateInput
    _avg?: submission_fileAvgOrderByAggregateInput
    _max?: submission_fileMaxOrderByAggregateInput
    _min?: submission_fileMinOrderByAggregateInput
    _sum?: submission_fileSumOrderByAggregateInput
  }

  export type submission_fileScalarWhereWithAggregatesInput = {
    AND?: submission_fileScalarWhereWithAggregatesInput | submission_fileScalarWhereWithAggregatesInput[]
    OR?: submission_fileScalarWhereWithAggregatesInput[]
    NOT?: submission_fileScalarWhereWithAggregatesInput | submission_fileScalarWhereWithAggregatesInput[]
    submitfileid?: IntWithAggregatesFilter<"submission_file"> | number
    submitid?: IntNullableWithAggregatesFilter<"submission_file"> | number | null
    sourcecode?: BytesWithAggregatesFilter<"submission_file"> | Buffer
    filename?: StringWithAggregatesFilter<"submission_file"> | string
    ranknumber?: IntWithAggregatesFilter<"submission_file"> | number
  }

  export type teamWhereInput = {
    AND?: teamWhereInput | teamWhereInput[]
    OR?: teamWhereInput[]
    NOT?: teamWhereInput | teamWhereInput[]
    teamid?: IntFilter<"team"> | number
    externalid?: StringNullableFilter<"team"> | string | null
    icpcid?: StringNullableFilter<"team"> | string | null
    name?: StringFilter<"team"> | string
    display_name?: StringNullableFilter<"team"> | string | null
    categoryid?: IntNullableFilter<"team"> | number | null
    affilid?: IntNullableFilter<"team"> | number | null
    enabled?: BoolFilter<"team"> | boolean
    publicdescription?: StringNullableFilter<"team"> | string | null
    room?: StringNullableFilter<"team"> | string | null
    internalcomments?: StringNullableFilter<"team"> | string | null
    judging_last_started?: DecimalNullableFilter<"team"> | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFilter<"team"> | number
    clarification_clarification_senderToteam?: ClarificationListRelationFilter
    clarification_clarification_recipientToteam?: ClarificationListRelationFilter
    contestteam?: ContestteamListRelationFilter
    queuetask?: QueuetaskListRelationFilter
    rankcache?: RankcacheListRelationFilter
    scorecache?: ScorecacheListRelationFilter
    submission?: SubmissionListRelationFilter
    team_category?: XOR<Team_categoryNullableRelationFilter, team_categoryWhereInput> | null
    team_affiliation?: XOR<Team_affiliationNullableRelationFilter, team_affiliationWhereInput> | null
    team_unread?: Team_unreadListRelationFilter
    user?: UserListRelationFilter
  }

  export type teamOrderByWithRelationInput = {
    teamid?: SortOrder
    externalid?: SortOrderInput | SortOrder
    icpcid?: SortOrderInput | SortOrder
    name?: SortOrder
    display_name?: SortOrderInput | SortOrder
    categoryid?: SortOrderInput | SortOrder
    affilid?: SortOrderInput | SortOrder
    enabled?: SortOrder
    publicdescription?: SortOrderInput | SortOrder
    room?: SortOrderInput | SortOrder
    internalcomments?: SortOrderInput | SortOrder
    judging_last_started?: SortOrderInput | SortOrder
    penalty?: SortOrder
    clarification_clarification_senderToteam?: clarificationOrderByRelationAggregateInput
    clarification_clarification_recipientToteam?: clarificationOrderByRelationAggregateInput
    contestteam?: contestteamOrderByRelationAggregateInput
    queuetask?: queuetaskOrderByRelationAggregateInput
    rankcache?: rankcacheOrderByRelationAggregateInput
    scorecache?: scorecacheOrderByRelationAggregateInput
    submission?: submissionOrderByRelationAggregateInput
    team_category?: team_categoryOrderByWithRelationInput
    team_affiliation?: team_affiliationOrderByWithRelationInput
    team_unread?: team_unreadOrderByRelationAggregateInput
    user?: userOrderByRelationAggregateInput
  }

  export type teamWhereUniqueInput = Prisma.AtLeast<{
    teamid?: number
    externalid?: string
    AND?: teamWhereInput | teamWhereInput[]
    OR?: teamWhereInput[]
    NOT?: teamWhereInput | teamWhereInput[]
    icpcid?: StringNullableFilter<"team"> | string | null
    name?: StringFilter<"team"> | string
    display_name?: StringNullableFilter<"team"> | string | null
    categoryid?: IntNullableFilter<"team"> | number | null
    affilid?: IntNullableFilter<"team"> | number | null
    enabled?: BoolFilter<"team"> | boolean
    publicdescription?: StringNullableFilter<"team"> | string | null
    room?: StringNullableFilter<"team"> | string | null
    internalcomments?: StringNullableFilter<"team"> | string | null
    judging_last_started?: DecimalNullableFilter<"team"> | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFilter<"team"> | number
    clarification_clarification_senderToteam?: ClarificationListRelationFilter
    clarification_clarification_recipientToteam?: ClarificationListRelationFilter
    contestteam?: ContestteamListRelationFilter
    queuetask?: QueuetaskListRelationFilter
    rankcache?: RankcacheListRelationFilter
    scorecache?: ScorecacheListRelationFilter
    submission?: SubmissionListRelationFilter
    team_category?: XOR<Team_categoryNullableRelationFilter, team_categoryWhereInput> | null
    team_affiliation?: XOR<Team_affiliationNullableRelationFilter, team_affiliationWhereInput> | null
    team_unread?: Team_unreadListRelationFilter
    user?: UserListRelationFilter
  }, "teamid" | "externalid">

  export type teamOrderByWithAggregationInput = {
    teamid?: SortOrder
    externalid?: SortOrderInput | SortOrder
    icpcid?: SortOrderInput | SortOrder
    name?: SortOrder
    display_name?: SortOrderInput | SortOrder
    categoryid?: SortOrderInput | SortOrder
    affilid?: SortOrderInput | SortOrder
    enabled?: SortOrder
    publicdescription?: SortOrderInput | SortOrder
    room?: SortOrderInput | SortOrder
    internalcomments?: SortOrderInput | SortOrder
    judging_last_started?: SortOrderInput | SortOrder
    penalty?: SortOrder
    _count?: teamCountOrderByAggregateInput
    _avg?: teamAvgOrderByAggregateInput
    _max?: teamMaxOrderByAggregateInput
    _min?: teamMinOrderByAggregateInput
    _sum?: teamSumOrderByAggregateInput
  }

  export type teamScalarWhereWithAggregatesInput = {
    AND?: teamScalarWhereWithAggregatesInput | teamScalarWhereWithAggregatesInput[]
    OR?: teamScalarWhereWithAggregatesInput[]
    NOT?: teamScalarWhereWithAggregatesInput | teamScalarWhereWithAggregatesInput[]
    teamid?: IntWithAggregatesFilter<"team"> | number
    externalid?: StringNullableWithAggregatesFilter<"team"> | string | null
    icpcid?: StringNullableWithAggregatesFilter<"team"> | string | null
    name?: StringWithAggregatesFilter<"team"> | string
    display_name?: StringNullableWithAggregatesFilter<"team"> | string | null
    categoryid?: IntNullableWithAggregatesFilter<"team"> | number | null
    affilid?: IntNullableWithAggregatesFilter<"team"> | number | null
    enabled?: BoolWithAggregatesFilter<"team"> | boolean
    publicdescription?: StringNullableWithAggregatesFilter<"team"> | string | null
    room?: StringNullableWithAggregatesFilter<"team"> | string | null
    internalcomments?: StringNullableWithAggregatesFilter<"team"> | string | null
    judging_last_started?: DecimalNullableWithAggregatesFilter<"team"> | Decimal | DecimalJsLike | number | string | null
    penalty?: IntWithAggregatesFilter<"team"> | number
  }

  export type team_affiliationWhereInput = {
    AND?: team_affiliationWhereInput | team_affiliationWhereInput[]
    OR?: team_affiliationWhereInput[]
    NOT?: team_affiliationWhereInput | team_affiliationWhereInput[]
    affilid?: IntFilter<"team_affiliation"> | number
    externalid?: StringNullableFilter<"team_affiliation"> | string | null
    icpcid?: StringNullableFilter<"team_affiliation"> | string | null
    shortname?: StringFilter<"team_affiliation"> | string
    name?: StringFilter<"team_affiliation"> | string
    country?: StringNullableFilter<"team_affiliation"> | string | null
    internalcomments?: StringNullableFilter<"team_affiliation"> | string | null
    team?: TeamListRelationFilter
  }

  export type team_affiliationOrderByWithRelationInput = {
    affilid?: SortOrder
    externalid?: SortOrderInput | SortOrder
    icpcid?: SortOrderInput | SortOrder
    shortname?: SortOrder
    name?: SortOrder
    country?: SortOrderInput | SortOrder
    internalcomments?: SortOrderInput | SortOrder
    team?: teamOrderByRelationAggregateInput
  }

  export type team_affiliationWhereUniqueInput = Prisma.AtLeast<{
    affilid?: number
    externalid?: string
    AND?: team_affiliationWhereInput | team_affiliationWhereInput[]
    OR?: team_affiliationWhereInput[]
    NOT?: team_affiliationWhereInput | team_affiliationWhereInput[]
    icpcid?: StringNullableFilter<"team_affiliation"> | string | null
    shortname?: StringFilter<"team_affiliation"> | string
    name?: StringFilter<"team_affiliation"> | string
    country?: StringNullableFilter<"team_affiliation"> | string | null
    internalcomments?: StringNullableFilter<"team_affiliation"> | string | null
    team?: TeamListRelationFilter
  }, "affilid" | "externalid">

  export type team_affiliationOrderByWithAggregationInput = {
    affilid?: SortOrder
    externalid?: SortOrderInput | SortOrder
    icpcid?: SortOrderInput | SortOrder
    shortname?: SortOrder
    name?: SortOrder
    country?: SortOrderInput | SortOrder
    internalcomments?: SortOrderInput | SortOrder
    _count?: team_affiliationCountOrderByAggregateInput
    _avg?: team_affiliationAvgOrderByAggregateInput
    _max?: team_affiliationMaxOrderByAggregateInput
    _min?: team_affiliationMinOrderByAggregateInput
    _sum?: team_affiliationSumOrderByAggregateInput
  }

  export type team_affiliationScalarWhereWithAggregatesInput = {
    AND?: team_affiliationScalarWhereWithAggregatesInput | team_affiliationScalarWhereWithAggregatesInput[]
    OR?: team_affiliationScalarWhereWithAggregatesInput[]
    NOT?: team_affiliationScalarWhereWithAggregatesInput | team_affiliationScalarWhereWithAggregatesInput[]
    affilid?: IntWithAggregatesFilter<"team_affiliation"> | number
    externalid?: StringNullableWithAggregatesFilter<"team_affiliation"> | string | null
    icpcid?: StringNullableWithAggregatesFilter<"team_affiliation"> | string | null
    shortname?: StringWithAggregatesFilter<"team_affiliation"> | string
    name?: StringWithAggregatesFilter<"team_affiliation"> | string
    country?: StringNullableWithAggregatesFilter<"team_affiliation"> | string | null
    internalcomments?: StringNullableWithAggregatesFilter<"team_affiliation"> | string | null
  }

  export type team_categoryWhereInput = {
    AND?: team_categoryWhereInput | team_categoryWhereInput[]
    OR?: team_categoryWhereInput[]
    NOT?: team_categoryWhereInput | team_categoryWhereInput[]
    categoryid?: IntFilter<"team_category"> | number
    externalid?: StringNullableFilter<"team_category"> | string | null
    icpcid?: StringNullableFilter<"team_category"> | string | null
    name?: StringFilter<"team_category"> | string
    sortorder?: BoolFilter<"team_category"> | boolean
    color?: StringNullableFilter<"team_category"> | string | null
    visible?: BoolFilter<"team_category"> | boolean
    allow_self_registration?: BoolFilter<"team_category"> | boolean
    contestteamcategory?: ContestteamcategoryListRelationFilter
    contestteamcategoryformedals?: ContestteamcategoryformedalsListRelationFilter
    team?: TeamListRelationFilter
  }

  export type team_categoryOrderByWithRelationInput = {
    categoryid?: SortOrder
    externalid?: SortOrderInput | SortOrder
    icpcid?: SortOrderInput | SortOrder
    name?: SortOrder
    sortorder?: SortOrder
    color?: SortOrderInput | SortOrder
    visible?: SortOrder
    allow_self_registration?: SortOrder
    contestteamcategory?: contestteamcategoryOrderByRelationAggregateInput
    contestteamcategoryformedals?: contestteamcategoryformedalsOrderByRelationAggregateInput
    team?: teamOrderByRelationAggregateInput
  }

  export type team_categoryWhereUniqueInput = Prisma.AtLeast<{
    categoryid?: number
    externalid?: string
    AND?: team_categoryWhereInput | team_categoryWhereInput[]
    OR?: team_categoryWhereInput[]
    NOT?: team_categoryWhereInput | team_categoryWhereInput[]
    icpcid?: StringNullableFilter<"team_category"> | string | null
    name?: StringFilter<"team_category"> | string
    sortorder?: BoolFilter<"team_category"> | boolean
    color?: StringNullableFilter<"team_category"> | string | null
    visible?: BoolFilter<"team_category"> | boolean
    allow_self_registration?: BoolFilter<"team_category"> | boolean
    contestteamcategory?: ContestteamcategoryListRelationFilter
    contestteamcategoryformedals?: ContestteamcategoryformedalsListRelationFilter
    team?: TeamListRelationFilter
  }, "categoryid" | "externalid">

  export type team_categoryOrderByWithAggregationInput = {
    categoryid?: SortOrder
    externalid?: SortOrderInput | SortOrder
    icpcid?: SortOrderInput | SortOrder
    name?: SortOrder
    sortorder?: SortOrder
    color?: SortOrderInput | SortOrder
    visible?: SortOrder
    allow_self_registration?: SortOrder
    _count?: team_categoryCountOrderByAggregateInput
    _avg?: team_categoryAvgOrderByAggregateInput
    _max?: team_categoryMaxOrderByAggregateInput
    _min?: team_categoryMinOrderByAggregateInput
    _sum?: team_categorySumOrderByAggregateInput
  }

  export type team_categoryScalarWhereWithAggregatesInput = {
    AND?: team_categoryScalarWhereWithAggregatesInput | team_categoryScalarWhereWithAggregatesInput[]
    OR?: team_categoryScalarWhereWithAggregatesInput[]
    NOT?: team_categoryScalarWhereWithAggregatesInput | team_categoryScalarWhereWithAggregatesInput[]
    categoryid?: IntWithAggregatesFilter<"team_category"> | number
    externalid?: StringNullableWithAggregatesFilter<"team_category"> | string | null
    icpcid?: StringNullableWithAggregatesFilter<"team_category"> | string | null
    name?: StringWithAggregatesFilter<"team_category"> | string
    sortorder?: BoolWithAggregatesFilter<"team_category"> | boolean
    color?: StringNullableWithAggregatesFilter<"team_category"> | string | null
    visible?: BoolWithAggregatesFilter<"team_category"> | boolean
    allow_self_registration?: BoolWithAggregatesFilter<"team_category"> | boolean
  }

  export type team_unreadWhereInput = {
    AND?: team_unreadWhereInput | team_unreadWhereInput[]
    OR?: team_unreadWhereInput[]
    NOT?: team_unreadWhereInput | team_unreadWhereInput[]
    teamid?: IntFilter<"team_unread"> | number
    mesgid?: IntFilter<"team_unread"> | number
    team?: XOR<TeamRelationFilter, teamWhereInput>
    clarification?: XOR<ClarificationRelationFilter, clarificationWhereInput>
  }

  export type team_unreadOrderByWithRelationInput = {
    teamid?: SortOrder
    mesgid?: SortOrder
    team?: teamOrderByWithRelationInput
    clarification?: clarificationOrderByWithRelationInput
  }

  export type team_unreadWhereUniqueInput = Prisma.AtLeast<{
    teamid_mesgid?: team_unreadTeamidMesgidCompoundUniqueInput
    AND?: team_unreadWhereInput | team_unreadWhereInput[]
    OR?: team_unreadWhereInput[]
    NOT?: team_unreadWhereInput | team_unreadWhereInput[]
    teamid?: IntFilter<"team_unread"> | number
    mesgid?: IntFilter<"team_unread"> | number
    team?: XOR<TeamRelationFilter, teamWhereInput>
    clarification?: XOR<ClarificationRelationFilter, clarificationWhereInput>
  }, "teamid_mesgid">

  export type team_unreadOrderByWithAggregationInput = {
    teamid?: SortOrder
    mesgid?: SortOrder
    _count?: team_unreadCountOrderByAggregateInput
    _avg?: team_unreadAvgOrderByAggregateInput
    _max?: team_unreadMaxOrderByAggregateInput
    _min?: team_unreadMinOrderByAggregateInput
    _sum?: team_unreadSumOrderByAggregateInput
  }

  export type team_unreadScalarWhereWithAggregatesInput = {
    AND?: team_unreadScalarWhereWithAggregatesInput | team_unreadScalarWhereWithAggregatesInput[]
    OR?: team_unreadScalarWhereWithAggregatesInput[]
    NOT?: team_unreadScalarWhereWithAggregatesInput | team_unreadScalarWhereWithAggregatesInput[]
    teamid?: IntWithAggregatesFilter<"team_unread"> | number
    mesgid?: IntWithAggregatesFilter<"team_unread"> | number
  }

  export type testcaseWhereInput = {
    AND?: testcaseWhereInput | testcaseWhereInput[]
    OR?: testcaseWhereInput[]
    NOT?: testcaseWhereInput | testcaseWhereInput[]
    testcaseid?: IntFilter<"testcase"> | number
    md5sum_input?: StringNullableFilter<"testcase"> | string | null
    md5sum_output?: StringNullableFilter<"testcase"> | string | null
    probid?: IntNullableFilter<"testcase"> | number | null
    ranknumber?: IntFilter<"testcase"> | number
    description?: BytesNullableFilter<"testcase"> | Buffer | null
    image_type?: StringNullableFilter<"testcase"> | string | null
    sample?: BoolFilter<"testcase"> | boolean
    orig_input_filename?: StringNullableFilter<"testcase"> | string | null
    deleted?: BoolFilter<"testcase"> | boolean
    external_run?: External_runListRelationFilter
    judging_run?: Judging_runListRelationFilter
    problem?: XOR<ProblemNullableRelationFilter, problemWhereInput> | null
    testcase_content?: Testcase_contentListRelationFilter
  }

  export type testcaseOrderByWithRelationInput = {
    testcaseid?: SortOrder
    md5sum_input?: SortOrderInput | SortOrder
    md5sum_output?: SortOrderInput | SortOrder
    probid?: SortOrderInput | SortOrder
    ranknumber?: SortOrder
    description?: SortOrderInput | SortOrder
    image_type?: SortOrderInput | SortOrder
    sample?: SortOrder
    orig_input_filename?: SortOrderInput | SortOrder
    deleted?: SortOrder
    external_run?: external_runOrderByRelationAggregateInput
    judging_run?: judging_runOrderByRelationAggregateInput
    problem?: problemOrderByWithRelationInput
    testcase_content?: testcase_contentOrderByRelationAggregateInput
  }

  export type testcaseWhereUniqueInput = Prisma.AtLeast<{
    testcaseid?: number
    probid_ranknumber?: testcaseProbidRanknumberCompoundUniqueInput
    AND?: testcaseWhereInput | testcaseWhereInput[]
    OR?: testcaseWhereInput[]
    NOT?: testcaseWhereInput | testcaseWhereInput[]
    md5sum_input?: StringNullableFilter<"testcase"> | string | null
    md5sum_output?: StringNullableFilter<"testcase"> | string | null
    probid?: IntNullableFilter<"testcase"> | number | null
    ranknumber?: IntFilter<"testcase"> | number
    description?: BytesNullableFilter<"testcase"> | Buffer | null
    image_type?: StringNullableFilter<"testcase"> | string | null
    sample?: BoolFilter<"testcase"> | boolean
    orig_input_filename?: StringNullableFilter<"testcase"> | string | null
    deleted?: BoolFilter<"testcase"> | boolean
    external_run?: External_runListRelationFilter
    judging_run?: Judging_runListRelationFilter
    problem?: XOR<ProblemNullableRelationFilter, problemWhereInput> | null
    testcase_content?: Testcase_contentListRelationFilter
  }, "testcaseid" | "probid_ranknumber">

  export type testcaseOrderByWithAggregationInput = {
    testcaseid?: SortOrder
    md5sum_input?: SortOrderInput | SortOrder
    md5sum_output?: SortOrderInput | SortOrder
    probid?: SortOrderInput | SortOrder
    ranknumber?: SortOrder
    description?: SortOrderInput | SortOrder
    image_type?: SortOrderInput | SortOrder
    sample?: SortOrder
    orig_input_filename?: SortOrderInput | SortOrder
    deleted?: SortOrder
    _count?: testcaseCountOrderByAggregateInput
    _avg?: testcaseAvgOrderByAggregateInput
    _max?: testcaseMaxOrderByAggregateInput
    _min?: testcaseMinOrderByAggregateInput
    _sum?: testcaseSumOrderByAggregateInput
  }

  export type testcaseScalarWhereWithAggregatesInput = {
    AND?: testcaseScalarWhereWithAggregatesInput | testcaseScalarWhereWithAggregatesInput[]
    OR?: testcaseScalarWhereWithAggregatesInput[]
    NOT?: testcaseScalarWhereWithAggregatesInput | testcaseScalarWhereWithAggregatesInput[]
    testcaseid?: IntWithAggregatesFilter<"testcase"> | number
    md5sum_input?: StringNullableWithAggregatesFilter<"testcase"> | string | null
    md5sum_output?: StringNullableWithAggregatesFilter<"testcase"> | string | null
    probid?: IntNullableWithAggregatesFilter<"testcase"> | number | null
    ranknumber?: IntWithAggregatesFilter<"testcase"> | number
    description?: BytesNullableWithAggregatesFilter<"testcase"> | Buffer | null
    image_type?: StringNullableWithAggregatesFilter<"testcase"> | string | null
    sample?: BoolWithAggregatesFilter<"testcase"> | boolean
    orig_input_filename?: StringNullableWithAggregatesFilter<"testcase"> | string | null
    deleted?: BoolWithAggregatesFilter<"testcase"> | boolean
  }

  export type testcase_contentWhereInput = {
    AND?: testcase_contentWhereInput | testcase_contentWhereInput[]
    OR?: testcase_contentWhereInput[]
    NOT?: testcase_contentWhereInput | testcase_contentWhereInput[]
    testcaseid?: IntNullableFilter<"testcase_content"> | number | null
    input?: BytesNullableFilter<"testcase_content"> | Buffer | null
    output?: BytesNullableFilter<"testcase_content"> | Buffer | null
    image?: BytesNullableFilter<"testcase_content"> | Buffer | null
    image_thumb?: BytesNullableFilter<"testcase_content"> | Buffer | null
    tc_contentid?: IntFilter<"testcase_content"> | number
    testcase?: XOR<TestcaseNullableRelationFilter, testcaseWhereInput> | null
  }

  export type testcase_contentOrderByWithRelationInput = {
    testcaseid?: SortOrderInput | SortOrder
    input?: SortOrderInput | SortOrder
    output?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    image_thumb?: SortOrderInput | SortOrder
    tc_contentid?: SortOrder
    testcase?: testcaseOrderByWithRelationInput
  }

  export type testcase_contentWhereUniqueInput = Prisma.AtLeast<{
    tc_contentid?: number
    AND?: testcase_contentWhereInput | testcase_contentWhereInput[]
    OR?: testcase_contentWhereInput[]
    NOT?: testcase_contentWhereInput | testcase_contentWhereInput[]
    testcaseid?: IntNullableFilter<"testcase_content"> | number | null
    input?: BytesNullableFilter<"testcase_content"> | Buffer | null
    output?: BytesNullableFilter<"testcase_content"> | Buffer | null
    image?: BytesNullableFilter<"testcase_content"> | Buffer | null
    image_thumb?: BytesNullableFilter<"testcase_content"> | Buffer | null
    testcase?: XOR<TestcaseNullableRelationFilter, testcaseWhereInput> | null
  }, "tc_contentid">

  export type testcase_contentOrderByWithAggregationInput = {
    testcaseid?: SortOrderInput | SortOrder
    input?: SortOrderInput | SortOrder
    output?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    image_thumb?: SortOrderInput | SortOrder
    tc_contentid?: SortOrder
    _count?: testcase_contentCountOrderByAggregateInput
    _avg?: testcase_contentAvgOrderByAggregateInput
    _max?: testcase_contentMaxOrderByAggregateInput
    _min?: testcase_contentMinOrderByAggregateInput
    _sum?: testcase_contentSumOrderByAggregateInput
  }

  export type testcase_contentScalarWhereWithAggregatesInput = {
    AND?: testcase_contentScalarWhereWithAggregatesInput | testcase_contentScalarWhereWithAggregatesInput[]
    OR?: testcase_contentScalarWhereWithAggregatesInput[]
    NOT?: testcase_contentScalarWhereWithAggregatesInput | testcase_contentScalarWhereWithAggregatesInput[]
    testcaseid?: IntNullableWithAggregatesFilter<"testcase_content"> | number | null
    input?: BytesNullableWithAggregatesFilter<"testcase_content"> | Buffer | null
    output?: BytesNullableWithAggregatesFilter<"testcase_content"> | Buffer | null
    image?: BytesNullableWithAggregatesFilter<"testcase_content"> | Buffer | null
    image_thumb?: BytesNullableWithAggregatesFilter<"testcase_content"> | Buffer | null
    tc_contentid?: IntWithAggregatesFilter<"testcase_content"> | number
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    userid?: IntFilter<"user"> | number
    externalid?: StringNullableFilter<"user"> | string | null
    username?: StringFilter<"user"> | string
    name?: StringFilter<"user"> | string
    email?: StringNullableFilter<"user"> | string | null
    last_login?: DecimalNullableFilter<"user"> | Decimal | DecimalJsLike | number | string | null
    last_api_login?: DecimalNullableFilter<"user"> | Decimal | DecimalJsLike | number | string | null
    first_login?: DecimalNullableFilter<"user"> | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: StringNullableFilter<"user"> | string | null
    password?: StringNullableFilter<"user"> | string | null
    ip_address?: StringNullableFilter<"user"> | string | null
    enabled?: BoolFilter<"user"> | boolean
    teamid?: IntNullableFilter<"user"> | number | null
    immutable_executable?: Immutable_executableListRelationFilter
    rejudging_rejudging_userid_startTouser?: RejudgingListRelationFilter
    rejudging_rejudging_userid_finishTouser?: RejudgingListRelationFilter
    submission?: SubmissionListRelationFilter
    team?: XOR<TeamNullableRelationFilter, teamWhereInput> | null
    userrole?: UserroleListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    userid?: SortOrder
    externalid?: SortOrderInput | SortOrder
    username?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    last_api_login?: SortOrderInput | SortOrder
    first_login?: SortOrderInput | SortOrder
    last_ip_address?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    enabled?: SortOrder
    teamid?: SortOrderInput | SortOrder
    immutable_executable?: immutable_executableOrderByRelationAggregateInput
    rejudging_rejudging_userid_startTouser?: rejudgingOrderByRelationAggregateInput
    rejudging_rejudging_userid_finishTouser?: rejudgingOrderByRelationAggregateInput
    submission?: submissionOrderByRelationAggregateInput
    team?: teamOrderByWithRelationInput
    userrole?: userroleOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    userid?: number
    externalid?: string
    username?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    name?: StringFilter<"user"> | string
    email?: StringNullableFilter<"user"> | string | null
    last_login?: DecimalNullableFilter<"user"> | Decimal | DecimalJsLike | number | string | null
    last_api_login?: DecimalNullableFilter<"user"> | Decimal | DecimalJsLike | number | string | null
    first_login?: DecimalNullableFilter<"user"> | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: StringNullableFilter<"user"> | string | null
    password?: StringNullableFilter<"user"> | string | null
    ip_address?: StringNullableFilter<"user"> | string | null
    enabled?: BoolFilter<"user"> | boolean
    teamid?: IntNullableFilter<"user"> | number | null
    immutable_executable?: Immutable_executableListRelationFilter
    rejudging_rejudging_userid_startTouser?: RejudgingListRelationFilter
    rejudging_rejudging_userid_finishTouser?: RejudgingListRelationFilter
    submission?: SubmissionListRelationFilter
    team?: XOR<TeamNullableRelationFilter, teamWhereInput> | null
    userrole?: UserroleListRelationFilter
  }, "userid" | "externalid" | "username">

  export type userOrderByWithAggregationInput = {
    userid?: SortOrder
    externalid?: SortOrderInput | SortOrder
    username?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    last_api_login?: SortOrderInput | SortOrder
    first_login?: SortOrderInput | SortOrder
    last_ip_address?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    enabled?: SortOrder
    teamid?: SortOrderInput | SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    userid?: IntWithAggregatesFilter<"user"> | number
    externalid?: StringNullableWithAggregatesFilter<"user"> | string | null
    username?: StringWithAggregatesFilter<"user"> | string
    name?: StringWithAggregatesFilter<"user"> | string
    email?: StringNullableWithAggregatesFilter<"user"> | string | null
    last_login?: DecimalNullableWithAggregatesFilter<"user"> | Decimal | DecimalJsLike | number | string | null
    last_api_login?: DecimalNullableWithAggregatesFilter<"user"> | Decimal | DecimalJsLike | number | string | null
    first_login?: DecimalNullableWithAggregatesFilter<"user"> | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: StringNullableWithAggregatesFilter<"user"> | string | null
    password?: StringNullableWithAggregatesFilter<"user"> | string | null
    ip_address?: StringNullableWithAggregatesFilter<"user"> | string | null
    enabled?: BoolWithAggregatesFilter<"user"> | boolean
    teamid?: IntNullableWithAggregatesFilter<"user"> | number | null
  }

  export type userroleWhereInput = {
    AND?: userroleWhereInput | userroleWhereInput[]
    OR?: userroleWhereInput[]
    NOT?: userroleWhereInput | userroleWhereInput[]
    userid?: IntFilter<"userrole"> | number
    roleid?: IntFilter<"userrole"> | number
    user?: XOR<UserRelationFilter, userWhereInput>
    role?: XOR<RoleRelationFilter, roleWhereInput>
  }

  export type userroleOrderByWithRelationInput = {
    userid?: SortOrder
    roleid?: SortOrder
    user?: userOrderByWithRelationInput
    role?: roleOrderByWithRelationInput
  }

  export type userroleWhereUniqueInput = Prisma.AtLeast<{
    userid_roleid?: userroleUseridRoleidCompoundUniqueInput
    AND?: userroleWhereInput | userroleWhereInput[]
    OR?: userroleWhereInput[]
    NOT?: userroleWhereInput | userroleWhereInput[]
    userid?: IntFilter<"userrole"> | number
    roleid?: IntFilter<"userrole"> | number
    user?: XOR<UserRelationFilter, userWhereInput>
    role?: XOR<RoleRelationFilter, roleWhereInput>
  }, "userid_roleid">

  export type userroleOrderByWithAggregationInput = {
    userid?: SortOrder
    roleid?: SortOrder
    _count?: userroleCountOrderByAggregateInput
    _avg?: userroleAvgOrderByAggregateInput
    _max?: userroleMaxOrderByAggregateInput
    _min?: userroleMinOrderByAggregateInput
    _sum?: userroleSumOrderByAggregateInput
  }

  export type userroleScalarWhereWithAggregatesInput = {
    AND?: userroleScalarWhereWithAggregatesInput | userroleScalarWhereWithAggregatesInput[]
    OR?: userroleScalarWhereWithAggregatesInput[]
    NOT?: userroleScalarWhereWithAggregatesInput | userroleScalarWhereWithAggregatesInput[]
    userid?: IntWithAggregatesFilter<"userrole"> | number
    roleid?: IntWithAggregatesFilter<"userrole"> | number
  }

  export type auditlogCreateInput = {
    logtime: Decimal | DecimalJsLike | number | string
    cid?: number | null
    user?: string | null
    datatype: string
    dataid?: string | null
    action: string
    extrainfo?: string | null
  }

  export type auditlogUncheckedCreateInput = {
    logid?: number
    logtime: Decimal | DecimalJsLike | number | string
    cid?: number | null
    user?: string | null
    datatype: string
    dataid?: string | null
    action: string
    extrainfo?: string | null
  }

  export type auditlogUpdateInput = {
    logtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    datatype?: StringFieldUpdateOperationsInput | string
    dataid?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    extrainfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auditlogUncheckedUpdateInput = {
    logid?: IntFieldUpdateOperationsInput | number
    logtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    datatype?: StringFieldUpdateOperationsInput | string
    dataid?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    extrainfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auditlogCreateManyInput = {
    logid?: number
    logtime: Decimal | DecimalJsLike | number | string
    cid?: number | null
    user?: string | null
    datatype: string
    dataid?: string | null
    action: string
    extrainfo?: string | null
  }

  export type auditlogUpdateManyMutationInput = {
    logtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    datatype?: StringFieldUpdateOperationsInput | string
    dataid?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    extrainfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auditlogUncheckedUpdateManyInput = {
    logid?: IntFieldUpdateOperationsInput | number
    logtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    datatype?: StringFieldUpdateOperationsInput | string
    dataid?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    extrainfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type balloonCreateInput = {
    done?: boolean
    submission?: submissionCreateNestedOneWithoutBalloonInput
  }

  export type balloonUncheckedCreateInput = {
    balloonid?: number
    submitid?: number | null
    done?: boolean
  }

  export type balloonUpdateInput = {
    done?: BoolFieldUpdateOperationsInput | boolean
    submission?: submissionUpdateOneWithoutBalloonNestedInput
  }

  export type balloonUncheckedUpdateInput = {
    balloonid?: IntFieldUpdateOperationsInput | number
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
  }

  export type balloonCreateManyInput = {
    balloonid?: number
    submitid?: number | null
    done?: boolean
  }

  export type balloonUpdateManyMutationInput = {
    done?: BoolFieldUpdateOperationsInput | boolean
  }

  export type balloonUncheckedUpdateManyInput = {
    balloonid?: IntFieldUpdateOperationsInput | number
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    done?: BoolFieldUpdateOperationsInput | boolean
  }

  export type clarificationCreateInput = {
    externalid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    jury_member?: string | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
    contest?: contestCreateNestedOneWithoutClarificationInput
    clarification?: clarificationCreateNestedOneWithoutOther_clarificationInput
    other_clarification?: clarificationCreateNestedManyWithoutClarificationInput
    problem?: problemCreateNestedOneWithoutClarificationInput
    team_clarification_senderToteam?: teamCreateNestedOneWithoutClarification_clarification_senderToteamInput
    team_clarification_recipientToteam?: teamCreateNestedOneWithoutClarification_clarification_recipientToteamInput
    team_unread?: team_unreadCreateNestedManyWithoutClarificationInput
  }

  export type clarificationUncheckedCreateInput = {
    clarid?: number
    externalid?: string | null
    cid?: number | null
    respid?: number | null
    submittime: Decimal | DecimalJsLike | number | string
    sender?: number | null
    recipient?: number | null
    jury_member?: string | null
    probid?: number | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
    other_clarification?: clarificationUncheckedCreateNestedManyWithoutClarificationInput
    team_unread?: team_unreadUncheckedCreateNestedManyWithoutClarificationInput
  }

  export type clarificationUpdateInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    contest?: contestUpdateOneWithoutClarificationNestedInput
    clarification?: clarificationUpdateOneWithoutOther_clarificationNestedInput
    other_clarification?: clarificationUpdateManyWithoutClarificationNestedInput
    problem?: problemUpdateOneWithoutClarificationNestedInput
    team_clarification_senderToteam?: teamUpdateOneWithoutClarification_clarification_senderToteamNestedInput
    team_clarification_recipientToteam?: teamUpdateOneWithoutClarification_clarification_recipientToteamNestedInput
    team_unread?: team_unreadUpdateManyWithoutClarificationNestedInput
  }

  export type clarificationUncheckedUpdateInput = {
    clarid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    respid?: NullableIntFieldUpdateOperationsInput | number | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sender?: NullableIntFieldUpdateOperationsInput | number | null
    recipient?: NullableIntFieldUpdateOperationsInput | number | null
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    other_clarification?: clarificationUncheckedUpdateManyWithoutClarificationNestedInput
    team_unread?: team_unreadUncheckedUpdateManyWithoutClarificationNestedInput
  }

  export type clarificationCreateManyInput = {
    clarid?: number
    externalid?: string | null
    cid?: number | null
    respid?: number | null
    submittime: Decimal | DecimalJsLike | number | string
    sender?: number | null
    recipient?: number | null
    jury_member?: string | null
    probid?: number | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
  }

  export type clarificationUpdateManyMutationInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
  }

  export type clarificationUncheckedUpdateManyInput = {
    clarid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    respid?: NullableIntFieldUpdateOperationsInput | number | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sender?: NullableIntFieldUpdateOperationsInput | number | null
    recipient?: NullableIntFieldUpdateOperationsInput | number | null
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
  }

  export type configurationCreateInput = {
    name: string
    value: string
  }

  export type configurationUncheckedCreateInput = {
    configid?: number
    name: string
    value: string
  }

  export type configurationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type configurationUncheckedUpdateInput = {
    configid?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type configurationCreateManyInput = {
    configid?: number
    name: string
    value: string
  }

  export type configurationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type configurationUncheckedUpdateManyInput = {
    configid?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type contestCreateInput = {
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemCreateNestedManyWithoutContestInput
    contestteam?: contestteamCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsCreateNestedManyWithoutContestInput
    event?: eventCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementCreateNestedManyWithoutContestInput
    external_run?: external_runCreateNestedManyWithoutContestInput
    internal_error?: internal_errorCreateNestedManyWithoutContestInput
    judging?: judgingCreateNestedManyWithoutContestInput
    rankcache?: rankcacheCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalCreateNestedManyWithoutContestInput
    scorecache?: scorecacheCreateNestedManyWithoutContestInput
    submission?: submissionCreateNestedManyWithoutContestInput
  }

  export type contestUncheckedCreateInput = {
    cid?: number
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutContestInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryUncheckedCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedCreateNestedManyWithoutContestInput
    event?: eventUncheckedCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceUncheckedCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutContestInput
    external_run?: external_runUncheckedCreateNestedManyWithoutContestInput
    internal_error?: internal_errorUncheckedCreateNestedManyWithoutContestInput
    judging?: judgingUncheckedCreateNestedManyWithoutContestInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalUncheckedCreateNestedManyWithoutContestInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutContestInput
    submission?: submissionUncheckedCreateNestedManyWithoutContestInput
  }

  export type contestUpdateInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUpdateManyWithoutContestNestedInput
    event?: eventUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUpdateManyWithoutContestNestedInput
    external_run?: external_runUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUpdateManyWithoutContestNestedInput
    judging?: judgingUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUpdateManyWithoutContestNestedInput
    submission?: submissionUpdateManyWithoutContestNestedInput
  }

  export type contestUncheckedUpdateInput = {
    cid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedUpdateManyWithoutContestNestedInput
    event?: eventUncheckedUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUncheckedUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutContestNestedInput
    external_run?: external_runUncheckedUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUncheckedUpdateManyWithoutContestNestedInput
    judging?: judgingUncheckedUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUncheckedUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutContestNestedInput
    submission?: submissionUncheckedUpdateManyWithoutContestNestedInput
  }

  export type contestCreateManyInput = {
    cid?: number
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
  }

  export type contestUpdateManyMutationInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contestUncheckedUpdateManyInput = {
    cid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contestproblemCreateInput = {
    shortname: string
    points?: number
    allow_submit?: boolean
    allow_judge?: boolean
    color?: string | null
    lazy_eval_results?: number | null
    contest: contestCreateNestedOneWithoutContestproblemInput
    problem: problemCreateNestedOneWithoutContestproblemInput
    submission?: submissionCreateNestedManyWithoutContestproblemInput
  }

  export type contestproblemUncheckedCreateInput = {
    cid: number
    probid: number
    shortname: string
    points?: number
    allow_submit?: boolean
    allow_judge?: boolean
    color?: string | null
    lazy_eval_results?: number | null
    submission?: submissionUncheckedCreateNestedManyWithoutContestproblemInput
  }

  export type contestproblemUpdateInput = {
    shortname?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    lazy_eval_results?: NullableIntFieldUpdateOperationsInput | number | null
    contest?: contestUpdateOneRequiredWithoutContestproblemNestedInput
    problem?: problemUpdateOneRequiredWithoutContestproblemNestedInput
    submission?: submissionUpdateManyWithoutContestproblemNestedInput
  }

  export type contestproblemUncheckedUpdateInput = {
    cid?: IntFieldUpdateOperationsInput | number
    probid?: IntFieldUpdateOperationsInput | number
    shortname?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    lazy_eval_results?: NullableIntFieldUpdateOperationsInput | number | null
    submission?: submissionUncheckedUpdateManyWithoutContestproblemNestedInput
  }

  export type contestproblemCreateManyInput = {
    cid: number
    probid: number
    shortname: string
    points?: number
    allow_submit?: boolean
    allow_judge?: boolean
    color?: string | null
    lazy_eval_results?: number | null
  }

  export type contestproblemUpdateManyMutationInput = {
    shortname?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    lazy_eval_results?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type contestproblemUncheckedUpdateManyInput = {
    cid?: IntFieldUpdateOperationsInput | number
    probid?: IntFieldUpdateOperationsInput | number
    shortname?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    lazy_eval_results?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type contestteamCreateInput = {
    contest: contestCreateNestedOneWithoutContestteamInput
    team: teamCreateNestedOneWithoutContestteamInput
  }

  export type contestteamUncheckedCreateInput = {
    cid: number
    teamid: number
  }

  export type contestteamUpdateInput = {
    contest?: contestUpdateOneRequiredWithoutContestteamNestedInput
    team?: teamUpdateOneRequiredWithoutContestteamNestedInput
  }

  export type contestteamUncheckedUpdateInput = {
    cid?: IntFieldUpdateOperationsInput | number
    teamid?: IntFieldUpdateOperationsInput | number
  }

  export type contestteamCreateManyInput = {
    cid: number
    teamid: number
  }

  export type contestteamUpdateManyMutationInput = {

  }

  export type contestteamUncheckedUpdateManyInput = {
    cid?: IntFieldUpdateOperationsInput | number
    teamid?: IntFieldUpdateOperationsInput | number
  }

  export type contestteamcategoryCreateInput = {
    contest: contestCreateNestedOneWithoutContestteamcategoryInput
    team_category: team_categoryCreateNestedOneWithoutContestteamcategoryInput
  }

  export type contestteamcategoryUncheckedCreateInput = {
    cid: number
    categoryid: number
  }

  export type contestteamcategoryUpdateInput = {
    contest?: contestUpdateOneRequiredWithoutContestteamcategoryNestedInput
    team_category?: team_categoryUpdateOneRequiredWithoutContestteamcategoryNestedInput
  }

  export type contestteamcategoryUncheckedUpdateInput = {
    cid?: IntFieldUpdateOperationsInput | number
    categoryid?: IntFieldUpdateOperationsInput | number
  }

  export type contestteamcategoryCreateManyInput = {
    cid: number
    categoryid: number
  }

  export type contestteamcategoryUpdateManyMutationInput = {

  }

  export type contestteamcategoryUncheckedUpdateManyInput = {
    cid?: IntFieldUpdateOperationsInput | number
    categoryid?: IntFieldUpdateOperationsInput | number
  }

  export type contestteamcategoryformedalsCreateInput = {
    contest: contestCreateNestedOneWithoutContestteamcategoryformedalsInput
    team_category: team_categoryCreateNestedOneWithoutContestteamcategoryformedalsInput
  }

  export type contestteamcategoryformedalsUncheckedCreateInput = {
    cid: number
    categoryid: number
  }

  export type contestteamcategoryformedalsUpdateInput = {
    contest?: contestUpdateOneRequiredWithoutContestteamcategoryformedalsNestedInput
    team_category?: team_categoryUpdateOneRequiredWithoutContestteamcategoryformedalsNestedInput
  }

  export type contestteamcategoryformedalsUncheckedUpdateInput = {
    cid?: IntFieldUpdateOperationsInput | number
    categoryid?: IntFieldUpdateOperationsInput | number
  }

  export type contestteamcategoryformedalsCreateManyInput = {
    cid: number
    categoryid: number
  }

  export type contestteamcategoryformedalsUpdateManyMutationInput = {

  }

  export type contestteamcategoryformedalsUncheckedUpdateManyInput = {
    cid?: IntFieldUpdateOperationsInput | number
    categoryid?: IntFieldUpdateOperationsInput | number
  }

  export type debug_packageCreateInput = {
    filename: string
    judging?: judgingCreateNestedOneWithoutDebug_packageInput
    judgehost?: judgehostCreateNestedOneWithoutDebug_packageInput
  }

  export type debug_packageUncheckedCreateInput = {
    debug_package_id?: number
    judgingid?: number | null
    judgehostid?: number | null
    filename: string
  }

  export type debug_packageUpdateInput = {
    filename?: StringFieldUpdateOperationsInput | string
    judging?: judgingUpdateOneWithoutDebug_packageNestedInput
    judgehost?: judgehostUpdateOneWithoutDebug_packageNestedInput
  }

  export type debug_packageUncheckedUpdateInput = {
    debug_package_id?: IntFieldUpdateOperationsInput | number
    judgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judgehostid?: NullableIntFieldUpdateOperationsInput | number | null
    filename?: StringFieldUpdateOperationsInput | string
  }

  export type debug_packageCreateManyInput = {
    debug_package_id?: number
    judgingid?: number | null
    judgehostid?: number | null
    filename: string
  }

  export type debug_packageUpdateManyMutationInput = {
    filename?: StringFieldUpdateOperationsInput | string
  }

  export type debug_packageUncheckedUpdateManyInput = {
    debug_package_id?: IntFieldUpdateOperationsInput | number
    judgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judgehostid?: NullableIntFieldUpdateOperationsInput | number | null
    filename?: StringFieldUpdateOperationsInput | string
  }

  export type doctrine_migration_versionsCreateInput = {
    version: string
    executed_at?: Date | string | null
    execution_time?: number | null
  }

  export type doctrine_migration_versionsUncheckedCreateInput = {
    version: string
    executed_at?: Date | string | null
    execution_time?: number | null
  }

  export type doctrine_migration_versionsUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    execution_time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type doctrine_migration_versionsUncheckedUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    execution_time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type doctrine_migration_versionsCreateManyInput = {
    version: string
    executed_at?: Date | string | null
    execution_time?: number | null
  }

  export type doctrine_migration_versionsUpdateManyMutationInput = {
    version?: StringFieldUpdateOperationsInput | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    execution_time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type doctrine_migration_versionsUncheckedUpdateManyInput = {
    version?: StringFieldUpdateOperationsInput | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    execution_time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type eventCreateInput = {
    eventtime: Decimal | DecimalJsLike | number | string
    endpointtype: string
    endpointid: string
    action: string
    content: Buffer
    contest?: contestCreateNestedOneWithoutEventInput
  }

  export type eventUncheckedCreateInput = {
    eventid?: number
    eventtime: Decimal | DecimalJsLike | number | string
    cid?: number | null
    endpointtype: string
    endpointid: string
    action: string
    content: Buffer
  }

  export type eventUpdateInput = {
    eventtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endpointtype?: StringFieldUpdateOperationsInput | string
    endpointid?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Buffer
    contest?: contestUpdateOneWithoutEventNestedInput
  }

  export type eventUncheckedUpdateInput = {
    eventid?: IntFieldUpdateOperationsInput | number
    eventtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    endpointtype?: StringFieldUpdateOperationsInput | string
    endpointid?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type eventCreateManyInput = {
    eventid?: number
    eventtime: Decimal | DecimalJsLike | number | string
    cid?: number | null
    endpointtype: string
    endpointid: string
    action: string
    content: Buffer
  }

  export type eventUpdateManyMutationInput = {
    eventtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endpointtype?: StringFieldUpdateOperationsInput | string
    endpointid?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type eventUncheckedUpdateManyInput = {
    eventid?: IntFieldUpdateOperationsInput | number
    eventtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    endpointtype?: StringFieldUpdateOperationsInput | string
    endpointid?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type executableCreateInput = {
    execid: string
    description?: string | null
    type: string
    immutable_executable?: immutable_executableCreateNestedOneWithoutExecutableInput
    language?: languageCreateNestedManyWithoutExecutableInput
    problem_problem_special_runToexecutable?: problemCreateNestedManyWithoutExecutable_problem_special_runToexecutableInput
    problem_problem_special_compareToexecutable?: problemCreateNestedManyWithoutExecutable_problem_special_compareToexecutableInput
  }

  export type executableUncheckedCreateInput = {
    execid: string
    description?: string | null
    type: string
    immutable_execid?: number | null
    language?: languageUncheckedCreateNestedManyWithoutExecutableInput
    problem_problem_special_runToexecutable?: problemUncheckedCreateNestedManyWithoutExecutable_problem_special_runToexecutableInput
    problem_problem_special_compareToexecutable?: problemUncheckedCreateNestedManyWithoutExecutable_problem_special_compareToexecutableInput
  }

  export type executableUpdateInput = {
    execid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    immutable_executable?: immutable_executableUpdateOneWithoutExecutableNestedInput
    language?: languageUpdateManyWithoutExecutableNestedInput
    problem_problem_special_runToexecutable?: problemUpdateManyWithoutExecutable_problem_special_runToexecutableNestedInput
    problem_problem_special_compareToexecutable?: problemUpdateManyWithoutExecutable_problem_special_compareToexecutableNestedInput
  }

  export type executableUncheckedUpdateInput = {
    execid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    immutable_execid?: NullableIntFieldUpdateOperationsInput | number | null
    language?: languageUncheckedUpdateManyWithoutExecutableNestedInput
    problem_problem_special_runToexecutable?: problemUncheckedUpdateManyWithoutExecutable_problem_special_runToexecutableNestedInput
    problem_problem_special_compareToexecutable?: problemUncheckedUpdateManyWithoutExecutable_problem_special_compareToexecutableNestedInput
  }

  export type executableCreateManyInput = {
    execid: string
    description?: string | null
    type: string
    immutable_execid?: number | null
  }

  export type executableUpdateManyMutationInput = {
    execid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type executableUncheckedUpdateManyInput = {
    execid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    immutable_execid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type executable_fileCreateInput = {
    filename: string
    ranknumber: number
    file_content: Buffer
    hash?: string | null
    is_executable?: boolean
    immutable_executable?: immutable_executableCreateNestedOneWithoutExecutable_fileInput
  }

  export type executable_fileUncheckedCreateInput = {
    execfileid?: number
    immutable_execid?: number | null
    filename: string
    ranknumber: number
    file_content: Buffer
    hash?: string | null
    is_executable?: boolean
  }

  export type executable_fileUpdateInput = {
    filename?: StringFieldUpdateOperationsInput | string
    ranknumber?: IntFieldUpdateOperationsInput | number
    file_content?: BytesFieldUpdateOperationsInput | Buffer
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_executable?: BoolFieldUpdateOperationsInput | boolean
    immutable_executable?: immutable_executableUpdateOneWithoutExecutable_fileNestedInput
  }

  export type executable_fileUncheckedUpdateInput = {
    execfileid?: IntFieldUpdateOperationsInput | number
    immutable_execid?: NullableIntFieldUpdateOperationsInput | number | null
    filename?: StringFieldUpdateOperationsInput | string
    ranknumber?: IntFieldUpdateOperationsInput | number
    file_content?: BytesFieldUpdateOperationsInput | Buffer
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_executable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type executable_fileCreateManyInput = {
    execfileid?: number
    immutable_execid?: number | null
    filename: string
    ranknumber: number
    file_content: Buffer
    hash?: string | null
    is_executable?: boolean
  }

  export type executable_fileUpdateManyMutationInput = {
    filename?: StringFieldUpdateOperationsInput | string
    ranknumber?: IntFieldUpdateOperationsInput | number
    file_content?: BytesFieldUpdateOperationsInput | Buffer
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_executable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type executable_fileUncheckedUpdateManyInput = {
    execfileid?: IntFieldUpdateOperationsInput | number
    immutable_execid?: NullableIntFieldUpdateOperationsInput | number | null
    filename?: StringFieldUpdateOperationsInput | string
    ranknumber?: IntFieldUpdateOperationsInput | number
    file_content?: BytesFieldUpdateOperationsInput | Buffer
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_executable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type external_contest_sourceCreateInput = {
    type: string
    source: string
    username?: string | null
    password?: string | null
    last_event_id?: string | null
    last_poll_time?: Decimal | DecimalJsLike | number | string | null
    contest?: contestCreateNestedOneWithoutExternal_contest_sourceInput
    external_source_warning?: external_source_warningCreateNestedManyWithoutExternal_contest_sourceInput
  }

  export type external_contest_sourceUncheckedCreateInput = {
    extsourceid?: number
    cid?: number | null
    type: string
    source: string
    username?: string | null
    password?: string | null
    last_event_id?: string | null
    last_poll_time?: Decimal | DecimalJsLike | number | string | null
    external_source_warning?: external_source_warningUncheckedCreateNestedManyWithoutExternal_contest_sourceInput
  }

  export type external_contest_sourceUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    last_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_poll_time?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contest?: contestUpdateOneWithoutExternal_contest_sourceNestedInput
    external_source_warning?: external_source_warningUpdateManyWithoutExternal_contest_sourceNestedInput
  }

  export type external_contest_sourceUncheckedUpdateInput = {
    extsourceid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    last_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_poll_time?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    external_source_warning?: external_source_warningUncheckedUpdateManyWithoutExternal_contest_sourceNestedInput
  }

  export type external_contest_sourceCreateManyInput = {
    extsourceid?: number
    cid?: number | null
    type: string
    source: string
    username?: string | null
    password?: string | null
    last_event_id?: string | null
    last_poll_time?: Decimal | DecimalJsLike | number | string | null
  }

  export type external_contest_sourceUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    last_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_poll_time?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type external_contest_sourceUncheckedUpdateManyInput = {
    extsourceid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    last_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_poll_time?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type external_judgementCreateInput = {
    externalid?: string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    valid?: boolean
    submission?: submissionCreateNestedOneWithoutExternal_judgementInput
    contest?: contestCreateNestedOneWithoutExternal_judgementInput
    external_run?: external_runCreateNestedManyWithoutExternal_judgementInput
  }

  export type external_judgementUncheckedCreateInput = {
    extjudgementid?: number
    externalid?: string | null
    cid?: number | null
    submitid?: number | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    valid?: boolean
    external_run?: external_runUncheckedCreateNestedManyWithoutExternal_judgementInput
  }

  export type external_judgementUpdateInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    submission?: submissionUpdateOneWithoutExternal_judgementNestedInput
    contest?: contestUpdateOneWithoutExternal_judgementNestedInput
    external_run?: external_runUpdateManyWithoutExternal_judgementNestedInput
  }

  export type external_judgementUncheckedUpdateInput = {
    extjudgementid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    external_run?: external_runUncheckedUpdateManyWithoutExternal_judgementNestedInput
  }

  export type external_judgementCreateManyInput = {
    extjudgementid?: number
    externalid?: string | null
    cid?: number | null
    submitid?: number | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    valid?: boolean
  }

  export type external_judgementUpdateManyMutationInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type external_judgementUncheckedUpdateManyInput = {
    extjudgementid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type external_runCreateInput = {
    externalid?: string | null
    result: string
    endtime: Decimal | DecimalJsLike | number | string
    runtime: number
    external_judgement?: external_judgementCreateNestedOneWithoutExternal_runInput
    testcase?: testcaseCreateNestedOneWithoutExternal_runInput
    contest?: contestCreateNestedOneWithoutExternal_runInput
  }

  export type external_runUncheckedCreateInput = {
    extrunid?: number
    extjudgementid?: number | null
    testcaseid?: number | null
    externalid?: string | null
    cid?: number | null
    result: string
    endtime: Decimal | DecimalJsLike | number | string
    runtime: number
  }

  export type external_runUpdateInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    result?: StringFieldUpdateOperationsInput | string
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runtime?: FloatFieldUpdateOperationsInput | number
    external_judgement?: external_judgementUpdateOneWithoutExternal_runNestedInput
    testcase?: testcaseUpdateOneWithoutExternal_runNestedInput
    contest?: contestUpdateOneWithoutExternal_runNestedInput
  }

  export type external_runUncheckedUpdateInput = {
    extrunid?: IntFieldUpdateOperationsInput | number
    extjudgementid?: NullableIntFieldUpdateOperationsInput | number | null
    testcaseid?: NullableIntFieldUpdateOperationsInput | number | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    result?: StringFieldUpdateOperationsInput | string
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runtime?: FloatFieldUpdateOperationsInput | number
  }

  export type external_runCreateManyInput = {
    extrunid?: number
    extjudgementid?: number | null
    testcaseid?: number | null
    externalid?: string | null
    cid?: number | null
    result: string
    endtime: Decimal | DecimalJsLike | number | string
    runtime: number
  }

  export type external_runUpdateManyMutationInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    result?: StringFieldUpdateOperationsInput | string
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runtime?: FloatFieldUpdateOperationsInput | number
  }

  export type external_runUncheckedUpdateManyInput = {
    extrunid?: IntFieldUpdateOperationsInput | number
    extjudgementid?: NullableIntFieldUpdateOperationsInput | number | null
    testcaseid?: NullableIntFieldUpdateOperationsInput | number | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    result?: StringFieldUpdateOperationsInput | string
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runtime?: FloatFieldUpdateOperationsInput | number
  }

  export type external_source_warningCreateInput = {
    last_event_id?: string | null
    time: Decimal | DecimalJsLike | number | string
    entity_type: string
    entity_id: string
    type: string
    hash: string
    content: string
    external_contest_source?: external_contest_sourceCreateNestedOneWithoutExternal_source_warningInput
  }

  export type external_source_warningUncheckedCreateInput = {
    extwarningid?: number
    extsourceid?: number | null
    last_event_id?: string | null
    time: Decimal | DecimalJsLike | number | string
    entity_type: string
    entity_id: string
    type: string
    hash: string
    content: string
  }

  export type external_source_warningUpdateInput = {
    last_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    external_contest_source?: external_contest_sourceUpdateOneWithoutExternal_source_warningNestedInput
  }

  export type external_source_warningUncheckedUpdateInput = {
    extwarningid?: IntFieldUpdateOperationsInput | number
    extsourceid?: NullableIntFieldUpdateOperationsInput | number | null
    last_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type external_source_warningCreateManyInput = {
    extwarningid?: number
    extsourceid?: number | null
    last_event_id?: string | null
    time: Decimal | DecimalJsLike | number | string
    entity_type: string
    entity_id: string
    type: string
    hash: string
    content: string
  }

  export type external_source_warningUpdateManyMutationInput = {
    last_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type external_source_warningUncheckedUpdateManyInput = {
    extwarningid?: IntFieldUpdateOperationsInput | number
    extsourceid?: NullableIntFieldUpdateOperationsInput | number | null
    last_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type immutable_executableCreateInput = {
    hash?: string | null
    executable?: executableCreateNestedOneWithoutImmutable_executableInput
    executable_file?: executable_fileCreateNestedManyWithoutImmutable_executableInput
    user?: userCreateNestedOneWithoutImmutable_executableInput
  }

  export type immutable_executableUncheckedCreateInput = {
    immutable_execid?: number
    userid?: number | null
    hash?: string | null
    executable?: executableUncheckedCreateNestedOneWithoutImmutable_executableInput
    executable_file?: executable_fileUncheckedCreateNestedManyWithoutImmutable_executableInput
  }

  export type immutable_executableUpdateInput = {
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    executable?: executableUpdateOneWithoutImmutable_executableNestedInput
    executable_file?: executable_fileUpdateManyWithoutImmutable_executableNestedInput
    user?: userUpdateOneWithoutImmutable_executableNestedInput
  }

  export type immutable_executableUncheckedUpdateInput = {
    immutable_execid?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    executable?: executableUncheckedUpdateOneWithoutImmutable_executableNestedInput
    executable_file?: executable_fileUncheckedUpdateManyWithoutImmutable_executableNestedInput
  }

  export type immutable_executableCreateManyInput = {
    immutable_execid?: number
    userid?: number | null
    hash?: string | null
  }

  export type immutable_executableUpdateManyMutationInput = {
    hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type immutable_executableUncheckedUpdateManyInput = {
    immutable_execid?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type internal_errorCreateInput = {
    description: string
    judgehostlog: string
    time: Decimal | DecimalJsLike | number | string
    disabled: string
    status?: $Enums.internal_error_status
    judging_internal_error_judgingidTojudging?: judgingCreateNestedOneWithoutInternal_error_internal_error_judgingidTojudgingInput
    contest?: contestCreateNestedOneWithoutInternal_errorInput
    judging_judging_erroridTointernal_error?: judgingCreateNestedManyWithoutInternal_error_judging_erroridTointernal_errorInput
  }

  export type internal_errorUncheckedCreateInput = {
    errorid?: number
    judgingid?: number | null
    cid?: number | null
    description: string
    judgehostlog: string
    time: Decimal | DecimalJsLike | number | string
    disabled: string
    status?: $Enums.internal_error_status
    judging_judging_erroridTointernal_error?: judgingUncheckedCreateNestedManyWithoutInternal_error_judging_erroridTointernal_errorInput
  }

  export type internal_errorUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    judgehostlog?: StringFieldUpdateOperationsInput | string
    time?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disabled?: StringFieldUpdateOperationsInput | string
    status?: Enuminternal_error_statusFieldUpdateOperationsInput | $Enums.internal_error_status
    judging_internal_error_judgingidTojudging?: judgingUpdateOneWithoutInternal_error_internal_error_judgingidTojudgingNestedInput
    contest?: contestUpdateOneWithoutInternal_errorNestedInput
    judging_judging_erroridTointernal_error?: judgingUpdateManyWithoutInternal_error_judging_erroridTointernal_errorNestedInput
  }

  export type internal_errorUncheckedUpdateInput = {
    errorid?: IntFieldUpdateOperationsInput | number
    judgingid?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    judgehostlog?: StringFieldUpdateOperationsInput | string
    time?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disabled?: StringFieldUpdateOperationsInput | string
    status?: Enuminternal_error_statusFieldUpdateOperationsInput | $Enums.internal_error_status
    judging_judging_erroridTointernal_error?: judgingUncheckedUpdateManyWithoutInternal_error_judging_erroridTointernal_errorNestedInput
  }

  export type internal_errorCreateManyInput = {
    errorid?: number
    judgingid?: number | null
    cid?: number | null
    description: string
    judgehostlog: string
    time: Decimal | DecimalJsLike | number | string
    disabled: string
    status?: $Enums.internal_error_status
  }

  export type internal_errorUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    judgehostlog?: StringFieldUpdateOperationsInput | string
    time?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disabled?: StringFieldUpdateOperationsInput | string
    status?: Enuminternal_error_statusFieldUpdateOperationsInput | $Enums.internal_error_status
  }

  export type internal_errorUncheckedUpdateManyInput = {
    errorid?: IntFieldUpdateOperationsInput | number
    judgingid?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    judgehostlog?: StringFieldUpdateOperationsInput | string
    time?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disabled?: StringFieldUpdateOperationsInput | string
    status?: Enuminternal_error_statusFieldUpdateOperationsInput | $Enums.internal_error_status
  }

  export type judgehostCreateInput = {
    hostname: string
    enabled?: boolean
    polltime?: Decimal | DecimalJsLike | number | string | null
    hidden?: boolean
    debug_package?: debug_packageCreateNestedManyWithoutJudgehostInput
    judgetask?: judgetaskCreateNestedManyWithoutJudgehostInput
  }

  export type judgehostUncheckedCreateInput = {
    judgehostid?: number
    hostname: string
    enabled?: boolean
    polltime?: Decimal | DecimalJsLike | number | string | null
    hidden?: boolean
    debug_package?: debug_packageUncheckedCreateNestedManyWithoutJudgehostInput
    judgetask?: judgetaskUncheckedCreateNestedManyWithoutJudgehostInput
  }

  export type judgehostUpdateInput = {
    hostname?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    polltime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    debug_package?: debug_packageUpdateManyWithoutJudgehostNestedInput
    judgetask?: judgetaskUpdateManyWithoutJudgehostNestedInput
  }

  export type judgehostUncheckedUpdateInput = {
    judgehostid?: IntFieldUpdateOperationsInput | number
    hostname?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    polltime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    debug_package?: debug_packageUncheckedUpdateManyWithoutJudgehostNestedInput
    judgetask?: judgetaskUncheckedUpdateManyWithoutJudgehostNestedInput
  }

  export type judgehostCreateManyInput = {
    judgehostid?: number
    hostname: string
    enabled?: boolean
    polltime?: Decimal | DecimalJsLike | number | string | null
    hidden?: boolean
  }

  export type judgehostUpdateManyMutationInput = {
    hostname?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    polltime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type judgehostUncheckedUpdateManyInput = {
    judgehostid?: IntFieldUpdateOperationsInput | number
    hostname?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    polltime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type judgetaskCreateInput = {
    type?: $Enums.judgetask_type
    priority: number
    jobid?: number | null
    submitid?: number | null
    compile_script_id?: number | null
    run_script_id?: number | null
    compare_script_id?: number | null
    testcase_id?: number | null
    compile_config?: string | null
    run_config?: string | null
    compare_config?: string | null
    valid?: boolean
    starttime?: Decimal | DecimalJsLike | number | string | null
    uuid?: string | null
    testcase_hash?: string | null
    judgehost?: judgehostCreateNestedOneWithoutJudgetaskInput
    judging_run?: judging_runCreateNestedManyWithoutJudgetaskInput
  }

  export type judgetaskUncheckedCreateInput = {
    judgetaskid?: number
    judgehostid?: number | null
    type?: $Enums.judgetask_type
    priority: number
    jobid?: number | null
    submitid?: number | null
    compile_script_id?: number | null
    run_script_id?: number | null
    compare_script_id?: number | null
    testcase_id?: number | null
    compile_config?: string | null
    run_config?: string | null
    compare_config?: string | null
    valid?: boolean
    starttime?: Decimal | DecimalJsLike | number | string | null
    uuid?: string | null
    testcase_hash?: string | null
    judging_run?: judging_runUncheckedCreateNestedManyWithoutJudgetaskInput
  }

  export type judgetaskUpdateInput = {
    type?: Enumjudgetask_typeFieldUpdateOperationsInput | $Enums.judgetask_type
    priority?: IntFieldUpdateOperationsInput | number
    jobid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    compile_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    run_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    compare_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    testcase_id?: NullableIntFieldUpdateOperationsInput | number | null
    compile_config?: NullableStringFieldUpdateOperationsInput | string | null
    run_config?: NullableStringFieldUpdateOperationsInput | string | null
    compare_config?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    testcase_hash?: NullableStringFieldUpdateOperationsInput | string | null
    judgehost?: judgehostUpdateOneWithoutJudgetaskNestedInput
    judging_run?: judging_runUpdateManyWithoutJudgetaskNestedInput
  }

  export type judgetaskUncheckedUpdateInput = {
    judgetaskid?: IntFieldUpdateOperationsInput | number
    judgehostid?: NullableIntFieldUpdateOperationsInput | number | null
    type?: Enumjudgetask_typeFieldUpdateOperationsInput | $Enums.judgetask_type
    priority?: IntFieldUpdateOperationsInput | number
    jobid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    compile_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    run_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    compare_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    testcase_id?: NullableIntFieldUpdateOperationsInput | number | null
    compile_config?: NullableStringFieldUpdateOperationsInput | string | null
    run_config?: NullableStringFieldUpdateOperationsInput | string | null
    compare_config?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    testcase_hash?: NullableStringFieldUpdateOperationsInput | string | null
    judging_run?: judging_runUncheckedUpdateManyWithoutJudgetaskNestedInput
  }

  export type judgetaskCreateManyInput = {
    judgetaskid?: number
    judgehostid?: number | null
    type?: $Enums.judgetask_type
    priority: number
    jobid?: number | null
    submitid?: number | null
    compile_script_id?: number | null
    run_script_id?: number | null
    compare_script_id?: number | null
    testcase_id?: number | null
    compile_config?: string | null
    run_config?: string | null
    compare_config?: string | null
    valid?: boolean
    starttime?: Decimal | DecimalJsLike | number | string | null
    uuid?: string | null
    testcase_hash?: string | null
  }

  export type judgetaskUpdateManyMutationInput = {
    type?: Enumjudgetask_typeFieldUpdateOperationsInput | $Enums.judgetask_type
    priority?: IntFieldUpdateOperationsInput | number
    jobid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    compile_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    run_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    compare_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    testcase_id?: NullableIntFieldUpdateOperationsInput | number | null
    compile_config?: NullableStringFieldUpdateOperationsInput | string | null
    run_config?: NullableStringFieldUpdateOperationsInput | string | null
    compare_config?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    testcase_hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type judgetaskUncheckedUpdateManyInput = {
    judgetaskid?: IntFieldUpdateOperationsInput | number
    judgehostid?: NullableIntFieldUpdateOperationsInput | number | null
    type?: Enumjudgetask_typeFieldUpdateOperationsInput | $Enums.judgetask_type
    priority?: IntFieldUpdateOperationsInput | number
    jobid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    compile_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    run_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    compare_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    testcase_id?: NullableIntFieldUpdateOperationsInput | number | null
    compile_config?: NullableStringFieldUpdateOperationsInput | string | null
    run_config?: NullableStringFieldUpdateOperationsInput | string | null
    compare_config?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    testcase_hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type judgingCreateInput = {
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    judge_completely?: boolean
    uuid: string
    metadata?: Buffer | null
    debug_package?: debug_packageCreateNestedManyWithoutJudgingInput
    internal_error_internal_error_judgingidTojudging?: internal_errorCreateNestedManyWithoutJudging_internal_error_judgingidTojudgingInput
    internal_error_judging_erroridTointernal_error?: internal_errorCreateNestedOneWithoutJudging_judging_erroridTointernal_errorInput
    contest?: contestCreateNestedOneWithoutJudgingInput
    submission?: submissionCreateNestedOneWithoutJudgingInput
    rejudging?: rejudgingCreateNestedOneWithoutJudgingInput
    judging?: judgingCreateNestedOneWithoutOther_judgingInput
    other_judging?: judgingCreateNestedManyWithoutJudgingInput
    judging_run?: judging_runCreateNestedManyWithoutJudgingInput
  }

  export type judgingUncheckedCreateInput = {
    judgingid?: number
    cid?: number | null
    submitid?: number | null
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    rejudgingid?: number | null
    prevjudgingid?: number | null
    judge_completely?: boolean
    errorid?: number | null
    uuid: string
    metadata?: Buffer | null
    debug_package?: debug_packageUncheckedCreateNestedManyWithoutJudgingInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUncheckedCreateNestedManyWithoutJudging_internal_error_judgingidTojudgingInput
    other_judging?: judgingUncheckedCreateNestedManyWithoutJudgingInput
    judging_run?: judging_runUncheckedCreateNestedManyWithoutJudgingInput
  }

  export type judgingUpdateInput = {
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    debug_package?: debug_packageUpdateManyWithoutJudgingNestedInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUpdateManyWithoutJudging_internal_error_judgingidTojudgingNestedInput
    internal_error_judging_erroridTointernal_error?: internal_errorUpdateOneWithoutJudging_judging_erroridTointernal_errorNestedInput
    contest?: contestUpdateOneWithoutJudgingNestedInput
    submission?: submissionUpdateOneWithoutJudgingNestedInput
    rejudging?: rejudgingUpdateOneWithoutJudgingNestedInput
    judging?: judgingUpdateOneWithoutOther_judgingNestedInput
    other_judging?: judgingUpdateManyWithoutJudgingNestedInput
    judging_run?: judging_runUpdateManyWithoutJudgingNestedInput
  }

  export type judgingUncheckedUpdateInput = {
    judgingid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    prevjudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    errorid?: NullableIntFieldUpdateOperationsInput | number | null
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    debug_package?: debug_packageUncheckedUpdateManyWithoutJudgingNestedInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUncheckedUpdateManyWithoutJudging_internal_error_judgingidTojudgingNestedInput
    other_judging?: judgingUncheckedUpdateManyWithoutJudgingNestedInput
    judging_run?: judging_runUncheckedUpdateManyWithoutJudgingNestedInput
  }

  export type judgingCreateManyInput = {
    judgingid?: number
    cid?: number | null
    submitid?: number | null
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    rejudgingid?: number | null
    prevjudgingid?: number | null
    judge_completely?: boolean
    errorid?: number | null
    uuid: string
    metadata?: Buffer | null
  }

  export type judgingUpdateManyMutationInput = {
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type judgingUncheckedUpdateManyInput = {
    judgingid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    prevjudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    errorid?: NullableIntFieldUpdateOperationsInput | number | null
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type judging_runCreateInput = {
    runresult?: string | null
    runtime?: number | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    judgetask?: judgetaskCreateNestedOneWithoutJudging_runInput
    testcase?: testcaseCreateNestedOneWithoutJudging_runInput
    judging?: judgingCreateNestedOneWithoutJudging_runInput
    judging_run_output?: judging_run_outputCreateNestedOneWithoutJudging_runInput
  }

  export type judging_runUncheckedCreateInput = {
    runid?: number
    judgingid?: number | null
    testcaseid?: number | null
    runresult?: string | null
    runtime?: number | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    judgetaskid?: number | null
    judging_run_output?: judging_run_outputUncheckedCreateNestedOneWithoutJudging_runInput
  }

  export type judging_runUpdateInput = {
    runresult?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableFloatFieldUpdateOperationsInput | number | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    judgetask?: judgetaskUpdateOneWithoutJudging_runNestedInput
    testcase?: testcaseUpdateOneWithoutJudging_runNestedInput
    judging?: judgingUpdateOneWithoutJudging_runNestedInput
    judging_run_output?: judging_run_outputUpdateOneWithoutJudging_runNestedInput
  }

  export type judging_runUncheckedUpdateInput = {
    runid?: IntFieldUpdateOperationsInput | number
    judgingid?: NullableIntFieldUpdateOperationsInput | number | null
    testcaseid?: NullableIntFieldUpdateOperationsInput | number | null
    runresult?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableFloatFieldUpdateOperationsInput | number | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    judgetaskid?: NullableIntFieldUpdateOperationsInput | number | null
    judging_run_output?: judging_run_outputUncheckedUpdateOneWithoutJudging_runNestedInput
  }

  export type judging_runCreateManyInput = {
    runid?: number
    judgingid?: number | null
    testcaseid?: number | null
    runresult?: string | null
    runtime?: number | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    judgetaskid?: number | null
  }

  export type judging_runUpdateManyMutationInput = {
    runresult?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableFloatFieldUpdateOperationsInput | number | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type judging_runUncheckedUpdateManyInput = {
    runid?: IntFieldUpdateOperationsInput | number
    judgingid?: NullableIntFieldUpdateOperationsInput | number | null
    testcaseid?: NullableIntFieldUpdateOperationsInput | number | null
    runresult?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableFloatFieldUpdateOperationsInput | number | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    judgetaskid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type judging_run_outputCreateInput = {
    output_run?: Buffer | null
    output_diff?: Buffer | null
    output_error?: Buffer | null
    output_system?: Buffer | null
    metadata?: Buffer | null
    judging_run: judging_runCreateNestedOneWithoutJudging_run_outputInput
  }

  export type judging_run_outputUncheckedCreateInput = {
    runid: number
    output_run?: Buffer | null
    output_diff?: Buffer | null
    output_error?: Buffer | null
    output_system?: Buffer | null
    metadata?: Buffer | null
  }

  export type judging_run_outputUpdateInput = {
    output_run?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output_diff?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output_error?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output_system?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    judging_run?: judging_runUpdateOneRequiredWithoutJudging_run_outputNestedInput
  }

  export type judging_run_outputUncheckedUpdateInput = {
    runid?: IntFieldUpdateOperationsInput | number
    output_run?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output_diff?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output_error?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output_system?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type judging_run_outputCreateManyInput = {
    runid: number
    output_run?: Buffer | null
    output_diff?: Buffer | null
    output_error?: Buffer | null
    output_system?: Buffer | null
    metadata?: Buffer | null
  }

  export type judging_run_outputUpdateManyMutationInput = {
    output_run?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output_diff?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output_error?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output_system?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type judging_run_outputUncheckedUpdateManyInput = {
    runid?: IntFieldUpdateOperationsInput | number
    output_run?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output_diff?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output_error?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output_system?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type languageCreateInput = {
    langid: string
    externalid?: string | null
    name: string
    extensions?: string | null
    require_entry_point?: boolean
    entry_point_description?: string | null
    allow_submit?: boolean
    allow_judge?: boolean
    time_factor?: number
    filter_compiler_files?: boolean
    executable?: executableCreateNestedOneWithoutLanguageInput
    submission?: submissionCreateNestedManyWithoutLanguageInput
  }

  export type languageUncheckedCreateInput = {
    langid: string
    externalid?: string | null
    name: string
    extensions?: string | null
    require_entry_point?: boolean
    entry_point_description?: string | null
    allow_submit?: boolean
    allow_judge?: boolean
    time_factor?: number
    compile_script?: string | null
    filter_compiler_files?: boolean
    submission?: submissionUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type languageUpdateInput = {
    langid?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    extensions?: NullableStringFieldUpdateOperationsInput | string | null
    require_entry_point?: BoolFieldUpdateOperationsInput | boolean
    entry_point_description?: NullableStringFieldUpdateOperationsInput | string | null
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    time_factor?: FloatFieldUpdateOperationsInput | number
    filter_compiler_files?: BoolFieldUpdateOperationsInput | boolean
    executable?: executableUpdateOneWithoutLanguageNestedInput
    submission?: submissionUpdateManyWithoutLanguageNestedInput
  }

  export type languageUncheckedUpdateInput = {
    langid?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    extensions?: NullableStringFieldUpdateOperationsInput | string | null
    require_entry_point?: BoolFieldUpdateOperationsInput | boolean
    entry_point_description?: NullableStringFieldUpdateOperationsInput | string | null
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    time_factor?: FloatFieldUpdateOperationsInput | number
    compile_script?: NullableStringFieldUpdateOperationsInput | string | null
    filter_compiler_files?: BoolFieldUpdateOperationsInput | boolean
    submission?: submissionUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type languageCreateManyInput = {
    langid: string
    externalid?: string | null
    name: string
    extensions?: string | null
    require_entry_point?: boolean
    entry_point_description?: string | null
    allow_submit?: boolean
    allow_judge?: boolean
    time_factor?: number
    compile_script?: string | null
    filter_compiler_files?: boolean
  }

  export type languageUpdateManyMutationInput = {
    langid?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    extensions?: NullableStringFieldUpdateOperationsInput | string | null
    require_entry_point?: BoolFieldUpdateOperationsInput | boolean
    entry_point_description?: NullableStringFieldUpdateOperationsInput | string | null
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    time_factor?: FloatFieldUpdateOperationsInput | number
    filter_compiler_files?: BoolFieldUpdateOperationsInput | boolean
  }

  export type languageUncheckedUpdateManyInput = {
    langid?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    extensions?: NullableStringFieldUpdateOperationsInput | string | null
    require_entry_point?: BoolFieldUpdateOperationsInput | boolean
    entry_point_description?: NullableStringFieldUpdateOperationsInput | string | null
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    time_factor?: FloatFieldUpdateOperationsInput | number
    compile_script?: NullableStringFieldUpdateOperationsInput | string | null
    filter_compiler_files?: BoolFieldUpdateOperationsInput | boolean
  }

  export type problemCreateInput = {
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
    clarification?: clarificationCreateNestedManyWithoutProblemInput
    contestproblem?: contestproblemCreateNestedManyWithoutProblemInput
    executable_problem_special_runToexecutable?: executableCreateNestedOneWithoutProblem_problem_special_runToexecutableInput
    executable_problem_special_compareToexecutable?: executableCreateNestedOneWithoutProblem_problem_special_compareToexecutableInput
    problem_attachment?: problem_attachmentCreateNestedManyWithoutProblemInput
    scorecache?: scorecacheCreateNestedManyWithoutProblemInput
    submission?: submissionCreateNestedManyWithoutProblemInput
    testcase?: testcaseCreateNestedManyWithoutProblemInput
  }

  export type problemUncheckedCreateInput = {
    probid?: number
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_run?: string | null
    special_compare?: string | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutProblemInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutProblemInput
    problem_attachment?: problem_attachmentUncheckedCreateNestedManyWithoutProblemInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutProblemInput
    submission?: submissionUncheckedCreateNestedManyWithoutProblemInput
    testcase?: testcaseUncheckedCreateNestedManyWithoutProblemInput
  }

  export type problemUpdateInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutProblemNestedInput
    contestproblem?: contestproblemUpdateManyWithoutProblemNestedInput
    executable_problem_special_runToexecutable?: executableUpdateOneWithoutProblem_problem_special_runToexecutableNestedInput
    executable_problem_special_compareToexecutable?: executableUpdateOneWithoutProblem_problem_special_compareToexecutableNestedInput
    problem_attachment?: problem_attachmentUpdateManyWithoutProblemNestedInput
    scorecache?: scorecacheUpdateManyWithoutProblemNestedInput
    submission?: submissionUpdateManyWithoutProblemNestedInput
    testcase?: testcaseUpdateManyWithoutProblemNestedInput
  }

  export type problemUncheckedUpdateInput = {
    probid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_run?: NullableStringFieldUpdateOperationsInput | string | null
    special_compare?: NullableStringFieldUpdateOperationsInput | string | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutProblemNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutProblemNestedInput
    problem_attachment?: problem_attachmentUncheckedUpdateManyWithoutProblemNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutProblemNestedInput
    submission?: submissionUncheckedUpdateManyWithoutProblemNestedInput
    testcase?: testcaseUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type problemCreateManyInput = {
    probid?: number
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_run?: string | null
    special_compare?: string | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
  }

  export type problemUpdateManyMutationInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type problemUncheckedUpdateManyInput = {
    probid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_run?: NullableStringFieldUpdateOperationsInput | string | null
    special_compare?: NullableStringFieldUpdateOperationsInput | string | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type problem_attachmentCreateInput = {
    name: string
    type: string
    problem?: problemCreateNestedOneWithoutProblem_attachmentInput
    problem_attachment_content?: problem_attachment_contentCreateNestedOneWithoutProblem_attachmentInput
  }

  export type problem_attachmentUncheckedCreateInput = {
    attachmentid?: number
    probid?: number | null
    name: string
    type: string
    problem_attachment_content?: problem_attachment_contentUncheckedCreateNestedOneWithoutProblem_attachmentInput
  }

  export type problem_attachmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    problem?: problemUpdateOneWithoutProblem_attachmentNestedInput
    problem_attachment_content?: problem_attachment_contentUpdateOneWithoutProblem_attachmentNestedInput
  }

  export type problem_attachmentUncheckedUpdateInput = {
    attachmentid?: IntFieldUpdateOperationsInput | number
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    problem_attachment_content?: problem_attachment_contentUncheckedUpdateOneWithoutProblem_attachmentNestedInput
  }

  export type problem_attachmentCreateManyInput = {
    attachmentid?: number
    probid?: number | null
    name: string
    type: string
  }

  export type problem_attachmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type problem_attachmentUncheckedUpdateManyInput = {
    attachmentid?: IntFieldUpdateOperationsInput | number
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type problem_attachment_contentCreateInput = {
    content: Buffer
    problem_attachment: problem_attachmentCreateNestedOneWithoutProblem_attachment_contentInput
  }

  export type problem_attachment_contentUncheckedCreateInput = {
    attachmentid: number
    content: Buffer
  }

  export type problem_attachment_contentUpdateInput = {
    content?: BytesFieldUpdateOperationsInput | Buffer
    problem_attachment?: problem_attachmentUpdateOneRequiredWithoutProblem_attachment_contentNestedInput
  }

  export type problem_attachment_contentUncheckedUpdateInput = {
    attachmentid?: IntFieldUpdateOperationsInput | number
    content?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type problem_attachment_contentCreateManyInput = {
    attachmentid: number
    content: Buffer
  }

  export type problem_attachment_contentUpdateManyMutationInput = {
    content?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type problem_attachment_contentUncheckedUpdateManyInput = {
    attachmentid?: IntFieldUpdateOperationsInput | number
    content?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type queuetaskCreateInput = {
    jobid?: number | null
    priority: number
    teampriority: number
    starttime?: Decimal | DecimalJsLike | number | string | null
    team?: teamCreateNestedOneWithoutQueuetaskInput
  }

  export type queuetaskUncheckedCreateInput = {
    queuetaskid?: number
    teamid?: number | null
    jobid?: number | null
    priority: number
    teampriority: number
    starttime?: Decimal | DecimalJsLike | number | string | null
  }

  export type queuetaskUpdateInput = {
    jobid?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    teampriority?: IntFieldUpdateOperationsInput | number
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    team?: teamUpdateOneWithoutQueuetaskNestedInput
  }

  export type queuetaskUncheckedUpdateInput = {
    queuetaskid?: IntFieldUpdateOperationsInput | number
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    jobid?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    teampriority?: IntFieldUpdateOperationsInput | number
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type queuetaskCreateManyInput = {
    queuetaskid?: number
    teamid?: number | null
    jobid?: number | null
    priority: number
    teampriority: number
    starttime?: Decimal | DecimalJsLike | number | string | null
  }

  export type queuetaskUpdateManyMutationInput = {
    jobid?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    teampriority?: IntFieldUpdateOperationsInput | number
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type queuetaskUncheckedUpdateManyInput = {
    queuetaskid?: IntFieldUpdateOperationsInput | number
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    jobid?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    teampriority?: IntFieldUpdateOperationsInput | number
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type rankcacheCreateInput = {
    points_restricted?: number
    totaltime_restricted?: number
    points_public?: number
    totaltime_public?: number
    contest: contestCreateNestedOneWithoutRankcacheInput
    team: teamCreateNestedOneWithoutRankcacheInput
  }

  export type rankcacheUncheckedCreateInput = {
    cid: number
    teamid: number
    points_restricted?: number
    totaltime_restricted?: number
    points_public?: number
    totaltime_public?: number
  }

  export type rankcacheUpdateInput = {
    points_restricted?: IntFieldUpdateOperationsInput | number
    totaltime_restricted?: IntFieldUpdateOperationsInput | number
    points_public?: IntFieldUpdateOperationsInput | number
    totaltime_public?: IntFieldUpdateOperationsInput | number
    contest?: contestUpdateOneRequiredWithoutRankcacheNestedInput
    team?: teamUpdateOneRequiredWithoutRankcacheNestedInput
  }

  export type rankcacheUncheckedUpdateInput = {
    cid?: IntFieldUpdateOperationsInput | number
    teamid?: IntFieldUpdateOperationsInput | number
    points_restricted?: IntFieldUpdateOperationsInput | number
    totaltime_restricted?: IntFieldUpdateOperationsInput | number
    points_public?: IntFieldUpdateOperationsInput | number
    totaltime_public?: IntFieldUpdateOperationsInput | number
  }

  export type rankcacheCreateManyInput = {
    cid: number
    teamid: number
    points_restricted?: number
    totaltime_restricted?: number
    points_public?: number
    totaltime_public?: number
  }

  export type rankcacheUpdateManyMutationInput = {
    points_restricted?: IntFieldUpdateOperationsInput | number
    totaltime_restricted?: IntFieldUpdateOperationsInput | number
    points_public?: IntFieldUpdateOperationsInput | number
    totaltime_public?: IntFieldUpdateOperationsInput | number
  }

  export type rankcacheUncheckedUpdateManyInput = {
    cid?: IntFieldUpdateOperationsInput | number
    teamid?: IntFieldUpdateOperationsInput | number
    points_restricted?: IntFieldUpdateOperationsInput | number
    totaltime_restricted?: IntFieldUpdateOperationsInput | number
    points_public?: IntFieldUpdateOperationsInput | number
    totaltime_public?: IntFieldUpdateOperationsInput | number
  }

  export type rejudgingCreateInput = {
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    reason: string
    valid?: boolean
    auto_apply?: boolean
    repeat?: number | null
    judging?: judgingCreateNestedManyWithoutRejudgingInput
    rejudging?: rejudgingCreateNestedOneWithoutOther_rejudgingInput
    other_rejudging?: rejudgingCreateNestedManyWithoutRejudgingInput
    user_rejudging_userid_startTouser?: userCreateNestedOneWithoutRejudging_rejudging_userid_startTouserInput
    user_rejudging_userid_finishTouser?: userCreateNestedOneWithoutRejudging_rejudging_userid_finishTouserInput
    submission?: submissionCreateNestedManyWithoutRejudgingInput
  }

  export type rejudgingUncheckedCreateInput = {
    rejudgingid?: number
    userid_start?: number | null
    userid_finish?: number | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    reason: string
    valid?: boolean
    auto_apply?: boolean
    repeat?: number | null
    repeat_rejudgingid?: number | null
    judging?: judgingUncheckedCreateNestedManyWithoutRejudgingInput
    other_rejudging?: rejudgingUncheckedCreateNestedManyWithoutRejudgingInput
    submission?: submissionUncheckedCreateNestedManyWithoutRejudgingInput
  }

  export type rejudgingUpdateInput = {
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    auto_apply?: BoolFieldUpdateOperationsInput | boolean
    repeat?: NullableIntFieldUpdateOperationsInput | number | null
    judging?: judgingUpdateManyWithoutRejudgingNestedInput
    rejudging?: rejudgingUpdateOneWithoutOther_rejudgingNestedInput
    other_rejudging?: rejudgingUpdateManyWithoutRejudgingNestedInput
    user_rejudging_userid_startTouser?: userUpdateOneWithoutRejudging_rejudging_userid_startTouserNestedInput
    user_rejudging_userid_finishTouser?: userUpdateOneWithoutRejudging_rejudging_userid_finishTouserNestedInput
    submission?: submissionUpdateManyWithoutRejudgingNestedInput
  }

  export type rejudgingUncheckedUpdateInput = {
    rejudgingid?: IntFieldUpdateOperationsInput | number
    userid_start?: NullableIntFieldUpdateOperationsInput | number | null
    userid_finish?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    auto_apply?: BoolFieldUpdateOperationsInput | boolean
    repeat?: NullableIntFieldUpdateOperationsInput | number | null
    repeat_rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judging?: judgingUncheckedUpdateManyWithoutRejudgingNestedInput
    other_rejudging?: rejudgingUncheckedUpdateManyWithoutRejudgingNestedInput
    submission?: submissionUncheckedUpdateManyWithoutRejudgingNestedInput
  }

  export type rejudgingCreateManyInput = {
    rejudgingid?: number
    userid_start?: number | null
    userid_finish?: number | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    reason: string
    valid?: boolean
    auto_apply?: boolean
    repeat?: number | null
    repeat_rejudgingid?: number | null
  }

  export type rejudgingUpdateManyMutationInput = {
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    auto_apply?: BoolFieldUpdateOperationsInput | boolean
    repeat?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rejudgingUncheckedUpdateManyInput = {
    rejudgingid?: IntFieldUpdateOperationsInput | number
    userid_start?: NullableIntFieldUpdateOperationsInput | number | null
    userid_finish?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    auto_apply?: BoolFieldUpdateOperationsInput | boolean
    repeat?: NullableIntFieldUpdateOperationsInput | number | null
    repeat_rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type removed_intervalCreateInput = {
    starttime: Decimal | DecimalJsLike | number | string
    endtime: Decimal | DecimalJsLike | number | string
    starttime_string: string
    endtime_string: string
    contest?: contestCreateNestedOneWithoutRemoved_intervalInput
  }

  export type removed_intervalUncheckedCreateInput = {
    intervalid?: number
    cid?: number | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime: Decimal | DecimalJsLike | number | string
    starttime_string: string
    endtime_string: string
  }

  export type removed_intervalUpdateInput = {
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    endtime_string?: StringFieldUpdateOperationsInput | string
    contest?: contestUpdateOneWithoutRemoved_intervalNestedInput
  }

  export type removed_intervalUncheckedUpdateInput = {
    intervalid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    endtime_string?: StringFieldUpdateOperationsInput | string
  }

  export type removed_intervalCreateManyInput = {
    intervalid?: number
    cid?: number | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime: Decimal | DecimalJsLike | number | string
    starttime_string: string
    endtime_string: string
  }

  export type removed_intervalUpdateManyMutationInput = {
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    endtime_string?: StringFieldUpdateOperationsInput | string
  }

  export type removed_intervalUncheckedUpdateManyInput = {
    intervalid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    endtime_string?: StringFieldUpdateOperationsInput | string
  }

  export type roleCreateInput = {
    role: string
    description: string
    userrole?: userroleCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateInput = {
    roleid?: number
    role: string
    description: string
    userrole?: userroleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userrole?: userroleUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateInput = {
    roleid?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userrole?: userroleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type roleCreateManyInput = {
    roleid?: number
    role: string
    description: string
  }

  export type roleUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type roleUncheckedUpdateManyInput = {
    roleid?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type scorecacheCreateInput = {
    submissions_restricted?: number
    pending_restricted?: number
    solvetime_restricted?: Decimal | DecimalJsLike | number | string
    is_correct_restricted?: boolean
    submissions_public?: number
    pending_public?: number
    solvetime_public?: Decimal | DecimalJsLike | number | string
    is_correct_public?: boolean
    is_first_to_solve?: boolean
    contest: contestCreateNestedOneWithoutScorecacheInput
    team: teamCreateNestedOneWithoutScorecacheInput
    problem: problemCreateNestedOneWithoutScorecacheInput
  }

  export type scorecacheUncheckedCreateInput = {
    cid: number
    teamid: number
    probid: number
    submissions_restricted?: number
    pending_restricted?: number
    solvetime_restricted?: Decimal | DecimalJsLike | number | string
    is_correct_restricted?: boolean
    submissions_public?: number
    pending_public?: number
    solvetime_public?: Decimal | DecimalJsLike | number | string
    is_correct_public?: boolean
    is_first_to_solve?: boolean
  }

  export type scorecacheUpdateInput = {
    submissions_restricted?: IntFieldUpdateOperationsInput | number
    pending_restricted?: IntFieldUpdateOperationsInput | number
    solvetime_restricted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_restricted?: BoolFieldUpdateOperationsInput | boolean
    submissions_public?: IntFieldUpdateOperationsInput | number
    pending_public?: IntFieldUpdateOperationsInput | number
    solvetime_public?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_public?: BoolFieldUpdateOperationsInput | boolean
    is_first_to_solve?: BoolFieldUpdateOperationsInput | boolean
    contest?: contestUpdateOneRequiredWithoutScorecacheNestedInput
    team?: teamUpdateOneRequiredWithoutScorecacheNestedInput
    problem?: problemUpdateOneRequiredWithoutScorecacheNestedInput
  }

  export type scorecacheUncheckedUpdateInput = {
    cid?: IntFieldUpdateOperationsInput | number
    teamid?: IntFieldUpdateOperationsInput | number
    probid?: IntFieldUpdateOperationsInput | number
    submissions_restricted?: IntFieldUpdateOperationsInput | number
    pending_restricted?: IntFieldUpdateOperationsInput | number
    solvetime_restricted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_restricted?: BoolFieldUpdateOperationsInput | boolean
    submissions_public?: IntFieldUpdateOperationsInput | number
    pending_public?: IntFieldUpdateOperationsInput | number
    solvetime_public?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_public?: BoolFieldUpdateOperationsInput | boolean
    is_first_to_solve?: BoolFieldUpdateOperationsInput | boolean
  }

  export type scorecacheCreateManyInput = {
    cid: number
    teamid: number
    probid: number
    submissions_restricted?: number
    pending_restricted?: number
    solvetime_restricted?: Decimal | DecimalJsLike | number | string
    is_correct_restricted?: boolean
    submissions_public?: number
    pending_public?: number
    solvetime_public?: Decimal | DecimalJsLike | number | string
    is_correct_public?: boolean
    is_first_to_solve?: boolean
  }

  export type scorecacheUpdateManyMutationInput = {
    submissions_restricted?: IntFieldUpdateOperationsInput | number
    pending_restricted?: IntFieldUpdateOperationsInput | number
    solvetime_restricted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_restricted?: BoolFieldUpdateOperationsInput | boolean
    submissions_public?: IntFieldUpdateOperationsInput | number
    pending_public?: IntFieldUpdateOperationsInput | number
    solvetime_public?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_public?: BoolFieldUpdateOperationsInput | boolean
    is_first_to_solve?: BoolFieldUpdateOperationsInput | boolean
  }

  export type scorecacheUncheckedUpdateManyInput = {
    cid?: IntFieldUpdateOperationsInput | number
    teamid?: IntFieldUpdateOperationsInput | number
    probid?: IntFieldUpdateOperationsInput | number
    submissions_restricted?: IntFieldUpdateOperationsInput | number
    pending_restricted?: IntFieldUpdateOperationsInput | number
    solvetime_restricted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_restricted?: BoolFieldUpdateOperationsInput | boolean
    submissions_public?: IntFieldUpdateOperationsInput | number
    pending_public?: IntFieldUpdateOperationsInput | number
    solvetime_public?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_public?: BoolFieldUpdateOperationsInput | boolean
    is_first_to_solve?: BoolFieldUpdateOperationsInput | boolean
  }

  export type sessionsCreateInput = {
    sess_id: Buffer
    sess_data: Buffer
    sess_lifetime: number
    sess_time: number
  }

  export type sessionsUncheckedCreateInput = {
    sess_id: Buffer
    sess_data: Buffer
    sess_lifetime: number
    sess_time: number
  }

  export type sessionsUpdateInput = {
    sess_id?: BytesFieldUpdateOperationsInput | Buffer
    sess_data?: BytesFieldUpdateOperationsInput | Buffer
    sess_lifetime?: IntFieldUpdateOperationsInput | number
    sess_time?: IntFieldUpdateOperationsInput | number
  }

  export type sessionsUncheckedUpdateInput = {
    sess_id?: BytesFieldUpdateOperationsInput | Buffer
    sess_data?: BytesFieldUpdateOperationsInput | Buffer
    sess_lifetime?: IntFieldUpdateOperationsInput | number
    sess_time?: IntFieldUpdateOperationsInput | number
  }

  export type sessionsCreateManyInput = {
    sess_id: Buffer
    sess_data: Buffer
    sess_lifetime: number
    sess_time: number
  }

  export type sessionsUpdateManyMutationInput = {
    sess_id?: BytesFieldUpdateOperationsInput | Buffer
    sess_data?: BytesFieldUpdateOperationsInput | Buffer
    sess_lifetime?: IntFieldUpdateOperationsInput | number
    sess_time?: IntFieldUpdateOperationsInput | number
  }

  export type sessionsUncheckedUpdateManyInput = {
    sess_id?: BytesFieldUpdateOperationsInput | Buffer
    sess_data?: BytesFieldUpdateOperationsInput | Buffer
    sess_lifetime?: IntFieldUpdateOperationsInput | number
    sess_time?: IntFieldUpdateOperationsInput | number
  }

  export type submissionCreateInput = {
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementCreateNestedManyWithoutSubmissionInput
    judging?: judgingCreateNestedManyWithoutSubmissionInput
    user?: userCreateNestedOneWithoutSubmissionInput
    contest?: contestCreateNestedOneWithoutSubmissionInput
    team?: teamCreateNestedOneWithoutSubmissionInput
    problem?: problemCreateNestedOneWithoutSubmissionInput
    language?: languageCreateNestedOneWithoutSubmissionInput
    submission?: submissionCreateNestedOneWithoutOther_submissionInput
    other_submission?: submissionCreateNestedManyWithoutSubmissionInput
    rejudging?: rejudgingCreateNestedOneWithoutSubmissionInput
    contestproblem?: contestproblemCreateNestedOneWithoutSubmissionInput
    submission_file?: submission_fileCreateNestedManyWithoutSubmissionInput
  }

  export type submissionUncheckedCreateInput = {
    submitid?: number
    origsubmitid?: number | null
    cid?: number | null
    teamid?: number | null
    userid?: number | null
    probid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonUncheckedCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutSubmissionInput
    judging?: judgingUncheckedCreateNestedManyWithoutSubmissionInput
    other_submission?: submissionUncheckedCreateNestedManyWithoutSubmissionInput
    submission_file?: submission_fileUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type submissionUpdateInput = {
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUpdateManyWithoutSubmissionNestedInput
    user?: userUpdateOneWithoutSubmissionNestedInput
    contest?: contestUpdateOneWithoutSubmissionNestedInput
    team?: teamUpdateOneWithoutSubmissionNestedInput
    problem?: problemUpdateOneWithoutSubmissionNestedInput
    language?: languageUpdateOneWithoutSubmissionNestedInput
    submission?: submissionUpdateOneWithoutOther_submissionNestedInput
    other_submission?: submissionUpdateManyWithoutSubmissionNestedInput
    rejudging?: rejudgingUpdateOneWithoutSubmissionNestedInput
    contestproblem?: contestproblemUpdateOneWithoutSubmissionNestedInput
    submission_file?: submission_fileUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUncheckedUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUncheckedUpdateManyWithoutSubmissionNestedInput
    other_submission?: submissionUncheckedUpdateManyWithoutSubmissionNestedInput
    submission_file?: submission_fileUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionCreateManyInput = {
    submitid?: number
    origsubmitid?: number | null
    cid?: number | null
    teamid?: number | null
    userid?: number | null
    probid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
  }

  export type submissionUpdateManyMutationInput = {
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type submissionUncheckedUpdateManyInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type submission_fileCreateInput = {
    sourcecode: Buffer
    filename: string
    ranknumber: number
    submission?: submissionCreateNestedOneWithoutSubmission_fileInput
  }

  export type submission_fileUncheckedCreateInput = {
    submitfileid?: number
    submitid?: number | null
    sourcecode: Buffer
    filename: string
    ranknumber: number
  }

  export type submission_fileUpdateInput = {
    sourcecode?: BytesFieldUpdateOperationsInput | Buffer
    filename?: StringFieldUpdateOperationsInput | string
    ranknumber?: IntFieldUpdateOperationsInput | number
    submission?: submissionUpdateOneWithoutSubmission_fileNestedInput
  }

  export type submission_fileUncheckedUpdateInput = {
    submitfileid?: IntFieldUpdateOperationsInput | number
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    sourcecode?: BytesFieldUpdateOperationsInput | Buffer
    filename?: StringFieldUpdateOperationsInput | string
    ranknumber?: IntFieldUpdateOperationsInput | number
  }

  export type submission_fileCreateManyInput = {
    submitfileid?: number
    submitid?: number | null
    sourcecode: Buffer
    filename: string
    ranknumber: number
  }

  export type submission_fileUpdateManyMutationInput = {
    sourcecode?: BytesFieldUpdateOperationsInput | Buffer
    filename?: StringFieldUpdateOperationsInput | string
    ranknumber?: IntFieldUpdateOperationsInput | number
  }

  export type submission_fileUncheckedUpdateManyInput = {
    submitfileid?: IntFieldUpdateOperationsInput | number
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    sourcecode?: BytesFieldUpdateOperationsInput | Buffer
    filename?: StringFieldUpdateOperationsInput | string
    ranknumber?: IntFieldUpdateOperationsInput | number
  }

  export type teamCreateInput = {
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationCreateNestedManyWithoutTeam_clarification_senderToteamInput
    clarification_clarification_recipientToteam?: clarificationCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    contestteam?: contestteamCreateNestedManyWithoutTeamInput
    queuetask?: queuetaskCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheCreateNestedManyWithoutTeamInput
    submission?: submissionCreateNestedManyWithoutTeamInput
    team_category?: team_categoryCreateNestedOneWithoutTeamInput
    team_affiliation?: team_affiliationCreateNestedOneWithoutTeamInput
    team_unread?: team_unreadCreateNestedManyWithoutTeamInput
    user?: userCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateInput = {
    teamid?: number
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    categoryid?: number | null
    affilid?: number | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_senderToteamInput
    clarification_clarification_recipientToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutTeamInput
    queuetask?: queuetaskUncheckedCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutTeamInput
    submission?: submissionUncheckedCreateNestedManyWithoutTeamInput
    team_unread?: team_unreadUncheckedCreateNestedManyWithoutTeamInput
    user?: userUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamUpdateInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    clarification_clarification_recipientToteam?: clarificationUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    contestteam?: contestteamUpdateManyWithoutTeamNestedInput
    queuetask?: queuetaskUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUpdateManyWithoutTeamNestedInput
    submission?: submissionUpdateManyWithoutTeamNestedInput
    team_category?: team_categoryUpdateOneWithoutTeamNestedInput
    team_affiliation?: team_affiliationUpdateOneWithoutTeamNestedInput
    team_unread?: team_unreadUpdateManyWithoutTeamNestedInput
    user?: userUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    categoryid?: NullableIntFieldUpdateOperationsInput | number | null
    affilid?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    clarification_clarification_recipientToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutTeamNestedInput
    queuetask?: queuetaskUncheckedUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutTeamNestedInput
    submission?: submissionUncheckedUpdateManyWithoutTeamNestedInput
    team_unread?: team_unreadUncheckedUpdateManyWithoutTeamNestedInput
    user?: userUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type teamCreateManyInput = {
    teamid?: number
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    categoryid?: number | null
    affilid?: number | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
  }

  export type teamUpdateManyMutationInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
  }

  export type teamUncheckedUpdateManyInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    categoryid?: NullableIntFieldUpdateOperationsInput | number | null
    affilid?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
  }

  export type team_affiliationCreateInput = {
    externalid?: string | null
    icpcid?: string | null
    shortname: string
    name: string
    country?: string | null
    internalcomments?: string | null
    team?: teamCreateNestedManyWithoutTeam_affiliationInput
  }

  export type team_affiliationUncheckedCreateInput = {
    affilid?: number
    externalid?: string | null
    icpcid?: string | null
    shortname: string
    name: string
    country?: string | null
    internalcomments?: string | null
    team?: teamUncheckedCreateNestedManyWithoutTeam_affiliationInput
  }

  export type team_affiliationUpdateInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    shortname?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    team?: teamUpdateManyWithoutTeam_affiliationNestedInput
  }

  export type team_affiliationUncheckedUpdateInput = {
    affilid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    shortname?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    team?: teamUncheckedUpdateManyWithoutTeam_affiliationNestedInput
  }

  export type team_affiliationCreateManyInput = {
    affilid?: number
    externalid?: string | null
    icpcid?: string | null
    shortname: string
    name: string
    country?: string | null
    internalcomments?: string | null
  }

  export type team_affiliationUpdateManyMutationInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    shortname?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type team_affiliationUncheckedUpdateManyInput = {
    affilid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    shortname?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type team_categoryCreateInput = {
    externalid?: string | null
    icpcid?: string | null
    name: string
    sortorder?: boolean
    color?: string | null
    visible?: boolean
    allow_self_registration?: boolean
    contestteamcategory?: contestteamcategoryCreateNestedManyWithoutTeam_categoryInput
    contestteamcategoryformedals?: contestteamcategoryformedalsCreateNestedManyWithoutTeam_categoryInput
    team?: teamCreateNestedManyWithoutTeam_categoryInput
  }

  export type team_categoryUncheckedCreateInput = {
    categoryid?: number
    externalid?: string | null
    icpcid?: string | null
    name: string
    sortorder?: boolean
    color?: string | null
    visible?: boolean
    allow_self_registration?: boolean
    contestteamcategory?: contestteamcategoryUncheckedCreateNestedManyWithoutTeam_categoryInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedCreateNestedManyWithoutTeam_categoryInput
    team?: teamUncheckedCreateNestedManyWithoutTeam_categoryInput
  }

  export type team_categoryUpdateInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sortorder?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    allow_self_registration?: BoolFieldUpdateOperationsInput | boolean
    contestteamcategory?: contestteamcategoryUpdateManyWithoutTeam_categoryNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUpdateManyWithoutTeam_categoryNestedInput
    team?: teamUpdateManyWithoutTeam_categoryNestedInput
  }

  export type team_categoryUncheckedUpdateInput = {
    categoryid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sortorder?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    allow_self_registration?: BoolFieldUpdateOperationsInput | boolean
    contestteamcategory?: contestteamcategoryUncheckedUpdateManyWithoutTeam_categoryNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedUpdateManyWithoutTeam_categoryNestedInput
    team?: teamUncheckedUpdateManyWithoutTeam_categoryNestedInput
  }

  export type team_categoryCreateManyInput = {
    categoryid?: number
    externalid?: string | null
    icpcid?: string | null
    name: string
    sortorder?: boolean
    color?: string | null
    visible?: boolean
    allow_self_registration?: boolean
  }

  export type team_categoryUpdateManyMutationInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sortorder?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    allow_self_registration?: BoolFieldUpdateOperationsInput | boolean
  }

  export type team_categoryUncheckedUpdateManyInput = {
    categoryid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sortorder?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    allow_self_registration?: BoolFieldUpdateOperationsInput | boolean
  }

  export type team_unreadCreateInput = {
    team: teamCreateNestedOneWithoutTeam_unreadInput
    clarification: clarificationCreateNestedOneWithoutTeam_unreadInput
  }

  export type team_unreadUncheckedCreateInput = {
    teamid: number
    mesgid: number
  }

  export type team_unreadUpdateInput = {
    team?: teamUpdateOneRequiredWithoutTeam_unreadNestedInput
    clarification?: clarificationUpdateOneRequiredWithoutTeam_unreadNestedInput
  }

  export type team_unreadUncheckedUpdateInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    mesgid?: IntFieldUpdateOperationsInput | number
  }

  export type team_unreadCreateManyInput = {
    teamid: number
    mesgid: number
  }

  export type team_unreadUpdateManyMutationInput = {

  }

  export type team_unreadUncheckedUpdateManyInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    mesgid?: IntFieldUpdateOperationsInput | number
  }

  export type testcaseCreateInput = {
    md5sum_input?: string | null
    md5sum_output?: string | null
    ranknumber: number
    description?: Buffer | null
    image_type?: string | null
    sample?: boolean
    orig_input_filename?: string | null
    deleted?: boolean
    external_run?: external_runCreateNestedManyWithoutTestcaseInput
    judging_run?: judging_runCreateNestedManyWithoutTestcaseInput
    problem?: problemCreateNestedOneWithoutTestcaseInput
    testcase_content?: testcase_contentCreateNestedManyWithoutTestcaseInput
  }

  export type testcaseUncheckedCreateInput = {
    testcaseid?: number
    md5sum_input?: string | null
    md5sum_output?: string | null
    probid?: number | null
    ranknumber: number
    description?: Buffer | null
    image_type?: string | null
    sample?: boolean
    orig_input_filename?: string | null
    deleted?: boolean
    external_run?: external_runUncheckedCreateNestedManyWithoutTestcaseInput
    judging_run?: judging_runUncheckedCreateNestedManyWithoutTestcaseInput
    testcase_content?: testcase_contentUncheckedCreateNestedManyWithoutTestcaseInput
  }

  export type testcaseUpdateInput = {
    md5sum_input?: NullableStringFieldUpdateOperationsInput | string | null
    md5sum_output?: NullableStringFieldUpdateOperationsInput | string | null
    ranknumber?: IntFieldUpdateOperationsInput | number
    description?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image_type?: NullableStringFieldUpdateOperationsInput | string | null
    sample?: BoolFieldUpdateOperationsInput | boolean
    orig_input_filename?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    external_run?: external_runUpdateManyWithoutTestcaseNestedInput
    judging_run?: judging_runUpdateManyWithoutTestcaseNestedInput
    problem?: problemUpdateOneWithoutTestcaseNestedInput
    testcase_content?: testcase_contentUpdateManyWithoutTestcaseNestedInput
  }

  export type testcaseUncheckedUpdateInput = {
    testcaseid?: IntFieldUpdateOperationsInput | number
    md5sum_input?: NullableStringFieldUpdateOperationsInput | string | null
    md5sum_output?: NullableStringFieldUpdateOperationsInput | string | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    ranknumber?: IntFieldUpdateOperationsInput | number
    description?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image_type?: NullableStringFieldUpdateOperationsInput | string | null
    sample?: BoolFieldUpdateOperationsInput | boolean
    orig_input_filename?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    external_run?: external_runUncheckedUpdateManyWithoutTestcaseNestedInput
    judging_run?: judging_runUncheckedUpdateManyWithoutTestcaseNestedInput
    testcase_content?: testcase_contentUncheckedUpdateManyWithoutTestcaseNestedInput
  }

  export type testcaseCreateManyInput = {
    testcaseid?: number
    md5sum_input?: string | null
    md5sum_output?: string | null
    probid?: number | null
    ranknumber: number
    description?: Buffer | null
    image_type?: string | null
    sample?: boolean
    orig_input_filename?: string | null
    deleted?: boolean
  }

  export type testcaseUpdateManyMutationInput = {
    md5sum_input?: NullableStringFieldUpdateOperationsInput | string | null
    md5sum_output?: NullableStringFieldUpdateOperationsInput | string | null
    ranknumber?: IntFieldUpdateOperationsInput | number
    description?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image_type?: NullableStringFieldUpdateOperationsInput | string | null
    sample?: BoolFieldUpdateOperationsInput | boolean
    orig_input_filename?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type testcaseUncheckedUpdateManyInput = {
    testcaseid?: IntFieldUpdateOperationsInput | number
    md5sum_input?: NullableStringFieldUpdateOperationsInput | string | null
    md5sum_output?: NullableStringFieldUpdateOperationsInput | string | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    ranknumber?: IntFieldUpdateOperationsInput | number
    description?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image_type?: NullableStringFieldUpdateOperationsInput | string | null
    sample?: BoolFieldUpdateOperationsInput | boolean
    orig_input_filename?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type testcase_contentCreateInput = {
    input?: Buffer | null
    output?: Buffer | null
    image?: Buffer | null
    image_thumb?: Buffer | null
    testcase?: testcaseCreateNestedOneWithoutTestcase_contentInput
  }

  export type testcase_contentUncheckedCreateInput = {
    testcaseid?: number | null
    input?: Buffer | null
    output?: Buffer | null
    image?: Buffer | null
    image_thumb?: Buffer | null
    tc_contentid?: number
  }

  export type testcase_contentUpdateInput = {
    input?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image_thumb?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    testcase?: testcaseUpdateOneWithoutTestcase_contentNestedInput
  }

  export type testcase_contentUncheckedUpdateInput = {
    testcaseid?: NullableIntFieldUpdateOperationsInput | number | null
    input?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image_thumb?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    tc_contentid?: IntFieldUpdateOperationsInput | number
  }

  export type testcase_contentCreateManyInput = {
    testcaseid?: number | null
    input?: Buffer | null
    output?: Buffer | null
    image?: Buffer | null
    image_thumb?: Buffer | null
    tc_contentid?: number
  }

  export type testcase_contentUpdateManyMutationInput = {
    input?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image_thumb?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type testcase_contentUncheckedUpdateManyInput = {
    testcaseid?: NullableIntFieldUpdateOperationsInput | number | null
    input?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image_thumb?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    tc_contentid?: IntFieldUpdateOperationsInput | number
  }

  export type userCreateInput = {
    externalid?: string | null
    username: string
    name: string
    email?: string | null
    last_login?: Decimal | DecimalJsLike | number | string | null
    last_api_login?: Decimal | DecimalJsLike | number | string | null
    first_login?: Decimal | DecimalJsLike | number | string | null
    last_ip_address?: string | null
    password?: string | null
    ip_address?: string | null
    enabled?: boolean
    immutable_executable?: immutable_executableCreateNestedManyWithoutUserInput
    rejudging_rejudging_userid_startTouser?: rejudgingCreateNestedManyWithoutUser_rejudging_userid_startTouserInput
    rejudging_rejudging_userid_finishTouser?: rejudgingCreateNestedManyWithoutUser_rejudging_userid_finishTouserInput
    submission?: submissionCreateNestedManyWithoutUserInput
    team?: teamCreateNestedOneWithoutUserInput
    userrole?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    userid?: number
    externalid?: string | null
    username: string
    name: string
    email?: string | null
    last_login?: Decimal | DecimalJsLike | number | string | null
    last_api_login?: Decimal | DecimalJsLike | number | string | null
    first_login?: Decimal | DecimalJsLike | number | string | null
    last_ip_address?: string | null
    password?: string | null
    ip_address?: string | null
    enabled?: boolean
    teamid?: number | null
    immutable_executable?: immutable_executableUncheckedCreateNestedManyWithoutUserInput
    rejudging_rejudging_userid_startTouser?: rejudgingUncheckedCreateNestedManyWithoutUser_rejudging_userid_startTouserInput
    rejudging_rejudging_userid_finishTouser?: rejudgingUncheckedCreateNestedManyWithoutUser_rejudging_userid_finishTouserInput
    submission?: submissionUncheckedCreateNestedManyWithoutUserInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_api_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    immutable_executable?: immutable_executableUpdateManyWithoutUserNestedInput
    rejudging_rejudging_userid_startTouser?: rejudgingUpdateManyWithoutUser_rejudging_userid_startTouserNestedInput
    rejudging_rejudging_userid_finishTouser?: rejudgingUpdateManyWithoutUser_rejudging_userid_finishTouserNestedInput
    submission?: submissionUpdateManyWithoutUserNestedInput
    team?: teamUpdateOneWithoutUserNestedInput
    userrole?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    userid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_api_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    immutable_executable?: immutable_executableUncheckedUpdateManyWithoutUserNestedInput
    rejudging_rejudging_userid_startTouser?: rejudgingUncheckedUpdateManyWithoutUser_rejudging_userid_startTouserNestedInput
    rejudging_rejudging_userid_finishTouser?: rejudgingUncheckedUpdateManyWithoutUser_rejudging_userid_finishTouserNestedInput
    submission?: submissionUncheckedUpdateManyWithoutUserNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    userid?: number
    externalid?: string | null
    username: string
    name: string
    email?: string | null
    last_login?: Decimal | DecimalJsLike | number | string | null
    last_api_login?: Decimal | DecimalJsLike | number | string | null
    first_login?: Decimal | DecimalJsLike | number | string | null
    last_ip_address?: string | null
    password?: string | null
    ip_address?: string | null
    enabled?: boolean
    teamid?: number | null
  }

  export type userUpdateManyMutationInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_api_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type userUncheckedUpdateManyInput = {
    userid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_api_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userroleCreateInput = {
    user: userCreateNestedOneWithoutUserroleInput
    role: roleCreateNestedOneWithoutUserroleInput
  }

  export type userroleUncheckedCreateInput = {
    userid: number
    roleid: number
  }

  export type userroleUpdateInput = {
    user?: userUpdateOneRequiredWithoutUserroleNestedInput
    role?: roleUpdateOneRequiredWithoutUserroleNestedInput
  }

  export type userroleUncheckedUpdateInput = {
    userid?: IntFieldUpdateOperationsInput | number
    roleid?: IntFieldUpdateOperationsInput | number
  }

  export type userroleCreateManyInput = {
    userid: number
    roleid: number
  }

  export type userroleUpdateManyMutationInput = {

  }

  export type userroleUncheckedUpdateManyInput = {
    userid?: IntFieldUpdateOperationsInput | number
    roleid?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type auditlogCountOrderByAggregateInput = {
    logid?: SortOrder
    logtime?: SortOrder
    cid?: SortOrder
    user?: SortOrder
    datatype?: SortOrder
    dataid?: SortOrder
    action?: SortOrder
    extrainfo?: SortOrder
  }

  export type auditlogAvgOrderByAggregateInput = {
    logid?: SortOrder
    logtime?: SortOrder
    cid?: SortOrder
  }

  export type auditlogMaxOrderByAggregateInput = {
    logid?: SortOrder
    logtime?: SortOrder
    cid?: SortOrder
    user?: SortOrder
    datatype?: SortOrder
    dataid?: SortOrder
    action?: SortOrder
    extrainfo?: SortOrder
  }

  export type auditlogMinOrderByAggregateInput = {
    logid?: SortOrder
    logtime?: SortOrder
    cid?: SortOrder
    user?: SortOrder
    datatype?: SortOrder
    dataid?: SortOrder
    action?: SortOrder
    extrainfo?: SortOrder
  }

  export type auditlogSumOrderByAggregateInput = {
    logid?: SortOrder
    logtime?: SortOrder
    cid?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type SubmissionNullableRelationFilter = {
    is?: submissionWhereInput | null
    isNot?: submissionWhereInput | null
  }

  export type balloonCountOrderByAggregateInput = {
    balloonid?: SortOrder
    submitid?: SortOrder
    done?: SortOrder
  }

  export type balloonAvgOrderByAggregateInput = {
    balloonid?: SortOrder
    submitid?: SortOrder
  }

  export type balloonMaxOrderByAggregateInput = {
    balloonid?: SortOrder
    submitid?: SortOrder
    done?: SortOrder
  }

  export type balloonMinOrderByAggregateInput = {
    balloonid?: SortOrder
    submitid?: SortOrder
    done?: SortOrder
  }

  export type balloonSumOrderByAggregateInput = {
    balloonid?: SortOrder
    submitid?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ContestNullableRelationFilter = {
    is?: contestWhereInput | null
    isNot?: contestWhereInput | null
  }

  export type ClarificationNullableRelationFilter = {
    is?: clarificationWhereInput | null
    isNot?: clarificationWhereInput | null
  }

  export type ClarificationListRelationFilter = {
    every?: clarificationWhereInput
    some?: clarificationWhereInput
    none?: clarificationWhereInput
  }

  export type ProblemNullableRelationFilter = {
    is?: problemWhereInput | null
    isNot?: problemWhereInput | null
  }

  export type TeamNullableRelationFilter = {
    is?: teamWhereInput | null
    isNot?: teamWhereInput | null
  }

  export type Team_unreadListRelationFilter = {
    every?: team_unreadWhereInput
    some?: team_unreadWhereInput
    none?: team_unreadWhereInput
  }

  export type clarificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type team_unreadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clarificationCidExternalidCompoundUniqueInput = {
    cid: number
    externalid: string
  }

  export type clarificationCountOrderByAggregateInput = {
    clarid?: SortOrder
    externalid?: SortOrder
    cid?: SortOrder
    respid?: SortOrder
    submittime?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
    jury_member?: SortOrder
    probid?: SortOrder
    category?: SortOrder
    queue?: SortOrder
    body?: SortOrder
    answered?: SortOrder
  }

  export type clarificationAvgOrderByAggregateInput = {
    clarid?: SortOrder
    cid?: SortOrder
    respid?: SortOrder
    submittime?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
    probid?: SortOrder
  }

  export type clarificationMaxOrderByAggregateInput = {
    clarid?: SortOrder
    externalid?: SortOrder
    cid?: SortOrder
    respid?: SortOrder
    submittime?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
    jury_member?: SortOrder
    probid?: SortOrder
    category?: SortOrder
    queue?: SortOrder
    body?: SortOrder
    answered?: SortOrder
  }

  export type clarificationMinOrderByAggregateInput = {
    clarid?: SortOrder
    externalid?: SortOrder
    cid?: SortOrder
    respid?: SortOrder
    submittime?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
    jury_member?: SortOrder
    probid?: SortOrder
    category?: SortOrder
    queue?: SortOrder
    body?: SortOrder
    answered?: SortOrder
  }

  export type clarificationSumOrderByAggregateInput = {
    clarid?: SortOrder
    cid?: SortOrder
    respid?: SortOrder
    submittime?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
    probid?: SortOrder
  }

  export type configurationCountOrderByAggregateInput = {
    configid?: SortOrder
    name?: SortOrder
    value?: SortOrder
  }

  export type configurationAvgOrderByAggregateInput = {
    configid?: SortOrder
  }

  export type configurationMaxOrderByAggregateInput = {
    configid?: SortOrder
    name?: SortOrder
    value?: SortOrder
  }

  export type configurationMinOrderByAggregateInput = {
    configid?: SortOrder
    name?: SortOrder
    value?: SortOrder
  }

  export type configurationSumOrderByAggregateInput = {
    configid?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ContestproblemListRelationFilter = {
    every?: contestproblemWhereInput
    some?: contestproblemWhereInput
    none?: contestproblemWhereInput
  }

  export type ContestteamListRelationFilter = {
    every?: contestteamWhereInput
    some?: contestteamWhereInput
    none?: contestteamWhereInput
  }

  export type ContestteamcategoryListRelationFilter = {
    every?: contestteamcategoryWhereInput
    some?: contestteamcategoryWhereInput
    none?: contestteamcategoryWhereInput
  }

  export type ContestteamcategoryformedalsListRelationFilter = {
    every?: contestteamcategoryformedalsWhereInput
    some?: contestteamcategoryformedalsWhereInput
    none?: contestteamcategoryformedalsWhereInput
  }

  export type EventListRelationFilter = {
    every?: eventWhereInput
    some?: eventWhereInput
    none?: eventWhereInput
  }

  export type External_contest_sourceNullableRelationFilter = {
    is?: external_contest_sourceWhereInput | null
    isNot?: external_contest_sourceWhereInput | null
  }

  export type External_judgementListRelationFilter = {
    every?: external_judgementWhereInput
    some?: external_judgementWhereInput
    none?: external_judgementWhereInput
  }

  export type External_runListRelationFilter = {
    every?: external_runWhereInput
    some?: external_runWhereInput
    none?: external_runWhereInput
  }

  export type Internal_errorListRelationFilter = {
    every?: internal_errorWhereInput
    some?: internal_errorWhereInput
    none?: internal_errorWhereInput
  }

  export type JudgingListRelationFilter = {
    every?: judgingWhereInput
    some?: judgingWhereInput
    none?: judgingWhereInput
  }

  export type RankcacheListRelationFilter = {
    every?: rankcacheWhereInput
    some?: rankcacheWhereInput
    none?: rankcacheWhereInput
  }

  export type Removed_intervalListRelationFilter = {
    every?: removed_intervalWhereInput
    some?: removed_intervalWhereInput
    none?: removed_intervalWhereInput
  }

  export type ScorecacheListRelationFilter = {
    every?: scorecacheWhereInput
    some?: scorecacheWhereInput
    none?: scorecacheWhereInput
  }

  export type SubmissionListRelationFilter = {
    every?: submissionWhereInput
    some?: submissionWhereInput
    none?: submissionWhereInput
  }

  export type contestproblemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type contestteamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type contestteamcategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type contestteamcategoryformedalsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type eventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type external_judgementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type external_runOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type internal_errorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type judgingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rankcacheOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type removed_intervalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type scorecacheOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type submissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type contestCountOrderByAggregateInput = {
    cid?: SortOrder
    externalid?: SortOrder
    name?: SortOrder
    shortname?: SortOrder
    activatetime?: SortOrder
    starttime?: SortOrder
    freezetime?: SortOrder
    endtime?: SortOrder
    unfreezetime?: SortOrder
    deactivatetime?: SortOrder
    activatetime_string?: SortOrder
    starttime_string?: SortOrder
    freezetime_string?: SortOrder
    endtime_string?: SortOrder
    unfreezetime_string?: SortOrder
    deactivatetime_string?: SortOrder
    finalizetime?: SortOrder
    finalizecomment?: SortOrder
    b?: SortOrder
    enabled?: SortOrder
    starttime_enabled?: SortOrder
    process_balloons?: SortOrder
    public?: SortOrder
    open_to_all_teams?: SortOrder
    medals_enabled?: SortOrder
    gold_medals?: SortOrder
    silver_medals?: SortOrder
    bronze_medals?: SortOrder
    is_locked?: SortOrder
    allow_submit?: SortOrder
    warning_message?: SortOrder
  }

  export type contestAvgOrderByAggregateInput = {
    cid?: SortOrder
    activatetime?: SortOrder
    starttime?: SortOrder
    freezetime?: SortOrder
    endtime?: SortOrder
    unfreezetime?: SortOrder
    deactivatetime?: SortOrder
    finalizetime?: SortOrder
    b?: SortOrder
    gold_medals?: SortOrder
    silver_medals?: SortOrder
    bronze_medals?: SortOrder
  }

  export type contestMaxOrderByAggregateInput = {
    cid?: SortOrder
    externalid?: SortOrder
    name?: SortOrder
    shortname?: SortOrder
    activatetime?: SortOrder
    starttime?: SortOrder
    freezetime?: SortOrder
    endtime?: SortOrder
    unfreezetime?: SortOrder
    deactivatetime?: SortOrder
    activatetime_string?: SortOrder
    starttime_string?: SortOrder
    freezetime_string?: SortOrder
    endtime_string?: SortOrder
    unfreezetime_string?: SortOrder
    deactivatetime_string?: SortOrder
    finalizetime?: SortOrder
    finalizecomment?: SortOrder
    b?: SortOrder
    enabled?: SortOrder
    starttime_enabled?: SortOrder
    process_balloons?: SortOrder
    public?: SortOrder
    open_to_all_teams?: SortOrder
    medals_enabled?: SortOrder
    gold_medals?: SortOrder
    silver_medals?: SortOrder
    bronze_medals?: SortOrder
    is_locked?: SortOrder
    allow_submit?: SortOrder
    warning_message?: SortOrder
  }

  export type contestMinOrderByAggregateInput = {
    cid?: SortOrder
    externalid?: SortOrder
    name?: SortOrder
    shortname?: SortOrder
    activatetime?: SortOrder
    starttime?: SortOrder
    freezetime?: SortOrder
    endtime?: SortOrder
    unfreezetime?: SortOrder
    deactivatetime?: SortOrder
    activatetime_string?: SortOrder
    starttime_string?: SortOrder
    freezetime_string?: SortOrder
    endtime_string?: SortOrder
    unfreezetime_string?: SortOrder
    deactivatetime_string?: SortOrder
    finalizetime?: SortOrder
    finalizecomment?: SortOrder
    b?: SortOrder
    enabled?: SortOrder
    starttime_enabled?: SortOrder
    process_balloons?: SortOrder
    public?: SortOrder
    open_to_all_teams?: SortOrder
    medals_enabled?: SortOrder
    gold_medals?: SortOrder
    silver_medals?: SortOrder
    bronze_medals?: SortOrder
    is_locked?: SortOrder
    allow_submit?: SortOrder
    warning_message?: SortOrder
  }

  export type contestSumOrderByAggregateInput = {
    cid?: SortOrder
    activatetime?: SortOrder
    starttime?: SortOrder
    freezetime?: SortOrder
    endtime?: SortOrder
    unfreezetime?: SortOrder
    deactivatetime?: SortOrder
    finalizetime?: SortOrder
    b?: SortOrder
    gold_medals?: SortOrder
    silver_medals?: SortOrder
    bronze_medals?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ContestRelationFilter = {
    is?: contestWhereInput
    isNot?: contestWhereInput
  }

  export type ProblemRelationFilter = {
    is?: problemWhereInput
    isNot?: problemWhereInput
  }

  export type contestproblemCidShortnameCompoundUniqueInput = {
    cid: number
    shortname: string
  }

  export type contestproblemCidProbidCompoundUniqueInput = {
    cid: number
    probid: number
  }

  export type contestproblemCountOrderByAggregateInput = {
    cid?: SortOrder
    probid?: SortOrder
    shortname?: SortOrder
    points?: SortOrder
    allow_submit?: SortOrder
    allow_judge?: SortOrder
    color?: SortOrder
    lazy_eval_results?: SortOrder
  }

  export type contestproblemAvgOrderByAggregateInput = {
    cid?: SortOrder
    probid?: SortOrder
    points?: SortOrder
    lazy_eval_results?: SortOrder
  }

  export type contestproblemMaxOrderByAggregateInput = {
    cid?: SortOrder
    probid?: SortOrder
    shortname?: SortOrder
    points?: SortOrder
    allow_submit?: SortOrder
    allow_judge?: SortOrder
    color?: SortOrder
    lazy_eval_results?: SortOrder
  }

  export type contestproblemMinOrderByAggregateInput = {
    cid?: SortOrder
    probid?: SortOrder
    shortname?: SortOrder
    points?: SortOrder
    allow_submit?: SortOrder
    allow_judge?: SortOrder
    color?: SortOrder
    lazy_eval_results?: SortOrder
  }

  export type contestproblemSumOrderByAggregateInput = {
    cid?: SortOrder
    probid?: SortOrder
    points?: SortOrder
    lazy_eval_results?: SortOrder
  }

  export type TeamRelationFilter = {
    is?: teamWhereInput
    isNot?: teamWhereInput
  }

  export type contestteamCidTeamidCompoundUniqueInput = {
    cid: number
    teamid: number
  }

  export type contestteamCountOrderByAggregateInput = {
    cid?: SortOrder
    teamid?: SortOrder
  }

  export type contestteamAvgOrderByAggregateInput = {
    cid?: SortOrder
    teamid?: SortOrder
  }

  export type contestteamMaxOrderByAggregateInput = {
    cid?: SortOrder
    teamid?: SortOrder
  }

  export type contestteamMinOrderByAggregateInput = {
    cid?: SortOrder
    teamid?: SortOrder
  }

  export type contestteamSumOrderByAggregateInput = {
    cid?: SortOrder
    teamid?: SortOrder
  }

  export type Team_categoryRelationFilter = {
    is?: team_categoryWhereInput
    isNot?: team_categoryWhereInput
  }

  export type contestteamcategoryCidCategoryidCompoundUniqueInput = {
    cid: number
    categoryid: number
  }

  export type contestteamcategoryCountOrderByAggregateInput = {
    cid?: SortOrder
    categoryid?: SortOrder
  }

  export type contestteamcategoryAvgOrderByAggregateInput = {
    cid?: SortOrder
    categoryid?: SortOrder
  }

  export type contestteamcategoryMaxOrderByAggregateInput = {
    cid?: SortOrder
    categoryid?: SortOrder
  }

  export type contestteamcategoryMinOrderByAggregateInput = {
    cid?: SortOrder
    categoryid?: SortOrder
  }

  export type contestteamcategorySumOrderByAggregateInput = {
    cid?: SortOrder
    categoryid?: SortOrder
  }

  export type contestteamcategoryformedalsCidCategoryidCompoundUniqueInput = {
    cid: number
    categoryid: number
  }

  export type contestteamcategoryformedalsCountOrderByAggregateInput = {
    cid?: SortOrder
    categoryid?: SortOrder
  }

  export type contestteamcategoryformedalsAvgOrderByAggregateInput = {
    cid?: SortOrder
    categoryid?: SortOrder
  }

  export type contestteamcategoryformedalsMaxOrderByAggregateInput = {
    cid?: SortOrder
    categoryid?: SortOrder
  }

  export type contestteamcategoryformedalsMinOrderByAggregateInput = {
    cid?: SortOrder
    categoryid?: SortOrder
  }

  export type contestteamcategoryformedalsSumOrderByAggregateInput = {
    cid?: SortOrder
    categoryid?: SortOrder
  }

  export type JudgingNullableRelationFilter = {
    is?: judgingWhereInput | null
    isNot?: judgingWhereInput | null
  }

  export type JudgehostNullableRelationFilter = {
    is?: judgehostWhereInput | null
    isNot?: judgehostWhereInput | null
  }

  export type debug_packageCountOrderByAggregateInput = {
    debug_package_id?: SortOrder
    judgingid?: SortOrder
    judgehostid?: SortOrder
    filename?: SortOrder
  }

  export type debug_packageAvgOrderByAggregateInput = {
    debug_package_id?: SortOrder
    judgingid?: SortOrder
    judgehostid?: SortOrder
  }

  export type debug_packageMaxOrderByAggregateInput = {
    debug_package_id?: SortOrder
    judgingid?: SortOrder
    judgehostid?: SortOrder
    filename?: SortOrder
  }

  export type debug_packageMinOrderByAggregateInput = {
    debug_package_id?: SortOrder
    judgingid?: SortOrder
    judgehostid?: SortOrder
    filename?: SortOrder
  }

  export type debug_packageSumOrderByAggregateInput = {
    debug_package_id?: SortOrder
    judgingid?: SortOrder
    judgehostid?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type doctrine_migration_versionsCountOrderByAggregateInput = {
    version?: SortOrder
    executed_at?: SortOrder
    execution_time?: SortOrder
  }

  export type doctrine_migration_versionsAvgOrderByAggregateInput = {
    execution_time?: SortOrder
  }

  export type doctrine_migration_versionsMaxOrderByAggregateInput = {
    version?: SortOrder
    executed_at?: SortOrder
    execution_time?: SortOrder
  }

  export type doctrine_migration_versionsMinOrderByAggregateInput = {
    version?: SortOrder
    executed_at?: SortOrder
    execution_time?: SortOrder
  }

  export type doctrine_migration_versionsSumOrderByAggregateInput = {
    execution_time?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type eventCountOrderByAggregateInput = {
    eventid?: SortOrder
    eventtime?: SortOrder
    cid?: SortOrder
    endpointtype?: SortOrder
    endpointid?: SortOrder
    action?: SortOrder
    content?: SortOrder
  }

  export type eventAvgOrderByAggregateInput = {
    eventid?: SortOrder
    eventtime?: SortOrder
    cid?: SortOrder
  }

  export type eventMaxOrderByAggregateInput = {
    eventid?: SortOrder
    eventtime?: SortOrder
    cid?: SortOrder
    endpointtype?: SortOrder
    endpointid?: SortOrder
    action?: SortOrder
    content?: SortOrder
  }

  export type eventMinOrderByAggregateInput = {
    eventid?: SortOrder
    eventtime?: SortOrder
    cid?: SortOrder
    endpointtype?: SortOrder
    endpointid?: SortOrder
    action?: SortOrder
    content?: SortOrder
  }

  export type eventSumOrderByAggregateInput = {
    eventid?: SortOrder
    eventtime?: SortOrder
    cid?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type Immutable_executableNullableRelationFilter = {
    is?: immutable_executableWhereInput | null
    isNot?: immutable_executableWhereInput | null
  }

  export type LanguageListRelationFilter = {
    every?: languageWhereInput
    some?: languageWhereInput
    none?: languageWhereInput
  }

  export type ProblemListRelationFilter = {
    every?: problemWhereInput
    some?: problemWhereInput
    none?: problemWhereInput
  }

  export type languageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type problemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type executableCountOrderByAggregateInput = {
    execid?: SortOrder
    description?: SortOrder
    type?: SortOrder
    immutable_execid?: SortOrder
  }

  export type executableAvgOrderByAggregateInput = {
    immutable_execid?: SortOrder
  }

  export type executableMaxOrderByAggregateInput = {
    execid?: SortOrder
    description?: SortOrder
    type?: SortOrder
    immutable_execid?: SortOrder
  }

  export type executableMinOrderByAggregateInput = {
    execid?: SortOrder
    description?: SortOrder
    type?: SortOrder
    immutable_execid?: SortOrder
  }

  export type executableSumOrderByAggregateInput = {
    immutable_execid?: SortOrder
  }

  export type executable_fileImmutable_execidFilenameCompoundUniqueInput = {
    immutable_execid: number
    filename: string
  }

  export type executable_fileImmutable_execidRanknumberCompoundUniqueInput = {
    immutable_execid: number
    ranknumber: number
  }

  export type executable_fileCountOrderByAggregateInput = {
    execfileid?: SortOrder
    immutable_execid?: SortOrder
    filename?: SortOrder
    ranknumber?: SortOrder
    file_content?: SortOrder
    hash?: SortOrder
    is_executable?: SortOrder
  }

  export type executable_fileAvgOrderByAggregateInput = {
    execfileid?: SortOrder
    immutable_execid?: SortOrder
    ranknumber?: SortOrder
  }

  export type executable_fileMaxOrderByAggregateInput = {
    execfileid?: SortOrder
    immutable_execid?: SortOrder
    filename?: SortOrder
    ranknumber?: SortOrder
    file_content?: SortOrder
    hash?: SortOrder
    is_executable?: SortOrder
  }

  export type executable_fileMinOrderByAggregateInput = {
    execfileid?: SortOrder
    immutable_execid?: SortOrder
    filename?: SortOrder
    ranknumber?: SortOrder
    file_content?: SortOrder
    hash?: SortOrder
    is_executable?: SortOrder
  }

  export type executable_fileSumOrderByAggregateInput = {
    execfileid?: SortOrder
    immutable_execid?: SortOrder
    ranknumber?: SortOrder
  }

  export type External_source_warningListRelationFilter = {
    every?: external_source_warningWhereInput
    some?: external_source_warningWhereInput
    none?: external_source_warningWhereInput
  }

  export type external_source_warningOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type external_contest_sourceCountOrderByAggregateInput = {
    extsourceid?: SortOrder
    cid?: SortOrder
    type?: SortOrder
    source?: SortOrder
    username?: SortOrder
    password?: SortOrder
    last_event_id?: SortOrder
    last_poll_time?: SortOrder
  }

  export type external_contest_sourceAvgOrderByAggregateInput = {
    extsourceid?: SortOrder
    cid?: SortOrder
    last_poll_time?: SortOrder
  }

  export type external_contest_sourceMaxOrderByAggregateInput = {
    extsourceid?: SortOrder
    cid?: SortOrder
    type?: SortOrder
    source?: SortOrder
    username?: SortOrder
    password?: SortOrder
    last_event_id?: SortOrder
    last_poll_time?: SortOrder
  }

  export type external_contest_sourceMinOrderByAggregateInput = {
    extsourceid?: SortOrder
    cid?: SortOrder
    type?: SortOrder
    source?: SortOrder
    username?: SortOrder
    password?: SortOrder
    last_event_id?: SortOrder
    last_poll_time?: SortOrder
  }

  export type external_contest_sourceSumOrderByAggregateInput = {
    extsourceid?: SortOrder
    cid?: SortOrder
    last_poll_time?: SortOrder
  }

  export type external_judgementCidExternalidCompoundUniqueInput = {
    cid: number
    externalid: string
  }

  export type external_judgementCountOrderByAggregateInput = {
    extjudgementid?: SortOrder
    externalid?: SortOrder
    cid?: SortOrder
    submitid?: SortOrder
    result?: SortOrder
    verified?: SortOrder
    jury_member?: SortOrder
    verify_comment?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
    valid?: SortOrder
  }

  export type external_judgementAvgOrderByAggregateInput = {
    extjudgementid?: SortOrder
    cid?: SortOrder
    submitid?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
  }

  export type external_judgementMaxOrderByAggregateInput = {
    extjudgementid?: SortOrder
    externalid?: SortOrder
    cid?: SortOrder
    submitid?: SortOrder
    result?: SortOrder
    verified?: SortOrder
    jury_member?: SortOrder
    verify_comment?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
    valid?: SortOrder
  }

  export type external_judgementMinOrderByAggregateInput = {
    extjudgementid?: SortOrder
    externalid?: SortOrder
    cid?: SortOrder
    submitid?: SortOrder
    result?: SortOrder
    verified?: SortOrder
    jury_member?: SortOrder
    verify_comment?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
    valid?: SortOrder
  }

  export type external_judgementSumOrderByAggregateInput = {
    extjudgementid?: SortOrder
    cid?: SortOrder
    submitid?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type External_judgementNullableRelationFilter = {
    is?: external_judgementWhereInput | null
    isNot?: external_judgementWhereInput | null
  }

  export type TestcaseNullableRelationFilter = {
    is?: testcaseWhereInput | null
    isNot?: testcaseWhereInput | null
  }

  export type external_runCidExternalidCompoundUniqueInput = {
    cid: number
    externalid: string
  }

  export type external_runCountOrderByAggregateInput = {
    extrunid?: SortOrder
    extjudgementid?: SortOrder
    testcaseid?: SortOrder
    externalid?: SortOrder
    cid?: SortOrder
    result?: SortOrder
    endtime?: SortOrder
    runtime?: SortOrder
  }

  export type external_runAvgOrderByAggregateInput = {
    extrunid?: SortOrder
    extjudgementid?: SortOrder
    testcaseid?: SortOrder
    cid?: SortOrder
    endtime?: SortOrder
    runtime?: SortOrder
  }

  export type external_runMaxOrderByAggregateInput = {
    extrunid?: SortOrder
    extjudgementid?: SortOrder
    testcaseid?: SortOrder
    externalid?: SortOrder
    cid?: SortOrder
    result?: SortOrder
    endtime?: SortOrder
    runtime?: SortOrder
  }

  export type external_runMinOrderByAggregateInput = {
    extrunid?: SortOrder
    extjudgementid?: SortOrder
    testcaseid?: SortOrder
    externalid?: SortOrder
    cid?: SortOrder
    result?: SortOrder
    endtime?: SortOrder
    runtime?: SortOrder
  }

  export type external_runSumOrderByAggregateInput = {
    extrunid?: SortOrder
    extjudgementid?: SortOrder
    testcaseid?: SortOrder
    cid?: SortOrder
    endtime?: SortOrder
    runtime?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type external_source_warningExtsourceidHashCompoundUniqueInput = {
    extsourceid: number
    hash: string
  }

  export type external_source_warningCountOrderByAggregateInput = {
    extwarningid?: SortOrder
    extsourceid?: SortOrder
    last_event_id?: SortOrder
    time?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    type?: SortOrder
    hash?: SortOrder
    content?: SortOrder
  }

  export type external_source_warningAvgOrderByAggregateInput = {
    extwarningid?: SortOrder
    extsourceid?: SortOrder
    time?: SortOrder
  }

  export type external_source_warningMaxOrderByAggregateInput = {
    extwarningid?: SortOrder
    extsourceid?: SortOrder
    last_event_id?: SortOrder
    time?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    type?: SortOrder
    hash?: SortOrder
    content?: SortOrder
  }

  export type external_source_warningMinOrderByAggregateInput = {
    extwarningid?: SortOrder
    extsourceid?: SortOrder
    last_event_id?: SortOrder
    time?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    type?: SortOrder
    hash?: SortOrder
    content?: SortOrder
  }

  export type external_source_warningSumOrderByAggregateInput = {
    extwarningid?: SortOrder
    extsourceid?: SortOrder
    time?: SortOrder
  }

  export type ExecutableNullableRelationFilter = {
    is?: executableWhereInput | null
    isNot?: executableWhereInput | null
  }

  export type Executable_fileListRelationFilter = {
    every?: executable_fileWhereInput
    some?: executable_fileWhereInput
    none?: executable_fileWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type executable_fileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type immutable_executableCountOrderByAggregateInput = {
    immutable_execid?: SortOrder
    userid?: SortOrder
    hash?: SortOrder
  }

  export type immutable_executableAvgOrderByAggregateInput = {
    immutable_execid?: SortOrder
    userid?: SortOrder
  }

  export type immutable_executableMaxOrderByAggregateInput = {
    immutable_execid?: SortOrder
    userid?: SortOrder
    hash?: SortOrder
  }

  export type immutable_executableMinOrderByAggregateInput = {
    immutable_execid?: SortOrder
    userid?: SortOrder
    hash?: SortOrder
  }

  export type immutable_executableSumOrderByAggregateInput = {
    immutable_execid?: SortOrder
    userid?: SortOrder
  }

  export type Enuminternal_error_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.internal_error_status | Enuminternal_error_statusFieldRefInput<$PrismaModel>
    in?: $Enums.internal_error_status[]
    notIn?: $Enums.internal_error_status[]
    not?: NestedEnuminternal_error_statusFilter<$PrismaModel> | $Enums.internal_error_status
  }

  export type internal_errorCountOrderByAggregateInput = {
    errorid?: SortOrder
    judgingid?: SortOrder
    cid?: SortOrder
    description?: SortOrder
    judgehostlog?: SortOrder
    time?: SortOrder
    disabled?: SortOrder
    status?: SortOrder
  }

  export type internal_errorAvgOrderByAggregateInput = {
    errorid?: SortOrder
    judgingid?: SortOrder
    cid?: SortOrder
    time?: SortOrder
  }

  export type internal_errorMaxOrderByAggregateInput = {
    errorid?: SortOrder
    judgingid?: SortOrder
    cid?: SortOrder
    description?: SortOrder
    judgehostlog?: SortOrder
    time?: SortOrder
    disabled?: SortOrder
    status?: SortOrder
  }

  export type internal_errorMinOrderByAggregateInput = {
    errorid?: SortOrder
    judgingid?: SortOrder
    cid?: SortOrder
    description?: SortOrder
    judgehostlog?: SortOrder
    time?: SortOrder
    disabled?: SortOrder
    status?: SortOrder
  }

  export type internal_errorSumOrderByAggregateInput = {
    errorid?: SortOrder
    judgingid?: SortOrder
    cid?: SortOrder
    time?: SortOrder
  }

  export type Enuminternal_error_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.internal_error_status | Enuminternal_error_statusFieldRefInput<$PrismaModel>
    in?: $Enums.internal_error_status[]
    notIn?: $Enums.internal_error_status[]
    not?: NestedEnuminternal_error_statusWithAggregatesFilter<$PrismaModel> | $Enums.internal_error_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminternal_error_statusFilter<$PrismaModel>
    _max?: NestedEnuminternal_error_statusFilter<$PrismaModel>
  }

  export type Debug_packageListRelationFilter = {
    every?: debug_packageWhereInput
    some?: debug_packageWhereInput
    none?: debug_packageWhereInput
  }

  export type JudgetaskListRelationFilter = {
    every?: judgetaskWhereInput
    some?: judgetaskWhereInput
    none?: judgetaskWhereInput
  }

  export type debug_packageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type judgetaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type judgehostCountOrderByAggregateInput = {
    judgehostid?: SortOrder
    hostname?: SortOrder
    enabled?: SortOrder
    polltime?: SortOrder
    hidden?: SortOrder
  }

  export type judgehostAvgOrderByAggregateInput = {
    judgehostid?: SortOrder
    polltime?: SortOrder
  }

  export type judgehostMaxOrderByAggregateInput = {
    judgehostid?: SortOrder
    hostname?: SortOrder
    enabled?: SortOrder
    polltime?: SortOrder
    hidden?: SortOrder
  }

  export type judgehostMinOrderByAggregateInput = {
    judgehostid?: SortOrder
    hostname?: SortOrder
    enabled?: SortOrder
    polltime?: SortOrder
    hidden?: SortOrder
  }

  export type judgehostSumOrderByAggregateInput = {
    judgehostid?: SortOrder
    polltime?: SortOrder
  }

  export type Enumjudgetask_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.judgetask_type | Enumjudgetask_typeFieldRefInput<$PrismaModel>
    in?: $Enums.judgetask_type[]
    notIn?: $Enums.judgetask_type[]
    not?: NestedEnumjudgetask_typeFilter<$PrismaModel> | $Enums.judgetask_type
  }

  export type Judging_runListRelationFilter = {
    every?: judging_runWhereInput
    some?: judging_runWhereInput
    none?: judging_runWhereInput
  }

  export type judging_runOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type judgetaskCountOrderByAggregateInput = {
    judgetaskid?: SortOrder
    judgehostid?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    jobid?: SortOrder
    submitid?: SortOrder
    compile_script_id?: SortOrder
    run_script_id?: SortOrder
    compare_script_id?: SortOrder
    testcase_id?: SortOrder
    compile_config?: SortOrder
    run_config?: SortOrder
    compare_config?: SortOrder
    valid?: SortOrder
    starttime?: SortOrder
    uuid?: SortOrder
    testcase_hash?: SortOrder
  }

  export type judgetaskAvgOrderByAggregateInput = {
    judgetaskid?: SortOrder
    judgehostid?: SortOrder
    priority?: SortOrder
    jobid?: SortOrder
    submitid?: SortOrder
    compile_script_id?: SortOrder
    run_script_id?: SortOrder
    compare_script_id?: SortOrder
    testcase_id?: SortOrder
    starttime?: SortOrder
  }

  export type judgetaskMaxOrderByAggregateInput = {
    judgetaskid?: SortOrder
    judgehostid?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    jobid?: SortOrder
    submitid?: SortOrder
    compile_script_id?: SortOrder
    run_script_id?: SortOrder
    compare_script_id?: SortOrder
    testcase_id?: SortOrder
    compile_config?: SortOrder
    run_config?: SortOrder
    compare_config?: SortOrder
    valid?: SortOrder
    starttime?: SortOrder
    uuid?: SortOrder
    testcase_hash?: SortOrder
  }

  export type judgetaskMinOrderByAggregateInput = {
    judgetaskid?: SortOrder
    judgehostid?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    jobid?: SortOrder
    submitid?: SortOrder
    compile_script_id?: SortOrder
    run_script_id?: SortOrder
    compare_script_id?: SortOrder
    testcase_id?: SortOrder
    compile_config?: SortOrder
    run_config?: SortOrder
    compare_config?: SortOrder
    valid?: SortOrder
    starttime?: SortOrder
    uuid?: SortOrder
    testcase_hash?: SortOrder
  }

  export type judgetaskSumOrderByAggregateInput = {
    judgetaskid?: SortOrder
    judgehostid?: SortOrder
    priority?: SortOrder
    jobid?: SortOrder
    submitid?: SortOrder
    compile_script_id?: SortOrder
    run_script_id?: SortOrder
    compare_script_id?: SortOrder
    testcase_id?: SortOrder
    starttime?: SortOrder
  }

  export type Enumjudgetask_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.judgetask_type | Enumjudgetask_typeFieldRefInput<$PrismaModel>
    in?: $Enums.judgetask_type[]
    notIn?: $Enums.judgetask_type[]
    not?: NestedEnumjudgetask_typeWithAggregatesFilter<$PrismaModel> | $Enums.judgetask_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumjudgetask_typeFilter<$PrismaModel>
    _max?: NestedEnumjudgetask_typeFilter<$PrismaModel>
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | null
    notIn?: Buffer[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type Internal_errorNullableRelationFilter = {
    is?: internal_errorWhereInput | null
    isNot?: internal_errorWhereInput | null
  }

  export type RejudgingNullableRelationFilter = {
    is?: rejudgingWhereInput | null
    isNot?: rejudgingWhereInput | null
  }

  export type judgingCountOrderByAggregateInput = {
    judgingid?: SortOrder
    cid?: SortOrder
    submitid?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
    result?: SortOrder
    verified?: SortOrder
    jury_member?: SortOrder
    verify_comment?: SortOrder
    valid?: SortOrder
    output_compile?: SortOrder
    seen?: SortOrder
    rejudgingid?: SortOrder
    prevjudgingid?: SortOrder
    judge_completely?: SortOrder
    errorid?: SortOrder
    uuid?: SortOrder
    metadata?: SortOrder
  }

  export type judgingAvgOrderByAggregateInput = {
    judgingid?: SortOrder
    cid?: SortOrder
    submitid?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
    rejudgingid?: SortOrder
    prevjudgingid?: SortOrder
    errorid?: SortOrder
  }

  export type judgingMaxOrderByAggregateInput = {
    judgingid?: SortOrder
    cid?: SortOrder
    submitid?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
    result?: SortOrder
    verified?: SortOrder
    jury_member?: SortOrder
    verify_comment?: SortOrder
    valid?: SortOrder
    output_compile?: SortOrder
    seen?: SortOrder
    rejudgingid?: SortOrder
    prevjudgingid?: SortOrder
    judge_completely?: SortOrder
    errorid?: SortOrder
    uuid?: SortOrder
    metadata?: SortOrder
  }

  export type judgingMinOrderByAggregateInput = {
    judgingid?: SortOrder
    cid?: SortOrder
    submitid?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
    result?: SortOrder
    verified?: SortOrder
    jury_member?: SortOrder
    verify_comment?: SortOrder
    valid?: SortOrder
    output_compile?: SortOrder
    seen?: SortOrder
    rejudgingid?: SortOrder
    prevjudgingid?: SortOrder
    judge_completely?: SortOrder
    errorid?: SortOrder
    uuid?: SortOrder
    metadata?: SortOrder
  }

  export type judgingSumOrderByAggregateInput = {
    judgingid?: SortOrder
    cid?: SortOrder
    submitid?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
    rejudgingid?: SortOrder
    prevjudgingid?: SortOrder
    errorid?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | null
    notIn?: Buffer[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type JudgetaskNullableRelationFilter = {
    is?: judgetaskWhereInput | null
    isNot?: judgetaskWhereInput | null
  }

  export type Judging_run_outputNullableRelationFilter = {
    is?: judging_run_outputWhereInput | null
    isNot?: judging_run_outputWhereInput | null
  }

  export type judging_runJudgingidTestcaseidCompoundUniqueInput = {
    judgingid: number
    testcaseid: number
  }

  export type judging_runCountOrderByAggregateInput = {
    runid?: SortOrder
    judgingid?: SortOrder
    testcaseid?: SortOrder
    runresult?: SortOrder
    runtime?: SortOrder
    endtime?: SortOrder
    judgetaskid?: SortOrder
  }

  export type judging_runAvgOrderByAggregateInput = {
    runid?: SortOrder
    judgingid?: SortOrder
    testcaseid?: SortOrder
    runtime?: SortOrder
    endtime?: SortOrder
    judgetaskid?: SortOrder
  }

  export type judging_runMaxOrderByAggregateInput = {
    runid?: SortOrder
    judgingid?: SortOrder
    testcaseid?: SortOrder
    runresult?: SortOrder
    runtime?: SortOrder
    endtime?: SortOrder
    judgetaskid?: SortOrder
  }

  export type judging_runMinOrderByAggregateInput = {
    runid?: SortOrder
    judgingid?: SortOrder
    testcaseid?: SortOrder
    runresult?: SortOrder
    runtime?: SortOrder
    endtime?: SortOrder
    judgetaskid?: SortOrder
  }

  export type judging_runSumOrderByAggregateInput = {
    runid?: SortOrder
    judgingid?: SortOrder
    testcaseid?: SortOrder
    runtime?: SortOrder
    endtime?: SortOrder
    judgetaskid?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type Judging_runRelationFilter = {
    is?: judging_runWhereInput
    isNot?: judging_runWhereInput
  }

  export type judging_run_outputCountOrderByAggregateInput = {
    runid?: SortOrder
    output_run?: SortOrder
    output_diff?: SortOrder
    output_error?: SortOrder
    output_system?: SortOrder
    metadata?: SortOrder
  }

  export type judging_run_outputAvgOrderByAggregateInput = {
    runid?: SortOrder
  }

  export type judging_run_outputMaxOrderByAggregateInput = {
    runid?: SortOrder
    output_run?: SortOrder
    output_diff?: SortOrder
    output_error?: SortOrder
    output_system?: SortOrder
    metadata?: SortOrder
  }

  export type judging_run_outputMinOrderByAggregateInput = {
    runid?: SortOrder
    output_run?: SortOrder
    output_diff?: SortOrder
    output_error?: SortOrder
    output_system?: SortOrder
    metadata?: SortOrder
  }

  export type judging_run_outputSumOrderByAggregateInput = {
    runid?: SortOrder
  }

  export type languageCountOrderByAggregateInput = {
    langid?: SortOrder
    externalid?: SortOrder
    name?: SortOrder
    extensions?: SortOrder
    require_entry_point?: SortOrder
    entry_point_description?: SortOrder
    allow_submit?: SortOrder
    allow_judge?: SortOrder
    time_factor?: SortOrder
    compile_script?: SortOrder
    filter_compiler_files?: SortOrder
  }

  export type languageAvgOrderByAggregateInput = {
    time_factor?: SortOrder
  }

  export type languageMaxOrderByAggregateInput = {
    langid?: SortOrder
    externalid?: SortOrder
    name?: SortOrder
    extensions?: SortOrder
    require_entry_point?: SortOrder
    entry_point_description?: SortOrder
    allow_submit?: SortOrder
    allow_judge?: SortOrder
    time_factor?: SortOrder
    compile_script?: SortOrder
    filter_compiler_files?: SortOrder
  }

  export type languageMinOrderByAggregateInput = {
    langid?: SortOrder
    externalid?: SortOrder
    name?: SortOrder
    extensions?: SortOrder
    require_entry_point?: SortOrder
    entry_point_description?: SortOrder
    allow_submit?: SortOrder
    allow_judge?: SortOrder
    time_factor?: SortOrder
    compile_script?: SortOrder
    filter_compiler_files?: SortOrder
  }

  export type languageSumOrderByAggregateInput = {
    time_factor?: SortOrder
  }

  export type Problem_attachmentListRelationFilter = {
    every?: problem_attachmentWhereInput
    some?: problem_attachmentWhereInput
    none?: problem_attachmentWhereInput
  }

  export type TestcaseListRelationFilter = {
    every?: testcaseWhereInput
    some?: testcaseWhereInput
    none?: testcaseWhereInput
  }

  export type problem_attachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type testcaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type problemCountOrderByAggregateInput = {
    probid?: SortOrder
    externalid?: SortOrder
    name?: SortOrder
    timelimit?: SortOrder
    memlimit?: SortOrder
    outputlimit?: SortOrder
    special_run?: SortOrder
    special_compare?: SortOrder
    special_compare_args?: SortOrder
    combined_run_compare?: SortOrder
    problemtext?: SortOrder
    problemtext_type?: SortOrder
  }

  export type problemAvgOrderByAggregateInput = {
    probid?: SortOrder
    timelimit?: SortOrder
    memlimit?: SortOrder
    outputlimit?: SortOrder
  }

  export type problemMaxOrderByAggregateInput = {
    probid?: SortOrder
    externalid?: SortOrder
    name?: SortOrder
    timelimit?: SortOrder
    memlimit?: SortOrder
    outputlimit?: SortOrder
    special_run?: SortOrder
    special_compare?: SortOrder
    special_compare_args?: SortOrder
    combined_run_compare?: SortOrder
    problemtext?: SortOrder
    problemtext_type?: SortOrder
  }

  export type problemMinOrderByAggregateInput = {
    probid?: SortOrder
    externalid?: SortOrder
    name?: SortOrder
    timelimit?: SortOrder
    memlimit?: SortOrder
    outputlimit?: SortOrder
    special_run?: SortOrder
    special_compare?: SortOrder
    special_compare_args?: SortOrder
    combined_run_compare?: SortOrder
    problemtext?: SortOrder
    problemtext_type?: SortOrder
  }

  export type problemSumOrderByAggregateInput = {
    probid?: SortOrder
    timelimit?: SortOrder
    memlimit?: SortOrder
    outputlimit?: SortOrder
  }

  export type Problem_attachment_contentNullableRelationFilter = {
    is?: problem_attachment_contentWhereInput | null
    isNot?: problem_attachment_contentWhereInput | null
  }

  export type problem_attachmentCountOrderByAggregateInput = {
    attachmentid?: SortOrder
    probid?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type problem_attachmentAvgOrderByAggregateInput = {
    attachmentid?: SortOrder
    probid?: SortOrder
  }

  export type problem_attachmentMaxOrderByAggregateInput = {
    attachmentid?: SortOrder
    probid?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type problem_attachmentMinOrderByAggregateInput = {
    attachmentid?: SortOrder
    probid?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type problem_attachmentSumOrderByAggregateInput = {
    attachmentid?: SortOrder
    probid?: SortOrder
  }

  export type Problem_attachmentRelationFilter = {
    is?: problem_attachmentWhereInput
    isNot?: problem_attachmentWhereInput
  }

  export type problem_attachment_contentCountOrderByAggregateInput = {
    attachmentid?: SortOrder
    content?: SortOrder
  }

  export type problem_attachment_contentAvgOrderByAggregateInput = {
    attachmentid?: SortOrder
  }

  export type problem_attachment_contentMaxOrderByAggregateInput = {
    attachmentid?: SortOrder
    content?: SortOrder
  }

  export type problem_attachment_contentMinOrderByAggregateInput = {
    attachmentid?: SortOrder
    content?: SortOrder
  }

  export type problem_attachment_contentSumOrderByAggregateInput = {
    attachmentid?: SortOrder
  }

  export type queuetaskCountOrderByAggregateInput = {
    queuetaskid?: SortOrder
    teamid?: SortOrder
    jobid?: SortOrder
    priority?: SortOrder
    teampriority?: SortOrder
    starttime?: SortOrder
  }

  export type queuetaskAvgOrderByAggregateInput = {
    queuetaskid?: SortOrder
    teamid?: SortOrder
    jobid?: SortOrder
    priority?: SortOrder
    teampriority?: SortOrder
    starttime?: SortOrder
  }

  export type queuetaskMaxOrderByAggregateInput = {
    queuetaskid?: SortOrder
    teamid?: SortOrder
    jobid?: SortOrder
    priority?: SortOrder
    teampriority?: SortOrder
    starttime?: SortOrder
  }

  export type queuetaskMinOrderByAggregateInput = {
    queuetaskid?: SortOrder
    teamid?: SortOrder
    jobid?: SortOrder
    priority?: SortOrder
    teampriority?: SortOrder
    starttime?: SortOrder
  }

  export type queuetaskSumOrderByAggregateInput = {
    queuetaskid?: SortOrder
    teamid?: SortOrder
    jobid?: SortOrder
    priority?: SortOrder
    teampriority?: SortOrder
    starttime?: SortOrder
  }

  export type rankcacheCidTeamidCompoundUniqueInput = {
    cid: number
    teamid: number
  }

  export type rankcacheCountOrderByAggregateInput = {
    cid?: SortOrder
    teamid?: SortOrder
    points_restricted?: SortOrder
    totaltime_restricted?: SortOrder
    points_public?: SortOrder
    totaltime_public?: SortOrder
  }

  export type rankcacheAvgOrderByAggregateInput = {
    cid?: SortOrder
    teamid?: SortOrder
    points_restricted?: SortOrder
    totaltime_restricted?: SortOrder
    points_public?: SortOrder
    totaltime_public?: SortOrder
  }

  export type rankcacheMaxOrderByAggregateInput = {
    cid?: SortOrder
    teamid?: SortOrder
    points_restricted?: SortOrder
    totaltime_restricted?: SortOrder
    points_public?: SortOrder
    totaltime_public?: SortOrder
  }

  export type rankcacheMinOrderByAggregateInput = {
    cid?: SortOrder
    teamid?: SortOrder
    points_restricted?: SortOrder
    totaltime_restricted?: SortOrder
    points_public?: SortOrder
    totaltime_public?: SortOrder
  }

  export type rankcacheSumOrderByAggregateInput = {
    cid?: SortOrder
    teamid?: SortOrder
    points_restricted?: SortOrder
    totaltime_restricted?: SortOrder
    points_public?: SortOrder
    totaltime_public?: SortOrder
  }

  export type RejudgingListRelationFilter = {
    every?: rejudgingWhereInput
    some?: rejudgingWhereInput
    none?: rejudgingWhereInput
  }

  export type rejudgingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rejudgingCountOrderByAggregateInput = {
    rejudgingid?: SortOrder
    userid_start?: SortOrder
    userid_finish?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
    reason?: SortOrder
    valid?: SortOrder
    auto_apply?: SortOrder
    repeat?: SortOrder
    repeat_rejudgingid?: SortOrder
  }

  export type rejudgingAvgOrderByAggregateInput = {
    rejudgingid?: SortOrder
    userid_start?: SortOrder
    userid_finish?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
    repeat?: SortOrder
    repeat_rejudgingid?: SortOrder
  }

  export type rejudgingMaxOrderByAggregateInput = {
    rejudgingid?: SortOrder
    userid_start?: SortOrder
    userid_finish?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
    reason?: SortOrder
    valid?: SortOrder
    auto_apply?: SortOrder
    repeat?: SortOrder
    repeat_rejudgingid?: SortOrder
  }

  export type rejudgingMinOrderByAggregateInput = {
    rejudgingid?: SortOrder
    userid_start?: SortOrder
    userid_finish?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
    reason?: SortOrder
    valid?: SortOrder
    auto_apply?: SortOrder
    repeat?: SortOrder
    repeat_rejudgingid?: SortOrder
  }

  export type rejudgingSumOrderByAggregateInput = {
    rejudgingid?: SortOrder
    userid_start?: SortOrder
    userid_finish?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
    repeat?: SortOrder
    repeat_rejudgingid?: SortOrder
  }

  export type removed_intervalCountOrderByAggregateInput = {
    intervalid?: SortOrder
    cid?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
    starttime_string?: SortOrder
    endtime_string?: SortOrder
  }

  export type removed_intervalAvgOrderByAggregateInput = {
    intervalid?: SortOrder
    cid?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
  }

  export type removed_intervalMaxOrderByAggregateInput = {
    intervalid?: SortOrder
    cid?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
    starttime_string?: SortOrder
    endtime_string?: SortOrder
  }

  export type removed_intervalMinOrderByAggregateInput = {
    intervalid?: SortOrder
    cid?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
    starttime_string?: SortOrder
    endtime_string?: SortOrder
  }

  export type removed_intervalSumOrderByAggregateInput = {
    intervalid?: SortOrder
    cid?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
  }

  export type UserroleListRelationFilter = {
    every?: userroleWhereInput
    some?: userroleWhereInput
    none?: userroleWhereInput
  }

  export type userroleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type roleCountOrderByAggregateInput = {
    roleid?: SortOrder
    role?: SortOrder
    description?: SortOrder
  }

  export type roleAvgOrderByAggregateInput = {
    roleid?: SortOrder
  }

  export type roleMaxOrderByAggregateInput = {
    roleid?: SortOrder
    role?: SortOrder
    description?: SortOrder
  }

  export type roleMinOrderByAggregateInput = {
    roleid?: SortOrder
    role?: SortOrder
    description?: SortOrder
  }

  export type roleSumOrderByAggregateInput = {
    roleid?: SortOrder
  }

  export type scorecacheCidTeamidProbidCompoundUniqueInput = {
    cid: number
    teamid: number
    probid: number
  }

  export type scorecacheCountOrderByAggregateInput = {
    cid?: SortOrder
    teamid?: SortOrder
    probid?: SortOrder
    submissions_restricted?: SortOrder
    pending_restricted?: SortOrder
    solvetime_restricted?: SortOrder
    is_correct_restricted?: SortOrder
    submissions_public?: SortOrder
    pending_public?: SortOrder
    solvetime_public?: SortOrder
    is_correct_public?: SortOrder
    is_first_to_solve?: SortOrder
  }

  export type scorecacheAvgOrderByAggregateInput = {
    cid?: SortOrder
    teamid?: SortOrder
    probid?: SortOrder
    submissions_restricted?: SortOrder
    pending_restricted?: SortOrder
    solvetime_restricted?: SortOrder
    submissions_public?: SortOrder
    pending_public?: SortOrder
    solvetime_public?: SortOrder
  }

  export type scorecacheMaxOrderByAggregateInput = {
    cid?: SortOrder
    teamid?: SortOrder
    probid?: SortOrder
    submissions_restricted?: SortOrder
    pending_restricted?: SortOrder
    solvetime_restricted?: SortOrder
    is_correct_restricted?: SortOrder
    submissions_public?: SortOrder
    pending_public?: SortOrder
    solvetime_public?: SortOrder
    is_correct_public?: SortOrder
    is_first_to_solve?: SortOrder
  }

  export type scorecacheMinOrderByAggregateInput = {
    cid?: SortOrder
    teamid?: SortOrder
    probid?: SortOrder
    submissions_restricted?: SortOrder
    pending_restricted?: SortOrder
    solvetime_restricted?: SortOrder
    is_correct_restricted?: SortOrder
    submissions_public?: SortOrder
    pending_public?: SortOrder
    solvetime_public?: SortOrder
    is_correct_public?: SortOrder
    is_first_to_solve?: SortOrder
  }

  export type scorecacheSumOrderByAggregateInput = {
    cid?: SortOrder
    teamid?: SortOrder
    probid?: SortOrder
    submissions_restricted?: SortOrder
    pending_restricted?: SortOrder
    solvetime_restricted?: SortOrder
    submissions_public?: SortOrder
    pending_public?: SortOrder
    solvetime_public?: SortOrder
  }

  export type sessionsCountOrderByAggregateInput = {
    sess_id?: SortOrder
    sess_data?: SortOrder
    sess_lifetime?: SortOrder
    sess_time?: SortOrder
  }

  export type sessionsAvgOrderByAggregateInput = {
    sess_lifetime?: SortOrder
    sess_time?: SortOrder
  }

  export type sessionsMaxOrderByAggregateInput = {
    sess_id?: SortOrder
    sess_data?: SortOrder
    sess_lifetime?: SortOrder
    sess_time?: SortOrder
  }

  export type sessionsMinOrderByAggregateInput = {
    sess_id?: SortOrder
    sess_data?: SortOrder
    sess_lifetime?: SortOrder
    sess_time?: SortOrder
  }

  export type sessionsSumOrderByAggregateInput = {
    sess_lifetime?: SortOrder
    sess_time?: SortOrder
  }

  export type BalloonListRelationFilter = {
    every?: balloonWhereInput
    some?: balloonWhereInput
    none?: balloonWhereInput
  }

  export type LanguageNullableRelationFilter = {
    is?: languageWhereInput | null
    isNot?: languageWhereInput | null
  }

  export type ContestproblemNullableRelationFilter = {
    is?: contestproblemWhereInput | null
    isNot?: contestproblemWhereInput | null
  }

  export type Submission_fileListRelationFilter = {
    every?: submission_fileWhereInput
    some?: submission_fileWhereInput
    none?: submission_fileWhereInput
  }

  export type balloonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type submission_fileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type submissionCidExternalidCompoundUniqueInput = {
    cid: number
    externalid: string
  }

  export type submissionCountOrderByAggregateInput = {
    submitid?: SortOrder
    origsubmitid?: SortOrder
    cid?: SortOrder
    teamid?: SortOrder
    userid?: SortOrder
    probid?: SortOrder
    langid?: SortOrder
    submittime?: SortOrder
    valid?: SortOrder
    rejudgingid?: SortOrder
    expected_results?: SortOrder
    externalid?: SortOrder
    entry_point?: SortOrder
  }

  export type submissionAvgOrderByAggregateInput = {
    submitid?: SortOrder
    origsubmitid?: SortOrder
    cid?: SortOrder
    teamid?: SortOrder
    userid?: SortOrder
    probid?: SortOrder
    submittime?: SortOrder
    rejudgingid?: SortOrder
  }

  export type submissionMaxOrderByAggregateInput = {
    submitid?: SortOrder
    origsubmitid?: SortOrder
    cid?: SortOrder
    teamid?: SortOrder
    userid?: SortOrder
    probid?: SortOrder
    langid?: SortOrder
    submittime?: SortOrder
    valid?: SortOrder
    rejudgingid?: SortOrder
    expected_results?: SortOrder
    externalid?: SortOrder
    entry_point?: SortOrder
  }

  export type submissionMinOrderByAggregateInput = {
    submitid?: SortOrder
    origsubmitid?: SortOrder
    cid?: SortOrder
    teamid?: SortOrder
    userid?: SortOrder
    probid?: SortOrder
    langid?: SortOrder
    submittime?: SortOrder
    valid?: SortOrder
    rejudgingid?: SortOrder
    expected_results?: SortOrder
    externalid?: SortOrder
    entry_point?: SortOrder
  }

  export type submissionSumOrderByAggregateInput = {
    submitid?: SortOrder
    origsubmitid?: SortOrder
    cid?: SortOrder
    teamid?: SortOrder
    userid?: SortOrder
    probid?: SortOrder
    submittime?: SortOrder
    rejudgingid?: SortOrder
  }

  export type submission_fileSubmitidFilenameCompoundUniqueInput = {
    submitid: number
    filename: string
  }

  export type submission_fileSubmitidRanknumberCompoundUniqueInput = {
    submitid: number
    ranknumber: number
  }

  export type submission_fileCountOrderByAggregateInput = {
    submitfileid?: SortOrder
    submitid?: SortOrder
    sourcecode?: SortOrder
    filename?: SortOrder
    ranknumber?: SortOrder
  }

  export type submission_fileAvgOrderByAggregateInput = {
    submitfileid?: SortOrder
    submitid?: SortOrder
    ranknumber?: SortOrder
  }

  export type submission_fileMaxOrderByAggregateInput = {
    submitfileid?: SortOrder
    submitid?: SortOrder
    sourcecode?: SortOrder
    filename?: SortOrder
    ranknumber?: SortOrder
  }

  export type submission_fileMinOrderByAggregateInput = {
    submitfileid?: SortOrder
    submitid?: SortOrder
    sourcecode?: SortOrder
    filename?: SortOrder
    ranknumber?: SortOrder
  }

  export type submission_fileSumOrderByAggregateInput = {
    submitfileid?: SortOrder
    submitid?: SortOrder
    ranknumber?: SortOrder
  }

  export type QueuetaskListRelationFilter = {
    every?: queuetaskWhereInput
    some?: queuetaskWhereInput
    none?: queuetaskWhereInput
  }

  export type Team_categoryNullableRelationFilter = {
    is?: team_categoryWhereInput | null
    isNot?: team_categoryWhereInput | null
  }

  export type Team_affiliationNullableRelationFilter = {
    is?: team_affiliationWhereInput | null
    isNot?: team_affiliationWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: userWhereInput
    some?: userWhereInput
    none?: userWhereInput
  }

  export type queuetaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type teamCountOrderByAggregateInput = {
    teamid?: SortOrder
    externalid?: SortOrder
    icpcid?: SortOrder
    name?: SortOrder
    display_name?: SortOrder
    categoryid?: SortOrder
    affilid?: SortOrder
    enabled?: SortOrder
    publicdescription?: SortOrder
    room?: SortOrder
    internalcomments?: SortOrder
    judging_last_started?: SortOrder
    penalty?: SortOrder
  }

  export type teamAvgOrderByAggregateInput = {
    teamid?: SortOrder
    categoryid?: SortOrder
    affilid?: SortOrder
    judging_last_started?: SortOrder
    penalty?: SortOrder
  }

  export type teamMaxOrderByAggregateInput = {
    teamid?: SortOrder
    externalid?: SortOrder
    icpcid?: SortOrder
    name?: SortOrder
    display_name?: SortOrder
    categoryid?: SortOrder
    affilid?: SortOrder
    enabled?: SortOrder
    publicdescription?: SortOrder
    room?: SortOrder
    internalcomments?: SortOrder
    judging_last_started?: SortOrder
    penalty?: SortOrder
  }

  export type teamMinOrderByAggregateInput = {
    teamid?: SortOrder
    externalid?: SortOrder
    icpcid?: SortOrder
    name?: SortOrder
    display_name?: SortOrder
    categoryid?: SortOrder
    affilid?: SortOrder
    enabled?: SortOrder
    publicdescription?: SortOrder
    room?: SortOrder
    internalcomments?: SortOrder
    judging_last_started?: SortOrder
    penalty?: SortOrder
  }

  export type teamSumOrderByAggregateInput = {
    teamid?: SortOrder
    categoryid?: SortOrder
    affilid?: SortOrder
    judging_last_started?: SortOrder
    penalty?: SortOrder
  }

  export type TeamListRelationFilter = {
    every?: teamWhereInput
    some?: teamWhereInput
    none?: teamWhereInput
  }

  export type teamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type team_affiliationCountOrderByAggregateInput = {
    affilid?: SortOrder
    externalid?: SortOrder
    icpcid?: SortOrder
    shortname?: SortOrder
    name?: SortOrder
    country?: SortOrder
    internalcomments?: SortOrder
  }

  export type team_affiliationAvgOrderByAggregateInput = {
    affilid?: SortOrder
  }

  export type team_affiliationMaxOrderByAggregateInput = {
    affilid?: SortOrder
    externalid?: SortOrder
    icpcid?: SortOrder
    shortname?: SortOrder
    name?: SortOrder
    country?: SortOrder
    internalcomments?: SortOrder
  }

  export type team_affiliationMinOrderByAggregateInput = {
    affilid?: SortOrder
    externalid?: SortOrder
    icpcid?: SortOrder
    shortname?: SortOrder
    name?: SortOrder
    country?: SortOrder
    internalcomments?: SortOrder
  }

  export type team_affiliationSumOrderByAggregateInput = {
    affilid?: SortOrder
  }

  export type team_categoryCountOrderByAggregateInput = {
    categoryid?: SortOrder
    externalid?: SortOrder
    icpcid?: SortOrder
    name?: SortOrder
    sortorder?: SortOrder
    color?: SortOrder
    visible?: SortOrder
    allow_self_registration?: SortOrder
  }

  export type team_categoryAvgOrderByAggregateInput = {
    categoryid?: SortOrder
  }

  export type team_categoryMaxOrderByAggregateInput = {
    categoryid?: SortOrder
    externalid?: SortOrder
    icpcid?: SortOrder
    name?: SortOrder
    sortorder?: SortOrder
    color?: SortOrder
    visible?: SortOrder
    allow_self_registration?: SortOrder
  }

  export type team_categoryMinOrderByAggregateInput = {
    categoryid?: SortOrder
    externalid?: SortOrder
    icpcid?: SortOrder
    name?: SortOrder
    sortorder?: SortOrder
    color?: SortOrder
    visible?: SortOrder
    allow_self_registration?: SortOrder
  }

  export type team_categorySumOrderByAggregateInput = {
    categoryid?: SortOrder
  }

  export type ClarificationRelationFilter = {
    is?: clarificationWhereInput
    isNot?: clarificationWhereInput
  }

  export type team_unreadTeamidMesgidCompoundUniqueInput = {
    teamid: number
    mesgid: number
  }

  export type team_unreadCountOrderByAggregateInput = {
    teamid?: SortOrder
    mesgid?: SortOrder
  }

  export type team_unreadAvgOrderByAggregateInput = {
    teamid?: SortOrder
    mesgid?: SortOrder
  }

  export type team_unreadMaxOrderByAggregateInput = {
    teamid?: SortOrder
    mesgid?: SortOrder
  }

  export type team_unreadMinOrderByAggregateInput = {
    teamid?: SortOrder
    mesgid?: SortOrder
  }

  export type team_unreadSumOrderByAggregateInput = {
    teamid?: SortOrder
    mesgid?: SortOrder
  }

  export type Testcase_contentListRelationFilter = {
    every?: testcase_contentWhereInput
    some?: testcase_contentWhereInput
    none?: testcase_contentWhereInput
  }

  export type testcase_contentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type testcaseProbidRanknumberCompoundUniqueInput = {
    probid: number
    ranknumber: number
  }

  export type testcaseCountOrderByAggregateInput = {
    testcaseid?: SortOrder
    md5sum_input?: SortOrder
    md5sum_output?: SortOrder
    probid?: SortOrder
    ranknumber?: SortOrder
    description?: SortOrder
    image_type?: SortOrder
    sample?: SortOrder
    orig_input_filename?: SortOrder
    deleted?: SortOrder
  }

  export type testcaseAvgOrderByAggregateInput = {
    testcaseid?: SortOrder
    probid?: SortOrder
    ranknumber?: SortOrder
  }

  export type testcaseMaxOrderByAggregateInput = {
    testcaseid?: SortOrder
    md5sum_input?: SortOrder
    md5sum_output?: SortOrder
    probid?: SortOrder
    ranknumber?: SortOrder
    description?: SortOrder
    image_type?: SortOrder
    sample?: SortOrder
    orig_input_filename?: SortOrder
    deleted?: SortOrder
  }

  export type testcaseMinOrderByAggregateInput = {
    testcaseid?: SortOrder
    md5sum_input?: SortOrder
    md5sum_output?: SortOrder
    probid?: SortOrder
    ranknumber?: SortOrder
    description?: SortOrder
    image_type?: SortOrder
    sample?: SortOrder
    orig_input_filename?: SortOrder
    deleted?: SortOrder
  }

  export type testcaseSumOrderByAggregateInput = {
    testcaseid?: SortOrder
    probid?: SortOrder
    ranknumber?: SortOrder
  }

  export type testcase_contentCountOrderByAggregateInput = {
    testcaseid?: SortOrder
    input?: SortOrder
    output?: SortOrder
    image?: SortOrder
    image_thumb?: SortOrder
    tc_contentid?: SortOrder
  }

  export type testcase_contentAvgOrderByAggregateInput = {
    testcaseid?: SortOrder
    tc_contentid?: SortOrder
  }

  export type testcase_contentMaxOrderByAggregateInput = {
    testcaseid?: SortOrder
    input?: SortOrder
    output?: SortOrder
    image?: SortOrder
    image_thumb?: SortOrder
    tc_contentid?: SortOrder
  }

  export type testcase_contentMinOrderByAggregateInput = {
    testcaseid?: SortOrder
    input?: SortOrder
    output?: SortOrder
    image?: SortOrder
    image_thumb?: SortOrder
    tc_contentid?: SortOrder
  }

  export type testcase_contentSumOrderByAggregateInput = {
    testcaseid?: SortOrder
    tc_contentid?: SortOrder
  }

  export type Immutable_executableListRelationFilter = {
    every?: immutable_executableWhereInput
    some?: immutable_executableWhereInput
    none?: immutable_executableWhereInput
  }

  export type immutable_executableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    userid?: SortOrder
    externalid?: SortOrder
    username?: SortOrder
    name?: SortOrder
    email?: SortOrder
    last_login?: SortOrder
    last_api_login?: SortOrder
    first_login?: SortOrder
    last_ip_address?: SortOrder
    password?: SortOrder
    ip_address?: SortOrder
    enabled?: SortOrder
    teamid?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    userid?: SortOrder
    last_login?: SortOrder
    last_api_login?: SortOrder
    first_login?: SortOrder
    teamid?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    userid?: SortOrder
    externalid?: SortOrder
    username?: SortOrder
    name?: SortOrder
    email?: SortOrder
    last_login?: SortOrder
    last_api_login?: SortOrder
    first_login?: SortOrder
    last_ip_address?: SortOrder
    password?: SortOrder
    ip_address?: SortOrder
    enabled?: SortOrder
    teamid?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    userid?: SortOrder
    externalid?: SortOrder
    username?: SortOrder
    name?: SortOrder
    email?: SortOrder
    last_login?: SortOrder
    last_api_login?: SortOrder
    first_login?: SortOrder
    last_ip_address?: SortOrder
    password?: SortOrder
    ip_address?: SortOrder
    enabled?: SortOrder
    teamid?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    userid?: SortOrder
    last_login?: SortOrder
    last_api_login?: SortOrder
    first_login?: SortOrder
    teamid?: SortOrder
  }

  export type UserRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type RoleRelationFilter = {
    is?: roleWhereInput
    isNot?: roleWhereInput
  }

  export type userroleUseridRoleidCompoundUniqueInput = {
    userid: number
    roleid: number
  }

  export type userroleCountOrderByAggregateInput = {
    userid?: SortOrder
    roleid?: SortOrder
  }

  export type userroleAvgOrderByAggregateInput = {
    userid?: SortOrder
    roleid?: SortOrder
  }

  export type userroleMaxOrderByAggregateInput = {
    userid?: SortOrder
    roleid?: SortOrder
  }

  export type userroleMinOrderByAggregateInput = {
    userid?: SortOrder
    roleid?: SortOrder
  }

  export type userroleSumOrderByAggregateInput = {
    userid?: SortOrder
    roleid?: SortOrder
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type submissionCreateNestedOneWithoutBalloonInput = {
    create?: XOR<submissionCreateWithoutBalloonInput, submissionUncheckedCreateWithoutBalloonInput>
    connectOrCreate?: submissionCreateOrConnectWithoutBalloonInput
    connect?: submissionWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type submissionUpdateOneWithoutBalloonNestedInput = {
    create?: XOR<submissionCreateWithoutBalloonInput, submissionUncheckedCreateWithoutBalloonInput>
    connectOrCreate?: submissionCreateOrConnectWithoutBalloonInput
    upsert?: submissionUpsertWithoutBalloonInput
    disconnect?: submissionWhereInput | boolean
    delete?: submissionWhereInput | boolean
    connect?: submissionWhereUniqueInput
    update?: XOR<XOR<submissionUpdateToOneWithWhereWithoutBalloonInput, submissionUpdateWithoutBalloonInput>, submissionUncheckedUpdateWithoutBalloonInput>
  }

  export type contestCreateNestedOneWithoutClarificationInput = {
    create?: XOR<contestCreateWithoutClarificationInput, contestUncheckedCreateWithoutClarificationInput>
    connectOrCreate?: contestCreateOrConnectWithoutClarificationInput
    connect?: contestWhereUniqueInput
  }

  export type clarificationCreateNestedOneWithoutOther_clarificationInput = {
    create?: XOR<clarificationCreateWithoutOther_clarificationInput, clarificationUncheckedCreateWithoutOther_clarificationInput>
    connectOrCreate?: clarificationCreateOrConnectWithoutOther_clarificationInput
    connect?: clarificationWhereUniqueInput
  }

  export type clarificationCreateNestedManyWithoutClarificationInput = {
    create?: XOR<clarificationCreateWithoutClarificationInput, clarificationUncheckedCreateWithoutClarificationInput> | clarificationCreateWithoutClarificationInput[] | clarificationUncheckedCreateWithoutClarificationInput[]
    connectOrCreate?: clarificationCreateOrConnectWithoutClarificationInput | clarificationCreateOrConnectWithoutClarificationInput[]
    createMany?: clarificationCreateManyClarificationInputEnvelope
    connect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
  }

  export type problemCreateNestedOneWithoutClarificationInput = {
    create?: XOR<problemCreateWithoutClarificationInput, problemUncheckedCreateWithoutClarificationInput>
    connectOrCreate?: problemCreateOrConnectWithoutClarificationInput
    connect?: problemWhereUniqueInput
  }

  export type teamCreateNestedOneWithoutClarification_clarification_senderToteamInput = {
    create?: XOR<teamCreateWithoutClarification_clarification_senderToteamInput, teamUncheckedCreateWithoutClarification_clarification_senderToteamInput>
    connectOrCreate?: teamCreateOrConnectWithoutClarification_clarification_senderToteamInput
    connect?: teamWhereUniqueInput
  }

  export type teamCreateNestedOneWithoutClarification_clarification_recipientToteamInput = {
    create?: XOR<teamCreateWithoutClarification_clarification_recipientToteamInput, teamUncheckedCreateWithoutClarification_clarification_recipientToteamInput>
    connectOrCreate?: teamCreateOrConnectWithoutClarification_clarification_recipientToteamInput
    connect?: teamWhereUniqueInput
  }

  export type team_unreadCreateNestedManyWithoutClarificationInput = {
    create?: XOR<team_unreadCreateWithoutClarificationInput, team_unreadUncheckedCreateWithoutClarificationInput> | team_unreadCreateWithoutClarificationInput[] | team_unreadUncheckedCreateWithoutClarificationInput[]
    connectOrCreate?: team_unreadCreateOrConnectWithoutClarificationInput | team_unreadCreateOrConnectWithoutClarificationInput[]
    createMany?: team_unreadCreateManyClarificationInputEnvelope
    connect?: team_unreadWhereUniqueInput | team_unreadWhereUniqueInput[]
  }

  export type clarificationUncheckedCreateNestedManyWithoutClarificationInput = {
    create?: XOR<clarificationCreateWithoutClarificationInput, clarificationUncheckedCreateWithoutClarificationInput> | clarificationCreateWithoutClarificationInput[] | clarificationUncheckedCreateWithoutClarificationInput[]
    connectOrCreate?: clarificationCreateOrConnectWithoutClarificationInput | clarificationCreateOrConnectWithoutClarificationInput[]
    createMany?: clarificationCreateManyClarificationInputEnvelope
    connect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
  }

  export type team_unreadUncheckedCreateNestedManyWithoutClarificationInput = {
    create?: XOR<team_unreadCreateWithoutClarificationInput, team_unreadUncheckedCreateWithoutClarificationInput> | team_unreadCreateWithoutClarificationInput[] | team_unreadUncheckedCreateWithoutClarificationInput[]
    connectOrCreate?: team_unreadCreateOrConnectWithoutClarificationInput | team_unreadCreateOrConnectWithoutClarificationInput[]
    createMany?: team_unreadCreateManyClarificationInputEnvelope
    connect?: team_unreadWhereUniqueInput | team_unreadWhereUniqueInput[]
  }

  export type contestUpdateOneWithoutClarificationNestedInput = {
    create?: XOR<contestCreateWithoutClarificationInput, contestUncheckedCreateWithoutClarificationInput>
    connectOrCreate?: contestCreateOrConnectWithoutClarificationInput
    upsert?: contestUpsertWithoutClarificationInput
    disconnect?: contestWhereInput | boolean
    delete?: contestWhereInput | boolean
    connect?: contestWhereUniqueInput
    update?: XOR<XOR<contestUpdateToOneWithWhereWithoutClarificationInput, contestUpdateWithoutClarificationInput>, contestUncheckedUpdateWithoutClarificationInput>
  }

  export type clarificationUpdateOneWithoutOther_clarificationNestedInput = {
    create?: XOR<clarificationCreateWithoutOther_clarificationInput, clarificationUncheckedCreateWithoutOther_clarificationInput>
    connectOrCreate?: clarificationCreateOrConnectWithoutOther_clarificationInput
    upsert?: clarificationUpsertWithoutOther_clarificationInput
    disconnect?: clarificationWhereInput | boolean
    delete?: clarificationWhereInput | boolean
    connect?: clarificationWhereUniqueInput
    update?: XOR<XOR<clarificationUpdateToOneWithWhereWithoutOther_clarificationInput, clarificationUpdateWithoutOther_clarificationInput>, clarificationUncheckedUpdateWithoutOther_clarificationInput>
  }

  export type clarificationUpdateManyWithoutClarificationNestedInput = {
    create?: XOR<clarificationCreateWithoutClarificationInput, clarificationUncheckedCreateWithoutClarificationInput> | clarificationCreateWithoutClarificationInput[] | clarificationUncheckedCreateWithoutClarificationInput[]
    connectOrCreate?: clarificationCreateOrConnectWithoutClarificationInput | clarificationCreateOrConnectWithoutClarificationInput[]
    upsert?: clarificationUpsertWithWhereUniqueWithoutClarificationInput | clarificationUpsertWithWhereUniqueWithoutClarificationInput[]
    createMany?: clarificationCreateManyClarificationInputEnvelope
    set?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    disconnect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    delete?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    connect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    update?: clarificationUpdateWithWhereUniqueWithoutClarificationInput | clarificationUpdateWithWhereUniqueWithoutClarificationInput[]
    updateMany?: clarificationUpdateManyWithWhereWithoutClarificationInput | clarificationUpdateManyWithWhereWithoutClarificationInput[]
    deleteMany?: clarificationScalarWhereInput | clarificationScalarWhereInput[]
  }

  export type problemUpdateOneWithoutClarificationNestedInput = {
    create?: XOR<problemCreateWithoutClarificationInput, problemUncheckedCreateWithoutClarificationInput>
    connectOrCreate?: problemCreateOrConnectWithoutClarificationInput
    upsert?: problemUpsertWithoutClarificationInput
    disconnect?: problemWhereInput | boolean
    delete?: problemWhereInput | boolean
    connect?: problemWhereUniqueInput
    update?: XOR<XOR<problemUpdateToOneWithWhereWithoutClarificationInput, problemUpdateWithoutClarificationInput>, problemUncheckedUpdateWithoutClarificationInput>
  }

  export type teamUpdateOneWithoutClarification_clarification_senderToteamNestedInput = {
    create?: XOR<teamCreateWithoutClarification_clarification_senderToteamInput, teamUncheckedCreateWithoutClarification_clarification_senderToteamInput>
    connectOrCreate?: teamCreateOrConnectWithoutClarification_clarification_senderToteamInput
    upsert?: teamUpsertWithoutClarification_clarification_senderToteamInput
    disconnect?: teamWhereInput | boolean
    delete?: teamWhereInput | boolean
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutClarification_clarification_senderToteamInput, teamUpdateWithoutClarification_clarification_senderToteamInput>, teamUncheckedUpdateWithoutClarification_clarification_senderToteamInput>
  }

  export type teamUpdateOneWithoutClarification_clarification_recipientToteamNestedInput = {
    create?: XOR<teamCreateWithoutClarification_clarification_recipientToteamInput, teamUncheckedCreateWithoutClarification_clarification_recipientToteamInput>
    connectOrCreate?: teamCreateOrConnectWithoutClarification_clarification_recipientToteamInput
    upsert?: teamUpsertWithoutClarification_clarification_recipientToteamInput
    disconnect?: teamWhereInput | boolean
    delete?: teamWhereInput | boolean
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutClarification_clarification_recipientToteamInput, teamUpdateWithoutClarification_clarification_recipientToteamInput>, teamUncheckedUpdateWithoutClarification_clarification_recipientToteamInput>
  }

  export type team_unreadUpdateManyWithoutClarificationNestedInput = {
    create?: XOR<team_unreadCreateWithoutClarificationInput, team_unreadUncheckedCreateWithoutClarificationInput> | team_unreadCreateWithoutClarificationInput[] | team_unreadUncheckedCreateWithoutClarificationInput[]
    connectOrCreate?: team_unreadCreateOrConnectWithoutClarificationInput | team_unreadCreateOrConnectWithoutClarificationInput[]
    upsert?: team_unreadUpsertWithWhereUniqueWithoutClarificationInput | team_unreadUpsertWithWhereUniqueWithoutClarificationInput[]
    createMany?: team_unreadCreateManyClarificationInputEnvelope
    set?: team_unreadWhereUniqueInput | team_unreadWhereUniqueInput[]
    disconnect?: team_unreadWhereUniqueInput | team_unreadWhereUniqueInput[]
    delete?: team_unreadWhereUniqueInput | team_unreadWhereUniqueInput[]
    connect?: team_unreadWhereUniqueInput | team_unreadWhereUniqueInput[]
    update?: team_unreadUpdateWithWhereUniqueWithoutClarificationInput | team_unreadUpdateWithWhereUniqueWithoutClarificationInput[]
    updateMany?: team_unreadUpdateManyWithWhereWithoutClarificationInput | team_unreadUpdateManyWithWhereWithoutClarificationInput[]
    deleteMany?: team_unreadScalarWhereInput | team_unreadScalarWhereInput[]
  }

  export type clarificationUncheckedUpdateManyWithoutClarificationNestedInput = {
    create?: XOR<clarificationCreateWithoutClarificationInput, clarificationUncheckedCreateWithoutClarificationInput> | clarificationCreateWithoutClarificationInput[] | clarificationUncheckedCreateWithoutClarificationInput[]
    connectOrCreate?: clarificationCreateOrConnectWithoutClarificationInput | clarificationCreateOrConnectWithoutClarificationInput[]
    upsert?: clarificationUpsertWithWhereUniqueWithoutClarificationInput | clarificationUpsertWithWhereUniqueWithoutClarificationInput[]
    createMany?: clarificationCreateManyClarificationInputEnvelope
    set?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    disconnect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    delete?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    connect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    update?: clarificationUpdateWithWhereUniqueWithoutClarificationInput | clarificationUpdateWithWhereUniqueWithoutClarificationInput[]
    updateMany?: clarificationUpdateManyWithWhereWithoutClarificationInput | clarificationUpdateManyWithWhereWithoutClarificationInput[]
    deleteMany?: clarificationScalarWhereInput | clarificationScalarWhereInput[]
  }

  export type team_unreadUncheckedUpdateManyWithoutClarificationNestedInput = {
    create?: XOR<team_unreadCreateWithoutClarificationInput, team_unreadUncheckedCreateWithoutClarificationInput> | team_unreadCreateWithoutClarificationInput[] | team_unreadUncheckedCreateWithoutClarificationInput[]
    connectOrCreate?: team_unreadCreateOrConnectWithoutClarificationInput | team_unreadCreateOrConnectWithoutClarificationInput[]
    upsert?: team_unreadUpsertWithWhereUniqueWithoutClarificationInput | team_unreadUpsertWithWhereUniqueWithoutClarificationInput[]
    createMany?: team_unreadCreateManyClarificationInputEnvelope
    set?: team_unreadWhereUniqueInput | team_unreadWhereUniqueInput[]
    disconnect?: team_unreadWhereUniqueInput | team_unreadWhereUniqueInput[]
    delete?: team_unreadWhereUniqueInput | team_unreadWhereUniqueInput[]
    connect?: team_unreadWhereUniqueInput | team_unreadWhereUniqueInput[]
    update?: team_unreadUpdateWithWhereUniqueWithoutClarificationInput | team_unreadUpdateWithWhereUniqueWithoutClarificationInput[]
    updateMany?: team_unreadUpdateManyWithWhereWithoutClarificationInput | team_unreadUpdateManyWithWhereWithoutClarificationInput[]
    deleteMany?: team_unreadScalarWhereInput | team_unreadScalarWhereInput[]
  }

  export type clarificationCreateNestedManyWithoutContestInput = {
    create?: XOR<clarificationCreateWithoutContestInput, clarificationUncheckedCreateWithoutContestInput> | clarificationCreateWithoutContestInput[] | clarificationUncheckedCreateWithoutContestInput[]
    connectOrCreate?: clarificationCreateOrConnectWithoutContestInput | clarificationCreateOrConnectWithoutContestInput[]
    createMany?: clarificationCreateManyContestInputEnvelope
    connect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
  }

  export type contestproblemCreateNestedManyWithoutContestInput = {
    create?: XOR<contestproblemCreateWithoutContestInput, contestproblemUncheckedCreateWithoutContestInput> | contestproblemCreateWithoutContestInput[] | contestproblemUncheckedCreateWithoutContestInput[]
    connectOrCreate?: contestproblemCreateOrConnectWithoutContestInput | contestproblemCreateOrConnectWithoutContestInput[]
    createMany?: contestproblemCreateManyContestInputEnvelope
    connect?: contestproblemWhereUniqueInput | contestproblemWhereUniqueInput[]
  }

  export type contestteamCreateNestedManyWithoutContestInput = {
    create?: XOR<contestteamCreateWithoutContestInput, contestteamUncheckedCreateWithoutContestInput> | contestteamCreateWithoutContestInput[] | contestteamUncheckedCreateWithoutContestInput[]
    connectOrCreate?: contestteamCreateOrConnectWithoutContestInput | contestteamCreateOrConnectWithoutContestInput[]
    createMany?: contestteamCreateManyContestInputEnvelope
    connect?: contestteamWhereUniqueInput | contestteamWhereUniqueInput[]
  }

  export type contestteamcategoryCreateNestedManyWithoutContestInput = {
    create?: XOR<contestteamcategoryCreateWithoutContestInput, contestteamcategoryUncheckedCreateWithoutContestInput> | contestteamcategoryCreateWithoutContestInput[] | contestteamcategoryUncheckedCreateWithoutContestInput[]
    connectOrCreate?: contestteamcategoryCreateOrConnectWithoutContestInput | contestteamcategoryCreateOrConnectWithoutContestInput[]
    createMany?: contestteamcategoryCreateManyContestInputEnvelope
    connect?: contestteamcategoryWhereUniqueInput | contestteamcategoryWhereUniqueInput[]
  }

  export type contestteamcategoryformedalsCreateNestedManyWithoutContestInput = {
    create?: XOR<contestteamcategoryformedalsCreateWithoutContestInput, contestteamcategoryformedalsUncheckedCreateWithoutContestInput> | contestteamcategoryformedalsCreateWithoutContestInput[] | contestteamcategoryformedalsUncheckedCreateWithoutContestInput[]
    connectOrCreate?: contestteamcategoryformedalsCreateOrConnectWithoutContestInput | contestteamcategoryformedalsCreateOrConnectWithoutContestInput[]
    createMany?: contestteamcategoryformedalsCreateManyContestInputEnvelope
    connect?: contestteamcategoryformedalsWhereUniqueInput | contestteamcategoryformedalsWhereUniqueInput[]
  }

  export type eventCreateNestedManyWithoutContestInput = {
    create?: XOR<eventCreateWithoutContestInput, eventUncheckedCreateWithoutContestInput> | eventCreateWithoutContestInput[] | eventUncheckedCreateWithoutContestInput[]
    connectOrCreate?: eventCreateOrConnectWithoutContestInput | eventCreateOrConnectWithoutContestInput[]
    createMany?: eventCreateManyContestInputEnvelope
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[]
  }

  export type external_contest_sourceCreateNestedOneWithoutContestInput = {
    create?: XOR<external_contest_sourceCreateWithoutContestInput, external_contest_sourceUncheckedCreateWithoutContestInput>
    connectOrCreate?: external_contest_sourceCreateOrConnectWithoutContestInput
    connect?: external_contest_sourceWhereUniqueInput
  }

  export type external_judgementCreateNestedManyWithoutContestInput = {
    create?: XOR<external_judgementCreateWithoutContestInput, external_judgementUncheckedCreateWithoutContestInput> | external_judgementCreateWithoutContestInput[] | external_judgementUncheckedCreateWithoutContestInput[]
    connectOrCreate?: external_judgementCreateOrConnectWithoutContestInput | external_judgementCreateOrConnectWithoutContestInput[]
    createMany?: external_judgementCreateManyContestInputEnvelope
    connect?: external_judgementWhereUniqueInput | external_judgementWhereUniqueInput[]
  }

  export type external_runCreateNestedManyWithoutContestInput = {
    create?: XOR<external_runCreateWithoutContestInput, external_runUncheckedCreateWithoutContestInput> | external_runCreateWithoutContestInput[] | external_runUncheckedCreateWithoutContestInput[]
    connectOrCreate?: external_runCreateOrConnectWithoutContestInput | external_runCreateOrConnectWithoutContestInput[]
    createMany?: external_runCreateManyContestInputEnvelope
    connect?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
  }

  export type internal_errorCreateNestedManyWithoutContestInput = {
    create?: XOR<internal_errorCreateWithoutContestInput, internal_errorUncheckedCreateWithoutContestInput> | internal_errorCreateWithoutContestInput[] | internal_errorUncheckedCreateWithoutContestInput[]
    connectOrCreate?: internal_errorCreateOrConnectWithoutContestInput | internal_errorCreateOrConnectWithoutContestInput[]
    createMany?: internal_errorCreateManyContestInputEnvelope
    connect?: internal_errorWhereUniqueInput | internal_errorWhereUniqueInput[]
  }

  export type judgingCreateNestedManyWithoutContestInput = {
    create?: XOR<judgingCreateWithoutContestInput, judgingUncheckedCreateWithoutContestInput> | judgingCreateWithoutContestInput[] | judgingUncheckedCreateWithoutContestInput[]
    connectOrCreate?: judgingCreateOrConnectWithoutContestInput | judgingCreateOrConnectWithoutContestInput[]
    createMany?: judgingCreateManyContestInputEnvelope
    connect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
  }

  export type rankcacheCreateNestedManyWithoutContestInput = {
    create?: XOR<rankcacheCreateWithoutContestInput, rankcacheUncheckedCreateWithoutContestInput> | rankcacheCreateWithoutContestInput[] | rankcacheUncheckedCreateWithoutContestInput[]
    connectOrCreate?: rankcacheCreateOrConnectWithoutContestInput | rankcacheCreateOrConnectWithoutContestInput[]
    createMany?: rankcacheCreateManyContestInputEnvelope
    connect?: rankcacheWhereUniqueInput | rankcacheWhereUniqueInput[]
  }

  export type removed_intervalCreateNestedManyWithoutContestInput = {
    create?: XOR<removed_intervalCreateWithoutContestInput, removed_intervalUncheckedCreateWithoutContestInput> | removed_intervalCreateWithoutContestInput[] | removed_intervalUncheckedCreateWithoutContestInput[]
    connectOrCreate?: removed_intervalCreateOrConnectWithoutContestInput | removed_intervalCreateOrConnectWithoutContestInput[]
    createMany?: removed_intervalCreateManyContestInputEnvelope
    connect?: removed_intervalWhereUniqueInput | removed_intervalWhereUniqueInput[]
  }

  export type scorecacheCreateNestedManyWithoutContestInput = {
    create?: XOR<scorecacheCreateWithoutContestInput, scorecacheUncheckedCreateWithoutContestInput> | scorecacheCreateWithoutContestInput[] | scorecacheUncheckedCreateWithoutContestInput[]
    connectOrCreate?: scorecacheCreateOrConnectWithoutContestInput | scorecacheCreateOrConnectWithoutContestInput[]
    createMany?: scorecacheCreateManyContestInputEnvelope
    connect?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
  }

  export type submissionCreateNestedManyWithoutContestInput = {
    create?: XOR<submissionCreateWithoutContestInput, submissionUncheckedCreateWithoutContestInput> | submissionCreateWithoutContestInput[] | submissionUncheckedCreateWithoutContestInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutContestInput | submissionCreateOrConnectWithoutContestInput[]
    createMany?: submissionCreateManyContestInputEnvelope
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
  }

  export type clarificationUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<clarificationCreateWithoutContestInput, clarificationUncheckedCreateWithoutContestInput> | clarificationCreateWithoutContestInput[] | clarificationUncheckedCreateWithoutContestInput[]
    connectOrCreate?: clarificationCreateOrConnectWithoutContestInput | clarificationCreateOrConnectWithoutContestInput[]
    createMany?: clarificationCreateManyContestInputEnvelope
    connect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
  }

  export type contestproblemUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<contestproblemCreateWithoutContestInput, contestproblemUncheckedCreateWithoutContestInput> | contestproblemCreateWithoutContestInput[] | contestproblemUncheckedCreateWithoutContestInput[]
    connectOrCreate?: contestproblemCreateOrConnectWithoutContestInput | contestproblemCreateOrConnectWithoutContestInput[]
    createMany?: contestproblemCreateManyContestInputEnvelope
    connect?: contestproblemWhereUniqueInput | contestproblemWhereUniqueInput[]
  }

  export type contestteamUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<contestteamCreateWithoutContestInput, contestteamUncheckedCreateWithoutContestInput> | contestteamCreateWithoutContestInput[] | contestteamUncheckedCreateWithoutContestInput[]
    connectOrCreate?: contestteamCreateOrConnectWithoutContestInput | contestteamCreateOrConnectWithoutContestInput[]
    createMany?: contestteamCreateManyContestInputEnvelope
    connect?: contestteamWhereUniqueInput | contestteamWhereUniqueInput[]
  }

  export type contestteamcategoryUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<contestteamcategoryCreateWithoutContestInput, contestteamcategoryUncheckedCreateWithoutContestInput> | contestteamcategoryCreateWithoutContestInput[] | contestteamcategoryUncheckedCreateWithoutContestInput[]
    connectOrCreate?: contestteamcategoryCreateOrConnectWithoutContestInput | contestteamcategoryCreateOrConnectWithoutContestInput[]
    createMany?: contestteamcategoryCreateManyContestInputEnvelope
    connect?: contestteamcategoryWhereUniqueInput | contestteamcategoryWhereUniqueInput[]
  }

  export type contestteamcategoryformedalsUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<contestteamcategoryformedalsCreateWithoutContestInput, contestteamcategoryformedalsUncheckedCreateWithoutContestInput> | contestteamcategoryformedalsCreateWithoutContestInput[] | contestteamcategoryformedalsUncheckedCreateWithoutContestInput[]
    connectOrCreate?: contestteamcategoryformedalsCreateOrConnectWithoutContestInput | contestteamcategoryformedalsCreateOrConnectWithoutContestInput[]
    createMany?: contestteamcategoryformedalsCreateManyContestInputEnvelope
    connect?: contestteamcategoryformedalsWhereUniqueInput | contestteamcategoryformedalsWhereUniqueInput[]
  }

  export type eventUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<eventCreateWithoutContestInput, eventUncheckedCreateWithoutContestInput> | eventCreateWithoutContestInput[] | eventUncheckedCreateWithoutContestInput[]
    connectOrCreate?: eventCreateOrConnectWithoutContestInput | eventCreateOrConnectWithoutContestInput[]
    createMany?: eventCreateManyContestInputEnvelope
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[]
  }

  export type external_contest_sourceUncheckedCreateNestedOneWithoutContestInput = {
    create?: XOR<external_contest_sourceCreateWithoutContestInput, external_contest_sourceUncheckedCreateWithoutContestInput>
    connectOrCreate?: external_contest_sourceCreateOrConnectWithoutContestInput
    connect?: external_contest_sourceWhereUniqueInput
  }

  export type external_judgementUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<external_judgementCreateWithoutContestInput, external_judgementUncheckedCreateWithoutContestInput> | external_judgementCreateWithoutContestInput[] | external_judgementUncheckedCreateWithoutContestInput[]
    connectOrCreate?: external_judgementCreateOrConnectWithoutContestInput | external_judgementCreateOrConnectWithoutContestInput[]
    createMany?: external_judgementCreateManyContestInputEnvelope
    connect?: external_judgementWhereUniqueInput | external_judgementWhereUniqueInput[]
  }

  export type external_runUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<external_runCreateWithoutContestInput, external_runUncheckedCreateWithoutContestInput> | external_runCreateWithoutContestInput[] | external_runUncheckedCreateWithoutContestInput[]
    connectOrCreate?: external_runCreateOrConnectWithoutContestInput | external_runCreateOrConnectWithoutContestInput[]
    createMany?: external_runCreateManyContestInputEnvelope
    connect?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
  }

  export type internal_errorUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<internal_errorCreateWithoutContestInput, internal_errorUncheckedCreateWithoutContestInput> | internal_errorCreateWithoutContestInput[] | internal_errorUncheckedCreateWithoutContestInput[]
    connectOrCreate?: internal_errorCreateOrConnectWithoutContestInput | internal_errorCreateOrConnectWithoutContestInput[]
    createMany?: internal_errorCreateManyContestInputEnvelope
    connect?: internal_errorWhereUniqueInput | internal_errorWhereUniqueInput[]
  }

  export type judgingUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<judgingCreateWithoutContestInput, judgingUncheckedCreateWithoutContestInput> | judgingCreateWithoutContestInput[] | judgingUncheckedCreateWithoutContestInput[]
    connectOrCreate?: judgingCreateOrConnectWithoutContestInput | judgingCreateOrConnectWithoutContestInput[]
    createMany?: judgingCreateManyContestInputEnvelope
    connect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
  }

  export type rankcacheUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<rankcacheCreateWithoutContestInput, rankcacheUncheckedCreateWithoutContestInput> | rankcacheCreateWithoutContestInput[] | rankcacheUncheckedCreateWithoutContestInput[]
    connectOrCreate?: rankcacheCreateOrConnectWithoutContestInput | rankcacheCreateOrConnectWithoutContestInput[]
    createMany?: rankcacheCreateManyContestInputEnvelope
    connect?: rankcacheWhereUniqueInput | rankcacheWhereUniqueInput[]
  }

  export type removed_intervalUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<removed_intervalCreateWithoutContestInput, removed_intervalUncheckedCreateWithoutContestInput> | removed_intervalCreateWithoutContestInput[] | removed_intervalUncheckedCreateWithoutContestInput[]
    connectOrCreate?: removed_intervalCreateOrConnectWithoutContestInput | removed_intervalCreateOrConnectWithoutContestInput[]
    createMany?: removed_intervalCreateManyContestInputEnvelope
    connect?: removed_intervalWhereUniqueInput | removed_intervalWhereUniqueInput[]
  }

  export type scorecacheUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<scorecacheCreateWithoutContestInput, scorecacheUncheckedCreateWithoutContestInput> | scorecacheCreateWithoutContestInput[] | scorecacheUncheckedCreateWithoutContestInput[]
    connectOrCreate?: scorecacheCreateOrConnectWithoutContestInput | scorecacheCreateOrConnectWithoutContestInput[]
    createMany?: scorecacheCreateManyContestInputEnvelope
    connect?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
  }

  export type submissionUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<submissionCreateWithoutContestInput, submissionUncheckedCreateWithoutContestInput> | submissionCreateWithoutContestInput[] | submissionUncheckedCreateWithoutContestInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutContestInput | submissionCreateOrConnectWithoutContestInput[]
    createMany?: submissionCreateManyContestInputEnvelope
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type clarificationUpdateManyWithoutContestNestedInput = {
    create?: XOR<clarificationCreateWithoutContestInput, clarificationUncheckedCreateWithoutContestInput> | clarificationCreateWithoutContestInput[] | clarificationUncheckedCreateWithoutContestInput[]
    connectOrCreate?: clarificationCreateOrConnectWithoutContestInput | clarificationCreateOrConnectWithoutContestInput[]
    upsert?: clarificationUpsertWithWhereUniqueWithoutContestInput | clarificationUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: clarificationCreateManyContestInputEnvelope
    set?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    disconnect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    delete?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    connect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    update?: clarificationUpdateWithWhereUniqueWithoutContestInput | clarificationUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: clarificationUpdateManyWithWhereWithoutContestInput | clarificationUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: clarificationScalarWhereInput | clarificationScalarWhereInput[]
  }

  export type contestproblemUpdateManyWithoutContestNestedInput = {
    create?: XOR<contestproblemCreateWithoutContestInput, contestproblemUncheckedCreateWithoutContestInput> | contestproblemCreateWithoutContestInput[] | contestproblemUncheckedCreateWithoutContestInput[]
    connectOrCreate?: contestproblemCreateOrConnectWithoutContestInput | contestproblemCreateOrConnectWithoutContestInput[]
    upsert?: contestproblemUpsertWithWhereUniqueWithoutContestInput | contestproblemUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: contestproblemCreateManyContestInputEnvelope
    set?: contestproblemWhereUniqueInput | contestproblemWhereUniqueInput[]
    disconnect?: contestproblemWhereUniqueInput | contestproblemWhereUniqueInput[]
    delete?: contestproblemWhereUniqueInput | contestproblemWhereUniqueInput[]
    connect?: contestproblemWhereUniqueInput | contestproblemWhereUniqueInput[]
    update?: contestproblemUpdateWithWhereUniqueWithoutContestInput | contestproblemUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: contestproblemUpdateManyWithWhereWithoutContestInput | contestproblemUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: contestproblemScalarWhereInput | contestproblemScalarWhereInput[]
  }

  export type contestteamUpdateManyWithoutContestNestedInput = {
    create?: XOR<contestteamCreateWithoutContestInput, contestteamUncheckedCreateWithoutContestInput> | contestteamCreateWithoutContestInput[] | contestteamUncheckedCreateWithoutContestInput[]
    connectOrCreate?: contestteamCreateOrConnectWithoutContestInput | contestteamCreateOrConnectWithoutContestInput[]
    upsert?: contestteamUpsertWithWhereUniqueWithoutContestInput | contestteamUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: contestteamCreateManyContestInputEnvelope
    set?: contestteamWhereUniqueInput | contestteamWhereUniqueInput[]
    disconnect?: contestteamWhereUniqueInput | contestteamWhereUniqueInput[]
    delete?: contestteamWhereUniqueInput | contestteamWhereUniqueInput[]
    connect?: contestteamWhereUniqueInput | contestteamWhereUniqueInput[]
    update?: contestteamUpdateWithWhereUniqueWithoutContestInput | contestteamUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: contestteamUpdateManyWithWhereWithoutContestInput | contestteamUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: contestteamScalarWhereInput | contestteamScalarWhereInput[]
  }

  export type contestteamcategoryUpdateManyWithoutContestNestedInput = {
    create?: XOR<contestteamcategoryCreateWithoutContestInput, contestteamcategoryUncheckedCreateWithoutContestInput> | contestteamcategoryCreateWithoutContestInput[] | contestteamcategoryUncheckedCreateWithoutContestInput[]
    connectOrCreate?: contestteamcategoryCreateOrConnectWithoutContestInput | contestteamcategoryCreateOrConnectWithoutContestInput[]
    upsert?: contestteamcategoryUpsertWithWhereUniqueWithoutContestInput | contestteamcategoryUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: contestteamcategoryCreateManyContestInputEnvelope
    set?: contestteamcategoryWhereUniqueInput | contestteamcategoryWhereUniqueInput[]
    disconnect?: contestteamcategoryWhereUniqueInput | contestteamcategoryWhereUniqueInput[]
    delete?: contestteamcategoryWhereUniqueInput | contestteamcategoryWhereUniqueInput[]
    connect?: contestteamcategoryWhereUniqueInput | contestteamcategoryWhereUniqueInput[]
    update?: contestteamcategoryUpdateWithWhereUniqueWithoutContestInput | contestteamcategoryUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: contestteamcategoryUpdateManyWithWhereWithoutContestInput | contestteamcategoryUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: contestteamcategoryScalarWhereInput | contestteamcategoryScalarWhereInput[]
  }

  export type contestteamcategoryformedalsUpdateManyWithoutContestNestedInput = {
    create?: XOR<contestteamcategoryformedalsCreateWithoutContestInput, contestteamcategoryformedalsUncheckedCreateWithoutContestInput> | contestteamcategoryformedalsCreateWithoutContestInput[] | contestteamcategoryformedalsUncheckedCreateWithoutContestInput[]
    connectOrCreate?: contestteamcategoryformedalsCreateOrConnectWithoutContestInput | contestteamcategoryformedalsCreateOrConnectWithoutContestInput[]
    upsert?: contestteamcategoryformedalsUpsertWithWhereUniqueWithoutContestInput | contestteamcategoryformedalsUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: contestteamcategoryformedalsCreateManyContestInputEnvelope
    set?: contestteamcategoryformedalsWhereUniqueInput | contestteamcategoryformedalsWhereUniqueInput[]
    disconnect?: contestteamcategoryformedalsWhereUniqueInput | contestteamcategoryformedalsWhereUniqueInput[]
    delete?: contestteamcategoryformedalsWhereUniqueInput | contestteamcategoryformedalsWhereUniqueInput[]
    connect?: contestteamcategoryformedalsWhereUniqueInput | contestteamcategoryformedalsWhereUniqueInput[]
    update?: contestteamcategoryformedalsUpdateWithWhereUniqueWithoutContestInput | contestteamcategoryformedalsUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: contestteamcategoryformedalsUpdateManyWithWhereWithoutContestInput | contestteamcategoryformedalsUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: contestteamcategoryformedalsScalarWhereInput | contestteamcategoryformedalsScalarWhereInput[]
  }

  export type eventUpdateManyWithoutContestNestedInput = {
    create?: XOR<eventCreateWithoutContestInput, eventUncheckedCreateWithoutContestInput> | eventCreateWithoutContestInput[] | eventUncheckedCreateWithoutContestInput[]
    connectOrCreate?: eventCreateOrConnectWithoutContestInput | eventCreateOrConnectWithoutContestInput[]
    upsert?: eventUpsertWithWhereUniqueWithoutContestInput | eventUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: eventCreateManyContestInputEnvelope
    set?: eventWhereUniqueInput | eventWhereUniqueInput[]
    disconnect?: eventWhereUniqueInput | eventWhereUniqueInput[]
    delete?: eventWhereUniqueInput | eventWhereUniqueInput[]
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[]
    update?: eventUpdateWithWhereUniqueWithoutContestInput | eventUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: eventUpdateManyWithWhereWithoutContestInput | eventUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: eventScalarWhereInput | eventScalarWhereInput[]
  }

  export type external_contest_sourceUpdateOneWithoutContestNestedInput = {
    create?: XOR<external_contest_sourceCreateWithoutContestInput, external_contest_sourceUncheckedCreateWithoutContestInput>
    connectOrCreate?: external_contest_sourceCreateOrConnectWithoutContestInput
    upsert?: external_contest_sourceUpsertWithoutContestInput
    disconnect?: external_contest_sourceWhereInput | boolean
    delete?: external_contest_sourceWhereInput | boolean
    connect?: external_contest_sourceWhereUniqueInput
    update?: XOR<XOR<external_contest_sourceUpdateToOneWithWhereWithoutContestInput, external_contest_sourceUpdateWithoutContestInput>, external_contest_sourceUncheckedUpdateWithoutContestInput>
  }

  export type external_judgementUpdateManyWithoutContestNestedInput = {
    create?: XOR<external_judgementCreateWithoutContestInput, external_judgementUncheckedCreateWithoutContestInput> | external_judgementCreateWithoutContestInput[] | external_judgementUncheckedCreateWithoutContestInput[]
    connectOrCreate?: external_judgementCreateOrConnectWithoutContestInput | external_judgementCreateOrConnectWithoutContestInput[]
    upsert?: external_judgementUpsertWithWhereUniqueWithoutContestInput | external_judgementUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: external_judgementCreateManyContestInputEnvelope
    set?: external_judgementWhereUniqueInput | external_judgementWhereUniqueInput[]
    disconnect?: external_judgementWhereUniqueInput | external_judgementWhereUniqueInput[]
    delete?: external_judgementWhereUniqueInput | external_judgementWhereUniqueInput[]
    connect?: external_judgementWhereUniqueInput | external_judgementWhereUniqueInput[]
    update?: external_judgementUpdateWithWhereUniqueWithoutContestInput | external_judgementUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: external_judgementUpdateManyWithWhereWithoutContestInput | external_judgementUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: external_judgementScalarWhereInput | external_judgementScalarWhereInput[]
  }

  export type external_runUpdateManyWithoutContestNestedInput = {
    create?: XOR<external_runCreateWithoutContestInput, external_runUncheckedCreateWithoutContestInput> | external_runCreateWithoutContestInput[] | external_runUncheckedCreateWithoutContestInput[]
    connectOrCreate?: external_runCreateOrConnectWithoutContestInput | external_runCreateOrConnectWithoutContestInput[]
    upsert?: external_runUpsertWithWhereUniqueWithoutContestInput | external_runUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: external_runCreateManyContestInputEnvelope
    set?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    disconnect?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    delete?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    connect?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    update?: external_runUpdateWithWhereUniqueWithoutContestInput | external_runUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: external_runUpdateManyWithWhereWithoutContestInput | external_runUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: external_runScalarWhereInput | external_runScalarWhereInput[]
  }

  export type internal_errorUpdateManyWithoutContestNestedInput = {
    create?: XOR<internal_errorCreateWithoutContestInput, internal_errorUncheckedCreateWithoutContestInput> | internal_errorCreateWithoutContestInput[] | internal_errorUncheckedCreateWithoutContestInput[]
    connectOrCreate?: internal_errorCreateOrConnectWithoutContestInput | internal_errorCreateOrConnectWithoutContestInput[]
    upsert?: internal_errorUpsertWithWhereUniqueWithoutContestInput | internal_errorUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: internal_errorCreateManyContestInputEnvelope
    set?: internal_errorWhereUniqueInput | internal_errorWhereUniqueInput[]
    disconnect?: internal_errorWhereUniqueInput | internal_errorWhereUniqueInput[]
    delete?: internal_errorWhereUniqueInput | internal_errorWhereUniqueInput[]
    connect?: internal_errorWhereUniqueInput | internal_errorWhereUniqueInput[]
    update?: internal_errorUpdateWithWhereUniqueWithoutContestInput | internal_errorUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: internal_errorUpdateManyWithWhereWithoutContestInput | internal_errorUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: internal_errorScalarWhereInput | internal_errorScalarWhereInput[]
  }

  export type judgingUpdateManyWithoutContestNestedInput = {
    create?: XOR<judgingCreateWithoutContestInput, judgingUncheckedCreateWithoutContestInput> | judgingCreateWithoutContestInput[] | judgingUncheckedCreateWithoutContestInput[]
    connectOrCreate?: judgingCreateOrConnectWithoutContestInput | judgingCreateOrConnectWithoutContestInput[]
    upsert?: judgingUpsertWithWhereUniqueWithoutContestInput | judgingUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: judgingCreateManyContestInputEnvelope
    set?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    disconnect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    delete?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    connect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    update?: judgingUpdateWithWhereUniqueWithoutContestInput | judgingUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: judgingUpdateManyWithWhereWithoutContestInput | judgingUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: judgingScalarWhereInput | judgingScalarWhereInput[]
  }

  export type rankcacheUpdateManyWithoutContestNestedInput = {
    create?: XOR<rankcacheCreateWithoutContestInput, rankcacheUncheckedCreateWithoutContestInput> | rankcacheCreateWithoutContestInput[] | rankcacheUncheckedCreateWithoutContestInput[]
    connectOrCreate?: rankcacheCreateOrConnectWithoutContestInput | rankcacheCreateOrConnectWithoutContestInput[]
    upsert?: rankcacheUpsertWithWhereUniqueWithoutContestInput | rankcacheUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: rankcacheCreateManyContestInputEnvelope
    set?: rankcacheWhereUniqueInput | rankcacheWhereUniqueInput[]
    disconnect?: rankcacheWhereUniqueInput | rankcacheWhereUniqueInput[]
    delete?: rankcacheWhereUniqueInput | rankcacheWhereUniqueInput[]
    connect?: rankcacheWhereUniqueInput | rankcacheWhereUniqueInput[]
    update?: rankcacheUpdateWithWhereUniqueWithoutContestInput | rankcacheUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: rankcacheUpdateManyWithWhereWithoutContestInput | rankcacheUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: rankcacheScalarWhereInput | rankcacheScalarWhereInput[]
  }

  export type removed_intervalUpdateManyWithoutContestNestedInput = {
    create?: XOR<removed_intervalCreateWithoutContestInput, removed_intervalUncheckedCreateWithoutContestInput> | removed_intervalCreateWithoutContestInput[] | removed_intervalUncheckedCreateWithoutContestInput[]
    connectOrCreate?: removed_intervalCreateOrConnectWithoutContestInput | removed_intervalCreateOrConnectWithoutContestInput[]
    upsert?: removed_intervalUpsertWithWhereUniqueWithoutContestInput | removed_intervalUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: removed_intervalCreateManyContestInputEnvelope
    set?: removed_intervalWhereUniqueInput | removed_intervalWhereUniqueInput[]
    disconnect?: removed_intervalWhereUniqueInput | removed_intervalWhereUniqueInput[]
    delete?: removed_intervalWhereUniqueInput | removed_intervalWhereUniqueInput[]
    connect?: removed_intervalWhereUniqueInput | removed_intervalWhereUniqueInput[]
    update?: removed_intervalUpdateWithWhereUniqueWithoutContestInput | removed_intervalUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: removed_intervalUpdateManyWithWhereWithoutContestInput | removed_intervalUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: removed_intervalScalarWhereInput | removed_intervalScalarWhereInput[]
  }

  export type scorecacheUpdateManyWithoutContestNestedInput = {
    create?: XOR<scorecacheCreateWithoutContestInput, scorecacheUncheckedCreateWithoutContestInput> | scorecacheCreateWithoutContestInput[] | scorecacheUncheckedCreateWithoutContestInput[]
    connectOrCreate?: scorecacheCreateOrConnectWithoutContestInput | scorecacheCreateOrConnectWithoutContestInput[]
    upsert?: scorecacheUpsertWithWhereUniqueWithoutContestInput | scorecacheUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: scorecacheCreateManyContestInputEnvelope
    set?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    disconnect?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    delete?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    connect?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    update?: scorecacheUpdateWithWhereUniqueWithoutContestInput | scorecacheUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: scorecacheUpdateManyWithWhereWithoutContestInput | scorecacheUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: scorecacheScalarWhereInput | scorecacheScalarWhereInput[]
  }

  export type submissionUpdateManyWithoutContestNestedInput = {
    create?: XOR<submissionCreateWithoutContestInput, submissionUncheckedCreateWithoutContestInput> | submissionCreateWithoutContestInput[] | submissionUncheckedCreateWithoutContestInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutContestInput | submissionCreateOrConnectWithoutContestInput[]
    upsert?: submissionUpsertWithWhereUniqueWithoutContestInput | submissionUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: submissionCreateManyContestInputEnvelope
    set?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    disconnect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    delete?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    update?: submissionUpdateWithWhereUniqueWithoutContestInput | submissionUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: submissionUpdateManyWithWhereWithoutContestInput | submissionUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: submissionScalarWhereInput | submissionScalarWhereInput[]
  }

  export type clarificationUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<clarificationCreateWithoutContestInput, clarificationUncheckedCreateWithoutContestInput> | clarificationCreateWithoutContestInput[] | clarificationUncheckedCreateWithoutContestInput[]
    connectOrCreate?: clarificationCreateOrConnectWithoutContestInput | clarificationCreateOrConnectWithoutContestInput[]
    upsert?: clarificationUpsertWithWhereUniqueWithoutContestInput | clarificationUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: clarificationCreateManyContestInputEnvelope
    set?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    disconnect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    delete?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    connect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    update?: clarificationUpdateWithWhereUniqueWithoutContestInput | clarificationUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: clarificationUpdateManyWithWhereWithoutContestInput | clarificationUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: clarificationScalarWhereInput | clarificationScalarWhereInput[]
  }

  export type contestproblemUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<contestproblemCreateWithoutContestInput, contestproblemUncheckedCreateWithoutContestInput> | contestproblemCreateWithoutContestInput[] | contestproblemUncheckedCreateWithoutContestInput[]
    connectOrCreate?: contestproblemCreateOrConnectWithoutContestInput | contestproblemCreateOrConnectWithoutContestInput[]
    upsert?: contestproblemUpsertWithWhereUniqueWithoutContestInput | contestproblemUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: contestproblemCreateManyContestInputEnvelope
    set?: contestproblemWhereUniqueInput | contestproblemWhereUniqueInput[]
    disconnect?: contestproblemWhereUniqueInput | contestproblemWhereUniqueInput[]
    delete?: contestproblemWhereUniqueInput | contestproblemWhereUniqueInput[]
    connect?: contestproblemWhereUniqueInput | contestproblemWhereUniqueInput[]
    update?: contestproblemUpdateWithWhereUniqueWithoutContestInput | contestproblemUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: contestproblemUpdateManyWithWhereWithoutContestInput | contestproblemUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: contestproblemScalarWhereInput | contestproblemScalarWhereInput[]
  }

  export type contestteamUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<contestteamCreateWithoutContestInput, contestteamUncheckedCreateWithoutContestInput> | contestteamCreateWithoutContestInput[] | contestteamUncheckedCreateWithoutContestInput[]
    connectOrCreate?: contestteamCreateOrConnectWithoutContestInput | contestteamCreateOrConnectWithoutContestInput[]
    upsert?: contestteamUpsertWithWhereUniqueWithoutContestInput | contestteamUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: contestteamCreateManyContestInputEnvelope
    set?: contestteamWhereUniqueInput | contestteamWhereUniqueInput[]
    disconnect?: contestteamWhereUniqueInput | contestteamWhereUniqueInput[]
    delete?: contestteamWhereUniqueInput | contestteamWhereUniqueInput[]
    connect?: contestteamWhereUniqueInput | contestteamWhereUniqueInput[]
    update?: contestteamUpdateWithWhereUniqueWithoutContestInput | contestteamUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: contestteamUpdateManyWithWhereWithoutContestInput | contestteamUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: contestteamScalarWhereInput | contestteamScalarWhereInput[]
  }

  export type contestteamcategoryUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<contestteamcategoryCreateWithoutContestInput, contestteamcategoryUncheckedCreateWithoutContestInput> | contestteamcategoryCreateWithoutContestInput[] | contestteamcategoryUncheckedCreateWithoutContestInput[]
    connectOrCreate?: contestteamcategoryCreateOrConnectWithoutContestInput | contestteamcategoryCreateOrConnectWithoutContestInput[]
    upsert?: contestteamcategoryUpsertWithWhereUniqueWithoutContestInput | contestteamcategoryUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: contestteamcategoryCreateManyContestInputEnvelope
    set?: contestteamcategoryWhereUniqueInput | contestteamcategoryWhereUniqueInput[]
    disconnect?: contestteamcategoryWhereUniqueInput | contestteamcategoryWhereUniqueInput[]
    delete?: contestteamcategoryWhereUniqueInput | contestteamcategoryWhereUniqueInput[]
    connect?: contestteamcategoryWhereUniqueInput | contestteamcategoryWhereUniqueInput[]
    update?: contestteamcategoryUpdateWithWhereUniqueWithoutContestInput | contestteamcategoryUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: contestteamcategoryUpdateManyWithWhereWithoutContestInput | contestteamcategoryUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: contestteamcategoryScalarWhereInput | contestteamcategoryScalarWhereInput[]
  }

  export type contestteamcategoryformedalsUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<contestteamcategoryformedalsCreateWithoutContestInput, contestteamcategoryformedalsUncheckedCreateWithoutContestInput> | contestteamcategoryformedalsCreateWithoutContestInput[] | contestteamcategoryformedalsUncheckedCreateWithoutContestInput[]
    connectOrCreate?: contestteamcategoryformedalsCreateOrConnectWithoutContestInput | contestteamcategoryformedalsCreateOrConnectWithoutContestInput[]
    upsert?: contestteamcategoryformedalsUpsertWithWhereUniqueWithoutContestInput | contestteamcategoryformedalsUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: contestteamcategoryformedalsCreateManyContestInputEnvelope
    set?: contestteamcategoryformedalsWhereUniqueInput | contestteamcategoryformedalsWhereUniqueInput[]
    disconnect?: contestteamcategoryformedalsWhereUniqueInput | contestteamcategoryformedalsWhereUniqueInput[]
    delete?: contestteamcategoryformedalsWhereUniqueInput | contestteamcategoryformedalsWhereUniqueInput[]
    connect?: contestteamcategoryformedalsWhereUniqueInput | contestteamcategoryformedalsWhereUniqueInput[]
    update?: contestteamcategoryformedalsUpdateWithWhereUniqueWithoutContestInput | contestteamcategoryformedalsUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: contestteamcategoryformedalsUpdateManyWithWhereWithoutContestInput | contestteamcategoryformedalsUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: contestteamcategoryformedalsScalarWhereInput | contestteamcategoryformedalsScalarWhereInput[]
  }

  export type eventUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<eventCreateWithoutContestInput, eventUncheckedCreateWithoutContestInput> | eventCreateWithoutContestInput[] | eventUncheckedCreateWithoutContestInput[]
    connectOrCreate?: eventCreateOrConnectWithoutContestInput | eventCreateOrConnectWithoutContestInput[]
    upsert?: eventUpsertWithWhereUniqueWithoutContestInput | eventUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: eventCreateManyContestInputEnvelope
    set?: eventWhereUniqueInput | eventWhereUniqueInput[]
    disconnect?: eventWhereUniqueInput | eventWhereUniqueInput[]
    delete?: eventWhereUniqueInput | eventWhereUniqueInput[]
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[]
    update?: eventUpdateWithWhereUniqueWithoutContestInput | eventUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: eventUpdateManyWithWhereWithoutContestInput | eventUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: eventScalarWhereInput | eventScalarWhereInput[]
  }

  export type external_contest_sourceUncheckedUpdateOneWithoutContestNestedInput = {
    create?: XOR<external_contest_sourceCreateWithoutContestInput, external_contest_sourceUncheckedCreateWithoutContestInput>
    connectOrCreate?: external_contest_sourceCreateOrConnectWithoutContestInput
    upsert?: external_contest_sourceUpsertWithoutContestInput
    disconnect?: external_contest_sourceWhereInput | boolean
    delete?: external_contest_sourceWhereInput | boolean
    connect?: external_contest_sourceWhereUniqueInput
    update?: XOR<XOR<external_contest_sourceUpdateToOneWithWhereWithoutContestInput, external_contest_sourceUpdateWithoutContestInput>, external_contest_sourceUncheckedUpdateWithoutContestInput>
  }

  export type external_judgementUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<external_judgementCreateWithoutContestInput, external_judgementUncheckedCreateWithoutContestInput> | external_judgementCreateWithoutContestInput[] | external_judgementUncheckedCreateWithoutContestInput[]
    connectOrCreate?: external_judgementCreateOrConnectWithoutContestInput | external_judgementCreateOrConnectWithoutContestInput[]
    upsert?: external_judgementUpsertWithWhereUniqueWithoutContestInput | external_judgementUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: external_judgementCreateManyContestInputEnvelope
    set?: external_judgementWhereUniqueInput | external_judgementWhereUniqueInput[]
    disconnect?: external_judgementWhereUniqueInput | external_judgementWhereUniqueInput[]
    delete?: external_judgementWhereUniqueInput | external_judgementWhereUniqueInput[]
    connect?: external_judgementWhereUniqueInput | external_judgementWhereUniqueInput[]
    update?: external_judgementUpdateWithWhereUniqueWithoutContestInput | external_judgementUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: external_judgementUpdateManyWithWhereWithoutContestInput | external_judgementUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: external_judgementScalarWhereInput | external_judgementScalarWhereInput[]
  }

  export type external_runUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<external_runCreateWithoutContestInput, external_runUncheckedCreateWithoutContestInput> | external_runCreateWithoutContestInput[] | external_runUncheckedCreateWithoutContestInput[]
    connectOrCreate?: external_runCreateOrConnectWithoutContestInput | external_runCreateOrConnectWithoutContestInput[]
    upsert?: external_runUpsertWithWhereUniqueWithoutContestInput | external_runUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: external_runCreateManyContestInputEnvelope
    set?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    disconnect?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    delete?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    connect?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    update?: external_runUpdateWithWhereUniqueWithoutContestInput | external_runUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: external_runUpdateManyWithWhereWithoutContestInput | external_runUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: external_runScalarWhereInput | external_runScalarWhereInput[]
  }

  export type internal_errorUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<internal_errorCreateWithoutContestInput, internal_errorUncheckedCreateWithoutContestInput> | internal_errorCreateWithoutContestInput[] | internal_errorUncheckedCreateWithoutContestInput[]
    connectOrCreate?: internal_errorCreateOrConnectWithoutContestInput | internal_errorCreateOrConnectWithoutContestInput[]
    upsert?: internal_errorUpsertWithWhereUniqueWithoutContestInput | internal_errorUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: internal_errorCreateManyContestInputEnvelope
    set?: internal_errorWhereUniqueInput | internal_errorWhereUniqueInput[]
    disconnect?: internal_errorWhereUniqueInput | internal_errorWhereUniqueInput[]
    delete?: internal_errorWhereUniqueInput | internal_errorWhereUniqueInput[]
    connect?: internal_errorWhereUniqueInput | internal_errorWhereUniqueInput[]
    update?: internal_errorUpdateWithWhereUniqueWithoutContestInput | internal_errorUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: internal_errorUpdateManyWithWhereWithoutContestInput | internal_errorUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: internal_errorScalarWhereInput | internal_errorScalarWhereInput[]
  }

  export type judgingUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<judgingCreateWithoutContestInput, judgingUncheckedCreateWithoutContestInput> | judgingCreateWithoutContestInput[] | judgingUncheckedCreateWithoutContestInput[]
    connectOrCreate?: judgingCreateOrConnectWithoutContestInput | judgingCreateOrConnectWithoutContestInput[]
    upsert?: judgingUpsertWithWhereUniqueWithoutContestInput | judgingUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: judgingCreateManyContestInputEnvelope
    set?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    disconnect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    delete?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    connect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    update?: judgingUpdateWithWhereUniqueWithoutContestInput | judgingUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: judgingUpdateManyWithWhereWithoutContestInput | judgingUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: judgingScalarWhereInput | judgingScalarWhereInput[]
  }

  export type rankcacheUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<rankcacheCreateWithoutContestInput, rankcacheUncheckedCreateWithoutContestInput> | rankcacheCreateWithoutContestInput[] | rankcacheUncheckedCreateWithoutContestInput[]
    connectOrCreate?: rankcacheCreateOrConnectWithoutContestInput | rankcacheCreateOrConnectWithoutContestInput[]
    upsert?: rankcacheUpsertWithWhereUniqueWithoutContestInput | rankcacheUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: rankcacheCreateManyContestInputEnvelope
    set?: rankcacheWhereUniqueInput | rankcacheWhereUniqueInput[]
    disconnect?: rankcacheWhereUniqueInput | rankcacheWhereUniqueInput[]
    delete?: rankcacheWhereUniqueInput | rankcacheWhereUniqueInput[]
    connect?: rankcacheWhereUniqueInput | rankcacheWhereUniqueInput[]
    update?: rankcacheUpdateWithWhereUniqueWithoutContestInput | rankcacheUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: rankcacheUpdateManyWithWhereWithoutContestInput | rankcacheUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: rankcacheScalarWhereInput | rankcacheScalarWhereInput[]
  }

  export type removed_intervalUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<removed_intervalCreateWithoutContestInput, removed_intervalUncheckedCreateWithoutContestInput> | removed_intervalCreateWithoutContestInput[] | removed_intervalUncheckedCreateWithoutContestInput[]
    connectOrCreate?: removed_intervalCreateOrConnectWithoutContestInput | removed_intervalCreateOrConnectWithoutContestInput[]
    upsert?: removed_intervalUpsertWithWhereUniqueWithoutContestInput | removed_intervalUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: removed_intervalCreateManyContestInputEnvelope
    set?: removed_intervalWhereUniqueInput | removed_intervalWhereUniqueInput[]
    disconnect?: removed_intervalWhereUniqueInput | removed_intervalWhereUniqueInput[]
    delete?: removed_intervalWhereUniqueInput | removed_intervalWhereUniqueInput[]
    connect?: removed_intervalWhereUniqueInput | removed_intervalWhereUniqueInput[]
    update?: removed_intervalUpdateWithWhereUniqueWithoutContestInput | removed_intervalUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: removed_intervalUpdateManyWithWhereWithoutContestInput | removed_intervalUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: removed_intervalScalarWhereInput | removed_intervalScalarWhereInput[]
  }

  export type scorecacheUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<scorecacheCreateWithoutContestInput, scorecacheUncheckedCreateWithoutContestInput> | scorecacheCreateWithoutContestInput[] | scorecacheUncheckedCreateWithoutContestInput[]
    connectOrCreate?: scorecacheCreateOrConnectWithoutContestInput | scorecacheCreateOrConnectWithoutContestInput[]
    upsert?: scorecacheUpsertWithWhereUniqueWithoutContestInput | scorecacheUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: scorecacheCreateManyContestInputEnvelope
    set?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    disconnect?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    delete?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    connect?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    update?: scorecacheUpdateWithWhereUniqueWithoutContestInput | scorecacheUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: scorecacheUpdateManyWithWhereWithoutContestInput | scorecacheUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: scorecacheScalarWhereInput | scorecacheScalarWhereInput[]
  }

  export type submissionUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<submissionCreateWithoutContestInput, submissionUncheckedCreateWithoutContestInput> | submissionCreateWithoutContestInput[] | submissionUncheckedCreateWithoutContestInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutContestInput | submissionCreateOrConnectWithoutContestInput[]
    upsert?: submissionUpsertWithWhereUniqueWithoutContestInput | submissionUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: submissionCreateManyContestInputEnvelope
    set?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    disconnect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    delete?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    update?: submissionUpdateWithWhereUniqueWithoutContestInput | submissionUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: submissionUpdateManyWithWhereWithoutContestInput | submissionUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: submissionScalarWhereInput | submissionScalarWhereInput[]
  }

  export type contestCreateNestedOneWithoutContestproblemInput = {
    create?: XOR<contestCreateWithoutContestproblemInput, contestUncheckedCreateWithoutContestproblemInput>
    connectOrCreate?: contestCreateOrConnectWithoutContestproblemInput
    connect?: contestWhereUniqueInput
  }

  export type problemCreateNestedOneWithoutContestproblemInput = {
    create?: XOR<problemCreateWithoutContestproblemInput, problemUncheckedCreateWithoutContestproblemInput>
    connectOrCreate?: problemCreateOrConnectWithoutContestproblemInput
    connect?: problemWhereUniqueInput
  }

  export type submissionCreateNestedManyWithoutContestproblemInput = {
    create?: XOR<submissionCreateWithoutContestproblemInput, submissionUncheckedCreateWithoutContestproblemInput> | submissionCreateWithoutContestproblemInput[] | submissionUncheckedCreateWithoutContestproblemInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutContestproblemInput | submissionCreateOrConnectWithoutContestproblemInput[]
    createMany?: submissionCreateManyContestproblemInputEnvelope
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
  }

  export type submissionUncheckedCreateNestedManyWithoutContestproblemInput = {
    create?: XOR<submissionCreateWithoutContestproblemInput, submissionUncheckedCreateWithoutContestproblemInput> | submissionCreateWithoutContestproblemInput[] | submissionUncheckedCreateWithoutContestproblemInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutContestproblemInput | submissionCreateOrConnectWithoutContestproblemInput[]
    createMany?: submissionCreateManyContestproblemInputEnvelope
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
  }

  export type contestUpdateOneRequiredWithoutContestproblemNestedInput = {
    create?: XOR<contestCreateWithoutContestproblemInput, contestUncheckedCreateWithoutContestproblemInput>
    connectOrCreate?: contestCreateOrConnectWithoutContestproblemInput
    upsert?: contestUpsertWithoutContestproblemInput
    connect?: contestWhereUniqueInput
    update?: XOR<XOR<contestUpdateToOneWithWhereWithoutContestproblemInput, contestUpdateWithoutContestproblemInput>, contestUncheckedUpdateWithoutContestproblemInput>
  }

  export type problemUpdateOneRequiredWithoutContestproblemNestedInput = {
    create?: XOR<problemCreateWithoutContestproblemInput, problemUncheckedCreateWithoutContestproblemInput>
    connectOrCreate?: problemCreateOrConnectWithoutContestproblemInput
    upsert?: problemUpsertWithoutContestproblemInput
    connect?: problemWhereUniqueInput
    update?: XOR<XOR<problemUpdateToOneWithWhereWithoutContestproblemInput, problemUpdateWithoutContestproblemInput>, problemUncheckedUpdateWithoutContestproblemInput>
  }

  export type submissionUpdateManyWithoutContestproblemNestedInput = {
    create?: XOR<submissionCreateWithoutContestproblemInput, submissionUncheckedCreateWithoutContestproblemInput> | submissionCreateWithoutContestproblemInput[] | submissionUncheckedCreateWithoutContestproblemInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutContestproblemInput | submissionCreateOrConnectWithoutContestproblemInput[]
    upsert?: submissionUpsertWithWhereUniqueWithoutContestproblemInput | submissionUpsertWithWhereUniqueWithoutContestproblemInput[]
    createMany?: submissionCreateManyContestproblemInputEnvelope
    set?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    disconnect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    delete?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    update?: submissionUpdateWithWhereUniqueWithoutContestproblemInput | submissionUpdateWithWhereUniqueWithoutContestproblemInput[]
    updateMany?: submissionUpdateManyWithWhereWithoutContestproblemInput | submissionUpdateManyWithWhereWithoutContestproblemInput[]
    deleteMany?: submissionScalarWhereInput | submissionScalarWhereInput[]
  }

  export type submissionUncheckedUpdateManyWithoutContestproblemNestedInput = {
    create?: XOR<submissionCreateWithoutContestproblemInput, submissionUncheckedCreateWithoutContestproblemInput> | submissionCreateWithoutContestproblemInput[] | submissionUncheckedCreateWithoutContestproblemInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutContestproblemInput | submissionCreateOrConnectWithoutContestproblemInput[]
    upsert?: submissionUpsertWithWhereUniqueWithoutContestproblemInput | submissionUpsertWithWhereUniqueWithoutContestproblemInput[]
    createMany?: submissionCreateManyContestproblemInputEnvelope
    set?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    disconnect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    delete?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    update?: submissionUpdateWithWhereUniqueWithoutContestproblemInput | submissionUpdateWithWhereUniqueWithoutContestproblemInput[]
    updateMany?: submissionUpdateManyWithWhereWithoutContestproblemInput | submissionUpdateManyWithWhereWithoutContestproblemInput[]
    deleteMany?: submissionScalarWhereInput | submissionScalarWhereInput[]
  }

  export type contestCreateNestedOneWithoutContestteamInput = {
    create?: XOR<contestCreateWithoutContestteamInput, contestUncheckedCreateWithoutContestteamInput>
    connectOrCreate?: contestCreateOrConnectWithoutContestteamInput
    connect?: contestWhereUniqueInput
  }

  export type teamCreateNestedOneWithoutContestteamInput = {
    create?: XOR<teamCreateWithoutContestteamInput, teamUncheckedCreateWithoutContestteamInput>
    connectOrCreate?: teamCreateOrConnectWithoutContestteamInput
    connect?: teamWhereUniqueInput
  }

  export type contestUpdateOneRequiredWithoutContestteamNestedInput = {
    create?: XOR<contestCreateWithoutContestteamInput, contestUncheckedCreateWithoutContestteamInput>
    connectOrCreate?: contestCreateOrConnectWithoutContestteamInput
    upsert?: contestUpsertWithoutContestteamInput
    connect?: contestWhereUniqueInput
    update?: XOR<XOR<contestUpdateToOneWithWhereWithoutContestteamInput, contestUpdateWithoutContestteamInput>, contestUncheckedUpdateWithoutContestteamInput>
  }

  export type teamUpdateOneRequiredWithoutContestteamNestedInput = {
    create?: XOR<teamCreateWithoutContestteamInput, teamUncheckedCreateWithoutContestteamInput>
    connectOrCreate?: teamCreateOrConnectWithoutContestteamInput
    upsert?: teamUpsertWithoutContestteamInput
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutContestteamInput, teamUpdateWithoutContestteamInput>, teamUncheckedUpdateWithoutContestteamInput>
  }

  export type contestCreateNestedOneWithoutContestteamcategoryInput = {
    create?: XOR<contestCreateWithoutContestteamcategoryInput, contestUncheckedCreateWithoutContestteamcategoryInput>
    connectOrCreate?: contestCreateOrConnectWithoutContestteamcategoryInput
    connect?: contestWhereUniqueInput
  }

  export type team_categoryCreateNestedOneWithoutContestteamcategoryInput = {
    create?: XOR<team_categoryCreateWithoutContestteamcategoryInput, team_categoryUncheckedCreateWithoutContestteamcategoryInput>
    connectOrCreate?: team_categoryCreateOrConnectWithoutContestteamcategoryInput
    connect?: team_categoryWhereUniqueInput
  }

  export type contestUpdateOneRequiredWithoutContestteamcategoryNestedInput = {
    create?: XOR<contestCreateWithoutContestteamcategoryInput, contestUncheckedCreateWithoutContestteamcategoryInput>
    connectOrCreate?: contestCreateOrConnectWithoutContestteamcategoryInput
    upsert?: contestUpsertWithoutContestteamcategoryInput
    connect?: contestWhereUniqueInput
    update?: XOR<XOR<contestUpdateToOneWithWhereWithoutContestteamcategoryInput, contestUpdateWithoutContestteamcategoryInput>, contestUncheckedUpdateWithoutContestteamcategoryInput>
  }

  export type team_categoryUpdateOneRequiredWithoutContestteamcategoryNestedInput = {
    create?: XOR<team_categoryCreateWithoutContestteamcategoryInput, team_categoryUncheckedCreateWithoutContestteamcategoryInput>
    connectOrCreate?: team_categoryCreateOrConnectWithoutContestteamcategoryInput
    upsert?: team_categoryUpsertWithoutContestteamcategoryInput
    connect?: team_categoryWhereUniqueInput
    update?: XOR<XOR<team_categoryUpdateToOneWithWhereWithoutContestteamcategoryInput, team_categoryUpdateWithoutContestteamcategoryInput>, team_categoryUncheckedUpdateWithoutContestteamcategoryInput>
  }

  export type contestCreateNestedOneWithoutContestteamcategoryformedalsInput = {
    create?: XOR<contestCreateWithoutContestteamcategoryformedalsInput, contestUncheckedCreateWithoutContestteamcategoryformedalsInput>
    connectOrCreate?: contestCreateOrConnectWithoutContestteamcategoryformedalsInput
    connect?: contestWhereUniqueInput
  }

  export type team_categoryCreateNestedOneWithoutContestteamcategoryformedalsInput = {
    create?: XOR<team_categoryCreateWithoutContestteamcategoryformedalsInput, team_categoryUncheckedCreateWithoutContestteamcategoryformedalsInput>
    connectOrCreate?: team_categoryCreateOrConnectWithoutContestteamcategoryformedalsInput
    connect?: team_categoryWhereUniqueInput
  }

  export type contestUpdateOneRequiredWithoutContestteamcategoryformedalsNestedInput = {
    create?: XOR<contestCreateWithoutContestteamcategoryformedalsInput, contestUncheckedCreateWithoutContestteamcategoryformedalsInput>
    connectOrCreate?: contestCreateOrConnectWithoutContestteamcategoryformedalsInput
    upsert?: contestUpsertWithoutContestteamcategoryformedalsInput
    connect?: contestWhereUniqueInput
    update?: XOR<XOR<contestUpdateToOneWithWhereWithoutContestteamcategoryformedalsInput, contestUpdateWithoutContestteamcategoryformedalsInput>, contestUncheckedUpdateWithoutContestteamcategoryformedalsInput>
  }

  export type team_categoryUpdateOneRequiredWithoutContestteamcategoryformedalsNestedInput = {
    create?: XOR<team_categoryCreateWithoutContestteamcategoryformedalsInput, team_categoryUncheckedCreateWithoutContestteamcategoryformedalsInput>
    connectOrCreate?: team_categoryCreateOrConnectWithoutContestteamcategoryformedalsInput
    upsert?: team_categoryUpsertWithoutContestteamcategoryformedalsInput
    connect?: team_categoryWhereUniqueInput
    update?: XOR<XOR<team_categoryUpdateToOneWithWhereWithoutContestteamcategoryformedalsInput, team_categoryUpdateWithoutContestteamcategoryformedalsInput>, team_categoryUncheckedUpdateWithoutContestteamcategoryformedalsInput>
  }

  export type judgingCreateNestedOneWithoutDebug_packageInput = {
    create?: XOR<judgingCreateWithoutDebug_packageInput, judgingUncheckedCreateWithoutDebug_packageInput>
    connectOrCreate?: judgingCreateOrConnectWithoutDebug_packageInput
    connect?: judgingWhereUniqueInput
  }

  export type judgehostCreateNestedOneWithoutDebug_packageInput = {
    create?: XOR<judgehostCreateWithoutDebug_packageInput, judgehostUncheckedCreateWithoutDebug_packageInput>
    connectOrCreate?: judgehostCreateOrConnectWithoutDebug_packageInput
    connect?: judgehostWhereUniqueInput
  }

  export type judgingUpdateOneWithoutDebug_packageNestedInput = {
    create?: XOR<judgingCreateWithoutDebug_packageInput, judgingUncheckedCreateWithoutDebug_packageInput>
    connectOrCreate?: judgingCreateOrConnectWithoutDebug_packageInput
    upsert?: judgingUpsertWithoutDebug_packageInput
    disconnect?: judgingWhereInput | boolean
    delete?: judgingWhereInput | boolean
    connect?: judgingWhereUniqueInput
    update?: XOR<XOR<judgingUpdateToOneWithWhereWithoutDebug_packageInput, judgingUpdateWithoutDebug_packageInput>, judgingUncheckedUpdateWithoutDebug_packageInput>
  }

  export type judgehostUpdateOneWithoutDebug_packageNestedInput = {
    create?: XOR<judgehostCreateWithoutDebug_packageInput, judgehostUncheckedCreateWithoutDebug_packageInput>
    connectOrCreate?: judgehostCreateOrConnectWithoutDebug_packageInput
    upsert?: judgehostUpsertWithoutDebug_packageInput
    disconnect?: judgehostWhereInput | boolean
    delete?: judgehostWhereInput | boolean
    connect?: judgehostWhereUniqueInput
    update?: XOR<XOR<judgehostUpdateToOneWithWhereWithoutDebug_packageInput, judgehostUpdateWithoutDebug_packageInput>, judgehostUncheckedUpdateWithoutDebug_packageInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type contestCreateNestedOneWithoutEventInput = {
    create?: XOR<contestCreateWithoutEventInput, contestUncheckedCreateWithoutEventInput>
    connectOrCreate?: contestCreateOrConnectWithoutEventInput
    connect?: contestWhereUniqueInput
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type contestUpdateOneWithoutEventNestedInput = {
    create?: XOR<contestCreateWithoutEventInput, contestUncheckedCreateWithoutEventInput>
    connectOrCreate?: contestCreateOrConnectWithoutEventInput
    upsert?: contestUpsertWithoutEventInput
    disconnect?: contestWhereInput | boolean
    delete?: contestWhereInput | boolean
    connect?: contestWhereUniqueInput
    update?: XOR<XOR<contestUpdateToOneWithWhereWithoutEventInput, contestUpdateWithoutEventInput>, contestUncheckedUpdateWithoutEventInput>
  }

  export type immutable_executableCreateNestedOneWithoutExecutableInput = {
    create?: XOR<immutable_executableCreateWithoutExecutableInput, immutable_executableUncheckedCreateWithoutExecutableInput>
    connectOrCreate?: immutable_executableCreateOrConnectWithoutExecutableInput
    connect?: immutable_executableWhereUniqueInput
  }

  export type languageCreateNestedManyWithoutExecutableInput = {
    create?: XOR<languageCreateWithoutExecutableInput, languageUncheckedCreateWithoutExecutableInput> | languageCreateWithoutExecutableInput[] | languageUncheckedCreateWithoutExecutableInput[]
    connectOrCreate?: languageCreateOrConnectWithoutExecutableInput | languageCreateOrConnectWithoutExecutableInput[]
    createMany?: languageCreateManyExecutableInputEnvelope
    connect?: languageWhereUniqueInput | languageWhereUniqueInput[]
  }

  export type problemCreateNestedManyWithoutExecutable_problem_special_runToexecutableInput = {
    create?: XOR<problemCreateWithoutExecutable_problem_special_runToexecutableInput, problemUncheckedCreateWithoutExecutable_problem_special_runToexecutableInput> | problemCreateWithoutExecutable_problem_special_runToexecutableInput[] | problemUncheckedCreateWithoutExecutable_problem_special_runToexecutableInput[]
    connectOrCreate?: problemCreateOrConnectWithoutExecutable_problem_special_runToexecutableInput | problemCreateOrConnectWithoutExecutable_problem_special_runToexecutableInput[]
    createMany?: problemCreateManyExecutable_problem_special_runToexecutableInputEnvelope
    connect?: problemWhereUniqueInput | problemWhereUniqueInput[]
  }

  export type problemCreateNestedManyWithoutExecutable_problem_special_compareToexecutableInput = {
    create?: XOR<problemCreateWithoutExecutable_problem_special_compareToexecutableInput, problemUncheckedCreateWithoutExecutable_problem_special_compareToexecutableInput> | problemCreateWithoutExecutable_problem_special_compareToexecutableInput[] | problemUncheckedCreateWithoutExecutable_problem_special_compareToexecutableInput[]
    connectOrCreate?: problemCreateOrConnectWithoutExecutable_problem_special_compareToexecutableInput | problemCreateOrConnectWithoutExecutable_problem_special_compareToexecutableInput[]
    createMany?: problemCreateManyExecutable_problem_special_compareToexecutableInputEnvelope
    connect?: problemWhereUniqueInput | problemWhereUniqueInput[]
  }

  export type languageUncheckedCreateNestedManyWithoutExecutableInput = {
    create?: XOR<languageCreateWithoutExecutableInput, languageUncheckedCreateWithoutExecutableInput> | languageCreateWithoutExecutableInput[] | languageUncheckedCreateWithoutExecutableInput[]
    connectOrCreate?: languageCreateOrConnectWithoutExecutableInput | languageCreateOrConnectWithoutExecutableInput[]
    createMany?: languageCreateManyExecutableInputEnvelope
    connect?: languageWhereUniqueInput | languageWhereUniqueInput[]
  }

  export type problemUncheckedCreateNestedManyWithoutExecutable_problem_special_runToexecutableInput = {
    create?: XOR<problemCreateWithoutExecutable_problem_special_runToexecutableInput, problemUncheckedCreateWithoutExecutable_problem_special_runToexecutableInput> | problemCreateWithoutExecutable_problem_special_runToexecutableInput[] | problemUncheckedCreateWithoutExecutable_problem_special_runToexecutableInput[]
    connectOrCreate?: problemCreateOrConnectWithoutExecutable_problem_special_runToexecutableInput | problemCreateOrConnectWithoutExecutable_problem_special_runToexecutableInput[]
    createMany?: problemCreateManyExecutable_problem_special_runToexecutableInputEnvelope
    connect?: problemWhereUniqueInput | problemWhereUniqueInput[]
  }

  export type problemUncheckedCreateNestedManyWithoutExecutable_problem_special_compareToexecutableInput = {
    create?: XOR<problemCreateWithoutExecutable_problem_special_compareToexecutableInput, problemUncheckedCreateWithoutExecutable_problem_special_compareToexecutableInput> | problemCreateWithoutExecutable_problem_special_compareToexecutableInput[] | problemUncheckedCreateWithoutExecutable_problem_special_compareToexecutableInput[]
    connectOrCreate?: problemCreateOrConnectWithoutExecutable_problem_special_compareToexecutableInput | problemCreateOrConnectWithoutExecutable_problem_special_compareToexecutableInput[]
    createMany?: problemCreateManyExecutable_problem_special_compareToexecutableInputEnvelope
    connect?: problemWhereUniqueInput | problemWhereUniqueInput[]
  }

  export type immutable_executableUpdateOneWithoutExecutableNestedInput = {
    create?: XOR<immutable_executableCreateWithoutExecutableInput, immutable_executableUncheckedCreateWithoutExecutableInput>
    connectOrCreate?: immutable_executableCreateOrConnectWithoutExecutableInput
    upsert?: immutable_executableUpsertWithoutExecutableInput
    disconnect?: immutable_executableWhereInput | boolean
    delete?: immutable_executableWhereInput | boolean
    connect?: immutable_executableWhereUniqueInput
    update?: XOR<XOR<immutable_executableUpdateToOneWithWhereWithoutExecutableInput, immutable_executableUpdateWithoutExecutableInput>, immutable_executableUncheckedUpdateWithoutExecutableInput>
  }

  export type languageUpdateManyWithoutExecutableNestedInput = {
    create?: XOR<languageCreateWithoutExecutableInput, languageUncheckedCreateWithoutExecutableInput> | languageCreateWithoutExecutableInput[] | languageUncheckedCreateWithoutExecutableInput[]
    connectOrCreate?: languageCreateOrConnectWithoutExecutableInput | languageCreateOrConnectWithoutExecutableInput[]
    upsert?: languageUpsertWithWhereUniqueWithoutExecutableInput | languageUpsertWithWhereUniqueWithoutExecutableInput[]
    createMany?: languageCreateManyExecutableInputEnvelope
    set?: languageWhereUniqueInput | languageWhereUniqueInput[]
    disconnect?: languageWhereUniqueInput | languageWhereUniqueInput[]
    delete?: languageWhereUniqueInput | languageWhereUniqueInput[]
    connect?: languageWhereUniqueInput | languageWhereUniqueInput[]
    update?: languageUpdateWithWhereUniqueWithoutExecutableInput | languageUpdateWithWhereUniqueWithoutExecutableInput[]
    updateMany?: languageUpdateManyWithWhereWithoutExecutableInput | languageUpdateManyWithWhereWithoutExecutableInput[]
    deleteMany?: languageScalarWhereInput | languageScalarWhereInput[]
  }

  export type problemUpdateManyWithoutExecutable_problem_special_runToexecutableNestedInput = {
    create?: XOR<problemCreateWithoutExecutable_problem_special_runToexecutableInput, problemUncheckedCreateWithoutExecutable_problem_special_runToexecutableInput> | problemCreateWithoutExecutable_problem_special_runToexecutableInput[] | problemUncheckedCreateWithoutExecutable_problem_special_runToexecutableInput[]
    connectOrCreate?: problemCreateOrConnectWithoutExecutable_problem_special_runToexecutableInput | problemCreateOrConnectWithoutExecutable_problem_special_runToexecutableInput[]
    upsert?: problemUpsertWithWhereUniqueWithoutExecutable_problem_special_runToexecutableInput | problemUpsertWithWhereUniqueWithoutExecutable_problem_special_runToexecutableInput[]
    createMany?: problemCreateManyExecutable_problem_special_runToexecutableInputEnvelope
    set?: problemWhereUniqueInput | problemWhereUniqueInput[]
    disconnect?: problemWhereUniqueInput | problemWhereUniqueInput[]
    delete?: problemWhereUniqueInput | problemWhereUniqueInput[]
    connect?: problemWhereUniqueInput | problemWhereUniqueInput[]
    update?: problemUpdateWithWhereUniqueWithoutExecutable_problem_special_runToexecutableInput | problemUpdateWithWhereUniqueWithoutExecutable_problem_special_runToexecutableInput[]
    updateMany?: problemUpdateManyWithWhereWithoutExecutable_problem_special_runToexecutableInput | problemUpdateManyWithWhereWithoutExecutable_problem_special_runToexecutableInput[]
    deleteMany?: problemScalarWhereInput | problemScalarWhereInput[]
  }

  export type problemUpdateManyWithoutExecutable_problem_special_compareToexecutableNestedInput = {
    create?: XOR<problemCreateWithoutExecutable_problem_special_compareToexecutableInput, problemUncheckedCreateWithoutExecutable_problem_special_compareToexecutableInput> | problemCreateWithoutExecutable_problem_special_compareToexecutableInput[] | problemUncheckedCreateWithoutExecutable_problem_special_compareToexecutableInput[]
    connectOrCreate?: problemCreateOrConnectWithoutExecutable_problem_special_compareToexecutableInput | problemCreateOrConnectWithoutExecutable_problem_special_compareToexecutableInput[]
    upsert?: problemUpsertWithWhereUniqueWithoutExecutable_problem_special_compareToexecutableInput | problemUpsertWithWhereUniqueWithoutExecutable_problem_special_compareToexecutableInput[]
    createMany?: problemCreateManyExecutable_problem_special_compareToexecutableInputEnvelope
    set?: problemWhereUniqueInput | problemWhereUniqueInput[]
    disconnect?: problemWhereUniqueInput | problemWhereUniqueInput[]
    delete?: problemWhereUniqueInput | problemWhereUniqueInput[]
    connect?: problemWhereUniqueInput | problemWhereUniqueInput[]
    update?: problemUpdateWithWhereUniqueWithoutExecutable_problem_special_compareToexecutableInput | problemUpdateWithWhereUniqueWithoutExecutable_problem_special_compareToexecutableInput[]
    updateMany?: problemUpdateManyWithWhereWithoutExecutable_problem_special_compareToexecutableInput | problemUpdateManyWithWhereWithoutExecutable_problem_special_compareToexecutableInput[]
    deleteMany?: problemScalarWhereInput | problemScalarWhereInput[]
  }

  export type languageUncheckedUpdateManyWithoutExecutableNestedInput = {
    create?: XOR<languageCreateWithoutExecutableInput, languageUncheckedCreateWithoutExecutableInput> | languageCreateWithoutExecutableInput[] | languageUncheckedCreateWithoutExecutableInput[]
    connectOrCreate?: languageCreateOrConnectWithoutExecutableInput | languageCreateOrConnectWithoutExecutableInput[]
    upsert?: languageUpsertWithWhereUniqueWithoutExecutableInput | languageUpsertWithWhereUniqueWithoutExecutableInput[]
    createMany?: languageCreateManyExecutableInputEnvelope
    set?: languageWhereUniqueInput | languageWhereUniqueInput[]
    disconnect?: languageWhereUniqueInput | languageWhereUniqueInput[]
    delete?: languageWhereUniqueInput | languageWhereUniqueInput[]
    connect?: languageWhereUniqueInput | languageWhereUniqueInput[]
    update?: languageUpdateWithWhereUniqueWithoutExecutableInput | languageUpdateWithWhereUniqueWithoutExecutableInput[]
    updateMany?: languageUpdateManyWithWhereWithoutExecutableInput | languageUpdateManyWithWhereWithoutExecutableInput[]
    deleteMany?: languageScalarWhereInput | languageScalarWhereInput[]
  }

  export type problemUncheckedUpdateManyWithoutExecutable_problem_special_runToexecutableNestedInput = {
    create?: XOR<problemCreateWithoutExecutable_problem_special_runToexecutableInput, problemUncheckedCreateWithoutExecutable_problem_special_runToexecutableInput> | problemCreateWithoutExecutable_problem_special_runToexecutableInput[] | problemUncheckedCreateWithoutExecutable_problem_special_runToexecutableInput[]
    connectOrCreate?: problemCreateOrConnectWithoutExecutable_problem_special_runToexecutableInput | problemCreateOrConnectWithoutExecutable_problem_special_runToexecutableInput[]
    upsert?: problemUpsertWithWhereUniqueWithoutExecutable_problem_special_runToexecutableInput | problemUpsertWithWhereUniqueWithoutExecutable_problem_special_runToexecutableInput[]
    createMany?: problemCreateManyExecutable_problem_special_runToexecutableInputEnvelope
    set?: problemWhereUniqueInput | problemWhereUniqueInput[]
    disconnect?: problemWhereUniqueInput | problemWhereUniqueInput[]
    delete?: problemWhereUniqueInput | problemWhereUniqueInput[]
    connect?: problemWhereUniqueInput | problemWhereUniqueInput[]
    update?: problemUpdateWithWhereUniqueWithoutExecutable_problem_special_runToexecutableInput | problemUpdateWithWhereUniqueWithoutExecutable_problem_special_runToexecutableInput[]
    updateMany?: problemUpdateManyWithWhereWithoutExecutable_problem_special_runToexecutableInput | problemUpdateManyWithWhereWithoutExecutable_problem_special_runToexecutableInput[]
    deleteMany?: problemScalarWhereInput | problemScalarWhereInput[]
  }

  export type problemUncheckedUpdateManyWithoutExecutable_problem_special_compareToexecutableNestedInput = {
    create?: XOR<problemCreateWithoutExecutable_problem_special_compareToexecutableInput, problemUncheckedCreateWithoutExecutable_problem_special_compareToexecutableInput> | problemCreateWithoutExecutable_problem_special_compareToexecutableInput[] | problemUncheckedCreateWithoutExecutable_problem_special_compareToexecutableInput[]
    connectOrCreate?: problemCreateOrConnectWithoutExecutable_problem_special_compareToexecutableInput | problemCreateOrConnectWithoutExecutable_problem_special_compareToexecutableInput[]
    upsert?: problemUpsertWithWhereUniqueWithoutExecutable_problem_special_compareToexecutableInput | problemUpsertWithWhereUniqueWithoutExecutable_problem_special_compareToexecutableInput[]
    createMany?: problemCreateManyExecutable_problem_special_compareToexecutableInputEnvelope
    set?: problemWhereUniqueInput | problemWhereUniqueInput[]
    disconnect?: problemWhereUniqueInput | problemWhereUniqueInput[]
    delete?: problemWhereUniqueInput | problemWhereUniqueInput[]
    connect?: problemWhereUniqueInput | problemWhereUniqueInput[]
    update?: problemUpdateWithWhereUniqueWithoutExecutable_problem_special_compareToexecutableInput | problemUpdateWithWhereUniqueWithoutExecutable_problem_special_compareToexecutableInput[]
    updateMany?: problemUpdateManyWithWhereWithoutExecutable_problem_special_compareToexecutableInput | problemUpdateManyWithWhereWithoutExecutable_problem_special_compareToexecutableInput[]
    deleteMany?: problemScalarWhereInput | problemScalarWhereInput[]
  }

  export type immutable_executableCreateNestedOneWithoutExecutable_fileInput = {
    create?: XOR<immutable_executableCreateWithoutExecutable_fileInput, immutable_executableUncheckedCreateWithoutExecutable_fileInput>
    connectOrCreate?: immutable_executableCreateOrConnectWithoutExecutable_fileInput
    connect?: immutable_executableWhereUniqueInput
  }

  export type immutable_executableUpdateOneWithoutExecutable_fileNestedInput = {
    create?: XOR<immutable_executableCreateWithoutExecutable_fileInput, immutable_executableUncheckedCreateWithoutExecutable_fileInput>
    connectOrCreate?: immutable_executableCreateOrConnectWithoutExecutable_fileInput
    upsert?: immutable_executableUpsertWithoutExecutable_fileInput
    disconnect?: immutable_executableWhereInput | boolean
    delete?: immutable_executableWhereInput | boolean
    connect?: immutable_executableWhereUniqueInput
    update?: XOR<XOR<immutable_executableUpdateToOneWithWhereWithoutExecutable_fileInput, immutable_executableUpdateWithoutExecutable_fileInput>, immutable_executableUncheckedUpdateWithoutExecutable_fileInput>
  }

  export type contestCreateNestedOneWithoutExternal_contest_sourceInput = {
    create?: XOR<contestCreateWithoutExternal_contest_sourceInput, contestUncheckedCreateWithoutExternal_contest_sourceInput>
    connectOrCreate?: contestCreateOrConnectWithoutExternal_contest_sourceInput
    connect?: contestWhereUniqueInput
  }

  export type external_source_warningCreateNestedManyWithoutExternal_contest_sourceInput = {
    create?: XOR<external_source_warningCreateWithoutExternal_contest_sourceInput, external_source_warningUncheckedCreateWithoutExternal_contest_sourceInput> | external_source_warningCreateWithoutExternal_contest_sourceInput[] | external_source_warningUncheckedCreateWithoutExternal_contest_sourceInput[]
    connectOrCreate?: external_source_warningCreateOrConnectWithoutExternal_contest_sourceInput | external_source_warningCreateOrConnectWithoutExternal_contest_sourceInput[]
    createMany?: external_source_warningCreateManyExternal_contest_sourceInputEnvelope
    connect?: external_source_warningWhereUniqueInput | external_source_warningWhereUniqueInput[]
  }

  export type external_source_warningUncheckedCreateNestedManyWithoutExternal_contest_sourceInput = {
    create?: XOR<external_source_warningCreateWithoutExternal_contest_sourceInput, external_source_warningUncheckedCreateWithoutExternal_contest_sourceInput> | external_source_warningCreateWithoutExternal_contest_sourceInput[] | external_source_warningUncheckedCreateWithoutExternal_contest_sourceInput[]
    connectOrCreate?: external_source_warningCreateOrConnectWithoutExternal_contest_sourceInput | external_source_warningCreateOrConnectWithoutExternal_contest_sourceInput[]
    createMany?: external_source_warningCreateManyExternal_contest_sourceInputEnvelope
    connect?: external_source_warningWhereUniqueInput | external_source_warningWhereUniqueInput[]
  }

  export type contestUpdateOneWithoutExternal_contest_sourceNestedInput = {
    create?: XOR<contestCreateWithoutExternal_contest_sourceInput, contestUncheckedCreateWithoutExternal_contest_sourceInput>
    connectOrCreate?: contestCreateOrConnectWithoutExternal_contest_sourceInput
    upsert?: contestUpsertWithoutExternal_contest_sourceInput
    disconnect?: contestWhereInput | boolean
    delete?: contestWhereInput | boolean
    connect?: contestWhereUniqueInput
    update?: XOR<XOR<contestUpdateToOneWithWhereWithoutExternal_contest_sourceInput, contestUpdateWithoutExternal_contest_sourceInput>, contestUncheckedUpdateWithoutExternal_contest_sourceInput>
  }

  export type external_source_warningUpdateManyWithoutExternal_contest_sourceNestedInput = {
    create?: XOR<external_source_warningCreateWithoutExternal_contest_sourceInput, external_source_warningUncheckedCreateWithoutExternal_contest_sourceInput> | external_source_warningCreateWithoutExternal_contest_sourceInput[] | external_source_warningUncheckedCreateWithoutExternal_contest_sourceInput[]
    connectOrCreate?: external_source_warningCreateOrConnectWithoutExternal_contest_sourceInput | external_source_warningCreateOrConnectWithoutExternal_contest_sourceInput[]
    upsert?: external_source_warningUpsertWithWhereUniqueWithoutExternal_contest_sourceInput | external_source_warningUpsertWithWhereUniqueWithoutExternal_contest_sourceInput[]
    createMany?: external_source_warningCreateManyExternal_contest_sourceInputEnvelope
    set?: external_source_warningWhereUniqueInput | external_source_warningWhereUniqueInput[]
    disconnect?: external_source_warningWhereUniqueInput | external_source_warningWhereUniqueInput[]
    delete?: external_source_warningWhereUniqueInput | external_source_warningWhereUniqueInput[]
    connect?: external_source_warningWhereUniqueInput | external_source_warningWhereUniqueInput[]
    update?: external_source_warningUpdateWithWhereUniqueWithoutExternal_contest_sourceInput | external_source_warningUpdateWithWhereUniqueWithoutExternal_contest_sourceInput[]
    updateMany?: external_source_warningUpdateManyWithWhereWithoutExternal_contest_sourceInput | external_source_warningUpdateManyWithWhereWithoutExternal_contest_sourceInput[]
    deleteMany?: external_source_warningScalarWhereInput | external_source_warningScalarWhereInput[]
  }

  export type external_source_warningUncheckedUpdateManyWithoutExternal_contest_sourceNestedInput = {
    create?: XOR<external_source_warningCreateWithoutExternal_contest_sourceInput, external_source_warningUncheckedCreateWithoutExternal_contest_sourceInput> | external_source_warningCreateWithoutExternal_contest_sourceInput[] | external_source_warningUncheckedCreateWithoutExternal_contest_sourceInput[]
    connectOrCreate?: external_source_warningCreateOrConnectWithoutExternal_contest_sourceInput | external_source_warningCreateOrConnectWithoutExternal_contest_sourceInput[]
    upsert?: external_source_warningUpsertWithWhereUniqueWithoutExternal_contest_sourceInput | external_source_warningUpsertWithWhereUniqueWithoutExternal_contest_sourceInput[]
    createMany?: external_source_warningCreateManyExternal_contest_sourceInputEnvelope
    set?: external_source_warningWhereUniqueInput | external_source_warningWhereUniqueInput[]
    disconnect?: external_source_warningWhereUniqueInput | external_source_warningWhereUniqueInput[]
    delete?: external_source_warningWhereUniqueInput | external_source_warningWhereUniqueInput[]
    connect?: external_source_warningWhereUniqueInput | external_source_warningWhereUniqueInput[]
    update?: external_source_warningUpdateWithWhereUniqueWithoutExternal_contest_sourceInput | external_source_warningUpdateWithWhereUniqueWithoutExternal_contest_sourceInput[]
    updateMany?: external_source_warningUpdateManyWithWhereWithoutExternal_contest_sourceInput | external_source_warningUpdateManyWithWhereWithoutExternal_contest_sourceInput[]
    deleteMany?: external_source_warningScalarWhereInput | external_source_warningScalarWhereInput[]
  }

  export type submissionCreateNestedOneWithoutExternal_judgementInput = {
    create?: XOR<submissionCreateWithoutExternal_judgementInput, submissionUncheckedCreateWithoutExternal_judgementInput>
    connectOrCreate?: submissionCreateOrConnectWithoutExternal_judgementInput
    connect?: submissionWhereUniqueInput
  }

  export type contestCreateNestedOneWithoutExternal_judgementInput = {
    create?: XOR<contestCreateWithoutExternal_judgementInput, contestUncheckedCreateWithoutExternal_judgementInput>
    connectOrCreate?: contestCreateOrConnectWithoutExternal_judgementInput
    connect?: contestWhereUniqueInput
  }

  export type external_runCreateNestedManyWithoutExternal_judgementInput = {
    create?: XOR<external_runCreateWithoutExternal_judgementInput, external_runUncheckedCreateWithoutExternal_judgementInput> | external_runCreateWithoutExternal_judgementInput[] | external_runUncheckedCreateWithoutExternal_judgementInput[]
    connectOrCreate?: external_runCreateOrConnectWithoutExternal_judgementInput | external_runCreateOrConnectWithoutExternal_judgementInput[]
    createMany?: external_runCreateManyExternal_judgementInputEnvelope
    connect?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
  }

  export type external_runUncheckedCreateNestedManyWithoutExternal_judgementInput = {
    create?: XOR<external_runCreateWithoutExternal_judgementInput, external_runUncheckedCreateWithoutExternal_judgementInput> | external_runCreateWithoutExternal_judgementInput[] | external_runUncheckedCreateWithoutExternal_judgementInput[]
    connectOrCreate?: external_runCreateOrConnectWithoutExternal_judgementInput | external_runCreateOrConnectWithoutExternal_judgementInput[]
    createMany?: external_runCreateManyExternal_judgementInputEnvelope
    connect?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
  }

  export type submissionUpdateOneWithoutExternal_judgementNestedInput = {
    create?: XOR<submissionCreateWithoutExternal_judgementInput, submissionUncheckedCreateWithoutExternal_judgementInput>
    connectOrCreate?: submissionCreateOrConnectWithoutExternal_judgementInput
    upsert?: submissionUpsertWithoutExternal_judgementInput
    disconnect?: submissionWhereInput | boolean
    delete?: submissionWhereInput | boolean
    connect?: submissionWhereUniqueInput
    update?: XOR<XOR<submissionUpdateToOneWithWhereWithoutExternal_judgementInput, submissionUpdateWithoutExternal_judgementInput>, submissionUncheckedUpdateWithoutExternal_judgementInput>
  }

  export type contestUpdateOneWithoutExternal_judgementNestedInput = {
    create?: XOR<contestCreateWithoutExternal_judgementInput, contestUncheckedCreateWithoutExternal_judgementInput>
    connectOrCreate?: contestCreateOrConnectWithoutExternal_judgementInput
    upsert?: contestUpsertWithoutExternal_judgementInput
    disconnect?: contestWhereInput | boolean
    delete?: contestWhereInput | boolean
    connect?: contestWhereUniqueInput
    update?: XOR<XOR<contestUpdateToOneWithWhereWithoutExternal_judgementInput, contestUpdateWithoutExternal_judgementInput>, contestUncheckedUpdateWithoutExternal_judgementInput>
  }

  export type external_runUpdateManyWithoutExternal_judgementNestedInput = {
    create?: XOR<external_runCreateWithoutExternal_judgementInput, external_runUncheckedCreateWithoutExternal_judgementInput> | external_runCreateWithoutExternal_judgementInput[] | external_runUncheckedCreateWithoutExternal_judgementInput[]
    connectOrCreate?: external_runCreateOrConnectWithoutExternal_judgementInput | external_runCreateOrConnectWithoutExternal_judgementInput[]
    upsert?: external_runUpsertWithWhereUniqueWithoutExternal_judgementInput | external_runUpsertWithWhereUniqueWithoutExternal_judgementInput[]
    createMany?: external_runCreateManyExternal_judgementInputEnvelope
    set?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    disconnect?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    delete?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    connect?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    update?: external_runUpdateWithWhereUniqueWithoutExternal_judgementInput | external_runUpdateWithWhereUniqueWithoutExternal_judgementInput[]
    updateMany?: external_runUpdateManyWithWhereWithoutExternal_judgementInput | external_runUpdateManyWithWhereWithoutExternal_judgementInput[]
    deleteMany?: external_runScalarWhereInput | external_runScalarWhereInput[]
  }

  export type external_runUncheckedUpdateManyWithoutExternal_judgementNestedInput = {
    create?: XOR<external_runCreateWithoutExternal_judgementInput, external_runUncheckedCreateWithoutExternal_judgementInput> | external_runCreateWithoutExternal_judgementInput[] | external_runUncheckedCreateWithoutExternal_judgementInput[]
    connectOrCreate?: external_runCreateOrConnectWithoutExternal_judgementInput | external_runCreateOrConnectWithoutExternal_judgementInput[]
    upsert?: external_runUpsertWithWhereUniqueWithoutExternal_judgementInput | external_runUpsertWithWhereUniqueWithoutExternal_judgementInput[]
    createMany?: external_runCreateManyExternal_judgementInputEnvelope
    set?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    disconnect?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    delete?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    connect?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    update?: external_runUpdateWithWhereUniqueWithoutExternal_judgementInput | external_runUpdateWithWhereUniqueWithoutExternal_judgementInput[]
    updateMany?: external_runUpdateManyWithWhereWithoutExternal_judgementInput | external_runUpdateManyWithWhereWithoutExternal_judgementInput[]
    deleteMany?: external_runScalarWhereInput | external_runScalarWhereInput[]
  }

  export type external_judgementCreateNestedOneWithoutExternal_runInput = {
    create?: XOR<external_judgementCreateWithoutExternal_runInput, external_judgementUncheckedCreateWithoutExternal_runInput>
    connectOrCreate?: external_judgementCreateOrConnectWithoutExternal_runInput
    connect?: external_judgementWhereUniqueInput
  }

  export type testcaseCreateNestedOneWithoutExternal_runInput = {
    create?: XOR<testcaseCreateWithoutExternal_runInput, testcaseUncheckedCreateWithoutExternal_runInput>
    connectOrCreate?: testcaseCreateOrConnectWithoutExternal_runInput
    connect?: testcaseWhereUniqueInput
  }

  export type contestCreateNestedOneWithoutExternal_runInput = {
    create?: XOR<contestCreateWithoutExternal_runInput, contestUncheckedCreateWithoutExternal_runInput>
    connectOrCreate?: contestCreateOrConnectWithoutExternal_runInput
    connect?: contestWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type external_judgementUpdateOneWithoutExternal_runNestedInput = {
    create?: XOR<external_judgementCreateWithoutExternal_runInput, external_judgementUncheckedCreateWithoutExternal_runInput>
    connectOrCreate?: external_judgementCreateOrConnectWithoutExternal_runInput
    upsert?: external_judgementUpsertWithoutExternal_runInput
    disconnect?: external_judgementWhereInput | boolean
    delete?: external_judgementWhereInput | boolean
    connect?: external_judgementWhereUniqueInput
    update?: XOR<XOR<external_judgementUpdateToOneWithWhereWithoutExternal_runInput, external_judgementUpdateWithoutExternal_runInput>, external_judgementUncheckedUpdateWithoutExternal_runInput>
  }

  export type testcaseUpdateOneWithoutExternal_runNestedInput = {
    create?: XOR<testcaseCreateWithoutExternal_runInput, testcaseUncheckedCreateWithoutExternal_runInput>
    connectOrCreate?: testcaseCreateOrConnectWithoutExternal_runInput
    upsert?: testcaseUpsertWithoutExternal_runInput
    disconnect?: testcaseWhereInput | boolean
    delete?: testcaseWhereInput | boolean
    connect?: testcaseWhereUniqueInput
    update?: XOR<XOR<testcaseUpdateToOneWithWhereWithoutExternal_runInput, testcaseUpdateWithoutExternal_runInput>, testcaseUncheckedUpdateWithoutExternal_runInput>
  }

  export type contestUpdateOneWithoutExternal_runNestedInput = {
    create?: XOR<contestCreateWithoutExternal_runInput, contestUncheckedCreateWithoutExternal_runInput>
    connectOrCreate?: contestCreateOrConnectWithoutExternal_runInput
    upsert?: contestUpsertWithoutExternal_runInput
    disconnect?: contestWhereInput | boolean
    delete?: contestWhereInput | boolean
    connect?: contestWhereUniqueInput
    update?: XOR<XOR<contestUpdateToOneWithWhereWithoutExternal_runInput, contestUpdateWithoutExternal_runInput>, contestUncheckedUpdateWithoutExternal_runInput>
  }

  export type external_contest_sourceCreateNestedOneWithoutExternal_source_warningInput = {
    create?: XOR<external_contest_sourceCreateWithoutExternal_source_warningInput, external_contest_sourceUncheckedCreateWithoutExternal_source_warningInput>
    connectOrCreate?: external_contest_sourceCreateOrConnectWithoutExternal_source_warningInput
    connect?: external_contest_sourceWhereUniqueInput
  }

  export type external_contest_sourceUpdateOneWithoutExternal_source_warningNestedInput = {
    create?: XOR<external_contest_sourceCreateWithoutExternal_source_warningInput, external_contest_sourceUncheckedCreateWithoutExternal_source_warningInput>
    connectOrCreate?: external_contest_sourceCreateOrConnectWithoutExternal_source_warningInput
    upsert?: external_contest_sourceUpsertWithoutExternal_source_warningInput
    disconnect?: external_contest_sourceWhereInput | boolean
    delete?: external_contest_sourceWhereInput | boolean
    connect?: external_contest_sourceWhereUniqueInput
    update?: XOR<XOR<external_contest_sourceUpdateToOneWithWhereWithoutExternal_source_warningInput, external_contest_sourceUpdateWithoutExternal_source_warningInput>, external_contest_sourceUncheckedUpdateWithoutExternal_source_warningInput>
  }

  export type executableCreateNestedOneWithoutImmutable_executableInput = {
    create?: XOR<executableCreateWithoutImmutable_executableInput, executableUncheckedCreateWithoutImmutable_executableInput>
    connectOrCreate?: executableCreateOrConnectWithoutImmutable_executableInput
    connect?: executableWhereUniqueInput
  }

  export type executable_fileCreateNestedManyWithoutImmutable_executableInput = {
    create?: XOR<executable_fileCreateWithoutImmutable_executableInput, executable_fileUncheckedCreateWithoutImmutable_executableInput> | executable_fileCreateWithoutImmutable_executableInput[] | executable_fileUncheckedCreateWithoutImmutable_executableInput[]
    connectOrCreate?: executable_fileCreateOrConnectWithoutImmutable_executableInput | executable_fileCreateOrConnectWithoutImmutable_executableInput[]
    createMany?: executable_fileCreateManyImmutable_executableInputEnvelope
    connect?: executable_fileWhereUniqueInput | executable_fileWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutImmutable_executableInput = {
    create?: XOR<userCreateWithoutImmutable_executableInput, userUncheckedCreateWithoutImmutable_executableInput>
    connectOrCreate?: userCreateOrConnectWithoutImmutable_executableInput
    connect?: userWhereUniqueInput
  }

  export type executableUncheckedCreateNestedOneWithoutImmutable_executableInput = {
    create?: XOR<executableCreateWithoutImmutable_executableInput, executableUncheckedCreateWithoutImmutable_executableInput>
    connectOrCreate?: executableCreateOrConnectWithoutImmutable_executableInput
    connect?: executableWhereUniqueInput
  }

  export type executable_fileUncheckedCreateNestedManyWithoutImmutable_executableInput = {
    create?: XOR<executable_fileCreateWithoutImmutable_executableInput, executable_fileUncheckedCreateWithoutImmutable_executableInput> | executable_fileCreateWithoutImmutable_executableInput[] | executable_fileUncheckedCreateWithoutImmutable_executableInput[]
    connectOrCreate?: executable_fileCreateOrConnectWithoutImmutable_executableInput | executable_fileCreateOrConnectWithoutImmutable_executableInput[]
    createMany?: executable_fileCreateManyImmutable_executableInputEnvelope
    connect?: executable_fileWhereUniqueInput | executable_fileWhereUniqueInput[]
  }

  export type executableUpdateOneWithoutImmutable_executableNestedInput = {
    create?: XOR<executableCreateWithoutImmutable_executableInput, executableUncheckedCreateWithoutImmutable_executableInput>
    connectOrCreate?: executableCreateOrConnectWithoutImmutable_executableInput
    upsert?: executableUpsertWithoutImmutable_executableInput
    disconnect?: executableWhereInput | boolean
    delete?: executableWhereInput | boolean
    connect?: executableWhereUniqueInput
    update?: XOR<XOR<executableUpdateToOneWithWhereWithoutImmutable_executableInput, executableUpdateWithoutImmutable_executableInput>, executableUncheckedUpdateWithoutImmutable_executableInput>
  }

  export type executable_fileUpdateManyWithoutImmutable_executableNestedInput = {
    create?: XOR<executable_fileCreateWithoutImmutable_executableInput, executable_fileUncheckedCreateWithoutImmutable_executableInput> | executable_fileCreateWithoutImmutable_executableInput[] | executable_fileUncheckedCreateWithoutImmutable_executableInput[]
    connectOrCreate?: executable_fileCreateOrConnectWithoutImmutable_executableInput | executable_fileCreateOrConnectWithoutImmutable_executableInput[]
    upsert?: executable_fileUpsertWithWhereUniqueWithoutImmutable_executableInput | executable_fileUpsertWithWhereUniqueWithoutImmutable_executableInput[]
    createMany?: executable_fileCreateManyImmutable_executableInputEnvelope
    set?: executable_fileWhereUniqueInput | executable_fileWhereUniqueInput[]
    disconnect?: executable_fileWhereUniqueInput | executable_fileWhereUniqueInput[]
    delete?: executable_fileWhereUniqueInput | executable_fileWhereUniqueInput[]
    connect?: executable_fileWhereUniqueInput | executable_fileWhereUniqueInput[]
    update?: executable_fileUpdateWithWhereUniqueWithoutImmutable_executableInput | executable_fileUpdateWithWhereUniqueWithoutImmutable_executableInput[]
    updateMany?: executable_fileUpdateManyWithWhereWithoutImmutable_executableInput | executable_fileUpdateManyWithWhereWithoutImmutable_executableInput[]
    deleteMany?: executable_fileScalarWhereInput | executable_fileScalarWhereInput[]
  }

  export type userUpdateOneWithoutImmutable_executableNestedInput = {
    create?: XOR<userCreateWithoutImmutable_executableInput, userUncheckedCreateWithoutImmutable_executableInput>
    connectOrCreate?: userCreateOrConnectWithoutImmutable_executableInput
    upsert?: userUpsertWithoutImmutable_executableInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutImmutable_executableInput, userUpdateWithoutImmutable_executableInput>, userUncheckedUpdateWithoutImmutable_executableInput>
  }

  export type executableUncheckedUpdateOneWithoutImmutable_executableNestedInput = {
    create?: XOR<executableCreateWithoutImmutable_executableInput, executableUncheckedCreateWithoutImmutable_executableInput>
    connectOrCreate?: executableCreateOrConnectWithoutImmutable_executableInput
    upsert?: executableUpsertWithoutImmutable_executableInput
    disconnect?: executableWhereInput | boolean
    delete?: executableWhereInput | boolean
    connect?: executableWhereUniqueInput
    update?: XOR<XOR<executableUpdateToOneWithWhereWithoutImmutable_executableInput, executableUpdateWithoutImmutable_executableInput>, executableUncheckedUpdateWithoutImmutable_executableInput>
  }

  export type executable_fileUncheckedUpdateManyWithoutImmutable_executableNestedInput = {
    create?: XOR<executable_fileCreateWithoutImmutable_executableInput, executable_fileUncheckedCreateWithoutImmutable_executableInput> | executable_fileCreateWithoutImmutable_executableInput[] | executable_fileUncheckedCreateWithoutImmutable_executableInput[]
    connectOrCreate?: executable_fileCreateOrConnectWithoutImmutable_executableInput | executable_fileCreateOrConnectWithoutImmutable_executableInput[]
    upsert?: executable_fileUpsertWithWhereUniqueWithoutImmutable_executableInput | executable_fileUpsertWithWhereUniqueWithoutImmutable_executableInput[]
    createMany?: executable_fileCreateManyImmutable_executableInputEnvelope
    set?: executable_fileWhereUniqueInput | executable_fileWhereUniqueInput[]
    disconnect?: executable_fileWhereUniqueInput | executable_fileWhereUniqueInput[]
    delete?: executable_fileWhereUniqueInput | executable_fileWhereUniqueInput[]
    connect?: executable_fileWhereUniqueInput | executable_fileWhereUniqueInput[]
    update?: executable_fileUpdateWithWhereUniqueWithoutImmutable_executableInput | executable_fileUpdateWithWhereUniqueWithoutImmutable_executableInput[]
    updateMany?: executable_fileUpdateManyWithWhereWithoutImmutable_executableInput | executable_fileUpdateManyWithWhereWithoutImmutable_executableInput[]
    deleteMany?: executable_fileScalarWhereInput | executable_fileScalarWhereInput[]
  }

  export type judgingCreateNestedOneWithoutInternal_error_internal_error_judgingidTojudgingInput = {
    create?: XOR<judgingCreateWithoutInternal_error_internal_error_judgingidTojudgingInput, judgingUncheckedCreateWithoutInternal_error_internal_error_judgingidTojudgingInput>
    connectOrCreate?: judgingCreateOrConnectWithoutInternal_error_internal_error_judgingidTojudgingInput
    connect?: judgingWhereUniqueInput
  }

  export type contestCreateNestedOneWithoutInternal_errorInput = {
    create?: XOR<contestCreateWithoutInternal_errorInput, contestUncheckedCreateWithoutInternal_errorInput>
    connectOrCreate?: contestCreateOrConnectWithoutInternal_errorInput
    connect?: contestWhereUniqueInput
  }

  export type judgingCreateNestedManyWithoutInternal_error_judging_erroridTointernal_errorInput = {
    create?: XOR<judgingCreateWithoutInternal_error_judging_erroridTointernal_errorInput, judgingUncheckedCreateWithoutInternal_error_judging_erroridTointernal_errorInput> | judgingCreateWithoutInternal_error_judging_erroridTointernal_errorInput[] | judgingUncheckedCreateWithoutInternal_error_judging_erroridTointernal_errorInput[]
    connectOrCreate?: judgingCreateOrConnectWithoutInternal_error_judging_erroridTointernal_errorInput | judgingCreateOrConnectWithoutInternal_error_judging_erroridTointernal_errorInput[]
    createMany?: judgingCreateManyInternal_error_judging_erroridTointernal_errorInputEnvelope
    connect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
  }

  export type judgingUncheckedCreateNestedManyWithoutInternal_error_judging_erroridTointernal_errorInput = {
    create?: XOR<judgingCreateWithoutInternal_error_judging_erroridTointernal_errorInput, judgingUncheckedCreateWithoutInternal_error_judging_erroridTointernal_errorInput> | judgingCreateWithoutInternal_error_judging_erroridTointernal_errorInput[] | judgingUncheckedCreateWithoutInternal_error_judging_erroridTointernal_errorInput[]
    connectOrCreate?: judgingCreateOrConnectWithoutInternal_error_judging_erroridTointernal_errorInput | judgingCreateOrConnectWithoutInternal_error_judging_erroridTointernal_errorInput[]
    createMany?: judgingCreateManyInternal_error_judging_erroridTointernal_errorInputEnvelope
    connect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
  }

  export type Enuminternal_error_statusFieldUpdateOperationsInput = {
    set?: $Enums.internal_error_status
  }

  export type judgingUpdateOneWithoutInternal_error_internal_error_judgingidTojudgingNestedInput = {
    create?: XOR<judgingCreateWithoutInternal_error_internal_error_judgingidTojudgingInput, judgingUncheckedCreateWithoutInternal_error_internal_error_judgingidTojudgingInput>
    connectOrCreate?: judgingCreateOrConnectWithoutInternal_error_internal_error_judgingidTojudgingInput
    upsert?: judgingUpsertWithoutInternal_error_internal_error_judgingidTojudgingInput
    disconnect?: judgingWhereInput | boolean
    delete?: judgingWhereInput | boolean
    connect?: judgingWhereUniqueInput
    update?: XOR<XOR<judgingUpdateToOneWithWhereWithoutInternal_error_internal_error_judgingidTojudgingInput, judgingUpdateWithoutInternal_error_internal_error_judgingidTojudgingInput>, judgingUncheckedUpdateWithoutInternal_error_internal_error_judgingidTojudgingInput>
  }

  export type contestUpdateOneWithoutInternal_errorNestedInput = {
    create?: XOR<contestCreateWithoutInternal_errorInput, contestUncheckedCreateWithoutInternal_errorInput>
    connectOrCreate?: contestCreateOrConnectWithoutInternal_errorInput
    upsert?: contestUpsertWithoutInternal_errorInput
    disconnect?: contestWhereInput | boolean
    delete?: contestWhereInput | boolean
    connect?: contestWhereUniqueInput
    update?: XOR<XOR<contestUpdateToOneWithWhereWithoutInternal_errorInput, contestUpdateWithoutInternal_errorInput>, contestUncheckedUpdateWithoutInternal_errorInput>
  }

  export type judgingUpdateManyWithoutInternal_error_judging_erroridTointernal_errorNestedInput = {
    create?: XOR<judgingCreateWithoutInternal_error_judging_erroridTointernal_errorInput, judgingUncheckedCreateWithoutInternal_error_judging_erroridTointernal_errorInput> | judgingCreateWithoutInternal_error_judging_erroridTointernal_errorInput[] | judgingUncheckedCreateWithoutInternal_error_judging_erroridTointernal_errorInput[]
    connectOrCreate?: judgingCreateOrConnectWithoutInternal_error_judging_erroridTointernal_errorInput | judgingCreateOrConnectWithoutInternal_error_judging_erroridTointernal_errorInput[]
    upsert?: judgingUpsertWithWhereUniqueWithoutInternal_error_judging_erroridTointernal_errorInput | judgingUpsertWithWhereUniqueWithoutInternal_error_judging_erroridTointernal_errorInput[]
    createMany?: judgingCreateManyInternal_error_judging_erroridTointernal_errorInputEnvelope
    set?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    disconnect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    delete?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    connect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    update?: judgingUpdateWithWhereUniqueWithoutInternal_error_judging_erroridTointernal_errorInput | judgingUpdateWithWhereUniqueWithoutInternal_error_judging_erroridTointernal_errorInput[]
    updateMany?: judgingUpdateManyWithWhereWithoutInternal_error_judging_erroridTointernal_errorInput | judgingUpdateManyWithWhereWithoutInternal_error_judging_erroridTointernal_errorInput[]
    deleteMany?: judgingScalarWhereInput | judgingScalarWhereInput[]
  }

  export type judgingUncheckedUpdateManyWithoutInternal_error_judging_erroridTointernal_errorNestedInput = {
    create?: XOR<judgingCreateWithoutInternal_error_judging_erroridTointernal_errorInput, judgingUncheckedCreateWithoutInternal_error_judging_erroridTointernal_errorInput> | judgingCreateWithoutInternal_error_judging_erroridTointernal_errorInput[] | judgingUncheckedCreateWithoutInternal_error_judging_erroridTointernal_errorInput[]
    connectOrCreate?: judgingCreateOrConnectWithoutInternal_error_judging_erroridTointernal_errorInput | judgingCreateOrConnectWithoutInternal_error_judging_erroridTointernal_errorInput[]
    upsert?: judgingUpsertWithWhereUniqueWithoutInternal_error_judging_erroridTointernal_errorInput | judgingUpsertWithWhereUniqueWithoutInternal_error_judging_erroridTointernal_errorInput[]
    createMany?: judgingCreateManyInternal_error_judging_erroridTointernal_errorInputEnvelope
    set?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    disconnect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    delete?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    connect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    update?: judgingUpdateWithWhereUniqueWithoutInternal_error_judging_erroridTointernal_errorInput | judgingUpdateWithWhereUniqueWithoutInternal_error_judging_erroridTointernal_errorInput[]
    updateMany?: judgingUpdateManyWithWhereWithoutInternal_error_judging_erroridTointernal_errorInput | judgingUpdateManyWithWhereWithoutInternal_error_judging_erroridTointernal_errorInput[]
    deleteMany?: judgingScalarWhereInput | judgingScalarWhereInput[]
  }

  export type debug_packageCreateNestedManyWithoutJudgehostInput = {
    create?: XOR<debug_packageCreateWithoutJudgehostInput, debug_packageUncheckedCreateWithoutJudgehostInput> | debug_packageCreateWithoutJudgehostInput[] | debug_packageUncheckedCreateWithoutJudgehostInput[]
    connectOrCreate?: debug_packageCreateOrConnectWithoutJudgehostInput | debug_packageCreateOrConnectWithoutJudgehostInput[]
    createMany?: debug_packageCreateManyJudgehostInputEnvelope
    connect?: debug_packageWhereUniqueInput | debug_packageWhereUniqueInput[]
  }

  export type judgetaskCreateNestedManyWithoutJudgehostInput = {
    create?: XOR<judgetaskCreateWithoutJudgehostInput, judgetaskUncheckedCreateWithoutJudgehostInput> | judgetaskCreateWithoutJudgehostInput[] | judgetaskUncheckedCreateWithoutJudgehostInput[]
    connectOrCreate?: judgetaskCreateOrConnectWithoutJudgehostInput | judgetaskCreateOrConnectWithoutJudgehostInput[]
    createMany?: judgetaskCreateManyJudgehostInputEnvelope
    connect?: judgetaskWhereUniqueInput | judgetaskWhereUniqueInput[]
  }

  export type debug_packageUncheckedCreateNestedManyWithoutJudgehostInput = {
    create?: XOR<debug_packageCreateWithoutJudgehostInput, debug_packageUncheckedCreateWithoutJudgehostInput> | debug_packageCreateWithoutJudgehostInput[] | debug_packageUncheckedCreateWithoutJudgehostInput[]
    connectOrCreate?: debug_packageCreateOrConnectWithoutJudgehostInput | debug_packageCreateOrConnectWithoutJudgehostInput[]
    createMany?: debug_packageCreateManyJudgehostInputEnvelope
    connect?: debug_packageWhereUniqueInput | debug_packageWhereUniqueInput[]
  }

  export type judgetaskUncheckedCreateNestedManyWithoutJudgehostInput = {
    create?: XOR<judgetaskCreateWithoutJudgehostInput, judgetaskUncheckedCreateWithoutJudgehostInput> | judgetaskCreateWithoutJudgehostInput[] | judgetaskUncheckedCreateWithoutJudgehostInput[]
    connectOrCreate?: judgetaskCreateOrConnectWithoutJudgehostInput | judgetaskCreateOrConnectWithoutJudgehostInput[]
    createMany?: judgetaskCreateManyJudgehostInputEnvelope
    connect?: judgetaskWhereUniqueInput | judgetaskWhereUniqueInput[]
  }

  export type debug_packageUpdateManyWithoutJudgehostNestedInput = {
    create?: XOR<debug_packageCreateWithoutJudgehostInput, debug_packageUncheckedCreateWithoutJudgehostInput> | debug_packageCreateWithoutJudgehostInput[] | debug_packageUncheckedCreateWithoutJudgehostInput[]
    connectOrCreate?: debug_packageCreateOrConnectWithoutJudgehostInput | debug_packageCreateOrConnectWithoutJudgehostInput[]
    upsert?: debug_packageUpsertWithWhereUniqueWithoutJudgehostInput | debug_packageUpsertWithWhereUniqueWithoutJudgehostInput[]
    createMany?: debug_packageCreateManyJudgehostInputEnvelope
    set?: debug_packageWhereUniqueInput | debug_packageWhereUniqueInput[]
    disconnect?: debug_packageWhereUniqueInput | debug_packageWhereUniqueInput[]
    delete?: debug_packageWhereUniqueInput | debug_packageWhereUniqueInput[]
    connect?: debug_packageWhereUniqueInput | debug_packageWhereUniqueInput[]
    update?: debug_packageUpdateWithWhereUniqueWithoutJudgehostInput | debug_packageUpdateWithWhereUniqueWithoutJudgehostInput[]
    updateMany?: debug_packageUpdateManyWithWhereWithoutJudgehostInput | debug_packageUpdateManyWithWhereWithoutJudgehostInput[]
    deleteMany?: debug_packageScalarWhereInput | debug_packageScalarWhereInput[]
  }

  export type judgetaskUpdateManyWithoutJudgehostNestedInput = {
    create?: XOR<judgetaskCreateWithoutJudgehostInput, judgetaskUncheckedCreateWithoutJudgehostInput> | judgetaskCreateWithoutJudgehostInput[] | judgetaskUncheckedCreateWithoutJudgehostInput[]
    connectOrCreate?: judgetaskCreateOrConnectWithoutJudgehostInput | judgetaskCreateOrConnectWithoutJudgehostInput[]
    upsert?: judgetaskUpsertWithWhereUniqueWithoutJudgehostInput | judgetaskUpsertWithWhereUniqueWithoutJudgehostInput[]
    createMany?: judgetaskCreateManyJudgehostInputEnvelope
    set?: judgetaskWhereUniqueInput | judgetaskWhereUniqueInput[]
    disconnect?: judgetaskWhereUniqueInput | judgetaskWhereUniqueInput[]
    delete?: judgetaskWhereUniqueInput | judgetaskWhereUniqueInput[]
    connect?: judgetaskWhereUniqueInput | judgetaskWhereUniqueInput[]
    update?: judgetaskUpdateWithWhereUniqueWithoutJudgehostInput | judgetaskUpdateWithWhereUniqueWithoutJudgehostInput[]
    updateMany?: judgetaskUpdateManyWithWhereWithoutJudgehostInput | judgetaskUpdateManyWithWhereWithoutJudgehostInput[]
    deleteMany?: judgetaskScalarWhereInput | judgetaskScalarWhereInput[]
  }

  export type debug_packageUncheckedUpdateManyWithoutJudgehostNestedInput = {
    create?: XOR<debug_packageCreateWithoutJudgehostInput, debug_packageUncheckedCreateWithoutJudgehostInput> | debug_packageCreateWithoutJudgehostInput[] | debug_packageUncheckedCreateWithoutJudgehostInput[]
    connectOrCreate?: debug_packageCreateOrConnectWithoutJudgehostInput | debug_packageCreateOrConnectWithoutJudgehostInput[]
    upsert?: debug_packageUpsertWithWhereUniqueWithoutJudgehostInput | debug_packageUpsertWithWhereUniqueWithoutJudgehostInput[]
    createMany?: debug_packageCreateManyJudgehostInputEnvelope
    set?: debug_packageWhereUniqueInput | debug_packageWhereUniqueInput[]
    disconnect?: debug_packageWhereUniqueInput | debug_packageWhereUniqueInput[]
    delete?: debug_packageWhereUniqueInput | debug_packageWhereUniqueInput[]
    connect?: debug_packageWhereUniqueInput | debug_packageWhereUniqueInput[]
    update?: debug_packageUpdateWithWhereUniqueWithoutJudgehostInput | debug_packageUpdateWithWhereUniqueWithoutJudgehostInput[]
    updateMany?: debug_packageUpdateManyWithWhereWithoutJudgehostInput | debug_packageUpdateManyWithWhereWithoutJudgehostInput[]
    deleteMany?: debug_packageScalarWhereInput | debug_packageScalarWhereInput[]
  }

  export type judgetaskUncheckedUpdateManyWithoutJudgehostNestedInput = {
    create?: XOR<judgetaskCreateWithoutJudgehostInput, judgetaskUncheckedCreateWithoutJudgehostInput> | judgetaskCreateWithoutJudgehostInput[] | judgetaskUncheckedCreateWithoutJudgehostInput[]
    connectOrCreate?: judgetaskCreateOrConnectWithoutJudgehostInput | judgetaskCreateOrConnectWithoutJudgehostInput[]
    upsert?: judgetaskUpsertWithWhereUniqueWithoutJudgehostInput | judgetaskUpsertWithWhereUniqueWithoutJudgehostInput[]
    createMany?: judgetaskCreateManyJudgehostInputEnvelope
    set?: judgetaskWhereUniqueInput | judgetaskWhereUniqueInput[]
    disconnect?: judgetaskWhereUniqueInput | judgetaskWhereUniqueInput[]
    delete?: judgetaskWhereUniqueInput | judgetaskWhereUniqueInput[]
    connect?: judgetaskWhereUniqueInput | judgetaskWhereUniqueInput[]
    update?: judgetaskUpdateWithWhereUniqueWithoutJudgehostInput | judgetaskUpdateWithWhereUniqueWithoutJudgehostInput[]
    updateMany?: judgetaskUpdateManyWithWhereWithoutJudgehostInput | judgetaskUpdateManyWithWhereWithoutJudgehostInput[]
    deleteMany?: judgetaskScalarWhereInput | judgetaskScalarWhereInput[]
  }

  export type judgehostCreateNestedOneWithoutJudgetaskInput = {
    create?: XOR<judgehostCreateWithoutJudgetaskInput, judgehostUncheckedCreateWithoutJudgetaskInput>
    connectOrCreate?: judgehostCreateOrConnectWithoutJudgetaskInput
    connect?: judgehostWhereUniqueInput
  }

  export type judging_runCreateNestedManyWithoutJudgetaskInput = {
    create?: XOR<judging_runCreateWithoutJudgetaskInput, judging_runUncheckedCreateWithoutJudgetaskInput> | judging_runCreateWithoutJudgetaskInput[] | judging_runUncheckedCreateWithoutJudgetaskInput[]
    connectOrCreate?: judging_runCreateOrConnectWithoutJudgetaskInput | judging_runCreateOrConnectWithoutJudgetaskInput[]
    createMany?: judging_runCreateManyJudgetaskInputEnvelope
    connect?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
  }

  export type judging_runUncheckedCreateNestedManyWithoutJudgetaskInput = {
    create?: XOR<judging_runCreateWithoutJudgetaskInput, judging_runUncheckedCreateWithoutJudgetaskInput> | judging_runCreateWithoutJudgetaskInput[] | judging_runUncheckedCreateWithoutJudgetaskInput[]
    connectOrCreate?: judging_runCreateOrConnectWithoutJudgetaskInput | judging_runCreateOrConnectWithoutJudgetaskInput[]
    createMany?: judging_runCreateManyJudgetaskInputEnvelope
    connect?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
  }

  export type Enumjudgetask_typeFieldUpdateOperationsInput = {
    set?: $Enums.judgetask_type
  }

  export type judgehostUpdateOneWithoutJudgetaskNestedInput = {
    create?: XOR<judgehostCreateWithoutJudgetaskInput, judgehostUncheckedCreateWithoutJudgetaskInput>
    connectOrCreate?: judgehostCreateOrConnectWithoutJudgetaskInput
    upsert?: judgehostUpsertWithoutJudgetaskInput
    disconnect?: judgehostWhereInput | boolean
    delete?: judgehostWhereInput | boolean
    connect?: judgehostWhereUniqueInput
    update?: XOR<XOR<judgehostUpdateToOneWithWhereWithoutJudgetaskInput, judgehostUpdateWithoutJudgetaskInput>, judgehostUncheckedUpdateWithoutJudgetaskInput>
  }

  export type judging_runUpdateManyWithoutJudgetaskNestedInput = {
    create?: XOR<judging_runCreateWithoutJudgetaskInput, judging_runUncheckedCreateWithoutJudgetaskInput> | judging_runCreateWithoutJudgetaskInput[] | judging_runUncheckedCreateWithoutJudgetaskInput[]
    connectOrCreate?: judging_runCreateOrConnectWithoutJudgetaskInput | judging_runCreateOrConnectWithoutJudgetaskInput[]
    upsert?: judging_runUpsertWithWhereUniqueWithoutJudgetaskInput | judging_runUpsertWithWhereUniqueWithoutJudgetaskInput[]
    createMany?: judging_runCreateManyJudgetaskInputEnvelope
    set?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    disconnect?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    delete?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    connect?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    update?: judging_runUpdateWithWhereUniqueWithoutJudgetaskInput | judging_runUpdateWithWhereUniqueWithoutJudgetaskInput[]
    updateMany?: judging_runUpdateManyWithWhereWithoutJudgetaskInput | judging_runUpdateManyWithWhereWithoutJudgetaskInput[]
    deleteMany?: judging_runScalarWhereInput | judging_runScalarWhereInput[]
  }

  export type judging_runUncheckedUpdateManyWithoutJudgetaskNestedInput = {
    create?: XOR<judging_runCreateWithoutJudgetaskInput, judging_runUncheckedCreateWithoutJudgetaskInput> | judging_runCreateWithoutJudgetaskInput[] | judging_runUncheckedCreateWithoutJudgetaskInput[]
    connectOrCreate?: judging_runCreateOrConnectWithoutJudgetaskInput | judging_runCreateOrConnectWithoutJudgetaskInput[]
    upsert?: judging_runUpsertWithWhereUniqueWithoutJudgetaskInput | judging_runUpsertWithWhereUniqueWithoutJudgetaskInput[]
    createMany?: judging_runCreateManyJudgetaskInputEnvelope
    set?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    disconnect?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    delete?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    connect?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    update?: judging_runUpdateWithWhereUniqueWithoutJudgetaskInput | judging_runUpdateWithWhereUniqueWithoutJudgetaskInput[]
    updateMany?: judging_runUpdateManyWithWhereWithoutJudgetaskInput | judging_runUpdateManyWithWhereWithoutJudgetaskInput[]
    deleteMany?: judging_runScalarWhereInput | judging_runScalarWhereInput[]
  }

  export type debug_packageCreateNestedManyWithoutJudgingInput = {
    create?: XOR<debug_packageCreateWithoutJudgingInput, debug_packageUncheckedCreateWithoutJudgingInput> | debug_packageCreateWithoutJudgingInput[] | debug_packageUncheckedCreateWithoutJudgingInput[]
    connectOrCreate?: debug_packageCreateOrConnectWithoutJudgingInput | debug_packageCreateOrConnectWithoutJudgingInput[]
    createMany?: debug_packageCreateManyJudgingInputEnvelope
    connect?: debug_packageWhereUniqueInput | debug_packageWhereUniqueInput[]
  }

  export type internal_errorCreateNestedManyWithoutJudging_internal_error_judgingidTojudgingInput = {
    create?: XOR<internal_errorCreateWithoutJudging_internal_error_judgingidTojudgingInput, internal_errorUncheckedCreateWithoutJudging_internal_error_judgingidTojudgingInput> | internal_errorCreateWithoutJudging_internal_error_judgingidTojudgingInput[] | internal_errorUncheckedCreateWithoutJudging_internal_error_judgingidTojudgingInput[]
    connectOrCreate?: internal_errorCreateOrConnectWithoutJudging_internal_error_judgingidTojudgingInput | internal_errorCreateOrConnectWithoutJudging_internal_error_judgingidTojudgingInput[]
    createMany?: internal_errorCreateManyJudging_internal_error_judgingidTojudgingInputEnvelope
    connect?: internal_errorWhereUniqueInput | internal_errorWhereUniqueInput[]
  }

  export type internal_errorCreateNestedOneWithoutJudging_judging_erroridTointernal_errorInput = {
    create?: XOR<internal_errorCreateWithoutJudging_judging_erroridTointernal_errorInput, internal_errorUncheckedCreateWithoutJudging_judging_erroridTointernal_errorInput>
    connectOrCreate?: internal_errorCreateOrConnectWithoutJudging_judging_erroridTointernal_errorInput
    connect?: internal_errorWhereUniqueInput
  }

  export type contestCreateNestedOneWithoutJudgingInput = {
    create?: XOR<contestCreateWithoutJudgingInput, contestUncheckedCreateWithoutJudgingInput>
    connectOrCreate?: contestCreateOrConnectWithoutJudgingInput
    connect?: contestWhereUniqueInput
  }

  export type submissionCreateNestedOneWithoutJudgingInput = {
    create?: XOR<submissionCreateWithoutJudgingInput, submissionUncheckedCreateWithoutJudgingInput>
    connectOrCreate?: submissionCreateOrConnectWithoutJudgingInput
    connect?: submissionWhereUniqueInput
  }

  export type rejudgingCreateNestedOneWithoutJudgingInput = {
    create?: XOR<rejudgingCreateWithoutJudgingInput, rejudgingUncheckedCreateWithoutJudgingInput>
    connectOrCreate?: rejudgingCreateOrConnectWithoutJudgingInput
    connect?: rejudgingWhereUniqueInput
  }

  export type judgingCreateNestedOneWithoutOther_judgingInput = {
    create?: XOR<judgingCreateWithoutOther_judgingInput, judgingUncheckedCreateWithoutOther_judgingInput>
    connectOrCreate?: judgingCreateOrConnectWithoutOther_judgingInput
    connect?: judgingWhereUniqueInput
  }

  export type judgingCreateNestedManyWithoutJudgingInput = {
    create?: XOR<judgingCreateWithoutJudgingInput, judgingUncheckedCreateWithoutJudgingInput> | judgingCreateWithoutJudgingInput[] | judgingUncheckedCreateWithoutJudgingInput[]
    connectOrCreate?: judgingCreateOrConnectWithoutJudgingInput | judgingCreateOrConnectWithoutJudgingInput[]
    createMany?: judgingCreateManyJudgingInputEnvelope
    connect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
  }

  export type judging_runCreateNestedManyWithoutJudgingInput = {
    create?: XOR<judging_runCreateWithoutJudgingInput, judging_runUncheckedCreateWithoutJudgingInput> | judging_runCreateWithoutJudgingInput[] | judging_runUncheckedCreateWithoutJudgingInput[]
    connectOrCreate?: judging_runCreateOrConnectWithoutJudgingInput | judging_runCreateOrConnectWithoutJudgingInput[]
    createMany?: judging_runCreateManyJudgingInputEnvelope
    connect?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
  }

  export type debug_packageUncheckedCreateNestedManyWithoutJudgingInput = {
    create?: XOR<debug_packageCreateWithoutJudgingInput, debug_packageUncheckedCreateWithoutJudgingInput> | debug_packageCreateWithoutJudgingInput[] | debug_packageUncheckedCreateWithoutJudgingInput[]
    connectOrCreate?: debug_packageCreateOrConnectWithoutJudgingInput | debug_packageCreateOrConnectWithoutJudgingInput[]
    createMany?: debug_packageCreateManyJudgingInputEnvelope
    connect?: debug_packageWhereUniqueInput | debug_packageWhereUniqueInput[]
  }

  export type internal_errorUncheckedCreateNestedManyWithoutJudging_internal_error_judgingidTojudgingInput = {
    create?: XOR<internal_errorCreateWithoutJudging_internal_error_judgingidTojudgingInput, internal_errorUncheckedCreateWithoutJudging_internal_error_judgingidTojudgingInput> | internal_errorCreateWithoutJudging_internal_error_judgingidTojudgingInput[] | internal_errorUncheckedCreateWithoutJudging_internal_error_judgingidTojudgingInput[]
    connectOrCreate?: internal_errorCreateOrConnectWithoutJudging_internal_error_judgingidTojudgingInput | internal_errorCreateOrConnectWithoutJudging_internal_error_judgingidTojudgingInput[]
    createMany?: internal_errorCreateManyJudging_internal_error_judgingidTojudgingInputEnvelope
    connect?: internal_errorWhereUniqueInput | internal_errorWhereUniqueInput[]
  }

  export type judgingUncheckedCreateNestedManyWithoutJudgingInput = {
    create?: XOR<judgingCreateWithoutJudgingInput, judgingUncheckedCreateWithoutJudgingInput> | judgingCreateWithoutJudgingInput[] | judgingUncheckedCreateWithoutJudgingInput[]
    connectOrCreate?: judgingCreateOrConnectWithoutJudgingInput | judgingCreateOrConnectWithoutJudgingInput[]
    createMany?: judgingCreateManyJudgingInputEnvelope
    connect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
  }

  export type judging_runUncheckedCreateNestedManyWithoutJudgingInput = {
    create?: XOR<judging_runCreateWithoutJudgingInput, judging_runUncheckedCreateWithoutJudgingInput> | judging_runCreateWithoutJudgingInput[] | judging_runUncheckedCreateWithoutJudgingInput[]
    connectOrCreate?: judging_runCreateOrConnectWithoutJudgingInput | judging_runCreateOrConnectWithoutJudgingInput[]
    createMany?: judging_runCreateManyJudgingInputEnvelope
    connect?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type debug_packageUpdateManyWithoutJudgingNestedInput = {
    create?: XOR<debug_packageCreateWithoutJudgingInput, debug_packageUncheckedCreateWithoutJudgingInput> | debug_packageCreateWithoutJudgingInput[] | debug_packageUncheckedCreateWithoutJudgingInput[]
    connectOrCreate?: debug_packageCreateOrConnectWithoutJudgingInput | debug_packageCreateOrConnectWithoutJudgingInput[]
    upsert?: debug_packageUpsertWithWhereUniqueWithoutJudgingInput | debug_packageUpsertWithWhereUniqueWithoutJudgingInput[]
    createMany?: debug_packageCreateManyJudgingInputEnvelope
    set?: debug_packageWhereUniqueInput | debug_packageWhereUniqueInput[]
    disconnect?: debug_packageWhereUniqueInput | debug_packageWhereUniqueInput[]
    delete?: debug_packageWhereUniqueInput | debug_packageWhereUniqueInput[]
    connect?: debug_packageWhereUniqueInput | debug_packageWhereUniqueInput[]
    update?: debug_packageUpdateWithWhereUniqueWithoutJudgingInput | debug_packageUpdateWithWhereUniqueWithoutJudgingInput[]
    updateMany?: debug_packageUpdateManyWithWhereWithoutJudgingInput | debug_packageUpdateManyWithWhereWithoutJudgingInput[]
    deleteMany?: debug_packageScalarWhereInput | debug_packageScalarWhereInput[]
  }

  export type internal_errorUpdateManyWithoutJudging_internal_error_judgingidTojudgingNestedInput = {
    create?: XOR<internal_errorCreateWithoutJudging_internal_error_judgingidTojudgingInput, internal_errorUncheckedCreateWithoutJudging_internal_error_judgingidTojudgingInput> | internal_errorCreateWithoutJudging_internal_error_judgingidTojudgingInput[] | internal_errorUncheckedCreateWithoutJudging_internal_error_judgingidTojudgingInput[]
    connectOrCreate?: internal_errorCreateOrConnectWithoutJudging_internal_error_judgingidTojudgingInput | internal_errorCreateOrConnectWithoutJudging_internal_error_judgingidTojudgingInput[]
    upsert?: internal_errorUpsertWithWhereUniqueWithoutJudging_internal_error_judgingidTojudgingInput | internal_errorUpsertWithWhereUniqueWithoutJudging_internal_error_judgingidTojudgingInput[]
    createMany?: internal_errorCreateManyJudging_internal_error_judgingidTojudgingInputEnvelope
    set?: internal_errorWhereUniqueInput | internal_errorWhereUniqueInput[]
    disconnect?: internal_errorWhereUniqueInput | internal_errorWhereUniqueInput[]
    delete?: internal_errorWhereUniqueInput | internal_errorWhereUniqueInput[]
    connect?: internal_errorWhereUniqueInput | internal_errorWhereUniqueInput[]
    update?: internal_errorUpdateWithWhereUniqueWithoutJudging_internal_error_judgingidTojudgingInput | internal_errorUpdateWithWhereUniqueWithoutJudging_internal_error_judgingidTojudgingInput[]
    updateMany?: internal_errorUpdateManyWithWhereWithoutJudging_internal_error_judgingidTojudgingInput | internal_errorUpdateManyWithWhereWithoutJudging_internal_error_judgingidTojudgingInput[]
    deleteMany?: internal_errorScalarWhereInput | internal_errorScalarWhereInput[]
  }

  export type internal_errorUpdateOneWithoutJudging_judging_erroridTointernal_errorNestedInput = {
    create?: XOR<internal_errorCreateWithoutJudging_judging_erroridTointernal_errorInput, internal_errorUncheckedCreateWithoutJudging_judging_erroridTointernal_errorInput>
    connectOrCreate?: internal_errorCreateOrConnectWithoutJudging_judging_erroridTointernal_errorInput
    upsert?: internal_errorUpsertWithoutJudging_judging_erroridTointernal_errorInput
    disconnect?: internal_errorWhereInput | boolean
    delete?: internal_errorWhereInput | boolean
    connect?: internal_errorWhereUniqueInput
    update?: XOR<XOR<internal_errorUpdateToOneWithWhereWithoutJudging_judging_erroridTointernal_errorInput, internal_errorUpdateWithoutJudging_judging_erroridTointernal_errorInput>, internal_errorUncheckedUpdateWithoutJudging_judging_erroridTointernal_errorInput>
  }

  export type contestUpdateOneWithoutJudgingNestedInput = {
    create?: XOR<contestCreateWithoutJudgingInput, contestUncheckedCreateWithoutJudgingInput>
    connectOrCreate?: contestCreateOrConnectWithoutJudgingInput
    upsert?: contestUpsertWithoutJudgingInput
    disconnect?: contestWhereInput | boolean
    delete?: contestWhereInput | boolean
    connect?: contestWhereUniqueInput
    update?: XOR<XOR<contestUpdateToOneWithWhereWithoutJudgingInput, contestUpdateWithoutJudgingInput>, contestUncheckedUpdateWithoutJudgingInput>
  }

  export type submissionUpdateOneWithoutJudgingNestedInput = {
    create?: XOR<submissionCreateWithoutJudgingInput, submissionUncheckedCreateWithoutJudgingInput>
    connectOrCreate?: submissionCreateOrConnectWithoutJudgingInput
    upsert?: submissionUpsertWithoutJudgingInput
    disconnect?: submissionWhereInput | boolean
    delete?: submissionWhereInput | boolean
    connect?: submissionWhereUniqueInput
    update?: XOR<XOR<submissionUpdateToOneWithWhereWithoutJudgingInput, submissionUpdateWithoutJudgingInput>, submissionUncheckedUpdateWithoutJudgingInput>
  }

  export type rejudgingUpdateOneWithoutJudgingNestedInput = {
    create?: XOR<rejudgingCreateWithoutJudgingInput, rejudgingUncheckedCreateWithoutJudgingInput>
    connectOrCreate?: rejudgingCreateOrConnectWithoutJudgingInput
    upsert?: rejudgingUpsertWithoutJudgingInput
    disconnect?: rejudgingWhereInput | boolean
    delete?: rejudgingWhereInput | boolean
    connect?: rejudgingWhereUniqueInput
    update?: XOR<XOR<rejudgingUpdateToOneWithWhereWithoutJudgingInput, rejudgingUpdateWithoutJudgingInput>, rejudgingUncheckedUpdateWithoutJudgingInput>
  }

  export type judgingUpdateOneWithoutOther_judgingNestedInput = {
    create?: XOR<judgingCreateWithoutOther_judgingInput, judgingUncheckedCreateWithoutOther_judgingInput>
    connectOrCreate?: judgingCreateOrConnectWithoutOther_judgingInput
    upsert?: judgingUpsertWithoutOther_judgingInput
    disconnect?: judgingWhereInput | boolean
    delete?: judgingWhereInput | boolean
    connect?: judgingWhereUniqueInput
    update?: XOR<XOR<judgingUpdateToOneWithWhereWithoutOther_judgingInput, judgingUpdateWithoutOther_judgingInput>, judgingUncheckedUpdateWithoutOther_judgingInput>
  }

  export type judgingUpdateManyWithoutJudgingNestedInput = {
    create?: XOR<judgingCreateWithoutJudgingInput, judgingUncheckedCreateWithoutJudgingInput> | judgingCreateWithoutJudgingInput[] | judgingUncheckedCreateWithoutJudgingInput[]
    connectOrCreate?: judgingCreateOrConnectWithoutJudgingInput | judgingCreateOrConnectWithoutJudgingInput[]
    upsert?: judgingUpsertWithWhereUniqueWithoutJudgingInput | judgingUpsertWithWhereUniqueWithoutJudgingInput[]
    createMany?: judgingCreateManyJudgingInputEnvelope
    set?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    disconnect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    delete?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    connect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    update?: judgingUpdateWithWhereUniqueWithoutJudgingInput | judgingUpdateWithWhereUniqueWithoutJudgingInput[]
    updateMany?: judgingUpdateManyWithWhereWithoutJudgingInput | judgingUpdateManyWithWhereWithoutJudgingInput[]
    deleteMany?: judgingScalarWhereInput | judgingScalarWhereInput[]
  }

  export type judging_runUpdateManyWithoutJudgingNestedInput = {
    create?: XOR<judging_runCreateWithoutJudgingInput, judging_runUncheckedCreateWithoutJudgingInput> | judging_runCreateWithoutJudgingInput[] | judging_runUncheckedCreateWithoutJudgingInput[]
    connectOrCreate?: judging_runCreateOrConnectWithoutJudgingInput | judging_runCreateOrConnectWithoutJudgingInput[]
    upsert?: judging_runUpsertWithWhereUniqueWithoutJudgingInput | judging_runUpsertWithWhereUniqueWithoutJudgingInput[]
    createMany?: judging_runCreateManyJudgingInputEnvelope
    set?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    disconnect?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    delete?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    connect?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    update?: judging_runUpdateWithWhereUniqueWithoutJudgingInput | judging_runUpdateWithWhereUniqueWithoutJudgingInput[]
    updateMany?: judging_runUpdateManyWithWhereWithoutJudgingInput | judging_runUpdateManyWithWhereWithoutJudgingInput[]
    deleteMany?: judging_runScalarWhereInput | judging_runScalarWhereInput[]
  }

  export type debug_packageUncheckedUpdateManyWithoutJudgingNestedInput = {
    create?: XOR<debug_packageCreateWithoutJudgingInput, debug_packageUncheckedCreateWithoutJudgingInput> | debug_packageCreateWithoutJudgingInput[] | debug_packageUncheckedCreateWithoutJudgingInput[]
    connectOrCreate?: debug_packageCreateOrConnectWithoutJudgingInput | debug_packageCreateOrConnectWithoutJudgingInput[]
    upsert?: debug_packageUpsertWithWhereUniqueWithoutJudgingInput | debug_packageUpsertWithWhereUniqueWithoutJudgingInput[]
    createMany?: debug_packageCreateManyJudgingInputEnvelope
    set?: debug_packageWhereUniqueInput | debug_packageWhereUniqueInput[]
    disconnect?: debug_packageWhereUniqueInput | debug_packageWhereUniqueInput[]
    delete?: debug_packageWhereUniqueInput | debug_packageWhereUniqueInput[]
    connect?: debug_packageWhereUniqueInput | debug_packageWhereUniqueInput[]
    update?: debug_packageUpdateWithWhereUniqueWithoutJudgingInput | debug_packageUpdateWithWhereUniqueWithoutJudgingInput[]
    updateMany?: debug_packageUpdateManyWithWhereWithoutJudgingInput | debug_packageUpdateManyWithWhereWithoutJudgingInput[]
    deleteMany?: debug_packageScalarWhereInput | debug_packageScalarWhereInput[]
  }

  export type internal_errorUncheckedUpdateManyWithoutJudging_internal_error_judgingidTojudgingNestedInput = {
    create?: XOR<internal_errorCreateWithoutJudging_internal_error_judgingidTojudgingInput, internal_errorUncheckedCreateWithoutJudging_internal_error_judgingidTojudgingInput> | internal_errorCreateWithoutJudging_internal_error_judgingidTojudgingInput[] | internal_errorUncheckedCreateWithoutJudging_internal_error_judgingidTojudgingInput[]
    connectOrCreate?: internal_errorCreateOrConnectWithoutJudging_internal_error_judgingidTojudgingInput | internal_errorCreateOrConnectWithoutJudging_internal_error_judgingidTojudgingInput[]
    upsert?: internal_errorUpsertWithWhereUniqueWithoutJudging_internal_error_judgingidTojudgingInput | internal_errorUpsertWithWhereUniqueWithoutJudging_internal_error_judgingidTojudgingInput[]
    createMany?: internal_errorCreateManyJudging_internal_error_judgingidTojudgingInputEnvelope
    set?: internal_errorWhereUniqueInput | internal_errorWhereUniqueInput[]
    disconnect?: internal_errorWhereUniqueInput | internal_errorWhereUniqueInput[]
    delete?: internal_errorWhereUniqueInput | internal_errorWhereUniqueInput[]
    connect?: internal_errorWhereUniqueInput | internal_errorWhereUniqueInput[]
    update?: internal_errorUpdateWithWhereUniqueWithoutJudging_internal_error_judgingidTojudgingInput | internal_errorUpdateWithWhereUniqueWithoutJudging_internal_error_judgingidTojudgingInput[]
    updateMany?: internal_errorUpdateManyWithWhereWithoutJudging_internal_error_judgingidTojudgingInput | internal_errorUpdateManyWithWhereWithoutJudging_internal_error_judgingidTojudgingInput[]
    deleteMany?: internal_errorScalarWhereInput | internal_errorScalarWhereInput[]
  }

  export type judgingUncheckedUpdateManyWithoutJudgingNestedInput = {
    create?: XOR<judgingCreateWithoutJudgingInput, judgingUncheckedCreateWithoutJudgingInput> | judgingCreateWithoutJudgingInput[] | judgingUncheckedCreateWithoutJudgingInput[]
    connectOrCreate?: judgingCreateOrConnectWithoutJudgingInput | judgingCreateOrConnectWithoutJudgingInput[]
    upsert?: judgingUpsertWithWhereUniqueWithoutJudgingInput | judgingUpsertWithWhereUniqueWithoutJudgingInput[]
    createMany?: judgingCreateManyJudgingInputEnvelope
    set?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    disconnect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    delete?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    connect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    update?: judgingUpdateWithWhereUniqueWithoutJudgingInput | judgingUpdateWithWhereUniqueWithoutJudgingInput[]
    updateMany?: judgingUpdateManyWithWhereWithoutJudgingInput | judgingUpdateManyWithWhereWithoutJudgingInput[]
    deleteMany?: judgingScalarWhereInput | judgingScalarWhereInput[]
  }

  export type judging_runUncheckedUpdateManyWithoutJudgingNestedInput = {
    create?: XOR<judging_runCreateWithoutJudgingInput, judging_runUncheckedCreateWithoutJudgingInput> | judging_runCreateWithoutJudgingInput[] | judging_runUncheckedCreateWithoutJudgingInput[]
    connectOrCreate?: judging_runCreateOrConnectWithoutJudgingInput | judging_runCreateOrConnectWithoutJudgingInput[]
    upsert?: judging_runUpsertWithWhereUniqueWithoutJudgingInput | judging_runUpsertWithWhereUniqueWithoutJudgingInput[]
    createMany?: judging_runCreateManyJudgingInputEnvelope
    set?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    disconnect?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    delete?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    connect?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    update?: judging_runUpdateWithWhereUniqueWithoutJudgingInput | judging_runUpdateWithWhereUniqueWithoutJudgingInput[]
    updateMany?: judging_runUpdateManyWithWhereWithoutJudgingInput | judging_runUpdateManyWithWhereWithoutJudgingInput[]
    deleteMany?: judging_runScalarWhereInput | judging_runScalarWhereInput[]
  }

  export type judgetaskCreateNestedOneWithoutJudging_runInput = {
    create?: XOR<judgetaskCreateWithoutJudging_runInput, judgetaskUncheckedCreateWithoutJudging_runInput>
    connectOrCreate?: judgetaskCreateOrConnectWithoutJudging_runInput
    connect?: judgetaskWhereUniqueInput
  }

  export type testcaseCreateNestedOneWithoutJudging_runInput = {
    create?: XOR<testcaseCreateWithoutJudging_runInput, testcaseUncheckedCreateWithoutJudging_runInput>
    connectOrCreate?: testcaseCreateOrConnectWithoutJudging_runInput
    connect?: testcaseWhereUniqueInput
  }

  export type judgingCreateNestedOneWithoutJudging_runInput = {
    create?: XOR<judgingCreateWithoutJudging_runInput, judgingUncheckedCreateWithoutJudging_runInput>
    connectOrCreate?: judgingCreateOrConnectWithoutJudging_runInput
    connect?: judgingWhereUniqueInput
  }

  export type judging_run_outputCreateNestedOneWithoutJudging_runInput = {
    create?: XOR<judging_run_outputCreateWithoutJudging_runInput, judging_run_outputUncheckedCreateWithoutJudging_runInput>
    connectOrCreate?: judging_run_outputCreateOrConnectWithoutJudging_runInput
    connect?: judging_run_outputWhereUniqueInput
  }

  export type judging_run_outputUncheckedCreateNestedOneWithoutJudging_runInput = {
    create?: XOR<judging_run_outputCreateWithoutJudging_runInput, judging_run_outputUncheckedCreateWithoutJudging_runInput>
    connectOrCreate?: judging_run_outputCreateOrConnectWithoutJudging_runInput
    connect?: judging_run_outputWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type judgetaskUpdateOneWithoutJudging_runNestedInput = {
    create?: XOR<judgetaskCreateWithoutJudging_runInput, judgetaskUncheckedCreateWithoutJudging_runInput>
    connectOrCreate?: judgetaskCreateOrConnectWithoutJudging_runInput
    upsert?: judgetaskUpsertWithoutJudging_runInput
    disconnect?: judgetaskWhereInput | boolean
    delete?: judgetaskWhereInput | boolean
    connect?: judgetaskWhereUniqueInput
    update?: XOR<XOR<judgetaskUpdateToOneWithWhereWithoutJudging_runInput, judgetaskUpdateWithoutJudging_runInput>, judgetaskUncheckedUpdateWithoutJudging_runInput>
  }

  export type testcaseUpdateOneWithoutJudging_runNestedInput = {
    create?: XOR<testcaseCreateWithoutJudging_runInput, testcaseUncheckedCreateWithoutJudging_runInput>
    connectOrCreate?: testcaseCreateOrConnectWithoutJudging_runInput
    upsert?: testcaseUpsertWithoutJudging_runInput
    disconnect?: testcaseWhereInput | boolean
    delete?: testcaseWhereInput | boolean
    connect?: testcaseWhereUniqueInput
    update?: XOR<XOR<testcaseUpdateToOneWithWhereWithoutJudging_runInput, testcaseUpdateWithoutJudging_runInput>, testcaseUncheckedUpdateWithoutJudging_runInput>
  }

  export type judgingUpdateOneWithoutJudging_runNestedInput = {
    create?: XOR<judgingCreateWithoutJudging_runInput, judgingUncheckedCreateWithoutJudging_runInput>
    connectOrCreate?: judgingCreateOrConnectWithoutJudging_runInput
    upsert?: judgingUpsertWithoutJudging_runInput
    disconnect?: judgingWhereInput | boolean
    delete?: judgingWhereInput | boolean
    connect?: judgingWhereUniqueInput
    update?: XOR<XOR<judgingUpdateToOneWithWhereWithoutJudging_runInput, judgingUpdateWithoutJudging_runInput>, judgingUncheckedUpdateWithoutJudging_runInput>
  }

  export type judging_run_outputUpdateOneWithoutJudging_runNestedInput = {
    create?: XOR<judging_run_outputCreateWithoutJudging_runInput, judging_run_outputUncheckedCreateWithoutJudging_runInput>
    connectOrCreate?: judging_run_outputCreateOrConnectWithoutJudging_runInput
    upsert?: judging_run_outputUpsertWithoutJudging_runInput
    disconnect?: judging_run_outputWhereInput | boolean
    delete?: judging_run_outputWhereInput | boolean
    connect?: judging_run_outputWhereUniqueInput
    update?: XOR<XOR<judging_run_outputUpdateToOneWithWhereWithoutJudging_runInput, judging_run_outputUpdateWithoutJudging_runInput>, judging_run_outputUncheckedUpdateWithoutJudging_runInput>
  }

  export type judging_run_outputUncheckedUpdateOneWithoutJudging_runNestedInput = {
    create?: XOR<judging_run_outputCreateWithoutJudging_runInput, judging_run_outputUncheckedCreateWithoutJudging_runInput>
    connectOrCreate?: judging_run_outputCreateOrConnectWithoutJudging_runInput
    upsert?: judging_run_outputUpsertWithoutJudging_runInput
    disconnect?: judging_run_outputWhereInput | boolean
    delete?: judging_run_outputWhereInput | boolean
    connect?: judging_run_outputWhereUniqueInput
    update?: XOR<XOR<judging_run_outputUpdateToOneWithWhereWithoutJudging_runInput, judging_run_outputUpdateWithoutJudging_runInput>, judging_run_outputUncheckedUpdateWithoutJudging_runInput>
  }

  export type judging_runCreateNestedOneWithoutJudging_run_outputInput = {
    create?: XOR<judging_runCreateWithoutJudging_run_outputInput, judging_runUncheckedCreateWithoutJudging_run_outputInput>
    connectOrCreate?: judging_runCreateOrConnectWithoutJudging_run_outputInput
    connect?: judging_runWhereUniqueInput
  }

  export type judging_runUpdateOneRequiredWithoutJudging_run_outputNestedInput = {
    create?: XOR<judging_runCreateWithoutJudging_run_outputInput, judging_runUncheckedCreateWithoutJudging_run_outputInput>
    connectOrCreate?: judging_runCreateOrConnectWithoutJudging_run_outputInput
    upsert?: judging_runUpsertWithoutJudging_run_outputInput
    connect?: judging_runWhereUniqueInput
    update?: XOR<XOR<judging_runUpdateToOneWithWhereWithoutJudging_run_outputInput, judging_runUpdateWithoutJudging_run_outputInput>, judging_runUncheckedUpdateWithoutJudging_run_outputInput>
  }

  export type executableCreateNestedOneWithoutLanguageInput = {
    create?: XOR<executableCreateWithoutLanguageInput, executableUncheckedCreateWithoutLanguageInput>
    connectOrCreate?: executableCreateOrConnectWithoutLanguageInput
    connect?: executableWhereUniqueInput
  }

  export type submissionCreateNestedManyWithoutLanguageInput = {
    create?: XOR<submissionCreateWithoutLanguageInput, submissionUncheckedCreateWithoutLanguageInput> | submissionCreateWithoutLanguageInput[] | submissionUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutLanguageInput | submissionCreateOrConnectWithoutLanguageInput[]
    createMany?: submissionCreateManyLanguageInputEnvelope
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
  }

  export type submissionUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<submissionCreateWithoutLanguageInput, submissionUncheckedCreateWithoutLanguageInput> | submissionCreateWithoutLanguageInput[] | submissionUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutLanguageInput | submissionCreateOrConnectWithoutLanguageInput[]
    createMany?: submissionCreateManyLanguageInputEnvelope
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
  }

  export type executableUpdateOneWithoutLanguageNestedInput = {
    create?: XOR<executableCreateWithoutLanguageInput, executableUncheckedCreateWithoutLanguageInput>
    connectOrCreate?: executableCreateOrConnectWithoutLanguageInput
    upsert?: executableUpsertWithoutLanguageInput
    disconnect?: executableWhereInput | boolean
    delete?: executableWhereInput | boolean
    connect?: executableWhereUniqueInput
    update?: XOR<XOR<executableUpdateToOneWithWhereWithoutLanguageInput, executableUpdateWithoutLanguageInput>, executableUncheckedUpdateWithoutLanguageInput>
  }

  export type submissionUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<submissionCreateWithoutLanguageInput, submissionUncheckedCreateWithoutLanguageInput> | submissionCreateWithoutLanguageInput[] | submissionUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutLanguageInput | submissionCreateOrConnectWithoutLanguageInput[]
    upsert?: submissionUpsertWithWhereUniqueWithoutLanguageInput | submissionUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: submissionCreateManyLanguageInputEnvelope
    set?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    disconnect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    delete?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    update?: submissionUpdateWithWhereUniqueWithoutLanguageInput | submissionUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: submissionUpdateManyWithWhereWithoutLanguageInput | submissionUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: submissionScalarWhereInput | submissionScalarWhereInput[]
  }

  export type submissionUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<submissionCreateWithoutLanguageInput, submissionUncheckedCreateWithoutLanguageInput> | submissionCreateWithoutLanguageInput[] | submissionUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutLanguageInput | submissionCreateOrConnectWithoutLanguageInput[]
    upsert?: submissionUpsertWithWhereUniqueWithoutLanguageInput | submissionUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: submissionCreateManyLanguageInputEnvelope
    set?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    disconnect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    delete?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    update?: submissionUpdateWithWhereUniqueWithoutLanguageInput | submissionUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: submissionUpdateManyWithWhereWithoutLanguageInput | submissionUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: submissionScalarWhereInput | submissionScalarWhereInput[]
  }

  export type clarificationCreateNestedManyWithoutProblemInput = {
    create?: XOR<clarificationCreateWithoutProblemInput, clarificationUncheckedCreateWithoutProblemInput> | clarificationCreateWithoutProblemInput[] | clarificationUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: clarificationCreateOrConnectWithoutProblemInput | clarificationCreateOrConnectWithoutProblemInput[]
    createMany?: clarificationCreateManyProblemInputEnvelope
    connect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
  }

  export type contestproblemCreateNestedManyWithoutProblemInput = {
    create?: XOR<contestproblemCreateWithoutProblemInput, contestproblemUncheckedCreateWithoutProblemInput> | contestproblemCreateWithoutProblemInput[] | contestproblemUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: contestproblemCreateOrConnectWithoutProblemInput | contestproblemCreateOrConnectWithoutProblemInput[]
    createMany?: contestproblemCreateManyProblemInputEnvelope
    connect?: contestproblemWhereUniqueInput | contestproblemWhereUniqueInput[]
  }

  export type executableCreateNestedOneWithoutProblem_problem_special_runToexecutableInput = {
    create?: XOR<executableCreateWithoutProblem_problem_special_runToexecutableInput, executableUncheckedCreateWithoutProblem_problem_special_runToexecutableInput>
    connectOrCreate?: executableCreateOrConnectWithoutProblem_problem_special_runToexecutableInput
    connect?: executableWhereUniqueInput
  }

  export type executableCreateNestedOneWithoutProblem_problem_special_compareToexecutableInput = {
    create?: XOR<executableCreateWithoutProblem_problem_special_compareToexecutableInput, executableUncheckedCreateWithoutProblem_problem_special_compareToexecutableInput>
    connectOrCreate?: executableCreateOrConnectWithoutProblem_problem_special_compareToexecutableInput
    connect?: executableWhereUniqueInput
  }

  export type problem_attachmentCreateNestedManyWithoutProblemInput = {
    create?: XOR<problem_attachmentCreateWithoutProblemInput, problem_attachmentUncheckedCreateWithoutProblemInput> | problem_attachmentCreateWithoutProblemInput[] | problem_attachmentUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: problem_attachmentCreateOrConnectWithoutProblemInput | problem_attachmentCreateOrConnectWithoutProblemInput[]
    createMany?: problem_attachmentCreateManyProblemInputEnvelope
    connect?: problem_attachmentWhereUniqueInput | problem_attachmentWhereUniqueInput[]
  }

  export type scorecacheCreateNestedManyWithoutProblemInput = {
    create?: XOR<scorecacheCreateWithoutProblemInput, scorecacheUncheckedCreateWithoutProblemInput> | scorecacheCreateWithoutProblemInput[] | scorecacheUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: scorecacheCreateOrConnectWithoutProblemInput | scorecacheCreateOrConnectWithoutProblemInput[]
    createMany?: scorecacheCreateManyProblemInputEnvelope
    connect?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
  }

  export type submissionCreateNestedManyWithoutProblemInput = {
    create?: XOR<submissionCreateWithoutProblemInput, submissionUncheckedCreateWithoutProblemInput> | submissionCreateWithoutProblemInput[] | submissionUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutProblemInput | submissionCreateOrConnectWithoutProblemInput[]
    createMany?: submissionCreateManyProblemInputEnvelope
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
  }

  export type testcaseCreateNestedManyWithoutProblemInput = {
    create?: XOR<testcaseCreateWithoutProblemInput, testcaseUncheckedCreateWithoutProblemInput> | testcaseCreateWithoutProblemInput[] | testcaseUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: testcaseCreateOrConnectWithoutProblemInput | testcaseCreateOrConnectWithoutProblemInput[]
    createMany?: testcaseCreateManyProblemInputEnvelope
    connect?: testcaseWhereUniqueInput | testcaseWhereUniqueInput[]
  }

  export type clarificationUncheckedCreateNestedManyWithoutProblemInput = {
    create?: XOR<clarificationCreateWithoutProblemInput, clarificationUncheckedCreateWithoutProblemInput> | clarificationCreateWithoutProblemInput[] | clarificationUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: clarificationCreateOrConnectWithoutProblemInput | clarificationCreateOrConnectWithoutProblemInput[]
    createMany?: clarificationCreateManyProblemInputEnvelope
    connect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
  }

  export type contestproblemUncheckedCreateNestedManyWithoutProblemInput = {
    create?: XOR<contestproblemCreateWithoutProblemInput, contestproblemUncheckedCreateWithoutProblemInput> | contestproblemCreateWithoutProblemInput[] | contestproblemUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: contestproblemCreateOrConnectWithoutProblemInput | contestproblemCreateOrConnectWithoutProblemInput[]
    createMany?: contestproblemCreateManyProblemInputEnvelope
    connect?: contestproblemWhereUniqueInput | contestproblemWhereUniqueInput[]
  }

  export type problem_attachmentUncheckedCreateNestedManyWithoutProblemInput = {
    create?: XOR<problem_attachmentCreateWithoutProblemInput, problem_attachmentUncheckedCreateWithoutProblemInput> | problem_attachmentCreateWithoutProblemInput[] | problem_attachmentUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: problem_attachmentCreateOrConnectWithoutProblemInput | problem_attachmentCreateOrConnectWithoutProblemInput[]
    createMany?: problem_attachmentCreateManyProblemInputEnvelope
    connect?: problem_attachmentWhereUniqueInput | problem_attachmentWhereUniqueInput[]
  }

  export type scorecacheUncheckedCreateNestedManyWithoutProblemInput = {
    create?: XOR<scorecacheCreateWithoutProblemInput, scorecacheUncheckedCreateWithoutProblemInput> | scorecacheCreateWithoutProblemInput[] | scorecacheUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: scorecacheCreateOrConnectWithoutProblemInput | scorecacheCreateOrConnectWithoutProblemInput[]
    createMany?: scorecacheCreateManyProblemInputEnvelope
    connect?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
  }

  export type submissionUncheckedCreateNestedManyWithoutProblemInput = {
    create?: XOR<submissionCreateWithoutProblemInput, submissionUncheckedCreateWithoutProblemInput> | submissionCreateWithoutProblemInput[] | submissionUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutProblemInput | submissionCreateOrConnectWithoutProblemInput[]
    createMany?: submissionCreateManyProblemInputEnvelope
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
  }

  export type testcaseUncheckedCreateNestedManyWithoutProblemInput = {
    create?: XOR<testcaseCreateWithoutProblemInput, testcaseUncheckedCreateWithoutProblemInput> | testcaseCreateWithoutProblemInput[] | testcaseUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: testcaseCreateOrConnectWithoutProblemInput | testcaseCreateOrConnectWithoutProblemInput[]
    createMany?: testcaseCreateManyProblemInputEnvelope
    connect?: testcaseWhereUniqueInput | testcaseWhereUniqueInput[]
  }

  export type clarificationUpdateManyWithoutProblemNestedInput = {
    create?: XOR<clarificationCreateWithoutProblemInput, clarificationUncheckedCreateWithoutProblemInput> | clarificationCreateWithoutProblemInput[] | clarificationUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: clarificationCreateOrConnectWithoutProblemInput | clarificationCreateOrConnectWithoutProblemInput[]
    upsert?: clarificationUpsertWithWhereUniqueWithoutProblemInput | clarificationUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: clarificationCreateManyProblemInputEnvelope
    set?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    disconnect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    delete?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    connect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    update?: clarificationUpdateWithWhereUniqueWithoutProblemInput | clarificationUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: clarificationUpdateManyWithWhereWithoutProblemInput | clarificationUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: clarificationScalarWhereInput | clarificationScalarWhereInput[]
  }

  export type contestproblemUpdateManyWithoutProblemNestedInput = {
    create?: XOR<contestproblemCreateWithoutProblemInput, contestproblemUncheckedCreateWithoutProblemInput> | contestproblemCreateWithoutProblemInput[] | contestproblemUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: contestproblemCreateOrConnectWithoutProblemInput | contestproblemCreateOrConnectWithoutProblemInput[]
    upsert?: contestproblemUpsertWithWhereUniqueWithoutProblemInput | contestproblemUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: contestproblemCreateManyProblemInputEnvelope
    set?: contestproblemWhereUniqueInput | contestproblemWhereUniqueInput[]
    disconnect?: contestproblemWhereUniqueInput | contestproblemWhereUniqueInput[]
    delete?: contestproblemWhereUniqueInput | contestproblemWhereUniqueInput[]
    connect?: contestproblemWhereUniqueInput | contestproblemWhereUniqueInput[]
    update?: contestproblemUpdateWithWhereUniqueWithoutProblemInput | contestproblemUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: contestproblemUpdateManyWithWhereWithoutProblemInput | contestproblemUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: contestproblemScalarWhereInput | contestproblemScalarWhereInput[]
  }

  export type executableUpdateOneWithoutProblem_problem_special_runToexecutableNestedInput = {
    create?: XOR<executableCreateWithoutProblem_problem_special_runToexecutableInput, executableUncheckedCreateWithoutProblem_problem_special_runToexecutableInput>
    connectOrCreate?: executableCreateOrConnectWithoutProblem_problem_special_runToexecutableInput
    upsert?: executableUpsertWithoutProblem_problem_special_runToexecutableInput
    disconnect?: executableWhereInput | boolean
    delete?: executableWhereInput | boolean
    connect?: executableWhereUniqueInput
    update?: XOR<XOR<executableUpdateToOneWithWhereWithoutProblem_problem_special_runToexecutableInput, executableUpdateWithoutProblem_problem_special_runToexecutableInput>, executableUncheckedUpdateWithoutProblem_problem_special_runToexecutableInput>
  }

  export type executableUpdateOneWithoutProblem_problem_special_compareToexecutableNestedInput = {
    create?: XOR<executableCreateWithoutProblem_problem_special_compareToexecutableInput, executableUncheckedCreateWithoutProblem_problem_special_compareToexecutableInput>
    connectOrCreate?: executableCreateOrConnectWithoutProblem_problem_special_compareToexecutableInput
    upsert?: executableUpsertWithoutProblem_problem_special_compareToexecutableInput
    disconnect?: executableWhereInput | boolean
    delete?: executableWhereInput | boolean
    connect?: executableWhereUniqueInput
    update?: XOR<XOR<executableUpdateToOneWithWhereWithoutProblem_problem_special_compareToexecutableInput, executableUpdateWithoutProblem_problem_special_compareToexecutableInput>, executableUncheckedUpdateWithoutProblem_problem_special_compareToexecutableInput>
  }

  export type problem_attachmentUpdateManyWithoutProblemNestedInput = {
    create?: XOR<problem_attachmentCreateWithoutProblemInput, problem_attachmentUncheckedCreateWithoutProblemInput> | problem_attachmentCreateWithoutProblemInput[] | problem_attachmentUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: problem_attachmentCreateOrConnectWithoutProblemInput | problem_attachmentCreateOrConnectWithoutProblemInput[]
    upsert?: problem_attachmentUpsertWithWhereUniqueWithoutProblemInput | problem_attachmentUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: problem_attachmentCreateManyProblemInputEnvelope
    set?: problem_attachmentWhereUniqueInput | problem_attachmentWhereUniqueInput[]
    disconnect?: problem_attachmentWhereUniqueInput | problem_attachmentWhereUniqueInput[]
    delete?: problem_attachmentWhereUniqueInput | problem_attachmentWhereUniqueInput[]
    connect?: problem_attachmentWhereUniqueInput | problem_attachmentWhereUniqueInput[]
    update?: problem_attachmentUpdateWithWhereUniqueWithoutProblemInput | problem_attachmentUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: problem_attachmentUpdateManyWithWhereWithoutProblemInput | problem_attachmentUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: problem_attachmentScalarWhereInput | problem_attachmentScalarWhereInput[]
  }

  export type scorecacheUpdateManyWithoutProblemNestedInput = {
    create?: XOR<scorecacheCreateWithoutProblemInput, scorecacheUncheckedCreateWithoutProblemInput> | scorecacheCreateWithoutProblemInput[] | scorecacheUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: scorecacheCreateOrConnectWithoutProblemInput | scorecacheCreateOrConnectWithoutProblemInput[]
    upsert?: scorecacheUpsertWithWhereUniqueWithoutProblemInput | scorecacheUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: scorecacheCreateManyProblemInputEnvelope
    set?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    disconnect?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    delete?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    connect?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    update?: scorecacheUpdateWithWhereUniqueWithoutProblemInput | scorecacheUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: scorecacheUpdateManyWithWhereWithoutProblemInput | scorecacheUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: scorecacheScalarWhereInput | scorecacheScalarWhereInput[]
  }

  export type submissionUpdateManyWithoutProblemNestedInput = {
    create?: XOR<submissionCreateWithoutProblemInput, submissionUncheckedCreateWithoutProblemInput> | submissionCreateWithoutProblemInput[] | submissionUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutProblemInput | submissionCreateOrConnectWithoutProblemInput[]
    upsert?: submissionUpsertWithWhereUniqueWithoutProblemInput | submissionUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: submissionCreateManyProblemInputEnvelope
    set?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    disconnect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    delete?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    update?: submissionUpdateWithWhereUniqueWithoutProblemInput | submissionUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: submissionUpdateManyWithWhereWithoutProblemInput | submissionUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: submissionScalarWhereInput | submissionScalarWhereInput[]
  }

  export type testcaseUpdateManyWithoutProblemNestedInput = {
    create?: XOR<testcaseCreateWithoutProblemInput, testcaseUncheckedCreateWithoutProblemInput> | testcaseCreateWithoutProblemInput[] | testcaseUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: testcaseCreateOrConnectWithoutProblemInput | testcaseCreateOrConnectWithoutProblemInput[]
    upsert?: testcaseUpsertWithWhereUniqueWithoutProblemInput | testcaseUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: testcaseCreateManyProblemInputEnvelope
    set?: testcaseWhereUniqueInput | testcaseWhereUniqueInput[]
    disconnect?: testcaseWhereUniqueInput | testcaseWhereUniqueInput[]
    delete?: testcaseWhereUniqueInput | testcaseWhereUniqueInput[]
    connect?: testcaseWhereUniqueInput | testcaseWhereUniqueInput[]
    update?: testcaseUpdateWithWhereUniqueWithoutProblemInput | testcaseUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: testcaseUpdateManyWithWhereWithoutProblemInput | testcaseUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: testcaseScalarWhereInput | testcaseScalarWhereInput[]
  }

  export type clarificationUncheckedUpdateManyWithoutProblemNestedInput = {
    create?: XOR<clarificationCreateWithoutProblemInput, clarificationUncheckedCreateWithoutProblemInput> | clarificationCreateWithoutProblemInput[] | clarificationUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: clarificationCreateOrConnectWithoutProblemInput | clarificationCreateOrConnectWithoutProblemInput[]
    upsert?: clarificationUpsertWithWhereUniqueWithoutProblemInput | clarificationUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: clarificationCreateManyProblemInputEnvelope
    set?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    disconnect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    delete?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    connect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    update?: clarificationUpdateWithWhereUniqueWithoutProblemInput | clarificationUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: clarificationUpdateManyWithWhereWithoutProblemInput | clarificationUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: clarificationScalarWhereInput | clarificationScalarWhereInput[]
  }

  export type contestproblemUncheckedUpdateManyWithoutProblemNestedInput = {
    create?: XOR<contestproblemCreateWithoutProblemInput, contestproblemUncheckedCreateWithoutProblemInput> | contestproblemCreateWithoutProblemInput[] | contestproblemUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: contestproblemCreateOrConnectWithoutProblemInput | contestproblemCreateOrConnectWithoutProblemInput[]
    upsert?: contestproblemUpsertWithWhereUniqueWithoutProblemInput | contestproblemUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: contestproblemCreateManyProblemInputEnvelope
    set?: contestproblemWhereUniqueInput | contestproblemWhereUniqueInput[]
    disconnect?: contestproblemWhereUniqueInput | contestproblemWhereUniqueInput[]
    delete?: contestproblemWhereUniqueInput | contestproblemWhereUniqueInput[]
    connect?: contestproblemWhereUniqueInput | contestproblemWhereUniqueInput[]
    update?: contestproblemUpdateWithWhereUniqueWithoutProblemInput | contestproblemUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: contestproblemUpdateManyWithWhereWithoutProblemInput | contestproblemUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: contestproblemScalarWhereInput | contestproblemScalarWhereInput[]
  }

  export type problem_attachmentUncheckedUpdateManyWithoutProblemNestedInput = {
    create?: XOR<problem_attachmentCreateWithoutProblemInput, problem_attachmentUncheckedCreateWithoutProblemInput> | problem_attachmentCreateWithoutProblemInput[] | problem_attachmentUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: problem_attachmentCreateOrConnectWithoutProblemInput | problem_attachmentCreateOrConnectWithoutProblemInput[]
    upsert?: problem_attachmentUpsertWithWhereUniqueWithoutProblemInput | problem_attachmentUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: problem_attachmentCreateManyProblemInputEnvelope
    set?: problem_attachmentWhereUniqueInput | problem_attachmentWhereUniqueInput[]
    disconnect?: problem_attachmentWhereUniqueInput | problem_attachmentWhereUniqueInput[]
    delete?: problem_attachmentWhereUniqueInput | problem_attachmentWhereUniqueInput[]
    connect?: problem_attachmentWhereUniqueInput | problem_attachmentWhereUniqueInput[]
    update?: problem_attachmentUpdateWithWhereUniqueWithoutProblemInput | problem_attachmentUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: problem_attachmentUpdateManyWithWhereWithoutProblemInput | problem_attachmentUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: problem_attachmentScalarWhereInput | problem_attachmentScalarWhereInput[]
  }

  export type scorecacheUncheckedUpdateManyWithoutProblemNestedInput = {
    create?: XOR<scorecacheCreateWithoutProblemInput, scorecacheUncheckedCreateWithoutProblemInput> | scorecacheCreateWithoutProblemInput[] | scorecacheUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: scorecacheCreateOrConnectWithoutProblemInput | scorecacheCreateOrConnectWithoutProblemInput[]
    upsert?: scorecacheUpsertWithWhereUniqueWithoutProblemInput | scorecacheUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: scorecacheCreateManyProblemInputEnvelope
    set?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    disconnect?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    delete?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    connect?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    update?: scorecacheUpdateWithWhereUniqueWithoutProblemInput | scorecacheUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: scorecacheUpdateManyWithWhereWithoutProblemInput | scorecacheUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: scorecacheScalarWhereInput | scorecacheScalarWhereInput[]
  }

  export type submissionUncheckedUpdateManyWithoutProblemNestedInput = {
    create?: XOR<submissionCreateWithoutProblemInput, submissionUncheckedCreateWithoutProblemInput> | submissionCreateWithoutProblemInput[] | submissionUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutProblemInput | submissionCreateOrConnectWithoutProblemInput[]
    upsert?: submissionUpsertWithWhereUniqueWithoutProblemInput | submissionUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: submissionCreateManyProblemInputEnvelope
    set?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    disconnect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    delete?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    update?: submissionUpdateWithWhereUniqueWithoutProblemInput | submissionUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: submissionUpdateManyWithWhereWithoutProblemInput | submissionUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: submissionScalarWhereInput | submissionScalarWhereInput[]
  }

  export type testcaseUncheckedUpdateManyWithoutProblemNestedInput = {
    create?: XOR<testcaseCreateWithoutProblemInput, testcaseUncheckedCreateWithoutProblemInput> | testcaseCreateWithoutProblemInput[] | testcaseUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: testcaseCreateOrConnectWithoutProblemInput | testcaseCreateOrConnectWithoutProblemInput[]
    upsert?: testcaseUpsertWithWhereUniqueWithoutProblemInput | testcaseUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: testcaseCreateManyProblemInputEnvelope
    set?: testcaseWhereUniqueInput | testcaseWhereUniqueInput[]
    disconnect?: testcaseWhereUniqueInput | testcaseWhereUniqueInput[]
    delete?: testcaseWhereUniqueInput | testcaseWhereUniqueInput[]
    connect?: testcaseWhereUniqueInput | testcaseWhereUniqueInput[]
    update?: testcaseUpdateWithWhereUniqueWithoutProblemInput | testcaseUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: testcaseUpdateManyWithWhereWithoutProblemInput | testcaseUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: testcaseScalarWhereInput | testcaseScalarWhereInput[]
  }

  export type problemCreateNestedOneWithoutProblem_attachmentInput = {
    create?: XOR<problemCreateWithoutProblem_attachmentInput, problemUncheckedCreateWithoutProblem_attachmentInput>
    connectOrCreate?: problemCreateOrConnectWithoutProblem_attachmentInput
    connect?: problemWhereUniqueInput
  }

  export type problem_attachment_contentCreateNestedOneWithoutProblem_attachmentInput = {
    create?: XOR<problem_attachment_contentCreateWithoutProblem_attachmentInput, problem_attachment_contentUncheckedCreateWithoutProblem_attachmentInput>
    connectOrCreate?: problem_attachment_contentCreateOrConnectWithoutProblem_attachmentInput
    connect?: problem_attachment_contentWhereUniqueInput
  }

  export type problem_attachment_contentUncheckedCreateNestedOneWithoutProblem_attachmentInput = {
    create?: XOR<problem_attachment_contentCreateWithoutProblem_attachmentInput, problem_attachment_contentUncheckedCreateWithoutProblem_attachmentInput>
    connectOrCreate?: problem_attachment_contentCreateOrConnectWithoutProblem_attachmentInput
    connect?: problem_attachment_contentWhereUniqueInput
  }

  export type problemUpdateOneWithoutProblem_attachmentNestedInput = {
    create?: XOR<problemCreateWithoutProblem_attachmentInput, problemUncheckedCreateWithoutProblem_attachmentInput>
    connectOrCreate?: problemCreateOrConnectWithoutProblem_attachmentInput
    upsert?: problemUpsertWithoutProblem_attachmentInput
    disconnect?: problemWhereInput | boolean
    delete?: problemWhereInput | boolean
    connect?: problemWhereUniqueInput
    update?: XOR<XOR<problemUpdateToOneWithWhereWithoutProblem_attachmentInput, problemUpdateWithoutProblem_attachmentInput>, problemUncheckedUpdateWithoutProblem_attachmentInput>
  }

  export type problem_attachment_contentUpdateOneWithoutProblem_attachmentNestedInput = {
    create?: XOR<problem_attachment_contentCreateWithoutProblem_attachmentInput, problem_attachment_contentUncheckedCreateWithoutProblem_attachmentInput>
    connectOrCreate?: problem_attachment_contentCreateOrConnectWithoutProblem_attachmentInput
    upsert?: problem_attachment_contentUpsertWithoutProblem_attachmentInput
    disconnect?: problem_attachment_contentWhereInput | boolean
    delete?: problem_attachment_contentWhereInput | boolean
    connect?: problem_attachment_contentWhereUniqueInput
    update?: XOR<XOR<problem_attachment_contentUpdateToOneWithWhereWithoutProblem_attachmentInput, problem_attachment_contentUpdateWithoutProblem_attachmentInput>, problem_attachment_contentUncheckedUpdateWithoutProblem_attachmentInput>
  }

  export type problem_attachment_contentUncheckedUpdateOneWithoutProblem_attachmentNestedInput = {
    create?: XOR<problem_attachment_contentCreateWithoutProblem_attachmentInput, problem_attachment_contentUncheckedCreateWithoutProblem_attachmentInput>
    connectOrCreate?: problem_attachment_contentCreateOrConnectWithoutProblem_attachmentInput
    upsert?: problem_attachment_contentUpsertWithoutProblem_attachmentInput
    disconnect?: problem_attachment_contentWhereInput | boolean
    delete?: problem_attachment_contentWhereInput | boolean
    connect?: problem_attachment_contentWhereUniqueInput
    update?: XOR<XOR<problem_attachment_contentUpdateToOneWithWhereWithoutProblem_attachmentInput, problem_attachment_contentUpdateWithoutProblem_attachmentInput>, problem_attachment_contentUncheckedUpdateWithoutProblem_attachmentInput>
  }

  export type problem_attachmentCreateNestedOneWithoutProblem_attachment_contentInput = {
    create?: XOR<problem_attachmentCreateWithoutProblem_attachment_contentInput, problem_attachmentUncheckedCreateWithoutProblem_attachment_contentInput>
    connectOrCreate?: problem_attachmentCreateOrConnectWithoutProblem_attachment_contentInput
    connect?: problem_attachmentWhereUniqueInput
  }

  export type problem_attachmentUpdateOneRequiredWithoutProblem_attachment_contentNestedInput = {
    create?: XOR<problem_attachmentCreateWithoutProblem_attachment_contentInput, problem_attachmentUncheckedCreateWithoutProblem_attachment_contentInput>
    connectOrCreate?: problem_attachmentCreateOrConnectWithoutProblem_attachment_contentInput
    upsert?: problem_attachmentUpsertWithoutProblem_attachment_contentInput
    connect?: problem_attachmentWhereUniqueInput
    update?: XOR<XOR<problem_attachmentUpdateToOneWithWhereWithoutProblem_attachment_contentInput, problem_attachmentUpdateWithoutProblem_attachment_contentInput>, problem_attachmentUncheckedUpdateWithoutProblem_attachment_contentInput>
  }

  export type teamCreateNestedOneWithoutQueuetaskInput = {
    create?: XOR<teamCreateWithoutQueuetaskInput, teamUncheckedCreateWithoutQueuetaskInput>
    connectOrCreate?: teamCreateOrConnectWithoutQueuetaskInput
    connect?: teamWhereUniqueInput
  }

  export type teamUpdateOneWithoutQueuetaskNestedInput = {
    create?: XOR<teamCreateWithoutQueuetaskInput, teamUncheckedCreateWithoutQueuetaskInput>
    connectOrCreate?: teamCreateOrConnectWithoutQueuetaskInput
    upsert?: teamUpsertWithoutQueuetaskInput
    disconnect?: teamWhereInput | boolean
    delete?: teamWhereInput | boolean
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutQueuetaskInput, teamUpdateWithoutQueuetaskInput>, teamUncheckedUpdateWithoutQueuetaskInput>
  }

  export type contestCreateNestedOneWithoutRankcacheInput = {
    create?: XOR<contestCreateWithoutRankcacheInput, contestUncheckedCreateWithoutRankcacheInput>
    connectOrCreate?: contestCreateOrConnectWithoutRankcacheInput
    connect?: contestWhereUniqueInput
  }

  export type teamCreateNestedOneWithoutRankcacheInput = {
    create?: XOR<teamCreateWithoutRankcacheInput, teamUncheckedCreateWithoutRankcacheInput>
    connectOrCreate?: teamCreateOrConnectWithoutRankcacheInput
    connect?: teamWhereUniqueInput
  }

  export type contestUpdateOneRequiredWithoutRankcacheNestedInput = {
    create?: XOR<contestCreateWithoutRankcacheInput, contestUncheckedCreateWithoutRankcacheInput>
    connectOrCreate?: contestCreateOrConnectWithoutRankcacheInput
    upsert?: contestUpsertWithoutRankcacheInput
    connect?: contestWhereUniqueInput
    update?: XOR<XOR<contestUpdateToOneWithWhereWithoutRankcacheInput, contestUpdateWithoutRankcacheInput>, contestUncheckedUpdateWithoutRankcacheInput>
  }

  export type teamUpdateOneRequiredWithoutRankcacheNestedInput = {
    create?: XOR<teamCreateWithoutRankcacheInput, teamUncheckedCreateWithoutRankcacheInput>
    connectOrCreate?: teamCreateOrConnectWithoutRankcacheInput
    upsert?: teamUpsertWithoutRankcacheInput
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutRankcacheInput, teamUpdateWithoutRankcacheInput>, teamUncheckedUpdateWithoutRankcacheInput>
  }

  export type judgingCreateNestedManyWithoutRejudgingInput = {
    create?: XOR<judgingCreateWithoutRejudgingInput, judgingUncheckedCreateWithoutRejudgingInput> | judgingCreateWithoutRejudgingInput[] | judgingUncheckedCreateWithoutRejudgingInput[]
    connectOrCreate?: judgingCreateOrConnectWithoutRejudgingInput | judgingCreateOrConnectWithoutRejudgingInput[]
    createMany?: judgingCreateManyRejudgingInputEnvelope
    connect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
  }

  export type rejudgingCreateNestedOneWithoutOther_rejudgingInput = {
    create?: XOR<rejudgingCreateWithoutOther_rejudgingInput, rejudgingUncheckedCreateWithoutOther_rejudgingInput>
    connectOrCreate?: rejudgingCreateOrConnectWithoutOther_rejudgingInput
    connect?: rejudgingWhereUniqueInput
  }

  export type rejudgingCreateNestedManyWithoutRejudgingInput = {
    create?: XOR<rejudgingCreateWithoutRejudgingInput, rejudgingUncheckedCreateWithoutRejudgingInput> | rejudgingCreateWithoutRejudgingInput[] | rejudgingUncheckedCreateWithoutRejudgingInput[]
    connectOrCreate?: rejudgingCreateOrConnectWithoutRejudgingInput | rejudgingCreateOrConnectWithoutRejudgingInput[]
    createMany?: rejudgingCreateManyRejudgingInputEnvelope
    connect?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutRejudging_rejudging_userid_startTouserInput = {
    create?: XOR<userCreateWithoutRejudging_rejudging_userid_startTouserInput, userUncheckedCreateWithoutRejudging_rejudging_userid_startTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutRejudging_rejudging_userid_startTouserInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutRejudging_rejudging_userid_finishTouserInput = {
    create?: XOR<userCreateWithoutRejudging_rejudging_userid_finishTouserInput, userUncheckedCreateWithoutRejudging_rejudging_userid_finishTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutRejudging_rejudging_userid_finishTouserInput
    connect?: userWhereUniqueInput
  }

  export type submissionCreateNestedManyWithoutRejudgingInput = {
    create?: XOR<submissionCreateWithoutRejudgingInput, submissionUncheckedCreateWithoutRejudgingInput> | submissionCreateWithoutRejudgingInput[] | submissionUncheckedCreateWithoutRejudgingInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutRejudgingInput | submissionCreateOrConnectWithoutRejudgingInput[]
    createMany?: submissionCreateManyRejudgingInputEnvelope
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
  }

  export type judgingUncheckedCreateNestedManyWithoutRejudgingInput = {
    create?: XOR<judgingCreateWithoutRejudgingInput, judgingUncheckedCreateWithoutRejudgingInput> | judgingCreateWithoutRejudgingInput[] | judgingUncheckedCreateWithoutRejudgingInput[]
    connectOrCreate?: judgingCreateOrConnectWithoutRejudgingInput | judgingCreateOrConnectWithoutRejudgingInput[]
    createMany?: judgingCreateManyRejudgingInputEnvelope
    connect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
  }

  export type rejudgingUncheckedCreateNestedManyWithoutRejudgingInput = {
    create?: XOR<rejudgingCreateWithoutRejudgingInput, rejudgingUncheckedCreateWithoutRejudgingInput> | rejudgingCreateWithoutRejudgingInput[] | rejudgingUncheckedCreateWithoutRejudgingInput[]
    connectOrCreate?: rejudgingCreateOrConnectWithoutRejudgingInput | rejudgingCreateOrConnectWithoutRejudgingInput[]
    createMany?: rejudgingCreateManyRejudgingInputEnvelope
    connect?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
  }

  export type submissionUncheckedCreateNestedManyWithoutRejudgingInput = {
    create?: XOR<submissionCreateWithoutRejudgingInput, submissionUncheckedCreateWithoutRejudgingInput> | submissionCreateWithoutRejudgingInput[] | submissionUncheckedCreateWithoutRejudgingInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutRejudgingInput | submissionCreateOrConnectWithoutRejudgingInput[]
    createMany?: submissionCreateManyRejudgingInputEnvelope
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
  }

  export type judgingUpdateManyWithoutRejudgingNestedInput = {
    create?: XOR<judgingCreateWithoutRejudgingInput, judgingUncheckedCreateWithoutRejudgingInput> | judgingCreateWithoutRejudgingInput[] | judgingUncheckedCreateWithoutRejudgingInput[]
    connectOrCreate?: judgingCreateOrConnectWithoutRejudgingInput | judgingCreateOrConnectWithoutRejudgingInput[]
    upsert?: judgingUpsertWithWhereUniqueWithoutRejudgingInput | judgingUpsertWithWhereUniqueWithoutRejudgingInput[]
    createMany?: judgingCreateManyRejudgingInputEnvelope
    set?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    disconnect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    delete?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    connect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    update?: judgingUpdateWithWhereUniqueWithoutRejudgingInput | judgingUpdateWithWhereUniqueWithoutRejudgingInput[]
    updateMany?: judgingUpdateManyWithWhereWithoutRejudgingInput | judgingUpdateManyWithWhereWithoutRejudgingInput[]
    deleteMany?: judgingScalarWhereInput | judgingScalarWhereInput[]
  }

  export type rejudgingUpdateOneWithoutOther_rejudgingNestedInput = {
    create?: XOR<rejudgingCreateWithoutOther_rejudgingInput, rejudgingUncheckedCreateWithoutOther_rejudgingInput>
    connectOrCreate?: rejudgingCreateOrConnectWithoutOther_rejudgingInput
    upsert?: rejudgingUpsertWithoutOther_rejudgingInput
    disconnect?: rejudgingWhereInput | boolean
    delete?: rejudgingWhereInput | boolean
    connect?: rejudgingWhereUniqueInput
    update?: XOR<XOR<rejudgingUpdateToOneWithWhereWithoutOther_rejudgingInput, rejudgingUpdateWithoutOther_rejudgingInput>, rejudgingUncheckedUpdateWithoutOther_rejudgingInput>
  }

  export type rejudgingUpdateManyWithoutRejudgingNestedInput = {
    create?: XOR<rejudgingCreateWithoutRejudgingInput, rejudgingUncheckedCreateWithoutRejudgingInput> | rejudgingCreateWithoutRejudgingInput[] | rejudgingUncheckedCreateWithoutRejudgingInput[]
    connectOrCreate?: rejudgingCreateOrConnectWithoutRejudgingInput | rejudgingCreateOrConnectWithoutRejudgingInput[]
    upsert?: rejudgingUpsertWithWhereUniqueWithoutRejudgingInput | rejudgingUpsertWithWhereUniqueWithoutRejudgingInput[]
    createMany?: rejudgingCreateManyRejudgingInputEnvelope
    set?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    disconnect?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    delete?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    connect?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    update?: rejudgingUpdateWithWhereUniqueWithoutRejudgingInput | rejudgingUpdateWithWhereUniqueWithoutRejudgingInput[]
    updateMany?: rejudgingUpdateManyWithWhereWithoutRejudgingInput | rejudgingUpdateManyWithWhereWithoutRejudgingInput[]
    deleteMany?: rejudgingScalarWhereInput | rejudgingScalarWhereInput[]
  }

  export type userUpdateOneWithoutRejudging_rejudging_userid_startTouserNestedInput = {
    create?: XOR<userCreateWithoutRejudging_rejudging_userid_startTouserInput, userUncheckedCreateWithoutRejudging_rejudging_userid_startTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutRejudging_rejudging_userid_startTouserInput
    upsert?: userUpsertWithoutRejudging_rejudging_userid_startTouserInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutRejudging_rejudging_userid_startTouserInput, userUpdateWithoutRejudging_rejudging_userid_startTouserInput>, userUncheckedUpdateWithoutRejudging_rejudging_userid_startTouserInput>
  }

  export type userUpdateOneWithoutRejudging_rejudging_userid_finishTouserNestedInput = {
    create?: XOR<userCreateWithoutRejudging_rejudging_userid_finishTouserInput, userUncheckedCreateWithoutRejudging_rejudging_userid_finishTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutRejudging_rejudging_userid_finishTouserInput
    upsert?: userUpsertWithoutRejudging_rejudging_userid_finishTouserInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutRejudging_rejudging_userid_finishTouserInput, userUpdateWithoutRejudging_rejudging_userid_finishTouserInput>, userUncheckedUpdateWithoutRejudging_rejudging_userid_finishTouserInput>
  }

  export type submissionUpdateManyWithoutRejudgingNestedInput = {
    create?: XOR<submissionCreateWithoutRejudgingInput, submissionUncheckedCreateWithoutRejudgingInput> | submissionCreateWithoutRejudgingInput[] | submissionUncheckedCreateWithoutRejudgingInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutRejudgingInput | submissionCreateOrConnectWithoutRejudgingInput[]
    upsert?: submissionUpsertWithWhereUniqueWithoutRejudgingInput | submissionUpsertWithWhereUniqueWithoutRejudgingInput[]
    createMany?: submissionCreateManyRejudgingInputEnvelope
    set?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    disconnect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    delete?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    update?: submissionUpdateWithWhereUniqueWithoutRejudgingInput | submissionUpdateWithWhereUniqueWithoutRejudgingInput[]
    updateMany?: submissionUpdateManyWithWhereWithoutRejudgingInput | submissionUpdateManyWithWhereWithoutRejudgingInput[]
    deleteMany?: submissionScalarWhereInput | submissionScalarWhereInput[]
  }

  export type judgingUncheckedUpdateManyWithoutRejudgingNestedInput = {
    create?: XOR<judgingCreateWithoutRejudgingInput, judgingUncheckedCreateWithoutRejudgingInput> | judgingCreateWithoutRejudgingInput[] | judgingUncheckedCreateWithoutRejudgingInput[]
    connectOrCreate?: judgingCreateOrConnectWithoutRejudgingInput | judgingCreateOrConnectWithoutRejudgingInput[]
    upsert?: judgingUpsertWithWhereUniqueWithoutRejudgingInput | judgingUpsertWithWhereUniqueWithoutRejudgingInput[]
    createMany?: judgingCreateManyRejudgingInputEnvelope
    set?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    disconnect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    delete?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    connect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    update?: judgingUpdateWithWhereUniqueWithoutRejudgingInput | judgingUpdateWithWhereUniqueWithoutRejudgingInput[]
    updateMany?: judgingUpdateManyWithWhereWithoutRejudgingInput | judgingUpdateManyWithWhereWithoutRejudgingInput[]
    deleteMany?: judgingScalarWhereInput | judgingScalarWhereInput[]
  }

  export type rejudgingUncheckedUpdateManyWithoutRejudgingNestedInput = {
    create?: XOR<rejudgingCreateWithoutRejudgingInput, rejudgingUncheckedCreateWithoutRejudgingInput> | rejudgingCreateWithoutRejudgingInput[] | rejudgingUncheckedCreateWithoutRejudgingInput[]
    connectOrCreate?: rejudgingCreateOrConnectWithoutRejudgingInput | rejudgingCreateOrConnectWithoutRejudgingInput[]
    upsert?: rejudgingUpsertWithWhereUniqueWithoutRejudgingInput | rejudgingUpsertWithWhereUniqueWithoutRejudgingInput[]
    createMany?: rejudgingCreateManyRejudgingInputEnvelope
    set?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    disconnect?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    delete?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    connect?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    update?: rejudgingUpdateWithWhereUniqueWithoutRejudgingInput | rejudgingUpdateWithWhereUniqueWithoutRejudgingInput[]
    updateMany?: rejudgingUpdateManyWithWhereWithoutRejudgingInput | rejudgingUpdateManyWithWhereWithoutRejudgingInput[]
    deleteMany?: rejudgingScalarWhereInput | rejudgingScalarWhereInput[]
  }

  export type submissionUncheckedUpdateManyWithoutRejudgingNestedInput = {
    create?: XOR<submissionCreateWithoutRejudgingInput, submissionUncheckedCreateWithoutRejudgingInput> | submissionCreateWithoutRejudgingInput[] | submissionUncheckedCreateWithoutRejudgingInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutRejudgingInput | submissionCreateOrConnectWithoutRejudgingInput[]
    upsert?: submissionUpsertWithWhereUniqueWithoutRejudgingInput | submissionUpsertWithWhereUniqueWithoutRejudgingInput[]
    createMany?: submissionCreateManyRejudgingInputEnvelope
    set?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    disconnect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    delete?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    update?: submissionUpdateWithWhereUniqueWithoutRejudgingInput | submissionUpdateWithWhereUniqueWithoutRejudgingInput[]
    updateMany?: submissionUpdateManyWithWhereWithoutRejudgingInput | submissionUpdateManyWithWhereWithoutRejudgingInput[]
    deleteMany?: submissionScalarWhereInput | submissionScalarWhereInput[]
  }

  export type contestCreateNestedOneWithoutRemoved_intervalInput = {
    create?: XOR<contestCreateWithoutRemoved_intervalInput, contestUncheckedCreateWithoutRemoved_intervalInput>
    connectOrCreate?: contestCreateOrConnectWithoutRemoved_intervalInput
    connect?: contestWhereUniqueInput
  }

  export type contestUpdateOneWithoutRemoved_intervalNestedInput = {
    create?: XOR<contestCreateWithoutRemoved_intervalInput, contestUncheckedCreateWithoutRemoved_intervalInput>
    connectOrCreate?: contestCreateOrConnectWithoutRemoved_intervalInput
    upsert?: contestUpsertWithoutRemoved_intervalInput
    disconnect?: contestWhereInput | boolean
    delete?: contestWhereInput | boolean
    connect?: contestWhereUniqueInput
    update?: XOR<XOR<contestUpdateToOneWithWhereWithoutRemoved_intervalInput, contestUpdateWithoutRemoved_intervalInput>, contestUncheckedUpdateWithoutRemoved_intervalInput>
  }

  export type userroleCreateNestedManyWithoutRoleInput = {
    create?: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput> | userroleCreateWithoutRoleInput[] | userroleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutRoleInput | userroleCreateOrConnectWithoutRoleInput[]
    createMany?: userroleCreateManyRoleInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type userroleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput> | userroleCreateWithoutRoleInput[] | userroleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutRoleInput | userroleCreateOrConnectWithoutRoleInput[]
    createMany?: userroleCreateManyRoleInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type userroleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput> | userroleCreateWithoutRoleInput[] | userroleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutRoleInput | userroleCreateOrConnectWithoutRoleInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutRoleInput | userroleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: userroleCreateManyRoleInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutRoleInput | userroleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutRoleInput | userroleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type userroleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput> | userroleCreateWithoutRoleInput[] | userroleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutRoleInput | userroleCreateOrConnectWithoutRoleInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutRoleInput | userroleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: userroleCreateManyRoleInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutRoleInput | userroleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutRoleInput | userroleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type contestCreateNestedOneWithoutScorecacheInput = {
    create?: XOR<contestCreateWithoutScorecacheInput, contestUncheckedCreateWithoutScorecacheInput>
    connectOrCreate?: contestCreateOrConnectWithoutScorecacheInput
    connect?: contestWhereUniqueInput
  }

  export type teamCreateNestedOneWithoutScorecacheInput = {
    create?: XOR<teamCreateWithoutScorecacheInput, teamUncheckedCreateWithoutScorecacheInput>
    connectOrCreate?: teamCreateOrConnectWithoutScorecacheInput
    connect?: teamWhereUniqueInput
  }

  export type problemCreateNestedOneWithoutScorecacheInput = {
    create?: XOR<problemCreateWithoutScorecacheInput, problemUncheckedCreateWithoutScorecacheInput>
    connectOrCreate?: problemCreateOrConnectWithoutScorecacheInput
    connect?: problemWhereUniqueInput
  }

  export type contestUpdateOneRequiredWithoutScorecacheNestedInput = {
    create?: XOR<contestCreateWithoutScorecacheInput, contestUncheckedCreateWithoutScorecacheInput>
    connectOrCreate?: contestCreateOrConnectWithoutScorecacheInput
    upsert?: contestUpsertWithoutScorecacheInput
    connect?: contestWhereUniqueInput
    update?: XOR<XOR<contestUpdateToOneWithWhereWithoutScorecacheInput, contestUpdateWithoutScorecacheInput>, contestUncheckedUpdateWithoutScorecacheInput>
  }

  export type teamUpdateOneRequiredWithoutScorecacheNestedInput = {
    create?: XOR<teamCreateWithoutScorecacheInput, teamUncheckedCreateWithoutScorecacheInput>
    connectOrCreate?: teamCreateOrConnectWithoutScorecacheInput
    upsert?: teamUpsertWithoutScorecacheInput
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutScorecacheInput, teamUpdateWithoutScorecacheInput>, teamUncheckedUpdateWithoutScorecacheInput>
  }

  export type problemUpdateOneRequiredWithoutScorecacheNestedInput = {
    create?: XOR<problemCreateWithoutScorecacheInput, problemUncheckedCreateWithoutScorecacheInput>
    connectOrCreate?: problemCreateOrConnectWithoutScorecacheInput
    upsert?: problemUpsertWithoutScorecacheInput
    connect?: problemWhereUniqueInput
    update?: XOR<XOR<problemUpdateToOneWithWhereWithoutScorecacheInput, problemUpdateWithoutScorecacheInput>, problemUncheckedUpdateWithoutScorecacheInput>
  }

  export type balloonCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<balloonCreateWithoutSubmissionInput, balloonUncheckedCreateWithoutSubmissionInput> | balloonCreateWithoutSubmissionInput[] | balloonUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: balloonCreateOrConnectWithoutSubmissionInput | balloonCreateOrConnectWithoutSubmissionInput[]
    createMany?: balloonCreateManySubmissionInputEnvelope
    connect?: balloonWhereUniqueInput | balloonWhereUniqueInput[]
  }

  export type external_judgementCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<external_judgementCreateWithoutSubmissionInput, external_judgementUncheckedCreateWithoutSubmissionInput> | external_judgementCreateWithoutSubmissionInput[] | external_judgementUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: external_judgementCreateOrConnectWithoutSubmissionInput | external_judgementCreateOrConnectWithoutSubmissionInput[]
    createMany?: external_judgementCreateManySubmissionInputEnvelope
    connect?: external_judgementWhereUniqueInput | external_judgementWhereUniqueInput[]
  }

  export type judgingCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<judgingCreateWithoutSubmissionInput, judgingUncheckedCreateWithoutSubmissionInput> | judgingCreateWithoutSubmissionInput[] | judgingUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: judgingCreateOrConnectWithoutSubmissionInput | judgingCreateOrConnectWithoutSubmissionInput[]
    createMany?: judgingCreateManySubmissionInputEnvelope
    connect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutSubmissionInput = {
    create?: XOR<userCreateWithoutSubmissionInput, userUncheckedCreateWithoutSubmissionInput>
    connectOrCreate?: userCreateOrConnectWithoutSubmissionInput
    connect?: userWhereUniqueInput
  }

  export type contestCreateNestedOneWithoutSubmissionInput = {
    create?: XOR<contestCreateWithoutSubmissionInput, contestUncheckedCreateWithoutSubmissionInput>
    connectOrCreate?: contestCreateOrConnectWithoutSubmissionInput
    connect?: contestWhereUniqueInput
  }

  export type teamCreateNestedOneWithoutSubmissionInput = {
    create?: XOR<teamCreateWithoutSubmissionInput, teamUncheckedCreateWithoutSubmissionInput>
    connectOrCreate?: teamCreateOrConnectWithoutSubmissionInput
    connect?: teamWhereUniqueInput
  }

  export type problemCreateNestedOneWithoutSubmissionInput = {
    create?: XOR<problemCreateWithoutSubmissionInput, problemUncheckedCreateWithoutSubmissionInput>
    connectOrCreate?: problemCreateOrConnectWithoutSubmissionInput
    connect?: problemWhereUniqueInput
  }

  export type languageCreateNestedOneWithoutSubmissionInput = {
    create?: XOR<languageCreateWithoutSubmissionInput, languageUncheckedCreateWithoutSubmissionInput>
    connectOrCreate?: languageCreateOrConnectWithoutSubmissionInput
    connect?: languageWhereUniqueInput
  }

  export type submissionCreateNestedOneWithoutOther_submissionInput = {
    create?: XOR<submissionCreateWithoutOther_submissionInput, submissionUncheckedCreateWithoutOther_submissionInput>
    connectOrCreate?: submissionCreateOrConnectWithoutOther_submissionInput
    connect?: submissionWhereUniqueInput
  }

  export type submissionCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<submissionCreateWithoutSubmissionInput, submissionUncheckedCreateWithoutSubmissionInput> | submissionCreateWithoutSubmissionInput[] | submissionUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutSubmissionInput | submissionCreateOrConnectWithoutSubmissionInput[]
    createMany?: submissionCreateManySubmissionInputEnvelope
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
  }

  export type rejudgingCreateNestedOneWithoutSubmissionInput = {
    create?: XOR<rejudgingCreateWithoutSubmissionInput, rejudgingUncheckedCreateWithoutSubmissionInput>
    connectOrCreate?: rejudgingCreateOrConnectWithoutSubmissionInput
    connect?: rejudgingWhereUniqueInput
  }

  export type contestproblemCreateNestedOneWithoutSubmissionInput = {
    create?: XOR<contestproblemCreateWithoutSubmissionInput, contestproblemUncheckedCreateWithoutSubmissionInput>
    connectOrCreate?: contestproblemCreateOrConnectWithoutSubmissionInput
    connect?: contestproblemWhereUniqueInput
  }

  export type submission_fileCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<submission_fileCreateWithoutSubmissionInput, submission_fileUncheckedCreateWithoutSubmissionInput> | submission_fileCreateWithoutSubmissionInput[] | submission_fileUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: submission_fileCreateOrConnectWithoutSubmissionInput | submission_fileCreateOrConnectWithoutSubmissionInput[]
    createMany?: submission_fileCreateManySubmissionInputEnvelope
    connect?: submission_fileWhereUniqueInput | submission_fileWhereUniqueInput[]
  }

  export type balloonUncheckedCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<balloonCreateWithoutSubmissionInput, balloonUncheckedCreateWithoutSubmissionInput> | balloonCreateWithoutSubmissionInput[] | balloonUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: balloonCreateOrConnectWithoutSubmissionInput | balloonCreateOrConnectWithoutSubmissionInput[]
    createMany?: balloonCreateManySubmissionInputEnvelope
    connect?: balloonWhereUniqueInput | balloonWhereUniqueInput[]
  }

  export type external_judgementUncheckedCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<external_judgementCreateWithoutSubmissionInput, external_judgementUncheckedCreateWithoutSubmissionInput> | external_judgementCreateWithoutSubmissionInput[] | external_judgementUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: external_judgementCreateOrConnectWithoutSubmissionInput | external_judgementCreateOrConnectWithoutSubmissionInput[]
    createMany?: external_judgementCreateManySubmissionInputEnvelope
    connect?: external_judgementWhereUniqueInput | external_judgementWhereUniqueInput[]
  }

  export type judgingUncheckedCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<judgingCreateWithoutSubmissionInput, judgingUncheckedCreateWithoutSubmissionInput> | judgingCreateWithoutSubmissionInput[] | judgingUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: judgingCreateOrConnectWithoutSubmissionInput | judgingCreateOrConnectWithoutSubmissionInput[]
    createMany?: judgingCreateManySubmissionInputEnvelope
    connect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
  }

  export type submissionUncheckedCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<submissionCreateWithoutSubmissionInput, submissionUncheckedCreateWithoutSubmissionInput> | submissionCreateWithoutSubmissionInput[] | submissionUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutSubmissionInput | submissionCreateOrConnectWithoutSubmissionInput[]
    createMany?: submissionCreateManySubmissionInputEnvelope
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
  }

  export type submission_fileUncheckedCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<submission_fileCreateWithoutSubmissionInput, submission_fileUncheckedCreateWithoutSubmissionInput> | submission_fileCreateWithoutSubmissionInput[] | submission_fileUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: submission_fileCreateOrConnectWithoutSubmissionInput | submission_fileCreateOrConnectWithoutSubmissionInput[]
    createMany?: submission_fileCreateManySubmissionInputEnvelope
    connect?: submission_fileWhereUniqueInput | submission_fileWhereUniqueInput[]
  }

  export type balloonUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<balloonCreateWithoutSubmissionInput, balloonUncheckedCreateWithoutSubmissionInput> | balloonCreateWithoutSubmissionInput[] | balloonUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: balloonCreateOrConnectWithoutSubmissionInput | balloonCreateOrConnectWithoutSubmissionInput[]
    upsert?: balloonUpsertWithWhereUniqueWithoutSubmissionInput | balloonUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: balloonCreateManySubmissionInputEnvelope
    set?: balloonWhereUniqueInput | balloonWhereUniqueInput[]
    disconnect?: balloonWhereUniqueInput | balloonWhereUniqueInput[]
    delete?: balloonWhereUniqueInput | balloonWhereUniqueInput[]
    connect?: balloonWhereUniqueInput | balloonWhereUniqueInput[]
    update?: balloonUpdateWithWhereUniqueWithoutSubmissionInput | balloonUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: balloonUpdateManyWithWhereWithoutSubmissionInput | balloonUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: balloonScalarWhereInput | balloonScalarWhereInput[]
  }

  export type external_judgementUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<external_judgementCreateWithoutSubmissionInput, external_judgementUncheckedCreateWithoutSubmissionInput> | external_judgementCreateWithoutSubmissionInput[] | external_judgementUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: external_judgementCreateOrConnectWithoutSubmissionInput | external_judgementCreateOrConnectWithoutSubmissionInput[]
    upsert?: external_judgementUpsertWithWhereUniqueWithoutSubmissionInput | external_judgementUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: external_judgementCreateManySubmissionInputEnvelope
    set?: external_judgementWhereUniqueInput | external_judgementWhereUniqueInput[]
    disconnect?: external_judgementWhereUniqueInput | external_judgementWhereUniqueInput[]
    delete?: external_judgementWhereUniqueInput | external_judgementWhereUniqueInput[]
    connect?: external_judgementWhereUniqueInput | external_judgementWhereUniqueInput[]
    update?: external_judgementUpdateWithWhereUniqueWithoutSubmissionInput | external_judgementUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: external_judgementUpdateManyWithWhereWithoutSubmissionInput | external_judgementUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: external_judgementScalarWhereInput | external_judgementScalarWhereInput[]
  }

  export type judgingUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<judgingCreateWithoutSubmissionInput, judgingUncheckedCreateWithoutSubmissionInput> | judgingCreateWithoutSubmissionInput[] | judgingUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: judgingCreateOrConnectWithoutSubmissionInput | judgingCreateOrConnectWithoutSubmissionInput[]
    upsert?: judgingUpsertWithWhereUniqueWithoutSubmissionInput | judgingUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: judgingCreateManySubmissionInputEnvelope
    set?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    disconnect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    delete?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    connect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    update?: judgingUpdateWithWhereUniqueWithoutSubmissionInput | judgingUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: judgingUpdateManyWithWhereWithoutSubmissionInput | judgingUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: judgingScalarWhereInput | judgingScalarWhereInput[]
  }

  export type userUpdateOneWithoutSubmissionNestedInput = {
    create?: XOR<userCreateWithoutSubmissionInput, userUncheckedCreateWithoutSubmissionInput>
    connectOrCreate?: userCreateOrConnectWithoutSubmissionInput
    upsert?: userUpsertWithoutSubmissionInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutSubmissionInput, userUpdateWithoutSubmissionInput>, userUncheckedUpdateWithoutSubmissionInput>
  }

  export type contestUpdateOneWithoutSubmissionNestedInput = {
    create?: XOR<contestCreateWithoutSubmissionInput, contestUncheckedCreateWithoutSubmissionInput>
    connectOrCreate?: contestCreateOrConnectWithoutSubmissionInput
    upsert?: contestUpsertWithoutSubmissionInput
    disconnect?: contestWhereInput | boolean
    delete?: contestWhereInput | boolean
    connect?: contestWhereUniqueInput
    update?: XOR<XOR<contestUpdateToOneWithWhereWithoutSubmissionInput, contestUpdateWithoutSubmissionInput>, contestUncheckedUpdateWithoutSubmissionInput>
  }

  export type teamUpdateOneWithoutSubmissionNestedInput = {
    create?: XOR<teamCreateWithoutSubmissionInput, teamUncheckedCreateWithoutSubmissionInput>
    connectOrCreate?: teamCreateOrConnectWithoutSubmissionInput
    upsert?: teamUpsertWithoutSubmissionInput
    disconnect?: teamWhereInput | boolean
    delete?: teamWhereInput | boolean
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutSubmissionInput, teamUpdateWithoutSubmissionInput>, teamUncheckedUpdateWithoutSubmissionInput>
  }

  export type problemUpdateOneWithoutSubmissionNestedInput = {
    create?: XOR<problemCreateWithoutSubmissionInput, problemUncheckedCreateWithoutSubmissionInput>
    connectOrCreate?: problemCreateOrConnectWithoutSubmissionInput
    upsert?: problemUpsertWithoutSubmissionInput
    disconnect?: problemWhereInput | boolean
    delete?: problemWhereInput | boolean
    connect?: problemWhereUniqueInput
    update?: XOR<XOR<problemUpdateToOneWithWhereWithoutSubmissionInput, problemUpdateWithoutSubmissionInput>, problemUncheckedUpdateWithoutSubmissionInput>
  }

  export type languageUpdateOneWithoutSubmissionNestedInput = {
    create?: XOR<languageCreateWithoutSubmissionInput, languageUncheckedCreateWithoutSubmissionInput>
    connectOrCreate?: languageCreateOrConnectWithoutSubmissionInput
    upsert?: languageUpsertWithoutSubmissionInput
    disconnect?: languageWhereInput | boolean
    delete?: languageWhereInput | boolean
    connect?: languageWhereUniqueInput
    update?: XOR<XOR<languageUpdateToOneWithWhereWithoutSubmissionInput, languageUpdateWithoutSubmissionInput>, languageUncheckedUpdateWithoutSubmissionInput>
  }

  export type submissionUpdateOneWithoutOther_submissionNestedInput = {
    create?: XOR<submissionCreateWithoutOther_submissionInput, submissionUncheckedCreateWithoutOther_submissionInput>
    connectOrCreate?: submissionCreateOrConnectWithoutOther_submissionInput
    upsert?: submissionUpsertWithoutOther_submissionInput
    disconnect?: submissionWhereInput | boolean
    delete?: submissionWhereInput | boolean
    connect?: submissionWhereUniqueInput
    update?: XOR<XOR<submissionUpdateToOneWithWhereWithoutOther_submissionInput, submissionUpdateWithoutOther_submissionInput>, submissionUncheckedUpdateWithoutOther_submissionInput>
  }

  export type submissionUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<submissionCreateWithoutSubmissionInput, submissionUncheckedCreateWithoutSubmissionInput> | submissionCreateWithoutSubmissionInput[] | submissionUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutSubmissionInput | submissionCreateOrConnectWithoutSubmissionInput[]
    upsert?: submissionUpsertWithWhereUniqueWithoutSubmissionInput | submissionUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: submissionCreateManySubmissionInputEnvelope
    set?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    disconnect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    delete?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    update?: submissionUpdateWithWhereUniqueWithoutSubmissionInput | submissionUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: submissionUpdateManyWithWhereWithoutSubmissionInput | submissionUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: submissionScalarWhereInput | submissionScalarWhereInput[]
  }

  export type rejudgingUpdateOneWithoutSubmissionNestedInput = {
    create?: XOR<rejudgingCreateWithoutSubmissionInput, rejudgingUncheckedCreateWithoutSubmissionInput>
    connectOrCreate?: rejudgingCreateOrConnectWithoutSubmissionInput
    upsert?: rejudgingUpsertWithoutSubmissionInput
    disconnect?: rejudgingWhereInput | boolean
    delete?: rejudgingWhereInput | boolean
    connect?: rejudgingWhereUniqueInput
    update?: XOR<XOR<rejudgingUpdateToOneWithWhereWithoutSubmissionInput, rejudgingUpdateWithoutSubmissionInput>, rejudgingUncheckedUpdateWithoutSubmissionInput>
  }

  export type contestproblemUpdateOneWithoutSubmissionNestedInput = {
    create?: XOR<contestproblemCreateWithoutSubmissionInput, contestproblemUncheckedCreateWithoutSubmissionInput>
    connectOrCreate?: contestproblemCreateOrConnectWithoutSubmissionInput
    upsert?: contestproblemUpsertWithoutSubmissionInput
    disconnect?: contestproblemWhereInput | boolean
    delete?: contestproblemWhereInput | boolean
    connect?: contestproblemWhereUniqueInput
    update?: XOR<XOR<contestproblemUpdateToOneWithWhereWithoutSubmissionInput, contestproblemUpdateWithoutSubmissionInput>, contestproblemUncheckedUpdateWithoutSubmissionInput>
  }

  export type submission_fileUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<submission_fileCreateWithoutSubmissionInput, submission_fileUncheckedCreateWithoutSubmissionInput> | submission_fileCreateWithoutSubmissionInput[] | submission_fileUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: submission_fileCreateOrConnectWithoutSubmissionInput | submission_fileCreateOrConnectWithoutSubmissionInput[]
    upsert?: submission_fileUpsertWithWhereUniqueWithoutSubmissionInput | submission_fileUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: submission_fileCreateManySubmissionInputEnvelope
    set?: submission_fileWhereUniqueInput | submission_fileWhereUniqueInput[]
    disconnect?: submission_fileWhereUniqueInput | submission_fileWhereUniqueInput[]
    delete?: submission_fileWhereUniqueInput | submission_fileWhereUniqueInput[]
    connect?: submission_fileWhereUniqueInput | submission_fileWhereUniqueInput[]
    update?: submission_fileUpdateWithWhereUniqueWithoutSubmissionInput | submission_fileUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: submission_fileUpdateManyWithWhereWithoutSubmissionInput | submission_fileUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: submission_fileScalarWhereInput | submission_fileScalarWhereInput[]
  }

  export type balloonUncheckedUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<balloonCreateWithoutSubmissionInput, balloonUncheckedCreateWithoutSubmissionInput> | balloonCreateWithoutSubmissionInput[] | balloonUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: balloonCreateOrConnectWithoutSubmissionInput | balloonCreateOrConnectWithoutSubmissionInput[]
    upsert?: balloonUpsertWithWhereUniqueWithoutSubmissionInput | balloonUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: balloonCreateManySubmissionInputEnvelope
    set?: balloonWhereUniqueInput | balloonWhereUniqueInput[]
    disconnect?: balloonWhereUniqueInput | balloonWhereUniqueInput[]
    delete?: balloonWhereUniqueInput | balloonWhereUniqueInput[]
    connect?: balloonWhereUniqueInput | balloonWhereUniqueInput[]
    update?: balloonUpdateWithWhereUniqueWithoutSubmissionInput | balloonUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: balloonUpdateManyWithWhereWithoutSubmissionInput | balloonUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: balloonScalarWhereInput | balloonScalarWhereInput[]
  }

  export type external_judgementUncheckedUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<external_judgementCreateWithoutSubmissionInput, external_judgementUncheckedCreateWithoutSubmissionInput> | external_judgementCreateWithoutSubmissionInput[] | external_judgementUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: external_judgementCreateOrConnectWithoutSubmissionInput | external_judgementCreateOrConnectWithoutSubmissionInput[]
    upsert?: external_judgementUpsertWithWhereUniqueWithoutSubmissionInput | external_judgementUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: external_judgementCreateManySubmissionInputEnvelope
    set?: external_judgementWhereUniqueInput | external_judgementWhereUniqueInput[]
    disconnect?: external_judgementWhereUniqueInput | external_judgementWhereUniqueInput[]
    delete?: external_judgementWhereUniqueInput | external_judgementWhereUniqueInput[]
    connect?: external_judgementWhereUniqueInput | external_judgementWhereUniqueInput[]
    update?: external_judgementUpdateWithWhereUniqueWithoutSubmissionInput | external_judgementUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: external_judgementUpdateManyWithWhereWithoutSubmissionInput | external_judgementUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: external_judgementScalarWhereInput | external_judgementScalarWhereInput[]
  }

  export type judgingUncheckedUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<judgingCreateWithoutSubmissionInput, judgingUncheckedCreateWithoutSubmissionInput> | judgingCreateWithoutSubmissionInput[] | judgingUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: judgingCreateOrConnectWithoutSubmissionInput | judgingCreateOrConnectWithoutSubmissionInput[]
    upsert?: judgingUpsertWithWhereUniqueWithoutSubmissionInput | judgingUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: judgingCreateManySubmissionInputEnvelope
    set?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    disconnect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    delete?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    connect?: judgingWhereUniqueInput | judgingWhereUniqueInput[]
    update?: judgingUpdateWithWhereUniqueWithoutSubmissionInput | judgingUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: judgingUpdateManyWithWhereWithoutSubmissionInput | judgingUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: judgingScalarWhereInput | judgingScalarWhereInput[]
  }

  export type submissionUncheckedUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<submissionCreateWithoutSubmissionInput, submissionUncheckedCreateWithoutSubmissionInput> | submissionCreateWithoutSubmissionInput[] | submissionUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutSubmissionInput | submissionCreateOrConnectWithoutSubmissionInput[]
    upsert?: submissionUpsertWithWhereUniqueWithoutSubmissionInput | submissionUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: submissionCreateManySubmissionInputEnvelope
    set?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    disconnect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    delete?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    update?: submissionUpdateWithWhereUniqueWithoutSubmissionInput | submissionUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: submissionUpdateManyWithWhereWithoutSubmissionInput | submissionUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: submissionScalarWhereInput | submissionScalarWhereInput[]
  }

  export type submission_fileUncheckedUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<submission_fileCreateWithoutSubmissionInput, submission_fileUncheckedCreateWithoutSubmissionInput> | submission_fileCreateWithoutSubmissionInput[] | submission_fileUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: submission_fileCreateOrConnectWithoutSubmissionInput | submission_fileCreateOrConnectWithoutSubmissionInput[]
    upsert?: submission_fileUpsertWithWhereUniqueWithoutSubmissionInput | submission_fileUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: submission_fileCreateManySubmissionInputEnvelope
    set?: submission_fileWhereUniqueInput | submission_fileWhereUniqueInput[]
    disconnect?: submission_fileWhereUniqueInput | submission_fileWhereUniqueInput[]
    delete?: submission_fileWhereUniqueInput | submission_fileWhereUniqueInput[]
    connect?: submission_fileWhereUniqueInput | submission_fileWhereUniqueInput[]
    update?: submission_fileUpdateWithWhereUniqueWithoutSubmissionInput | submission_fileUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: submission_fileUpdateManyWithWhereWithoutSubmissionInput | submission_fileUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: submission_fileScalarWhereInput | submission_fileScalarWhereInput[]
  }

  export type submissionCreateNestedOneWithoutSubmission_fileInput = {
    create?: XOR<submissionCreateWithoutSubmission_fileInput, submissionUncheckedCreateWithoutSubmission_fileInput>
    connectOrCreate?: submissionCreateOrConnectWithoutSubmission_fileInput
    connect?: submissionWhereUniqueInput
  }

  export type submissionUpdateOneWithoutSubmission_fileNestedInput = {
    create?: XOR<submissionCreateWithoutSubmission_fileInput, submissionUncheckedCreateWithoutSubmission_fileInput>
    connectOrCreate?: submissionCreateOrConnectWithoutSubmission_fileInput
    upsert?: submissionUpsertWithoutSubmission_fileInput
    disconnect?: submissionWhereInput | boolean
    delete?: submissionWhereInput | boolean
    connect?: submissionWhereUniqueInput
    update?: XOR<XOR<submissionUpdateToOneWithWhereWithoutSubmission_fileInput, submissionUpdateWithoutSubmission_fileInput>, submissionUncheckedUpdateWithoutSubmission_fileInput>
  }

  export type clarificationCreateNestedManyWithoutTeam_clarification_senderToteamInput = {
    create?: XOR<clarificationCreateWithoutTeam_clarification_senderToteamInput, clarificationUncheckedCreateWithoutTeam_clarification_senderToteamInput> | clarificationCreateWithoutTeam_clarification_senderToteamInput[] | clarificationUncheckedCreateWithoutTeam_clarification_senderToteamInput[]
    connectOrCreate?: clarificationCreateOrConnectWithoutTeam_clarification_senderToteamInput | clarificationCreateOrConnectWithoutTeam_clarification_senderToteamInput[]
    createMany?: clarificationCreateManyTeam_clarification_senderToteamInputEnvelope
    connect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
  }

  export type clarificationCreateNestedManyWithoutTeam_clarification_recipientToteamInput = {
    create?: XOR<clarificationCreateWithoutTeam_clarification_recipientToteamInput, clarificationUncheckedCreateWithoutTeam_clarification_recipientToteamInput> | clarificationCreateWithoutTeam_clarification_recipientToteamInput[] | clarificationUncheckedCreateWithoutTeam_clarification_recipientToteamInput[]
    connectOrCreate?: clarificationCreateOrConnectWithoutTeam_clarification_recipientToteamInput | clarificationCreateOrConnectWithoutTeam_clarification_recipientToteamInput[]
    createMany?: clarificationCreateManyTeam_clarification_recipientToteamInputEnvelope
    connect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
  }

  export type contestteamCreateNestedManyWithoutTeamInput = {
    create?: XOR<contestteamCreateWithoutTeamInput, contestteamUncheckedCreateWithoutTeamInput> | contestteamCreateWithoutTeamInput[] | contestteamUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: contestteamCreateOrConnectWithoutTeamInput | contestteamCreateOrConnectWithoutTeamInput[]
    createMany?: contestteamCreateManyTeamInputEnvelope
    connect?: contestteamWhereUniqueInput | contestteamWhereUniqueInput[]
  }

  export type queuetaskCreateNestedManyWithoutTeamInput = {
    create?: XOR<queuetaskCreateWithoutTeamInput, queuetaskUncheckedCreateWithoutTeamInput> | queuetaskCreateWithoutTeamInput[] | queuetaskUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: queuetaskCreateOrConnectWithoutTeamInput | queuetaskCreateOrConnectWithoutTeamInput[]
    createMany?: queuetaskCreateManyTeamInputEnvelope
    connect?: queuetaskWhereUniqueInput | queuetaskWhereUniqueInput[]
  }

  export type rankcacheCreateNestedManyWithoutTeamInput = {
    create?: XOR<rankcacheCreateWithoutTeamInput, rankcacheUncheckedCreateWithoutTeamInput> | rankcacheCreateWithoutTeamInput[] | rankcacheUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: rankcacheCreateOrConnectWithoutTeamInput | rankcacheCreateOrConnectWithoutTeamInput[]
    createMany?: rankcacheCreateManyTeamInputEnvelope
    connect?: rankcacheWhereUniqueInput | rankcacheWhereUniqueInput[]
  }

  export type scorecacheCreateNestedManyWithoutTeamInput = {
    create?: XOR<scorecacheCreateWithoutTeamInput, scorecacheUncheckedCreateWithoutTeamInput> | scorecacheCreateWithoutTeamInput[] | scorecacheUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: scorecacheCreateOrConnectWithoutTeamInput | scorecacheCreateOrConnectWithoutTeamInput[]
    createMany?: scorecacheCreateManyTeamInputEnvelope
    connect?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
  }

  export type submissionCreateNestedManyWithoutTeamInput = {
    create?: XOR<submissionCreateWithoutTeamInput, submissionUncheckedCreateWithoutTeamInput> | submissionCreateWithoutTeamInput[] | submissionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutTeamInput | submissionCreateOrConnectWithoutTeamInput[]
    createMany?: submissionCreateManyTeamInputEnvelope
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
  }

  export type team_categoryCreateNestedOneWithoutTeamInput = {
    create?: XOR<team_categoryCreateWithoutTeamInput, team_categoryUncheckedCreateWithoutTeamInput>
    connectOrCreate?: team_categoryCreateOrConnectWithoutTeamInput
    connect?: team_categoryWhereUniqueInput
  }

  export type team_affiliationCreateNestedOneWithoutTeamInput = {
    create?: XOR<team_affiliationCreateWithoutTeamInput, team_affiliationUncheckedCreateWithoutTeamInput>
    connectOrCreate?: team_affiliationCreateOrConnectWithoutTeamInput
    connect?: team_affiliationWhereUniqueInput
  }

  export type team_unreadCreateNestedManyWithoutTeamInput = {
    create?: XOR<team_unreadCreateWithoutTeamInput, team_unreadUncheckedCreateWithoutTeamInput> | team_unreadCreateWithoutTeamInput[] | team_unreadUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: team_unreadCreateOrConnectWithoutTeamInput | team_unreadCreateOrConnectWithoutTeamInput[]
    createMany?: team_unreadCreateManyTeamInputEnvelope
    connect?: team_unreadWhereUniqueInput | team_unreadWhereUniqueInput[]
  }

  export type userCreateNestedManyWithoutTeamInput = {
    create?: XOR<userCreateWithoutTeamInput, userUncheckedCreateWithoutTeamInput> | userCreateWithoutTeamInput[] | userUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: userCreateOrConnectWithoutTeamInput | userCreateOrConnectWithoutTeamInput[]
    createMany?: userCreateManyTeamInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type clarificationUncheckedCreateNestedManyWithoutTeam_clarification_senderToteamInput = {
    create?: XOR<clarificationCreateWithoutTeam_clarification_senderToteamInput, clarificationUncheckedCreateWithoutTeam_clarification_senderToteamInput> | clarificationCreateWithoutTeam_clarification_senderToteamInput[] | clarificationUncheckedCreateWithoutTeam_clarification_senderToteamInput[]
    connectOrCreate?: clarificationCreateOrConnectWithoutTeam_clarification_senderToteamInput | clarificationCreateOrConnectWithoutTeam_clarification_senderToteamInput[]
    createMany?: clarificationCreateManyTeam_clarification_senderToteamInputEnvelope
    connect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
  }

  export type clarificationUncheckedCreateNestedManyWithoutTeam_clarification_recipientToteamInput = {
    create?: XOR<clarificationCreateWithoutTeam_clarification_recipientToteamInput, clarificationUncheckedCreateWithoutTeam_clarification_recipientToteamInput> | clarificationCreateWithoutTeam_clarification_recipientToteamInput[] | clarificationUncheckedCreateWithoutTeam_clarification_recipientToteamInput[]
    connectOrCreate?: clarificationCreateOrConnectWithoutTeam_clarification_recipientToteamInput | clarificationCreateOrConnectWithoutTeam_clarification_recipientToteamInput[]
    createMany?: clarificationCreateManyTeam_clarification_recipientToteamInputEnvelope
    connect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
  }

  export type contestteamUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<contestteamCreateWithoutTeamInput, contestteamUncheckedCreateWithoutTeamInput> | contestteamCreateWithoutTeamInput[] | contestteamUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: contestteamCreateOrConnectWithoutTeamInput | contestteamCreateOrConnectWithoutTeamInput[]
    createMany?: contestteamCreateManyTeamInputEnvelope
    connect?: contestteamWhereUniqueInput | contestteamWhereUniqueInput[]
  }

  export type queuetaskUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<queuetaskCreateWithoutTeamInput, queuetaskUncheckedCreateWithoutTeamInput> | queuetaskCreateWithoutTeamInput[] | queuetaskUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: queuetaskCreateOrConnectWithoutTeamInput | queuetaskCreateOrConnectWithoutTeamInput[]
    createMany?: queuetaskCreateManyTeamInputEnvelope
    connect?: queuetaskWhereUniqueInput | queuetaskWhereUniqueInput[]
  }

  export type rankcacheUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<rankcacheCreateWithoutTeamInput, rankcacheUncheckedCreateWithoutTeamInput> | rankcacheCreateWithoutTeamInput[] | rankcacheUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: rankcacheCreateOrConnectWithoutTeamInput | rankcacheCreateOrConnectWithoutTeamInput[]
    createMany?: rankcacheCreateManyTeamInputEnvelope
    connect?: rankcacheWhereUniqueInput | rankcacheWhereUniqueInput[]
  }

  export type scorecacheUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<scorecacheCreateWithoutTeamInput, scorecacheUncheckedCreateWithoutTeamInput> | scorecacheCreateWithoutTeamInput[] | scorecacheUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: scorecacheCreateOrConnectWithoutTeamInput | scorecacheCreateOrConnectWithoutTeamInput[]
    createMany?: scorecacheCreateManyTeamInputEnvelope
    connect?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
  }

  export type submissionUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<submissionCreateWithoutTeamInput, submissionUncheckedCreateWithoutTeamInput> | submissionCreateWithoutTeamInput[] | submissionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutTeamInput | submissionCreateOrConnectWithoutTeamInput[]
    createMany?: submissionCreateManyTeamInputEnvelope
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
  }

  export type team_unreadUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<team_unreadCreateWithoutTeamInput, team_unreadUncheckedCreateWithoutTeamInput> | team_unreadCreateWithoutTeamInput[] | team_unreadUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: team_unreadCreateOrConnectWithoutTeamInput | team_unreadCreateOrConnectWithoutTeamInput[]
    createMany?: team_unreadCreateManyTeamInputEnvelope
    connect?: team_unreadWhereUniqueInput | team_unreadWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<userCreateWithoutTeamInput, userUncheckedCreateWithoutTeamInput> | userCreateWithoutTeamInput[] | userUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: userCreateOrConnectWithoutTeamInput | userCreateOrConnectWithoutTeamInput[]
    createMany?: userCreateManyTeamInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type clarificationUpdateManyWithoutTeam_clarification_senderToteamNestedInput = {
    create?: XOR<clarificationCreateWithoutTeam_clarification_senderToteamInput, clarificationUncheckedCreateWithoutTeam_clarification_senderToteamInput> | clarificationCreateWithoutTeam_clarification_senderToteamInput[] | clarificationUncheckedCreateWithoutTeam_clarification_senderToteamInput[]
    connectOrCreate?: clarificationCreateOrConnectWithoutTeam_clarification_senderToteamInput | clarificationCreateOrConnectWithoutTeam_clarification_senderToteamInput[]
    upsert?: clarificationUpsertWithWhereUniqueWithoutTeam_clarification_senderToteamInput | clarificationUpsertWithWhereUniqueWithoutTeam_clarification_senderToteamInput[]
    createMany?: clarificationCreateManyTeam_clarification_senderToteamInputEnvelope
    set?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    disconnect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    delete?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    connect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    update?: clarificationUpdateWithWhereUniqueWithoutTeam_clarification_senderToteamInput | clarificationUpdateWithWhereUniqueWithoutTeam_clarification_senderToteamInput[]
    updateMany?: clarificationUpdateManyWithWhereWithoutTeam_clarification_senderToteamInput | clarificationUpdateManyWithWhereWithoutTeam_clarification_senderToteamInput[]
    deleteMany?: clarificationScalarWhereInput | clarificationScalarWhereInput[]
  }

  export type clarificationUpdateManyWithoutTeam_clarification_recipientToteamNestedInput = {
    create?: XOR<clarificationCreateWithoutTeam_clarification_recipientToteamInput, clarificationUncheckedCreateWithoutTeam_clarification_recipientToteamInput> | clarificationCreateWithoutTeam_clarification_recipientToteamInput[] | clarificationUncheckedCreateWithoutTeam_clarification_recipientToteamInput[]
    connectOrCreate?: clarificationCreateOrConnectWithoutTeam_clarification_recipientToteamInput | clarificationCreateOrConnectWithoutTeam_clarification_recipientToteamInput[]
    upsert?: clarificationUpsertWithWhereUniqueWithoutTeam_clarification_recipientToteamInput | clarificationUpsertWithWhereUniqueWithoutTeam_clarification_recipientToteamInput[]
    createMany?: clarificationCreateManyTeam_clarification_recipientToteamInputEnvelope
    set?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    disconnect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    delete?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    connect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    update?: clarificationUpdateWithWhereUniqueWithoutTeam_clarification_recipientToteamInput | clarificationUpdateWithWhereUniqueWithoutTeam_clarification_recipientToteamInput[]
    updateMany?: clarificationUpdateManyWithWhereWithoutTeam_clarification_recipientToteamInput | clarificationUpdateManyWithWhereWithoutTeam_clarification_recipientToteamInput[]
    deleteMany?: clarificationScalarWhereInput | clarificationScalarWhereInput[]
  }

  export type contestteamUpdateManyWithoutTeamNestedInput = {
    create?: XOR<contestteamCreateWithoutTeamInput, contestteamUncheckedCreateWithoutTeamInput> | contestteamCreateWithoutTeamInput[] | contestteamUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: contestteamCreateOrConnectWithoutTeamInput | contestteamCreateOrConnectWithoutTeamInput[]
    upsert?: contestteamUpsertWithWhereUniqueWithoutTeamInput | contestteamUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: contestteamCreateManyTeamInputEnvelope
    set?: contestteamWhereUniqueInput | contestteamWhereUniqueInput[]
    disconnect?: contestteamWhereUniqueInput | contestteamWhereUniqueInput[]
    delete?: contestteamWhereUniqueInput | contestteamWhereUniqueInput[]
    connect?: contestteamWhereUniqueInput | contestteamWhereUniqueInput[]
    update?: contestteamUpdateWithWhereUniqueWithoutTeamInput | contestteamUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: contestteamUpdateManyWithWhereWithoutTeamInput | contestteamUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: contestteamScalarWhereInput | contestteamScalarWhereInput[]
  }

  export type queuetaskUpdateManyWithoutTeamNestedInput = {
    create?: XOR<queuetaskCreateWithoutTeamInput, queuetaskUncheckedCreateWithoutTeamInput> | queuetaskCreateWithoutTeamInput[] | queuetaskUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: queuetaskCreateOrConnectWithoutTeamInput | queuetaskCreateOrConnectWithoutTeamInput[]
    upsert?: queuetaskUpsertWithWhereUniqueWithoutTeamInput | queuetaskUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: queuetaskCreateManyTeamInputEnvelope
    set?: queuetaskWhereUniqueInput | queuetaskWhereUniqueInput[]
    disconnect?: queuetaskWhereUniqueInput | queuetaskWhereUniqueInput[]
    delete?: queuetaskWhereUniqueInput | queuetaskWhereUniqueInput[]
    connect?: queuetaskWhereUniqueInput | queuetaskWhereUniqueInput[]
    update?: queuetaskUpdateWithWhereUniqueWithoutTeamInput | queuetaskUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: queuetaskUpdateManyWithWhereWithoutTeamInput | queuetaskUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: queuetaskScalarWhereInput | queuetaskScalarWhereInput[]
  }

  export type rankcacheUpdateManyWithoutTeamNestedInput = {
    create?: XOR<rankcacheCreateWithoutTeamInput, rankcacheUncheckedCreateWithoutTeamInput> | rankcacheCreateWithoutTeamInput[] | rankcacheUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: rankcacheCreateOrConnectWithoutTeamInput | rankcacheCreateOrConnectWithoutTeamInput[]
    upsert?: rankcacheUpsertWithWhereUniqueWithoutTeamInput | rankcacheUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: rankcacheCreateManyTeamInputEnvelope
    set?: rankcacheWhereUniqueInput | rankcacheWhereUniqueInput[]
    disconnect?: rankcacheWhereUniqueInput | rankcacheWhereUniqueInput[]
    delete?: rankcacheWhereUniqueInput | rankcacheWhereUniqueInput[]
    connect?: rankcacheWhereUniqueInput | rankcacheWhereUniqueInput[]
    update?: rankcacheUpdateWithWhereUniqueWithoutTeamInput | rankcacheUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: rankcacheUpdateManyWithWhereWithoutTeamInput | rankcacheUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: rankcacheScalarWhereInput | rankcacheScalarWhereInput[]
  }

  export type scorecacheUpdateManyWithoutTeamNestedInput = {
    create?: XOR<scorecacheCreateWithoutTeamInput, scorecacheUncheckedCreateWithoutTeamInput> | scorecacheCreateWithoutTeamInput[] | scorecacheUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: scorecacheCreateOrConnectWithoutTeamInput | scorecacheCreateOrConnectWithoutTeamInput[]
    upsert?: scorecacheUpsertWithWhereUniqueWithoutTeamInput | scorecacheUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: scorecacheCreateManyTeamInputEnvelope
    set?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    disconnect?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    delete?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    connect?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    update?: scorecacheUpdateWithWhereUniqueWithoutTeamInput | scorecacheUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: scorecacheUpdateManyWithWhereWithoutTeamInput | scorecacheUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: scorecacheScalarWhereInput | scorecacheScalarWhereInput[]
  }

  export type submissionUpdateManyWithoutTeamNestedInput = {
    create?: XOR<submissionCreateWithoutTeamInput, submissionUncheckedCreateWithoutTeamInput> | submissionCreateWithoutTeamInput[] | submissionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutTeamInput | submissionCreateOrConnectWithoutTeamInput[]
    upsert?: submissionUpsertWithWhereUniqueWithoutTeamInput | submissionUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: submissionCreateManyTeamInputEnvelope
    set?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    disconnect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    delete?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    update?: submissionUpdateWithWhereUniqueWithoutTeamInput | submissionUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: submissionUpdateManyWithWhereWithoutTeamInput | submissionUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: submissionScalarWhereInput | submissionScalarWhereInput[]
  }

  export type team_categoryUpdateOneWithoutTeamNestedInput = {
    create?: XOR<team_categoryCreateWithoutTeamInput, team_categoryUncheckedCreateWithoutTeamInput>
    connectOrCreate?: team_categoryCreateOrConnectWithoutTeamInput
    upsert?: team_categoryUpsertWithoutTeamInput
    disconnect?: team_categoryWhereInput | boolean
    delete?: team_categoryWhereInput | boolean
    connect?: team_categoryWhereUniqueInput
    update?: XOR<XOR<team_categoryUpdateToOneWithWhereWithoutTeamInput, team_categoryUpdateWithoutTeamInput>, team_categoryUncheckedUpdateWithoutTeamInput>
  }

  export type team_affiliationUpdateOneWithoutTeamNestedInput = {
    create?: XOR<team_affiliationCreateWithoutTeamInput, team_affiliationUncheckedCreateWithoutTeamInput>
    connectOrCreate?: team_affiliationCreateOrConnectWithoutTeamInput
    upsert?: team_affiliationUpsertWithoutTeamInput
    disconnect?: team_affiliationWhereInput | boolean
    delete?: team_affiliationWhereInput | boolean
    connect?: team_affiliationWhereUniqueInput
    update?: XOR<XOR<team_affiliationUpdateToOneWithWhereWithoutTeamInput, team_affiliationUpdateWithoutTeamInput>, team_affiliationUncheckedUpdateWithoutTeamInput>
  }

  export type team_unreadUpdateManyWithoutTeamNestedInput = {
    create?: XOR<team_unreadCreateWithoutTeamInput, team_unreadUncheckedCreateWithoutTeamInput> | team_unreadCreateWithoutTeamInput[] | team_unreadUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: team_unreadCreateOrConnectWithoutTeamInput | team_unreadCreateOrConnectWithoutTeamInput[]
    upsert?: team_unreadUpsertWithWhereUniqueWithoutTeamInput | team_unreadUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: team_unreadCreateManyTeamInputEnvelope
    set?: team_unreadWhereUniqueInput | team_unreadWhereUniqueInput[]
    disconnect?: team_unreadWhereUniqueInput | team_unreadWhereUniqueInput[]
    delete?: team_unreadWhereUniqueInput | team_unreadWhereUniqueInput[]
    connect?: team_unreadWhereUniqueInput | team_unreadWhereUniqueInput[]
    update?: team_unreadUpdateWithWhereUniqueWithoutTeamInput | team_unreadUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: team_unreadUpdateManyWithWhereWithoutTeamInput | team_unreadUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: team_unreadScalarWhereInput | team_unreadScalarWhereInput[]
  }

  export type userUpdateManyWithoutTeamNestedInput = {
    create?: XOR<userCreateWithoutTeamInput, userUncheckedCreateWithoutTeamInput> | userCreateWithoutTeamInput[] | userUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: userCreateOrConnectWithoutTeamInput | userCreateOrConnectWithoutTeamInput[]
    upsert?: userUpsertWithWhereUniqueWithoutTeamInput | userUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: userCreateManyTeamInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutTeamInput | userUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: userUpdateManyWithWhereWithoutTeamInput | userUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type clarificationUncheckedUpdateManyWithoutTeam_clarification_senderToteamNestedInput = {
    create?: XOR<clarificationCreateWithoutTeam_clarification_senderToteamInput, clarificationUncheckedCreateWithoutTeam_clarification_senderToteamInput> | clarificationCreateWithoutTeam_clarification_senderToteamInput[] | clarificationUncheckedCreateWithoutTeam_clarification_senderToteamInput[]
    connectOrCreate?: clarificationCreateOrConnectWithoutTeam_clarification_senderToteamInput | clarificationCreateOrConnectWithoutTeam_clarification_senderToteamInput[]
    upsert?: clarificationUpsertWithWhereUniqueWithoutTeam_clarification_senderToteamInput | clarificationUpsertWithWhereUniqueWithoutTeam_clarification_senderToteamInput[]
    createMany?: clarificationCreateManyTeam_clarification_senderToteamInputEnvelope
    set?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    disconnect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    delete?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    connect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    update?: clarificationUpdateWithWhereUniqueWithoutTeam_clarification_senderToteamInput | clarificationUpdateWithWhereUniqueWithoutTeam_clarification_senderToteamInput[]
    updateMany?: clarificationUpdateManyWithWhereWithoutTeam_clarification_senderToteamInput | clarificationUpdateManyWithWhereWithoutTeam_clarification_senderToteamInput[]
    deleteMany?: clarificationScalarWhereInput | clarificationScalarWhereInput[]
  }

  export type clarificationUncheckedUpdateManyWithoutTeam_clarification_recipientToteamNestedInput = {
    create?: XOR<clarificationCreateWithoutTeam_clarification_recipientToteamInput, clarificationUncheckedCreateWithoutTeam_clarification_recipientToteamInput> | clarificationCreateWithoutTeam_clarification_recipientToteamInput[] | clarificationUncheckedCreateWithoutTeam_clarification_recipientToteamInput[]
    connectOrCreate?: clarificationCreateOrConnectWithoutTeam_clarification_recipientToteamInput | clarificationCreateOrConnectWithoutTeam_clarification_recipientToteamInput[]
    upsert?: clarificationUpsertWithWhereUniqueWithoutTeam_clarification_recipientToteamInput | clarificationUpsertWithWhereUniqueWithoutTeam_clarification_recipientToteamInput[]
    createMany?: clarificationCreateManyTeam_clarification_recipientToteamInputEnvelope
    set?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    disconnect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    delete?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    connect?: clarificationWhereUniqueInput | clarificationWhereUniqueInput[]
    update?: clarificationUpdateWithWhereUniqueWithoutTeam_clarification_recipientToteamInput | clarificationUpdateWithWhereUniqueWithoutTeam_clarification_recipientToteamInput[]
    updateMany?: clarificationUpdateManyWithWhereWithoutTeam_clarification_recipientToteamInput | clarificationUpdateManyWithWhereWithoutTeam_clarification_recipientToteamInput[]
    deleteMany?: clarificationScalarWhereInput | clarificationScalarWhereInput[]
  }

  export type contestteamUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<contestteamCreateWithoutTeamInput, contestteamUncheckedCreateWithoutTeamInput> | contestteamCreateWithoutTeamInput[] | contestteamUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: contestteamCreateOrConnectWithoutTeamInput | contestteamCreateOrConnectWithoutTeamInput[]
    upsert?: contestteamUpsertWithWhereUniqueWithoutTeamInput | contestteamUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: contestteamCreateManyTeamInputEnvelope
    set?: contestteamWhereUniqueInput | contestteamWhereUniqueInput[]
    disconnect?: contestteamWhereUniqueInput | contestteamWhereUniqueInput[]
    delete?: contestteamWhereUniqueInput | contestteamWhereUniqueInput[]
    connect?: contestteamWhereUniqueInput | contestteamWhereUniqueInput[]
    update?: contestteamUpdateWithWhereUniqueWithoutTeamInput | contestteamUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: contestteamUpdateManyWithWhereWithoutTeamInput | contestteamUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: contestteamScalarWhereInput | contestteamScalarWhereInput[]
  }

  export type queuetaskUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<queuetaskCreateWithoutTeamInput, queuetaskUncheckedCreateWithoutTeamInput> | queuetaskCreateWithoutTeamInput[] | queuetaskUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: queuetaskCreateOrConnectWithoutTeamInput | queuetaskCreateOrConnectWithoutTeamInput[]
    upsert?: queuetaskUpsertWithWhereUniqueWithoutTeamInput | queuetaskUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: queuetaskCreateManyTeamInputEnvelope
    set?: queuetaskWhereUniqueInput | queuetaskWhereUniqueInput[]
    disconnect?: queuetaskWhereUniqueInput | queuetaskWhereUniqueInput[]
    delete?: queuetaskWhereUniqueInput | queuetaskWhereUniqueInput[]
    connect?: queuetaskWhereUniqueInput | queuetaskWhereUniqueInput[]
    update?: queuetaskUpdateWithWhereUniqueWithoutTeamInput | queuetaskUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: queuetaskUpdateManyWithWhereWithoutTeamInput | queuetaskUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: queuetaskScalarWhereInput | queuetaskScalarWhereInput[]
  }

  export type rankcacheUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<rankcacheCreateWithoutTeamInput, rankcacheUncheckedCreateWithoutTeamInput> | rankcacheCreateWithoutTeamInput[] | rankcacheUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: rankcacheCreateOrConnectWithoutTeamInput | rankcacheCreateOrConnectWithoutTeamInput[]
    upsert?: rankcacheUpsertWithWhereUniqueWithoutTeamInput | rankcacheUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: rankcacheCreateManyTeamInputEnvelope
    set?: rankcacheWhereUniqueInput | rankcacheWhereUniqueInput[]
    disconnect?: rankcacheWhereUniqueInput | rankcacheWhereUniqueInput[]
    delete?: rankcacheWhereUniqueInput | rankcacheWhereUniqueInput[]
    connect?: rankcacheWhereUniqueInput | rankcacheWhereUniqueInput[]
    update?: rankcacheUpdateWithWhereUniqueWithoutTeamInput | rankcacheUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: rankcacheUpdateManyWithWhereWithoutTeamInput | rankcacheUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: rankcacheScalarWhereInput | rankcacheScalarWhereInput[]
  }

  export type scorecacheUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<scorecacheCreateWithoutTeamInput, scorecacheUncheckedCreateWithoutTeamInput> | scorecacheCreateWithoutTeamInput[] | scorecacheUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: scorecacheCreateOrConnectWithoutTeamInput | scorecacheCreateOrConnectWithoutTeamInput[]
    upsert?: scorecacheUpsertWithWhereUniqueWithoutTeamInput | scorecacheUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: scorecacheCreateManyTeamInputEnvelope
    set?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    disconnect?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    delete?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    connect?: scorecacheWhereUniqueInput | scorecacheWhereUniqueInput[]
    update?: scorecacheUpdateWithWhereUniqueWithoutTeamInput | scorecacheUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: scorecacheUpdateManyWithWhereWithoutTeamInput | scorecacheUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: scorecacheScalarWhereInput | scorecacheScalarWhereInput[]
  }

  export type submissionUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<submissionCreateWithoutTeamInput, submissionUncheckedCreateWithoutTeamInput> | submissionCreateWithoutTeamInput[] | submissionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutTeamInput | submissionCreateOrConnectWithoutTeamInput[]
    upsert?: submissionUpsertWithWhereUniqueWithoutTeamInput | submissionUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: submissionCreateManyTeamInputEnvelope
    set?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    disconnect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    delete?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    update?: submissionUpdateWithWhereUniqueWithoutTeamInput | submissionUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: submissionUpdateManyWithWhereWithoutTeamInput | submissionUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: submissionScalarWhereInput | submissionScalarWhereInput[]
  }

  export type team_unreadUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<team_unreadCreateWithoutTeamInput, team_unreadUncheckedCreateWithoutTeamInput> | team_unreadCreateWithoutTeamInput[] | team_unreadUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: team_unreadCreateOrConnectWithoutTeamInput | team_unreadCreateOrConnectWithoutTeamInput[]
    upsert?: team_unreadUpsertWithWhereUniqueWithoutTeamInput | team_unreadUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: team_unreadCreateManyTeamInputEnvelope
    set?: team_unreadWhereUniqueInput | team_unreadWhereUniqueInput[]
    disconnect?: team_unreadWhereUniqueInput | team_unreadWhereUniqueInput[]
    delete?: team_unreadWhereUniqueInput | team_unreadWhereUniqueInput[]
    connect?: team_unreadWhereUniqueInput | team_unreadWhereUniqueInput[]
    update?: team_unreadUpdateWithWhereUniqueWithoutTeamInput | team_unreadUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: team_unreadUpdateManyWithWhereWithoutTeamInput | team_unreadUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: team_unreadScalarWhereInput | team_unreadScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<userCreateWithoutTeamInput, userUncheckedCreateWithoutTeamInput> | userCreateWithoutTeamInput[] | userUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: userCreateOrConnectWithoutTeamInput | userCreateOrConnectWithoutTeamInput[]
    upsert?: userUpsertWithWhereUniqueWithoutTeamInput | userUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: userCreateManyTeamInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutTeamInput | userUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: userUpdateManyWithWhereWithoutTeamInput | userUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type teamCreateNestedManyWithoutTeam_affiliationInput = {
    create?: XOR<teamCreateWithoutTeam_affiliationInput, teamUncheckedCreateWithoutTeam_affiliationInput> | teamCreateWithoutTeam_affiliationInput[] | teamUncheckedCreateWithoutTeam_affiliationInput[]
    connectOrCreate?: teamCreateOrConnectWithoutTeam_affiliationInput | teamCreateOrConnectWithoutTeam_affiliationInput[]
    createMany?: teamCreateManyTeam_affiliationInputEnvelope
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
  }

  export type teamUncheckedCreateNestedManyWithoutTeam_affiliationInput = {
    create?: XOR<teamCreateWithoutTeam_affiliationInput, teamUncheckedCreateWithoutTeam_affiliationInput> | teamCreateWithoutTeam_affiliationInput[] | teamUncheckedCreateWithoutTeam_affiliationInput[]
    connectOrCreate?: teamCreateOrConnectWithoutTeam_affiliationInput | teamCreateOrConnectWithoutTeam_affiliationInput[]
    createMany?: teamCreateManyTeam_affiliationInputEnvelope
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
  }

  export type teamUpdateManyWithoutTeam_affiliationNestedInput = {
    create?: XOR<teamCreateWithoutTeam_affiliationInput, teamUncheckedCreateWithoutTeam_affiliationInput> | teamCreateWithoutTeam_affiliationInput[] | teamUncheckedCreateWithoutTeam_affiliationInput[]
    connectOrCreate?: teamCreateOrConnectWithoutTeam_affiliationInput | teamCreateOrConnectWithoutTeam_affiliationInput[]
    upsert?: teamUpsertWithWhereUniqueWithoutTeam_affiliationInput | teamUpsertWithWhereUniqueWithoutTeam_affiliationInput[]
    createMany?: teamCreateManyTeam_affiliationInputEnvelope
    set?: teamWhereUniqueInput | teamWhereUniqueInput[]
    disconnect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    delete?: teamWhereUniqueInput | teamWhereUniqueInput[]
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    update?: teamUpdateWithWhereUniqueWithoutTeam_affiliationInput | teamUpdateWithWhereUniqueWithoutTeam_affiliationInput[]
    updateMany?: teamUpdateManyWithWhereWithoutTeam_affiliationInput | teamUpdateManyWithWhereWithoutTeam_affiliationInput[]
    deleteMany?: teamScalarWhereInput | teamScalarWhereInput[]
  }

  export type teamUncheckedUpdateManyWithoutTeam_affiliationNestedInput = {
    create?: XOR<teamCreateWithoutTeam_affiliationInput, teamUncheckedCreateWithoutTeam_affiliationInput> | teamCreateWithoutTeam_affiliationInput[] | teamUncheckedCreateWithoutTeam_affiliationInput[]
    connectOrCreate?: teamCreateOrConnectWithoutTeam_affiliationInput | teamCreateOrConnectWithoutTeam_affiliationInput[]
    upsert?: teamUpsertWithWhereUniqueWithoutTeam_affiliationInput | teamUpsertWithWhereUniqueWithoutTeam_affiliationInput[]
    createMany?: teamCreateManyTeam_affiliationInputEnvelope
    set?: teamWhereUniqueInput | teamWhereUniqueInput[]
    disconnect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    delete?: teamWhereUniqueInput | teamWhereUniqueInput[]
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    update?: teamUpdateWithWhereUniqueWithoutTeam_affiliationInput | teamUpdateWithWhereUniqueWithoutTeam_affiliationInput[]
    updateMany?: teamUpdateManyWithWhereWithoutTeam_affiliationInput | teamUpdateManyWithWhereWithoutTeam_affiliationInput[]
    deleteMany?: teamScalarWhereInput | teamScalarWhereInput[]
  }

  export type contestteamcategoryCreateNestedManyWithoutTeam_categoryInput = {
    create?: XOR<contestteamcategoryCreateWithoutTeam_categoryInput, contestteamcategoryUncheckedCreateWithoutTeam_categoryInput> | contestteamcategoryCreateWithoutTeam_categoryInput[] | contestteamcategoryUncheckedCreateWithoutTeam_categoryInput[]
    connectOrCreate?: contestteamcategoryCreateOrConnectWithoutTeam_categoryInput | contestteamcategoryCreateOrConnectWithoutTeam_categoryInput[]
    createMany?: contestteamcategoryCreateManyTeam_categoryInputEnvelope
    connect?: contestteamcategoryWhereUniqueInput | contestteamcategoryWhereUniqueInput[]
  }

  export type contestteamcategoryformedalsCreateNestedManyWithoutTeam_categoryInput = {
    create?: XOR<contestteamcategoryformedalsCreateWithoutTeam_categoryInput, contestteamcategoryformedalsUncheckedCreateWithoutTeam_categoryInput> | contestteamcategoryformedalsCreateWithoutTeam_categoryInput[] | contestteamcategoryformedalsUncheckedCreateWithoutTeam_categoryInput[]
    connectOrCreate?: contestteamcategoryformedalsCreateOrConnectWithoutTeam_categoryInput | contestteamcategoryformedalsCreateOrConnectWithoutTeam_categoryInput[]
    createMany?: contestteamcategoryformedalsCreateManyTeam_categoryInputEnvelope
    connect?: contestteamcategoryformedalsWhereUniqueInput | contestteamcategoryformedalsWhereUniqueInput[]
  }

  export type teamCreateNestedManyWithoutTeam_categoryInput = {
    create?: XOR<teamCreateWithoutTeam_categoryInput, teamUncheckedCreateWithoutTeam_categoryInput> | teamCreateWithoutTeam_categoryInput[] | teamUncheckedCreateWithoutTeam_categoryInput[]
    connectOrCreate?: teamCreateOrConnectWithoutTeam_categoryInput | teamCreateOrConnectWithoutTeam_categoryInput[]
    createMany?: teamCreateManyTeam_categoryInputEnvelope
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
  }

  export type contestteamcategoryUncheckedCreateNestedManyWithoutTeam_categoryInput = {
    create?: XOR<contestteamcategoryCreateWithoutTeam_categoryInput, contestteamcategoryUncheckedCreateWithoutTeam_categoryInput> | contestteamcategoryCreateWithoutTeam_categoryInput[] | contestteamcategoryUncheckedCreateWithoutTeam_categoryInput[]
    connectOrCreate?: contestteamcategoryCreateOrConnectWithoutTeam_categoryInput | contestteamcategoryCreateOrConnectWithoutTeam_categoryInput[]
    createMany?: contestteamcategoryCreateManyTeam_categoryInputEnvelope
    connect?: contestteamcategoryWhereUniqueInput | contestteamcategoryWhereUniqueInput[]
  }

  export type contestteamcategoryformedalsUncheckedCreateNestedManyWithoutTeam_categoryInput = {
    create?: XOR<contestteamcategoryformedalsCreateWithoutTeam_categoryInput, contestteamcategoryformedalsUncheckedCreateWithoutTeam_categoryInput> | contestteamcategoryformedalsCreateWithoutTeam_categoryInput[] | contestteamcategoryformedalsUncheckedCreateWithoutTeam_categoryInput[]
    connectOrCreate?: contestteamcategoryformedalsCreateOrConnectWithoutTeam_categoryInput | contestteamcategoryformedalsCreateOrConnectWithoutTeam_categoryInput[]
    createMany?: contestteamcategoryformedalsCreateManyTeam_categoryInputEnvelope
    connect?: contestteamcategoryformedalsWhereUniqueInput | contestteamcategoryformedalsWhereUniqueInput[]
  }

  export type teamUncheckedCreateNestedManyWithoutTeam_categoryInput = {
    create?: XOR<teamCreateWithoutTeam_categoryInput, teamUncheckedCreateWithoutTeam_categoryInput> | teamCreateWithoutTeam_categoryInput[] | teamUncheckedCreateWithoutTeam_categoryInput[]
    connectOrCreate?: teamCreateOrConnectWithoutTeam_categoryInput | teamCreateOrConnectWithoutTeam_categoryInput[]
    createMany?: teamCreateManyTeam_categoryInputEnvelope
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
  }

  export type contestteamcategoryUpdateManyWithoutTeam_categoryNestedInput = {
    create?: XOR<contestteamcategoryCreateWithoutTeam_categoryInput, contestteamcategoryUncheckedCreateWithoutTeam_categoryInput> | contestteamcategoryCreateWithoutTeam_categoryInput[] | contestteamcategoryUncheckedCreateWithoutTeam_categoryInput[]
    connectOrCreate?: contestteamcategoryCreateOrConnectWithoutTeam_categoryInput | contestteamcategoryCreateOrConnectWithoutTeam_categoryInput[]
    upsert?: contestteamcategoryUpsertWithWhereUniqueWithoutTeam_categoryInput | contestteamcategoryUpsertWithWhereUniqueWithoutTeam_categoryInput[]
    createMany?: contestteamcategoryCreateManyTeam_categoryInputEnvelope
    set?: contestteamcategoryWhereUniqueInput | contestteamcategoryWhereUniqueInput[]
    disconnect?: contestteamcategoryWhereUniqueInput | contestteamcategoryWhereUniqueInput[]
    delete?: contestteamcategoryWhereUniqueInput | contestteamcategoryWhereUniqueInput[]
    connect?: contestteamcategoryWhereUniqueInput | contestteamcategoryWhereUniqueInput[]
    update?: contestteamcategoryUpdateWithWhereUniqueWithoutTeam_categoryInput | contestteamcategoryUpdateWithWhereUniqueWithoutTeam_categoryInput[]
    updateMany?: contestteamcategoryUpdateManyWithWhereWithoutTeam_categoryInput | contestteamcategoryUpdateManyWithWhereWithoutTeam_categoryInput[]
    deleteMany?: contestteamcategoryScalarWhereInput | contestteamcategoryScalarWhereInput[]
  }

  export type contestteamcategoryformedalsUpdateManyWithoutTeam_categoryNestedInput = {
    create?: XOR<contestteamcategoryformedalsCreateWithoutTeam_categoryInput, contestteamcategoryformedalsUncheckedCreateWithoutTeam_categoryInput> | contestteamcategoryformedalsCreateWithoutTeam_categoryInput[] | contestteamcategoryformedalsUncheckedCreateWithoutTeam_categoryInput[]
    connectOrCreate?: contestteamcategoryformedalsCreateOrConnectWithoutTeam_categoryInput | contestteamcategoryformedalsCreateOrConnectWithoutTeam_categoryInput[]
    upsert?: contestteamcategoryformedalsUpsertWithWhereUniqueWithoutTeam_categoryInput | contestteamcategoryformedalsUpsertWithWhereUniqueWithoutTeam_categoryInput[]
    createMany?: contestteamcategoryformedalsCreateManyTeam_categoryInputEnvelope
    set?: contestteamcategoryformedalsWhereUniqueInput | contestteamcategoryformedalsWhereUniqueInput[]
    disconnect?: contestteamcategoryformedalsWhereUniqueInput | contestteamcategoryformedalsWhereUniqueInput[]
    delete?: contestteamcategoryformedalsWhereUniqueInput | contestteamcategoryformedalsWhereUniqueInput[]
    connect?: contestteamcategoryformedalsWhereUniqueInput | contestteamcategoryformedalsWhereUniqueInput[]
    update?: contestteamcategoryformedalsUpdateWithWhereUniqueWithoutTeam_categoryInput | contestteamcategoryformedalsUpdateWithWhereUniqueWithoutTeam_categoryInput[]
    updateMany?: contestteamcategoryformedalsUpdateManyWithWhereWithoutTeam_categoryInput | contestteamcategoryformedalsUpdateManyWithWhereWithoutTeam_categoryInput[]
    deleteMany?: contestteamcategoryformedalsScalarWhereInput | contestteamcategoryformedalsScalarWhereInput[]
  }

  export type teamUpdateManyWithoutTeam_categoryNestedInput = {
    create?: XOR<teamCreateWithoutTeam_categoryInput, teamUncheckedCreateWithoutTeam_categoryInput> | teamCreateWithoutTeam_categoryInput[] | teamUncheckedCreateWithoutTeam_categoryInput[]
    connectOrCreate?: teamCreateOrConnectWithoutTeam_categoryInput | teamCreateOrConnectWithoutTeam_categoryInput[]
    upsert?: teamUpsertWithWhereUniqueWithoutTeam_categoryInput | teamUpsertWithWhereUniqueWithoutTeam_categoryInput[]
    createMany?: teamCreateManyTeam_categoryInputEnvelope
    set?: teamWhereUniqueInput | teamWhereUniqueInput[]
    disconnect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    delete?: teamWhereUniqueInput | teamWhereUniqueInput[]
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    update?: teamUpdateWithWhereUniqueWithoutTeam_categoryInput | teamUpdateWithWhereUniqueWithoutTeam_categoryInput[]
    updateMany?: teamUpdateManyWithWhereWithoutTeam_categoryInput | teamUpdateManyWithWhereWithoutTeam_categoryInput[]
    deleteMany?: teamScalarWhereInput | teamScalarWhereInput[]
  }

  export type contestteamcategoryUncheckedUpdateManyWithoutTeam_categoryNestedInput = {
    create?: XOR<contestteamcategoryCreateWithoutTeam_categoryInput, contestteamcategoryUncheckedCreateWithoutTeam_categoryInput> | contestteamcategoryCreateWithoutTeam_categoryInput[] | contestteamcategoryUncheckedCreateWithoutTeam_categoryInput[]
    connectOrCreate?: contestteamcategoryCreateOrConnectWithoutTeam_categoryInput | contestteamcategoryCreateOrConnectWithoutTeam_categoryInput[]
    upsert?: contestteamcategoryUpsertWithWhereUniqueWithoutTeam_categoryInput | contestteamcategoryUpsertWithWhereUniqueWithoutTeam_categoryInput[]
    createMany?: contestteamcategoryCreateManyTeam_categoryInputEnvelope
    set?: contestteamcategoryWhereUniqueInput | contestteamcategoryWhereUniqueInput[]
    disconnect?: contestteamcategoryWhereUniqueInput | contestteamcategoryWhereUniqueInput[]
    delete?: contestteamcategoryWhereUniqueInput | contestteamcategoryWhereUniqueInput[]
    connect?: contestteamcategoryWhereUniqueInput | contestteamcategoryWhereUniqueInput[]
    update?: contestteamcategoryUpdateWithWhereUniqueWithoutTeam_categoryInput | contestteamcategoryUpdateWithWhereUniqueWithoutTeam_categoryInput[]
    updateMany?: contestteamcategoryUpdateManyWithWhereWithoutTeam_categoryInput | contestteamcategoryUpdateManyWithWhereWithoutTeam_categoryInput[]
    deleteMany?: contestteamcategoryScalarWhereInput | contestteamcategoryScalarWhereInput[]
  }

  export type contestteamcategoryformedalsUncheckedUpdateManyWithoutTeam_categoryNestedInput = {
    create?: XOR<contestteamcategoryformedalsCreateWithoutTeam_categoryInput, contestteamcategoryformedalsUncheckedCreateWithoutTeam_categoryInput> | contestteamcategoryformedalsCreateWithoutTeam_categoryInput[] | contestteamcategoryformedalsUncheckedCreateWithoutTeam_categoryInput[]
    connectOrCreate?: contestteamcategoryformedalsCreateOrConnectWithoutTeam_categoryInput | contestteamcategoryformedalsCreateOrConnectWithoutTeam_categoryInput[]
    upsert?: contestteamcategoryformedalsUpsertWithWhereUniqueWithoutTeam_categoryInput | contestteamcategoryformedalsUpsertWithWhereUniqueWithoutTeam_categoryInput[]
    createMany?: contestteamcategoryformedalsCreateManyTeam_categoryInputEnvelope
    set?: contestteamcategoryformedalsWhereUniqueInput | contestteamcategoryformedalsWhereUniqueInput[]
    disconnect?: contestteamcategoryformedalsWhereUniqueInput | contestteamcategoryformedalsWhereUniqueInput[]
    delete?: contestteamcategoryformedalsWhereUniqueInput | contestteamcategoryformedalsWhereUniqueInput[]
    connect?: contestteamcategoryformedalsWhereUniqueInput | contestteamcategoryformedalsWhereUniqueInput[]
    update?: contestteamcategoryformedalsUpdateWithWhereUniqueWithoutTeam_categoryInput | contestteamcategoryformedalsUpdateWithWhereUniqueWithoutTeam_categoryInput[]
    updateMany?: contestteamcategoryformedalsUpdateManyWithWhereWithoutTeam_categoryInput | contestteamcategoryformedalsUpdateManyWithWhereWithoutTeam_categoryInput[]
    deleteMany?: contestteamcategoryformedalsScalarWhereInput | contestteamcategoryformedalsScalarWhereInput[]
  }

  export type teamUncheckedUpdateManyWithoutTeam_categoryNestedInput = {
    create?: XOR<teamCreateWithoutTeam_categoryInput, teamUncheckedCreateWithoutTeam_categoryInput> | teamCreateWithoutTeam_categoryInput[] | teamUncheckedCreateWithoutTeam_categoryInput[]
    connectOrCreate?: teamCreateOrConnectWithoutTeam_categoryInput | teamCreateOrConnectWithoutTeam_categoryInput[]
    upsert?: teamUpsertWithWhereUniqueWithoutTeam_categoryInput | teamUpsertWithWhereUniqueWithoutTeam_categoryInput[]
    createMany?: teamCreateManyTeam_categoryInputEnvelope
    set?: teamWhereUniqueInput | teamWhereUniqueInput[]
    disconnect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    delete?: teamWhereUniqueInput | teamWhereUniqueInput[]
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    update?: teamUpdateWithWhereUniqueWithoutTeam_categoryInput | teamUpdateWithWhereUniqueWithoutTeam_categoryInput[]
    updateMany?: teamUpdateManyWithWhereWithoutTeam_categoryInput | teamUpdateManyWithWhereWithoutTeam_categoryInput[]
    deleteMany?: teamScalarWhereInput | teamScalarWhereInput[]
  }

  export type teamCreateNestedOneWithoutTeam_unreadInput = {
    create?: XOR<teamCreateWithoutTeam_unreadInput, teamUncheckedCreateWithoutTeam_unreadInput>
    connectOrCreate?: teamCreateOrConnectWithoutTeam_unreadInput
    connect?: teamWhereUniqueInput
  }

  export type clarificationCreateNestedOneWithoutTeam_unreadInput = {
    create?: XOR<clarificationCreateWithoutTeam_unreadInput, clarificationUncheckedCreateWithoutTeam_unreadInput>
    connectOrCreate?: clarificationCreateOrConnectWithoutTeam_unreadInput
    connect?: clarificationWhereUniqueInput
  }

  export type teamUpdateOneRequiredWithoutTeam_unreadNestedInput = {
    create?: XOR<teamCreateWithoutTeam_unreadInput, teamUncheckedCreateWithoutTeam_unreadInput>
    connectOrCreate?: teamCreateOrConnectWithoutTeam_unreadInput
    upsert?: teamUpsertWithoutTeam_unreadInput
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutTeam_unreadInput, teamUpdateWithoutTeam_unreadInput>, teamUncheckedUpdateWithoutTeam_unreadInput>
  }

  export type clarificationUpdateOneRequiredWithoutTeam_unreadNestedInput = {
    create?: XOR<clarificationCreateWithoutTeam_unreadInput, clarificationUncheckedCreateWithoutTeam_unreadInput>
    connectOrCreate?: clarificationCreateOrConnectWithoutTeam_unreadInput
    upsert?: clarificationUpsertWithoutTeam_unreadInput
    connect?: clarificationWhereUniqueInput
    update?: XOR<XOR<clarificationUpdateToOneWithWhereWithoutTeam_unreadInput, clarificationUpdateWithoutTeam_unreadInput>, clarificationUncheckedUpdateWithoutTeam_unreadInput>
  }

  export type external_runCreateNestedManyWithoutTestcaseInput = {
    create?: XOR<external_runCreateWithoutTestcaseInput, external_runUncheckedCreateWithoutTestcaseInput> | external_runCreateWithoutTestcaseInput[] | external_runUncheckedCreateWithoutTestcaseInput[]
    connectOrCreate?: external_runCreateOrConnectWithoutTestcaseInput | external_runCreateOrConnectWithoutTestcaseInput[]
    createMany?: external_runCreateManyTestcaseInputEnvelope
    connect?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
  }

  export type judging_runCreateNestedManyWithoutTestcaseInput = {
    create?: XOR<judging_runCreateWithoutTestcaseInput, judging_runUncheckedCreateWithoutTestcaseInput> | judging_runCreateWithoutTestcaseInput[] | judging_runUncheckedCreateWithoutTestcaseInput[]
    connectOrCreate?: judging_runCreateOrConnectWithoutTestcaseInput | judging_runCreateOrConnectWithoutTestcaseInput[]
    createMany?: judging_runCreateManyTestcaseInputEnvelope
    connect?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
  }

  export type problemCreateNestedOneWithoutTestcaseInput = {
    create?: XOR<problemCreateWithoutTestcaseInput, problemUncheckedCreateWithoutTestcaseInput>
    connectOrCreate?: problemCreateOrConnectWithoutTestcaseInput
    connect?: problemWhereUniqueInput
  }

  export type testcase_contentCreateNestedManyWithoutTestcaseInput = {
    create?: XOR<testcase_contentCreateWithoutTestcaseInput, testcase_contentUncheckedCreateWithoutTestcaseInput> | testcase_contentCreateWithoutTestcaseInput[] | testcase_contentUncheckedCreateWithoutTestcaseInput[]
    connectOrCreate?: testcase_contentCreateOrConnectWithoutTestcaseInput | testcase_contentCreateOrConnectWithoutTestcaseInput[]
    createMany?: testcase_contentCreateManyTestcaseInputEnvelope
    connect?: testcase_contentWhereUniqueInput | testcase_contentWhereUniqueInput[]
  }

  export type external_runUncheckedCreateNestedManyWithoutTestcaseInput = {
    create?: XOR<external_runCreateWithoutTestcaseInput, external_runUncheckedCreateWithoutTestcaseInput> | external_runCreateWithoutTestcaseInput[] | external_runUncheckedCreateWithoutTestcaseInput[]
    connectOrCreate?: external_runCreateOrConnectWithoutTestcaseInput | external_runCreateOrConnectWithoutTestcaseInput[]
    createMany?: external_runCreateManyTestcaseInputEnvelope
    connect?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
  }

  export type judging_runUncheckedCreateNestedManyWithoutTestcaseInput = {
    create?: XOR<judging_runCreateWithoutTestcaseInput, judging_runUncheckedCreateWithoutTestcaseInput> | judging_runCreateWithoutTestcaseInput[] | judging_runUncheckedCreateWithoutTestcaseInput[]
    connectOrCreate?: judging_runCreateOrConnectWithoutTestcaseInput | judging_runCreateOrConnectWithoutTestcaseInput[]
    createMany?: judging_runCreateManyTestcaseInputEnvelope
    connect?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
  }

  export type testcase_contentUncheckedCreateNestedManyWithoutTestcaseInput = {
    create?: XOR<testcase_contentCreateWithoutTestcaseInput, testcase_contentUncheckedCreateWithoutTestcaseInput> | testcase_contentCreateWithoutTestcaseInput[] | testcase_contentUncheckedCreateWithoutTestcaseInput[]
    connectOrCreate?: testcase_contentCreateOrConnectWithoutTestcaseInput | testcase_contentCreateOrConnectWithoutTestcaseInput[]
    createMany?: testcase_contentCreateManyTestcaseInputEnvelope
    connect?: testcase_contentWhereUniqueInput | testcase_contentWhereUniqueInput[]
  }

  export type external_runUpdateManyWithoutTestcaseNestedInput = {
    create?: XOR<external_runCreateWithoutTestcaseInput, external_runUncheckedCreateWithoutTestcaseInput> | external_runCreateWithoutTestcaseInput[] | external_runUncheckedCreateWithoutTestcaseInput[]
    connectOrCreate?: external_runCreateOrConnectWithoutTestcaseInput | external_runCreateOrConnectWithoutTestcaseInput[]
    upsert?: external_runUpsertWithWhereUniqueWithoutTestcaseInput | external_runUpsertWithWhereUniqueWithoutTestcaseInput[]
    createMany?: external_runCreateManyTestcaseInputEnvelope
    set?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    disconnect?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    delete?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    connect?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    update?: external_runUpdateWithWhereUniqueWithoutTestcaseInput | external_runUpdateWithWhereUniqueWithoutTestcaseInput[]
    updateMany?: external_runUpdateManyWithWhereWithoutTestcaseInput | external_runUpdateManyWithWhereWithoutTestcaseInput[]
    deleteMany?: external_runScalarWhereInput | external_runScalarWhereInput[]
  }

  export type judging_runUpdateManyWithoutTestcaseNestedInput = {
    create?: XOR<judging_runCreateWithoutTestcaseInput, judging_runUncheckedCreateWithoutTestcaseInput> | judging_runCreateWithoutTestcaseInput[] | judging_runUncheckedCreateWithoutTestcaseInput[]
    connectOrCreate?: judging_runCreateOrConnectWithoutTestcaseInput | judging_runCreateOrConnectWithoutTestcaseInput[]
    upsert?: judging_runUpsertWithWhereUniqueWithoutTestcaseInput | judging_runUpsertWithWhereUniqueWithoutTestcaseInput[]
    createMany?: judging_runCreateManyTestcaseInputEnvelope
    set?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    disconnect?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    delete?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    connect?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    update?: judging_runUpdateWithWhereUniqueWithoutTestcaseInput | judging_runUpdateWithWhereUniqueWithoutTestcaseInput[]
    updateMany?: judging_runUpdateManyWithWhereWithoutTestcaseInput | judging_runUpdateManyWithWhereWithoutTestcaseInput[]
    deleteMany?: judging_runScalarWhereInput | judging_runScalarWhereInput[]
  }

  export type problemUpdateOneWithoutTestcaseNestedInput = {
    create?: XOR<problemCreateWithoutTestcaseInput, problemUncheckedCreateWithoutTestcaseInput>
    connectOrCreate?: problemCreateOrConnectWithoutTestcaseInput
    upsert?: problemUpsertWithoutTestcaseInput
    disconnect?: problemWhereInput | boolean
    delete?: problemWhereInput | boolean
    connect?: problemWhereUniqueInput
    update?: XOR<XOR<problemUpdateToOneWithWhereWithoutTestcaseInput, problemUpdateWithoutTestcaseInput>, problemUncheckedUpdateWithoutTestcaseInput>
  }

  export type testcase_contentUpdateManyWithoutTestcaseNestedInput = {
    create?: XOR<testcase_contentCreateWithoutTestcaseInput, testcase_contentUncheckedCreateWithoutTestcaseInput> | testcase_contentCreateWithoutTestcaseInput[] | testcase_contentUncheckedCreateWithoutTestcaseInput[]
    connectOrCreate?: testcase_contentCreateOrConnectWithoutTestcaseInput | testcase_contentCreateOrConnectWithoutTestcaseInput[]
    upsert?: testcase_contentUpsertWithWhereUniqueWithoutTestcaseInput | testcase_contentUpsertWithWhereUniqueWithoutTestcaseInput[]
    createMany?: testcase_contentCreateManyTestcaseInputEnvelope
    set?: testcase_contentWhereUniqueInput | testcase_contentWhereUniqueInput[]
    disconnect?: testcase_contentWhereUniqueInput | testcase_contentWhereUniqueInput[]
    delete?: testcase_contentWhereUniqueInput | testcase_contentWhereUniqueInput[]
    connect?: testcase_contentWhereUniqueInput | testcase_contentWhereUniqueInput[]
    update?: testcase_contentUpdateWithWhereUniqueWithoutTestcaseInput | testcase_contentUpdateWithWhereUniqueWithoutTestcaseInput[]
    updateMany?: testcase_contentUpdateManyWithWhereWithoutTestcaseInput | testcase_contentUpdateManyWithWhereWithoutTestcaseInput[]
    deleteMany?: testcase_contentScalarWhereInput | testcase_contentScalarWhereInput[]
  }

  export type external_runUncheckedUpdateManyWithoutTestcaseNestedInput = {
    create?: XOR<external_runCreateWithoutTestcaseInput, external_runUncheckedCreateWithoutTestcaseInput> | external_runCreateWithoutTestcaseInput[] | external_runUncheckedCreateWithoutTestcaseInput[]
    connectOrCreate?: external_runCreateOrConnectWithoutTestcaseInput | external_runCreateOrConnectWithoutTestcaseInput[]
    upsert?: external_runUpsertWithWhereUniqueWithoutTestcaseInput | external_runUpsertWithWhereUniqueWithoutTestcaseInput[]
    createMany?: external_runCreateManyTestcaseInputEnvelope
    set?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    disconnect?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    delete?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    connect?: external_runWhereUniqueInput | external_runWhereUniqueInput[]
    update?: external_runUpdateWithWhereUniqueWithoutTestcaseInput | external_runUpdateWithWhereUniqueWithoutTestcaseInput[]
    updateMany?: external_runUpdateManyWithWhereWithoutTestcaseInput | external_runUpdateManyWithWhereWithoutTestcaseInput[]
    deleteMany?: external_runScalarWhereInput | external_runScalarWhereInput[]
  }

  export type judging_runUncheckedUpdateManyWithoutTestcaseNestedInput = {
    create?: XOR<judging_runCreateWithoutTestcaseInput, judging_runUncheckedCreateWithoutTestcaseInput> | judging_runCreateWithoutTestcaseInput[] | judging_runUncheckedCreateWithoutTestcaseInput[]
    connectOrCreate?: judging_runCreateOrConnectWithoutTestcaseInput | judging_runCreateOrConnectWithoutTestcaseInput[]
    upsert?: judging_runUpsertWithWhereUniqueWithoutTestcaseInput | judging_runUpsertWithWhereUniqueWithoutTestcaseInput[]
    createMany?: judging_runCreateManyTestcaseInputEnvelope
    set?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    disconnect?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    delete?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    connect?: judging_runWhereUniqueInput | judging_runWhereUniqueInput[]
    update?: judging_runUpdateWithWhereUniqueWithoutTestcaseInput | judging_runUpdateWithWhereUniqueWithoutTestcaseInput[]
    updateMany?: judging_runUpdateManyWithWhereWithoutTestcaseInput | judging_runUpdateManyWithWhereWithoutTestcaseInput[]
    deleteMany?: judging_runScalarWhereInput | judging_runScalarWhereInput[]
  }

  export type testcase_contentUncheckedUpdateManyWithoutTestcaseNestedInput = {
    create?: XOR<testcase_contentCreateWithoutTestcaseInput, testcase_contentUncheckedCreateWithoutTestcaseInput> | testcase_contentCreateWithoutTestcaseInput[] | testcase_contentUncheckedCreateWithoutTestcaseInput[]
    connectOrCreate?: testcase_contentCreateOrConnectWithoutTestcaseInput | testcase_contentCreateOrConnectWithoutTestcaseInput[]
    upsert?: testcase_contentUpsertWithWhereUniqueWithoutTestcaseInput | testcase_contentUpsertWithWhereUniqueWithoutTestcaseInput[]
    createMany?: testcase_contentCreateManyTestcaseInputEnvelope
    set?: testcase_contentWhereUniqueInput | testcase_contentWhereUniqueInput[]
    disconnect?: testcase_contentWhereUniqueInput | testcase_contentWhereUniqueInput[]
    delete?: testcase_contentWhereUniqueInput | testcase_contentWhereUniqueInput[]
    connect?: testcase_contentWhereUniqueInput | testcase_contentWhereUniqueInput[]
    update?: testcase_contentUpdateWithWhereUniqueWithoutTestcaseInput | testcase_contentUpdateWithWhereUniqueWithoutTestcaseInput[]
    updateMany?: testcase_contentUpdateManyWithWhereWithoutTestcaseInput | testcase_contentUpdateManyWithWhereWithoutTestcaseInput[]
    deleteMany?: testcase_contentScalarWhereInput | testcase_contentScalarWhereInput[]
  }

  export type testcaseCreateNestedOneWithoutTestcase_contentInput = {
    create?: XOR<testcaseCreateWithoutTestcase_contentInput, testcaseUncheckedCreateWithoutTestcase_contentInput>
    connectOrCreate?: testcaseCreateOrConnectWithoutTestcase_contentInput
    connect?: testcaseWhereUniqueInput
  }

  export type testcaseUpdateOneWithoutTestcase_contentNestedInput = {
    create?: XOR<testcaseCreateWithoutTestcase_contentInput, testcaseUncheckedCreateWithoutTestcase_contentInput>
    connectOrCreate?: testcaseCreateOrConnectWithoutTestcase_contentInput
    upsert?: testcaseUpsertWithoutTestcase_contentInput
    disconnect?: testcaseWhereInput | boolean
    delete?: testcaseWhereInput | boolean
    connect?: testcaseWhereUniqueInput
    update?: XOR<XOR<testcaseUpdateToOneWithWhereWithoutTestcase_contentInput, testcaseUpdateWithoutTestcase_contentInput>, testcaseUncheckedUpdateWithoutTestcase_contentInput>
  }

  export type immutable_executableCreateNestedManyWithoutUserInput = {
    create?: XOR<immutable_executableCreateWithoutUserInput, immutable_executableUncheckedCreateWithoutUserInput> | immutable_executableCreateWithoutUserInput[] | immutable_executableUncheckedCreateWithoutUserInput[]
    connectOrCreate?: immutable_executableCreateOrConnectWithoutUserInput | immutable_executableCreateOrConnectWithoutUserInput[]
    createMany?: immutable_executableCreateManyUserInputEnvelope
    connect?: immutable_executableWhereUniqueInput | immutable_executableWhereUniqueInput[]
  }

  export type rejudgingCreateNestedManyWithoutUser_rejudging_userid_startTouserInput = {
    create?: XOR<rejudgingCreateWithoutUser_rejudging_userid_startTouserInput, rejudgingUncheckedCreateWithoutUser_rejudging_userid_startTouserInput> | rejudgingCreateWithoutUser_rejudging_userid_startTouserInput[] | rejudgingUncheckedCreateWithoutUser_rejudging_userid_startTouserInput[]
    connectOrCreate?: rejudgingCreateOrConnectWithoutUser_rejudging_userid_startTouserInput | rejudgingCreateOrConnectWithoutUser_rejudging_userid_startTouserInput[]
    createMany?: rejudgingCreateManyUser_rejudging_userid_startTouserInputEnvelope
    connect?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
  }

  export type rejudgingCreateNestedManyWithoutUser_rejudging_userid_finishTouserInput = {
    create?: XOR<rejudgingCreateWithoutUser_rejudging_userid_finishTouserInput, rejudgingUncheckedCreateWithoutUser_rejudging_userid_finishTouserInput> | rejudgingCreateWithoutUser_rejudging_userid_finishTouserInput[] | rejudgingUncheckedCreateWithoutUser_rejudging_userid_finishTouserInput[]
    connectOrCreate?: rejudgingCreateOrConnectWithoutUser_rejudging_userid_finishTouserInput | rejudgingCreateOrConnectWithoutUser_rejudging_userid_finishTouserInput[]
    createMany?: rejudgingCreateManyUser_rejudging_userid_finishTouserInputEnvelope
    connect?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
  }

  export type submissionCreateNestedManyWithoutUserInput = {
    create?: XOR<submissionCreateWithoutUserInput, submissionUncheckedCreateWithoutUserInput> | submissionCreateWithoutUserInput[] | submissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutUserInput | submissionCreateOrConnectWithoutUserInput[]
    createMany?: submissionCreateManyUserInputEnvelope
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
  }

  export type teamCreateNestedOneWithoutUserInput = {
    create?: XOR<teamCreateWithoutUserInput, teamUncheckedCreateWithoutUserInput>
    connectOrCreate?: teamCreateOrConnectWithoutUserInput
    connect?: teamWhereUniqueInput
  }

  export type userroleCreateNestedManyWithoutUserInput = {
    create?: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput> | userroleCreateWithoutUserInput[] | userroleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUserInput | userroleCreateOrConnectWithoutUserInput[]
    createMany?: userroleCreateManyUserInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type immutable_executableUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<immutable_executableCreateWithoutUserInput, immutable_executableUncheckedCreateWithoutUserInput> | immutable_executableCreateWithoutUserInput[] | immutable_executableUncheckedCreateWithoutUserInput[]
    connectOrCreate?: immutable_executableCreateOrConnectWithoutUserInput | immutable_executableCreateOrConnectWithoutUserInput[]
    createMany?: immutable_executableCreateManyUserInputEnvelope
    connect?: immutable_executableWhereUniqueInput | immutable_executableWhereUniqueInput[]
  }

  export type rejudgingUncheckedCreateNestedManyWithoutUser_rejudging_userid_startTouserInput = {
    create?: XOR<rejudgingCreateWithoutUser_rejudging_userid_startTouserInput, rejudgingUncheckedCreateWithoutUser_rejudging_userid_startTouserInput> | rejudgingCreateWithoutUser_rejudging_userid_startTouserInput[] | rejudgingUncheckedCreateWithoutUser_rejudging_userid_startTouserInput[]
    connectOrCreate?: rejudgingCreateOrConnectWithoutUser_rejudging_userid_startTouserInput | rejudgingCreateOrConnectWithoutUser_rejudging_userid_startTouserInput[]
    createMany?: rejudgingCreateManyUser_rejudging_userid_startTouserInputEnvelope
    connect?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
  }

  export type rejudgingUncheckedCreateNestedManyWithoutUser_rejudging_userid_finishTouserInput = {
    create?: XOR<rejudgingCreateWithoutUser_rejudging_userid_finishTouserInput, rejudgingUncheckedCreateWithoutUser_rejudging_userid_finishTouserInput> | rejudgingCreateWithoutUser_rejudging_userid_finishTouserInput[] | rejudgingUncheckedCreateWithoutUser_rejudging_userid_finishTouserInput[]
    connectOrCreate?: rejudgingCreateOrConnectWithoutUser_rejudging_userid_finishTouserInput | rejudgingCreateOrConnectWithoutUser_rejudging_userid_finishTouserInput[]
    createMany?: rejudgingCreateManyUser_rejudging_userid_finishTouserInputEnvelope
    connect?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
  }

  export type submissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<submissionCreateWithoutUserInput, submissionUncheckedCreateWithoutUserInput> | submissionCreateWithoutUserInput[] | submissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutUserInput | submissionCreateOrConnectWithoutUserInput[]
    createMany?: submissionCreateManyUserInputEnvelope
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
  }

  export type userroleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput> | userroleCreateWithoutUserInput[] | userroleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUserInput | userroleCreateOrConnectWithoutUserInput[]
    createMany?: userroleCreateManyUserInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type immutable_executableUpdateManyWithoutUserNestedInput = {
    create?: XOR<immutable_executableCreateWithoutUserInput, immutable_executableUncheckedCreateWithoutUserInput> | immutable_executableCreateWithoutUserInput[] | immutable_executableUncheckedCreateWithoutUserInput[]
    connectOrCreate?: immutable_executableCreateOrConnectWithoutUserInput | immutable_executableCreateOrConnectWithoutUserInput[]
    upsert?: immutable_executableUpsertWithWhereUniqueWithoutUserInput | immutable_executableUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: immutable_executableCreateManyUserInputEnvelope
    set?: immutable_executableWhereUniqueInput | immutable_executableWhereUniqueInput[]
    disconnect?: immutable_executableWhereUniqueInput | immutable_executableWhereUniqueInput[]
    delete?: immutable_executableWhereUniqueInput | immutable_executableWhereUniqueInput[]
    connect?: immutable_executableWhereUniqueInput | immutable_executableWhereUniqueInput[]
    update?: immutable_executableUpdateWithWhereUniqueWithoutUserInput | immutable_executableUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: immutable_executableUpdateManyWithWhereWithoutUserInput | immutable_executableUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: immutable_executableScalarWhereInput | immutable_executableScalarWhereInput[]
  }

  export type rejudgingUpdateManyWithoutUser_rejudging_userid_startTouserNestedInput = {
    create?: XOR<rejudgingCreateWithoutUser_rejudging_userid_startTouserInput, rejudgingUncheckedCreateWithoutUser_rejudging_userid_startTouserInput> | rejudgingCreateWithoutUser_rejudging_userid_startTouserInput[] | rejudgingUncheckedCreateWithoutUser_rejudging_userid_startTouserInput[]
    connectOrCreate?: rejudgingCreateOrConnectWithoutUser_rejudging_userid_startTouserInput | rejudgingCreateOrConnectWithoutUser_rejudging_userid_startTouserInput[]
    upsert?: rejudgingUpsertWithWhereUniqueWithoutUser_rejudging_userid_startTouserInput | rejudgingUpsertWithWhereUniqueWithoutUser_rejudging_userid_startTouserInput[]
    createMany?: rejudgingCreateManyUser_rejudging_userid_startTouserInputEnvelope
    set?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    disconnect?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    delete?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    connect?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    update?: rejudgingUpdateWithWhereUniqueWithoutUser_rejudging_userid_startTouserInput | rejudgingUpdateWithWhereUniqueWithoutUser_rejudging_userid_startTouserInput[]
    updateMany?: rejudgingUpdateManyWithWhereWithoutUser_rejudging_userid_startTouserInput | rejudgingUpdateManyWithWhereWithoutUser_rejudging_userid_startTouserInput[]
    deleteMany?: rejudgingScalarWhereInput | rejudgingScalarWhereInput[]
  }

  export type rejudgingUpdateManyWithoutUser_rejudging_userid_finishTouserNestedInput = {
    create?: XOR<rejudgingCreateWithoutUser_rejudging_userid_finishTouserInput, rejudgingUncheckedCreateWithoutUser_rejudging_userid_finishTouserInput> | rejudgingCreateWithoutUser_rejudging_userid_finishTouserInput[] | rejudgingUncheckedCreateWithoutUser_rejudging_userid_finishTouserInput[]
    connectOrCreate?: rejudgingCreateOrConnectWithoutUser_rejudging_userid_finishTouserInput | rejudgingCreateOrConnectWithoutUser_rejudging_userid_finishTouserInput[]
    upsert?: rejudgingUpsertWithWhereUniqueWithoutUser_rejudging_userid_finishTouserInput | rejudgingUpsertWithWhereUniqueWithoutUser_rejudging_userid_finishTouserInput[]
    createMany?: rejudgingCreateManyUser_rejudging_userid_finishTouserInputEnvelope
    set?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    disconnect?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    delete?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    connect?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    update?: rejudgingUpdateWithWhereUniqueWithoutUser_rejudging_userid_finishTouserInput | rejudgingUpdateWithWhereUniqueWithoutUser_rejudging_userid_finishTouserInput[]
    updateMany?: rejudgingUpdateManyWithWhereWithoutUser_rejudging_userid_finishTouserInput | rejudgingUpdateManyWithWhereWithoutUser_rejudging_userid_finishTouserInput[]
    deleteMany?: rejudgingScalarWhereInput | rejudgingScalarWhereInput[]
  }

  export type submissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<submissionCreateWithoutUserInput, submissionUncheckedCreateWithoutUserInput> | submissionCreateWithoutUserInput[] | submissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutUserInput | submissionCreateOrConnectWithoutUserInput[]
    upsert?: submissionUpsertWithWhereUniqueWithoutUserInput | submissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: submissionCreateManyUserInputEnvelope
    set?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    disconnect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    delete?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    update?: submissionUpdateWithWhereUniqueWithoutUserInput | submissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: submissionUpdateManyWithWhereWithoutUserInput | submissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: submissionScalarWhereInput | submissionScalarWhereInput[]
  }

  export type teamUpdateOneWithoutUserNestedInput = {
    create?: XOR<teamCreateWithoutUserInput, teamUncheckedCreateWithoutUserInput>
    connectOrCreate?: teamCreateOrConnectWithoutUserInput
    upsert?: teamUpsertWithoutUserInput
    disconnect?: teamWhereInput | boolean
    delete?: teamWhereInput | boolean
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutUserInput, teamUpdateWithoutUserInput>, teamUncheckedUpdateWithoutUserInput>
  }

  export type userroleUpdateManyWithoutUserNestedInput = {
    create?: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput> | userroleCreateWithoutUserInput[] | userroleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUserInput | userroleCreateOrConnectWithoutUserInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutUserInput | userroleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userroleCreateManyUserInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutUserInput | userroleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutUserInput | userroleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type immutable_executableUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<immutable_executableCreateWithoutUserInput, immutable_executableUncheckedCreateWithoutUserInput> | immutable_executableCreateWithoutUserInput[] | immutable_executableUncheckedCreateWithoutUserInput[]
    connectOrCreate?: immutable_executableCreateOrConnectWithoutUserInput | immutable_executableCreateOrConnectWithoutUserInput[]
    upsert?: immutable_executableUpsertWithWhereUniqueWithoutUserInput | immutable_executableUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: immutable_executableCreateManyUserInputEnvelope
    set?: immutable_executableWhereUniqueInput | immutable_executableWhereUniqueInput[]
    disconnect?: immutable_executableWhereUniqueInput | immutable_executableWhereUniqueInput[]
    delete?: immutable_executableWhereUniqueInput | immutable_executableWhereUniqueInput[]
    connect?: immutable_executableWhereUniqueInput | immutable_executableWhereUniqueInput[]
    update?: immutable_executableUpdateWithWhereUniqueWithoutUserInput | immutable_executableUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: immutable_executableUpdateManyWithWhereWithoutUserInput | immutable_executableUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: immutable_executableScalarWhereInput | immutable_executableScalarWhereInput[]
  }

  export type rejudgingUncheckedUpdateManyWithoutUser_rejudging_userid_startTouserNestedInput = {
    create?: XOR<rejudgingCreateWithoutUser_rejudging_userid_startTouserInput, rejudgingUncheckedCreateWithoutUser_rejudging_userid_startTouserInput> | rejudgingCreateWithoutUser_rejudging_userid_startTouserInput[] | rejudgingUncheckedCreateWithoutUser_rejudging_userid_startTouserInput[]
    connectOrCreate?: rejudgingCreateOrConnectWithoutUser_rejudging_userid_startTouserInput | rejudgingCreateOrConnectWithoutUser_rejudging_userid_startTouserInput[]
    upsert?: rejudgingUpsertWithWhereUniqueWithoutUser_rejudging_userid_startTouserInput | rejudgingUpsertWithWhereUniqueWithoutUser_rejudging_userid_startTouserInput[]
    createMany?: rejudgingCreateManyUser_rejudging_userid_startTouserInputEnvelope
    set?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    disconnect?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    delete?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    connect?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    update?: rejudgingUpdateWithWhereUniqueWithoutUser_rejudging_userid_startTouserInput | rejudgingUpdateWithWhereUniqueWithoutUser_rejudging_userid_startTouserInput[]
    updateMany?: rejudgingUpdateManyWithWhereWithoutUser_rejudging_userid_startTouserInput | rejudgingUpdateManyWithWhereWithoutUser_rejudging_userid_startTouserInput[]
    deleteMany?: rejudgingScalarWhereInput | rejudgingScalarWhereInput[]
  }

  export type rejudgingUncheckedUpdateManyWithoutUser_rejudging_userid_finishTouserNestedInput = {
    create?: XOR<rejudgingCreateWithoutUser_rejudging_userid_finishTouserInput, rejudgingUncheckedCreateWithoutUser_rejudging_userid_finishTouserInput> | rejudgingCreateWithoutUser_rejudging_userid_finishTouserInput[] | rejudgingUncheckedCreateWithoutUser_rejudging_userid_finishTouserInput[]
    connectOrCreate?: rejudgingCreateOrConnectWithoutUser_rejudging_userid_finishTouserInput | rejudgingCreateOrConnectWithoutUser_rejudging_userid_finishTouserInput[]
    upsert?: rejudgingUpsertWithWhereUniqueWithoutUser_rejudging_userid_finishTouserInput | rejudgingUpsertWithWhereUniqueWithoutUser_rejudging_userid_finishTouserInput[]
    createMany?: rejudgingCreateManyUser_rejudging_userid_finishTouserInputEnvelope
    set?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    disconnect?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    delete?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    connect?: rejudgingWhereUniqueInput | rejudgingWhereUniqueInput[]
    update?: rejudgingUpdateWithWhereUniqueWithoutUser_rejudging_userid_finishTouserInput | rejudgingUpdateWithWhereUniqueWithoutUser_rejudging_userid_finishTouserInput[]
    updateMany?: rejudgingUpdateManyWithWhereWithoutUser_rejudging_userid_finishTouserInput | rejudgingUpdateManyWithWhereWithoutUser_rejudging_userid_finishTouserInput[]
    deleteMany?: rejudgingScalarWhereInput | rejudgingScalarWhereInput[]
  }

  export type submissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<submissionCreateWithoutUserInput, submissionUncheckedCreateWithoutUserInput> | submissionCreateWithoutUserInput[] | submissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: submissionCreateOrConnectWithoutUserInput | submissionCreateOrConnectWithoutUserInput[]
    upsert?: submissionUpsertWithWhereUniqueWithoutUserInput | submissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: submissionCreateManyUserInputEnvelope
    set?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    disconnect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    delete?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    connect?: submissionWhereUniqueInput | submissionWhereUniqueInput[]
    update?: submissionUpdateWithWhereUniqueWithoutUserInput | submissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: submissionUpdateManyWithWhereWithoutUserInput | submissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: submissionScalarWhereInput | submissionScalarWhereInput[]
  }

  export type userroleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput> | userroleCreateWithoutUserInput[] | userroleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUserInput | userroleCreateOrConnectWithoutUserInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutUserInput | userroleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userroleCreateManyUserInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutUserInput | userroleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutUserInput | userroleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutUserroleInput = {
    create?: XOR<userCreateWithoutUserroleInput, userUncheckedCreateWithoutUserroleInput>
    connectOrCreate?: userCreateOrConnectWithoutUserroleInput
    connect?: userWhereUniqueInput
  }

  export type roleCreateNestedOneWithoutUserroleInput = {
    create?: XOR<roleCreateWithoutUserroleInput, roleUncheckedCreateWithoutUserroleInput>
    connectOrCreate?: roleCreateOrConnectWithoutUserroleInput
    connect?: roleWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutUserroleNestedInput = {
    create?: XOR<userCreateWithoutUserroleInput, userUncheckedCreateWithoutUserroleInput>
    connectOrCreate?: userCreateOrConnectWithoutUserroleInput
    upsert?: userUpsertWithoutUserroleInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUserroleInput, userUpdateWithoutUserroleInput>, userUncheckedUpdateWithoutUserroleInput>
  }

  export type roleUpdateOneRequiredWithoutUserroleNestedInput = {
    create?: XOR<roleCreateWithoutUserroleInput, roleUncheckedCreateWithoutUserroleInput>
    connectOrCreate?: roleCreateOrConnectWithoutUserroleInput
    upsert?: roleUpsertWithoutUserroleInput
    connect?: roleWhereUniqueInput
    update?: XOR<XOR<roleUpdateToOneWithWhereWithoutUserroleInput, roleUpdateWithoutUserroleInput>, roleUncheckedUpdateWithoutUserroleInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnuminternal_error_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.internal_error_status | Enuminternal_error_statusFieldRefInput<$PrismaModel>
    in?: $Enums.internal_error_status[]
    notIn?: $Enums.internal_error_status[]
    not?: NestedEnuminternal_error_statusFilter<$PrismaModel> | $Enums.internal_error_status
  }

  export type NestedEnuminternal_error_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.internal_error_status | Enuminternal_error_statusFieldRefInput<$PrismaModel>
    in?: $Enums.internal_error_status[]
    notIn?: $Enums.internal_error_status[]
    not?: NestedEnuminternal_error_statusWithAggregatesFilter<$PrismaModel> | $Enums.internal_error_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminternal_error_statusFilter<$PrismaModel>
    _max?: NestedEnuminternal_error_statusFilter<$PrismaModel>
  }

  export type NestedEnumjudgetask_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.judgetask_type | Enumjudgetask_typeFieldRefInput<$PrismaModel>
    in?: $Enums.judgetask_type[]
    notIn?: $Enums.judgetask_type[]
    not?: NestedEnumjudgetask_typeFilter<$PrismaModel> | $Enums.judgetask_type
  }

  export type NestedEnumjudgetask_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.judgetask_type | Enumjudgetask_typeFieldRefInput<$PrismaModel>
    in?: $Enums.judgetask_type[]
    notIn?: $Enums.judgetask_type[]
    not?: NestedEnumjudgetask_typeWithAggregatesFilter<$PrismaModel> | $Enums.judgetask_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumjudgetask_typeFilter<$PrismaModel>
    _max?: NestedEnumjudgetask_typeFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | null
    notIn?: Buffer[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | null
    notIn?: Buffer[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type submissionCreateWithoutBalloonInput = {
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    external_judgement?: external_judgementCreateNestedManyWithoutSubmissionInput
    judging?: judgingCreateNestedManyWithoutSubmissionInput
    user?: userCreateNestedOneWithoutSubmissionInput
    contest?: contestCreateNestedOneWithoutSubmissionInput
    team?: teamCreateNestedOneWithoutSubmissionInput
    problem?: problemCreateNestedOneWithoutSubmissionInput
    language?: languageCreateNestedOneWithoutSubmissionInput
    submission?: submissionCreateNestedOneWithoutOther_submissionInput
    other_submission?: submissionCreateNestedManyWithoutSubmissionInput
    rejudging?: rejudgingCreateNestedOneWithoutSubmissionInput
    contestproblem?: contestproblemCreateNestedOneWithoutSubmissionInput
    submission_file?: submission_fileCreateNestedManyWithoutSubmissionInput
  }

  export type submissionUncheckedCreateWithoutBalloonInput = {
    submitid?: number
    origsubmitid?: number | null
    cid?: number | null
    teamid?: number | null
    userid?: number | null
    probid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutSubmissionInput
    judging?: judgingUncheckedCreateNestedManyWithoutSubmissionInput
    other_submission?: submissionUncheckedCreateNestedManyWithoutSubmissionInput
    submission_file?: submission_fileUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type submissionCreateOrConnectWithoutBalloonInput = {
    where: submissionWhereUniqueInput
    create: XOR<submissionCreateWithoutBalloonInput, submissionUncheckedCreateWithoutBalloonInput>
  }

  export type submissionUpsertWithoutBalloonInput = {
    update: XOR<submissionUpdateWithoutBalloonInput, submissionUncheckedUpdateWithoutBalloonInput>
    create: XOR<submissionCreateWithoutBalloonInput, submissionUncheckedCreateWithoutBalloonInput>
    where?: submissionWhereInput
  }

  export type submissionUpdateToOneWithWhereWithoutBalloonInput = {
    where?: submissionWhereInput
    data: XOR<submissionUpdateWithoutBalloonInput, submissionUncheckedUpdateWithoutBalloonInput>
  }

  export type submissionUpdateWithoutBalloonInput = {
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    external_judgement?: external_judgementUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUpdateManyWithoutSubmissionNestedInput
    user?: userUpdateOneWithoutSubmissionNestedInput
    contest?: contestUpdateOneWithoutSubmissionNestedInput
    team?: teamUpdateOneWithoutSubmissionNestedInput
    problem?: problemUpdateOneWithoutSubmissionNestedInput
    language?: languageUpdateOneWithoutSubmissionNestedInput
    submission?: submissionUpdateOneWithoutOther_submissionNestedInput
    other_submission?: submissionUpdateManyWithoutSubmissionNestedInput
    rejudging?: rejudgingUpdateOneWithoutSubmissionNestedInput
    contestproblem?: contestproblemUpdateOneWithoutSubmissionNestedInput
    submission_file?: submission_fileUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateWithoutBalloonInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    external_judgement?: external_judgementUncheckedUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUncheckedUpdateManyWithoutSubmissionNestedInput
    other_submission?: submissionUncheckedUpdateManyWithoutSubmissionNestedInput
    submission_file?: submission_fileUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type contestCreateWithoutClarificationInput = {
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    contestproblem?: contestproblemCreateNestedManyWithoutContestInput
    contestteam?: contestteamCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsCreateNestedManyWithoutContestInput
    event?: eventCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementCreateNestedManyWithoutContestInput
    external_run?: external_runCreateNestedManyWithoutContestInput
    internal_error?: internal_errorCreateNestedManyWithoutContestInput
    judging?: judgingCreateNestedManyWithoutContestInput
    rankcache?: rankcacheCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalCreateNestedManyWithoutContestInput
    scorecache?: scorecacheCreateNestedManyWithoutContestInput
    submission?: submissionCreateNestedManyWithoutContestInput
  }

  export type contestUncheckedCreateWithoutClarificationInput = {
    cid?: number
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutContestInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryUncheckedCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedCreateNestedManyWithoutContestInput
    event?: eventUncheckedCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceUncheckedCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutContestInput
    external_run?: external_runUncheckedCreateNestedManyWithoutContestInput
    internal_error?: internal_errorUncheckedCreateNestedManyWithoutContestInput
    judging?: judgingUncheckedCreateNestedManyWithoutContestInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalUncheckedCreateNestedManyWithoutContestInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutContestInput
    submission?: submissionUncheckedCreateNestedManyWithoutContestInput
  }

  export type contestCreateOrConnectWithoutClarificationInput = {
    where: contestWhereUniqueInput
    create: XOR<contestCreateWithoutClarificationInput, contestUncheckedCreateWithoutClarificationInput>
  }

  export type clarificationCreateWithoutOther_clarificationInput = {
    externalid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    jury_member?: string | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
    contest?: contestCreateNestedOneWithoutClarificationInput
    clarification?: clarificationCreateNestedOneWithoutOther_clarificationInput
    problem?: problemCreateNestedOneWithoutClarificationInput
    team_clarification_senderToteam?: teamCreateNestedOneWithoutClarification_clarification_senderToteamInput
    team_clarification_recipientToteam?: teamCreateNestedOneWithoutClarification_clarification_recipientToteamInput
    team_unread?: team_unreadCreateNestedManyWithoutClarificationInput
  }

  export type clarificationUncheckedCreateWithoutOther_clarificationInput = {
    clarid?: number
    externalid?: string | null
    cid?: number | null
    respid?: number | null
    submittime: Decimal | DecimalJsLike | number | string
    sender?: number | null
    recipient?: number | null
    jury_member?: string | null
    probid?: number | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
    team_unread?: team_unreadUncheckedCreateNestedManyWithoutClarificationInput
  }

  export type clarificationCreateOrConnectWithoutOther_clarificationInput = {
    where: clarificationWhereUniqueInput
    create: XOR<clarificationCreateWithoutOther_clarificationInput, clarificationUncheckedCreateWithoutOther_clarificationInput>
  }

  export type clarificationCreateWithoutClarificationInput = {
    externalid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    jury_member?: string | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
    contest?: contestCreateNestedOneWithoutClarificationInput
    other_clarification?: clarificationCreateNestedManyWithoutClarificationInput
    problem?: problemCreateNestedOneWithoutClarificationInput
    team_clarification_senderToteam?: teamCreateNestedOneWithoutClarification_clarification_senderToteamInput
    team_clarification_recipientToteam?: teamCreateNestedOneWithoutClarification_clarification_recipientToteamInput
    team_unread?: team_unreadCreateNestedManyWithoutClarificationInput
  }

  export type clarificationUncheckedCreateWithoutClarificationInput = {
    clarid?: number
    externalid?: string | null
    cid?: number | null
    submittime: Decimal | DecimalJsLike | number | string
    sender?: number | null
    recipient?: number | null
    jury_member?: string | null
    probid?: number | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
    other_clarification?: clarificationUncheckedCreateNestedManyWithoutClarificationInput
    team_unread?: team_unreadUncheckedCreateNestedManyWithoutClarificationInput
  }

  export type clarificationCreateOrConnectWithoutClarificationInput = {
    where: clarificationWhereUniqueInput
    create: XOR<clarificationCreateWithoutClarificationInput, clarificationUncheckedCreateWithoutClarificationInput>
  }

  export type clarificationCreateManyClarificationInputEnvelope = {
    data: clarificationCreateManyClarificationInput | clarificationCreateManyClarificationInput[]
    skipDuplicates?: boolean
  }

  export type problemCreateWithoutClarificationInput = {
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
    contestproblem?: contestproblemCreateNestedManyWithoutProblemInput
    executable_problem_special_runToexecutable?: executableCreateNestedOneWithoutProblem_problem_special_runToexecutableInput
    executable_problem_special_compareToexecutable?: executableCreateNestedOneWithoutProblem_problem_special_compareToexecutableInput
    problem_attachment?: problem_attachmentCreateNestedManyWithoutProblemInput
    scorecache?: scorecacheCreateNestedManyWithoutProblemInput
    submission?: submissionCreateNestedManyWithoutProblemInput
    testcase?: testcaseCreateNestedManyWithoutProblemInput
  }

  export type problemUncheckedCreateWithoutClarificationInput = {
    probid?: number
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_run?: string | null
    special_compare?: string | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutProblemInput
    problem_attachment?: problem_attachmentUncheckedCreateNestedManyWithoutProblemInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutProblemInput
    submission?: submissionUncheckedCreateNestedManyWithoutProblemInput
    testcase?: testcaseUncheckedCreateNestedManyWithoutProblemInput
  }

  export type problemCreateOrConnectWithoutClarificationInput = {
    where: problemWhereUniqueInput
    create: XOR<problemCreateWithoutClarificationInput, problemUncheckedCreateWithoutClarificationInput>
  }

  export type teamCreateWithoutClarification_clarification_senderToteamInput = {
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_recipientToteam?: clarificationCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    contestteam?: contestteamCreateNestedManyWithoutTeamInput
    queuetask?: queuetaskCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheCreateNestedManyWithoutTeamInput
    submission?: submissionCreateNestedManyWithoutTeamInput
    team_category?: team_categoryCreateNestedOneWithoutTeamInput
    team_affiliation?: team_affiliationCreateNestedOneWithoutTeamInput
    team_unread?: team_unreadCreateNestedManyWithoutTeamInput
    user?: userCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutClarification_clarification_senderToteamInput = {
    teamid?: number
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    categoryid?: number | null
    affilid?: number | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_recipientToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutTeamInput
    queuetask?: queuetaskUncheckedCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutTeamInput
    submission?: submissionUncheckedCreateNestedManyWithoutTeamInput
    team_unread?: team_unreadUncheckedCreateNestedManyWithoutTeamInput
    user?: userUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutClarification_clarification_senderToteamInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutClarification_clarification_senderToteamInput, teamUncheckedCreateWithoutClarification_clarification_senderToteamInput>
  }

  export type teamCreateWithoutClarification_clarification_recipientToteamInput = {
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationCreateNestedManyWithoutTeam_clarification_senderToteamInput
    contestteam?: contestteamCreateNestedManyWithoutTeamInput
    queuetask?: queuetaskCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheCreateNestedManyWithoutTeamInput
    submission?: submissionCreateNestedManyWithoutTeamInput
    team_category?: team_categoryCreateNestedOneWithoutTeamInput
    team_affiliation?: team_affiliationCreateNestedOneWithoutTeamInput
    team_unread?: team_unreadCreateNestedManyWithoutTeamInput
    user?: userCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutClarification_clarification_recipientToteamInput = {
    teamid?: number
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    categoryid?: number | null
    affilid?: number | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_senderToteamInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutTeamInput
    queuetask?: queuetaskUncheckedCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutTeamInput
    submission?: submissionUncheckedCreateNestedManyWithoutTeamInput
    team_unread?: team_unreadUncheckedCreateNestedManyWithoutTeamInput
    user?: userUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutClarification_clarification_recipientToteamInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutClarification_clarification_recipientToteamInput, teamUncheckedCreateWithoutClarification_clarification_recipientToteamInput>
  }

  export type team_unreadCreateWithoutClarificationInput = {
    team: teamCreateNestedOneWithoutTeam_unreadInput
  }

  export type team_unreadUncheckedCreateWithoutClarificationInput = {
    teamid: number
  }

  export type team_unreadCreateOrConnectWithoutClarificationInput = {
    where: team_unreadWhereUniqueInput
    create: XOR<team_unreadCreateWithoutClarificationInput, team_unreadUncheckedCreateWithoutClarificationInput>
  }

  export type team_unreadCreateManyClarificationInputEnvelope = {
    data: team_unreadCreateManyClarificationInput | team_unreadCreateManyClarificationInput[]
    skipDuplicates?: boolean
  }

  export type contestUpsertWithoutClarificationInput = {
    update: XOR<contestUpdateWithoutClarificationInput, contestUncheckedUpdateWithoutClarificationInput>
    create: XOR<contestCreateWithoutClarificationInput, contestUncheckedCreateWithoutClarificationInput>
    where?: contestWhereInput
  }

  export type contestUpdateToOneWithWhereWithoutClarificationInput = {
    where?: contestWhereInput
    data: XOR<contestUpdateWithoutClarificationInput, contestUncheckedUpdateWithoutClarificationInput>
  }

  export type contestUpdateWithoutClarificationInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    contestproblem?: contestproblemUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUpdateManyWithoutContestNestedInput
    event?: eventUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUpdateManyWithoutContestNestedInput
    external_run?: external_runUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUpdateManyWithoutContestNestedInput
    judging?: judgingUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUpdateManyWithoutContestNestedInput
    submission?: submissionUpdateManyWithoutContestNestedInput
  }

  export type contestUncheckedUpdateWithoutClarificationInput = {
    cid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    contestproblem?: contestproblemUncheckedUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedUpdateManyWithoutContestNestedInput
    event?: eventUncheckedUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUncheckedUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutContestNestedInput
    external_run?: external_runUncheckedUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUncheckedUpdateManyWithoutContestNestedInput
    judging?: judgingUncheckedUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUncheckedUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutContestNestedInput
    submission?: submissionUncheckedUpdateManyWithoutContestNestedInput
  }

  export type clarificationUpsertWithoutOther_clarificationInput = {
    update: XOR<clarificationUpdateWithoutOther_clarificationInput, clarificationUncheckedUpdateWithoutOther_clarificationInput>
    create: XOR<clarificationCreateWithoutOther_clarificationInput, clarificationUncheckedCreateWithoutOther_clarificationInput>
    where?: clarificationWhereInput
  }

  export type clarificationUpdateToOneWithWhereWithoutOther_clarificationInput = {
    where?: clarificationWhereInput
    data: XOR<clarificationUpdateWithoutOther_clarificationInput, clarificationUncheckedUpdateWithoutOther_clarificationInput>
  }

  export type clarificationUpdateWithoutOther_clarificationInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    contest?: contestUpdateOneWithoutClarificationNestedInput
    clarification?: clarificationUpdateOneWithoutOther_clarificationNestedInput
    problem?: problemUpdateOneWithoutClarificationNestedInput
    team_clarification_senderToteam?: teamUpdateOneWithoutClarification_clarification_senderToteamNestedInput
    team_clarification_recipientToteam?: teamUpdateOneWithoutClarification_clarification_recipientToteamNestedInput
    team_unread?: team_unreadUpdateManyWithoutClarificationNestedInput
  }

  export type clarificationUncheckedUpdateWithoutOther_clarificationInput = {
    clarid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    respid?: NullableIntFieldUpdateOperationsInput | number | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sender?: NullableIntFieldUpdateOperationsInput | number | null
    recipient?: NullableIntFieldUpdateOperationsInput | number | null
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    team_unread?: team_unreadUncheckedUpdateManyWithoutClarificationNestedInput
  }

  export type clarificationUpsertWithWhereUniqueWithoutClarificationInput = {
    where: clarificationWhereUniqueInput
    update: XOR<clarificationUpdateWithoutClarificationInput, clarificationUncheckedUpdateWithoutClarificationInput>
    create: XOR<clarificationCreateWithoutClarificationInput, clarificationUncheckedCreateWithoutClarificationInput>
  }

  export type clarificationUpdateWithWhereUniqueWithoutClarificationInput = {
    where: clarificationWhereUniqueInput
    data: XOR<clarificationUpdateWithoutClarificationInput, clarificationUncheckedUpdateWithoutClarificationInput>
  }

  export type clarificationUpdateManyWithWhereWithoutClarificationInput = {
    where: clarificationScalarWhereInput
    data: XOR<clarificationUpdateManyMutationInput, clarificationUncheckedUpdateManyWithoutClarificationInput>
  }

  export type clarificationScalarWhereInput = {
    AND?: clarificationScalarWhereInput | clarificationScalarWhereInput[]
    OR?: clarificationScalarWhereInput[]
    NOT?: clarificationScalarWhereInput | clarificationScalarWhereInput[]
    clarid?: IntFilter<"clarification"> | number
    externalid?: StringNullableFilter<"clarification"> | string | null
    cid?: IntNullableFilter<"clarification"> | number | null
    respid?: IntNullableFilter<"clarification"> | number | null
    submittime?: DecimalFilter<"clarification"> | Decimal | DecimalJsLike | number | string
    sender?: IntNullableFilter<"clarification"> | number | null
    recipient?: IntNullableFilter<"clarification"> | number | null
    jury_member?: StringNullableFilter<"clarification"> | string | null
    probid?: IntNullableFilter<"clarification"> | number | null
    category?: StringNullableFilter<"clarification"> | string | null
    queue?: StringNullableFilter<"clarification"> | string | null
    body?: StringFilter<"clarification"> | string
    answered?: BoolFilter<"clarification"> | boolean
  }

  export type problemUpsertWithoutClarificationInput = {
    update: XOR<problemUpdateWithoutClarificationInput, problemUncheckedUpdateWithoutClarificationInput>
    create: XOR<problemCreateWithoutClarificationInput, problemUncheckedCreateWithoutClarificationInput>
    where?: problemWhereInput
  }

  export type problemUpdateToOneWithWhereWithoutClarificationInput = {
    where?: problemWhereInput
    data: XOR<problemUpdateWithoutClarificationInput, problemUncheckedUpdateWithoutClarificationInput>
  }

  export type problemUpdateWithoutClarificationInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
    contestproblem?: contestproblemUpdateManyWithoutProblemNestedInput
    executable_problem_special_runToexecutable?: executableUpdateOneWithoutProblem_problem_special_runToexecutableNestedInput
    executable_problem_special_compareToexecutable?: executableUpdateOneWithoutProblem_problem_special_compareToexecutableNestedInput
    problem_attachment?: problem_attachmentUpdateManyWithoutProblemNestedInput
    scorecache?: scorecacheUpdateManyWithoutProblemNestedInput
    submission?: submissionUpdateManyWithoutProblemNestedInput
    testcase?: testcaseUpdateManyWithoutProblemNestedInput
  }

  export type problemUncheckedUpdateWithoutClarificationInput = {
    probid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_run?: NullableStringFieldUpdateOperationsInput | string | null
    special_compare?: NullableStringFieldUpdateOperationsInput | string | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
    contestproblem?: contestproblemUncheckedUpdateManyWithoutProblemNestedInput
    problem_attachment?: problem_attachmentUncheckedUpdateManyWithoutProblemNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutProblemNestedInput
    submission?: submissionUncheckedUpdateManyWithoutProblemNestedInput
    testcase?: testcaseUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type teamUpsertWithoutClarification_clarification_senderToteamInput = {
    update: XOR<teamUpdateWithoutClarification_clarification_senderToteamInput, teamUncheckedUpdateWithoutClarification_clarification_senderToteamInput>
    create: XOR<teamCreateWithoutClarification_clarification_senderToteamInput, teamUncheckedCreateWithoutClarification_clarification_senderToteamInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutClarification_clarification_senderToteamInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutClarification_clarification_senderToteamInput, teamUncheckedUpdateWithoutClarification_clarification_senderToteamInput>
  }

  export type teamUpdateWithoutClarification_clarification_senderToteamInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_recipientToteam?: clarificationUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    contestteam?: contestteamUpdateManyWithoutTeamNestedInput
    queuetask?: queuetaskUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUpdateManyWithoutTeamNestedInput
    submission?: submissionUpdateManyWithoutTeamNestedInput
    team_category?: team_categoryUpdateOneWithoutTeamNestedInput
    team_affiliation?: team_affiliationUpdateOneWithoutTeamNestedInput
    team_unread?: team_unreadUpdateManyWithoutTeamNestedInput
    user?: userUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutClarification_clarification_senderToteamInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    categoryid?: NullableIntFieldUpdateOperationsInput | number | null
    affilid?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_recipientToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutTeamNestedInput
    queuetask?: queuetaskUncheckedUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutTeamNestedInput
    submission?: submissionUncheckedUpdateManyWithoutTeamNestedInput
    team_unread?: team_unreadUncheckedUpdateManyWithoutTeamNestedInput
    user?: userUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type teamUpsertWithoutClarification_clarification_recipientToteamInput = {
    update: XOR<teamUpdateWithoutClarification_clarification_recipientToteamInput, teamUncheckedUpdateWithoutClarification_clarification_recipientToteamInput>
    create: XOR<teamCreateWithoutClarification_clarification_recipientToteamInput, teamUncheckedCreateWithoutClarification_clarification_recipientToteamInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutClarification_clarification_recipientToteamInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutClarification_clarification_recipientToteamInput, teamUncheckedUpdateWithoutClarification_clarification_recipientToteamInput>
  }

  export type teamUpdateWithoutClarification_clarification_recipientToteamInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    contestteam?: contestteamUpdateManyWithoutTeamNestedInput
    queuetask?: queuetaskUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUpdateManyWithoutTeamNestedInput
    submission?: submissionUpdateManyWithoutTeamNestedInput
    team_category?: team_categoryUpdateOneWithoutTeamNestedInput
    team_affiliation?: team_affiliationUpdateOneWithoutTeamNestedInput
    team_unread?: team_unreadUpdateManyWithoutTeamNestedInput
    user?: userUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutClarification_clarification_recipientToteamInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    categoryid?: NullableIntFieldUpdateOperationsInput | number | null
    affilid?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutTeamNestedInput
    queuetask?: queuetaskUncheckedUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutTeamNestedInput
    submission?: submissionUncheckedUpdateManyWithoutTeamNestedInput
    team_unread?: team_unreadUncheckedUpdateManyWithoutTeamNestedInput
    user?: userUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type team_unreadUpsertWithWhereUniqueWithoutClarificationInput = {
    where: team_unreadWhereUniqueInput
    update: XOR<team_unreadUpdateWithoutClarificationInput, team_unreadUncheckedUpdateWithoutClarificationInput>
    create: XOR<team_unreadCreateWithoutClarificationInput, team_unreadUncheckedCreateWithoutClarificationInput>
  }

  export type team_unreadUpdateWithWhereUniqueWithoutClarificationInput = {
    where: team_unreadWhereUniqueInput
    data: XOR<team_unreadUpdateWithoutClarificationInput, team_unreadUncheckedUpdateWithoutClarificationInput>
  }

  export type team_unreadUpdateManyWithWhereWithoutClarificationInput = {
    where: team_unreadScalarWhereInput
    data: XOR<team_unreadUpdateManyMutationInput, team_unreadUncheckedUpdateManyWithoutClarificationInput>
  }

  export type team_unreadScalarWhereInput = {
    AND?: team_unreadScalarWhereInput | team_unreadScalarWhereInput[]
    OR?: team_unreadScalarWhereInput[]
    NOT?: team_unreadScalarWhereInput | team_unreadScalarWhereInput[]
    teamid?: IntFilter<"team_unread"> | number
    mesgid?: IntFilter<"team_unread"> | number
  }

  export type clarificationCreateWithoutContestInput = {
    externalid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    jury_member?: string | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
    clarification?: clarificationCreateNestedOneWithoutOther_clarificationInput
    other_clarification?: clarificationCreateNestedManyWithoutClarificationInput
    problem?: problemCreateNestedOneWithoutClarificationInput
    team_clarification_senderToteam?: teamCreateNestedOneWithoutClarification_clarification_senderToteamInput
    team_clarification_recipientToteam?: teamCreateNestedOneWithoutClarification_clarification_recipientToteamInput
    team_unread?: team_unreadCreateNestedManyWithoutClarificationInput
  }

  export type clarificationUncheckedCreateWithoutContestInput = {
    clarid?: number
    externalid?: string | null
    respid?: number | null
    submittime: Decimal | DecimalJsLike | number | string
    sender?: number | null
    recipient?: number | null
    jury_member?: string | null
    probid?: number | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
    other_clarification?: clarificationUncheckedCreateNestedManyWithoutClarificationInput
    team_unread?: team_unreadUncheckedCreateNestedManyWithoutClarificationInput
  }

  export type clarificationCreateOrConnectWithoutContestInput = {
    where: clarificationWhereUniqueInput
    create: XOR<clarificationCreateWithoutContestInput, clarificationUncheckedCreateWithoutContestInput>
  }

  export type clarificationCreateManyContestInputEnvelope = {
    data: clarificationCreateManyContestInput | clarificationCreateManyContestInput[]
    skipDuplicates?: boolean
  }

  export type contestproblemCreateWithoutContestInput = {
    shortname: string
    points?: number
    allow_submit?: boolean
    allow_judge?: boolean
    color?: string | null
    lazy_eval_results?: number | null
    problem: problemCreateNestedOneWithoutContestproblemInput
    submission?: submissionCreateNestedManyWithoutContestproblemInput
  }

  export type contestproblemUncheckedCreateWithoutContestInput = {
    probid: number
    shortname: string
    points?: number
    allow_submit?: boolean
    allow_judge?: boolean
    color?: string | null
    lazy_eval_results?: number | null
    submission?: submissionUncheckedCreateNestedManyWithoutContestproblemInput
  }

  export type contestproblemCreateOrConnectWithoutContestInput = {
    where: contestproblemWhereUniqueInput
    create: XOR<contestproblemCreateWithoutContestInput, contestproblemUncheckedCreateWithoutContestInput>
  }

  export type contestproblemCreateManyContestInputEnvelope = {
    data: contestproblemCreateManyContestInput | contestproblemCreateManyContestInput[]
    skipDuplicates?: boolean
  }

  export type contestteamCreateWithoutContestInput = {
    team: teamCreateNestedOneWithoutContestteamInput
  }

  export type contestteamUncheckedCreateWithoutContestInput = {
    teamid: number
  }

  export type contestteamCreateOrConnectWithoutContestInput = {
    where: contestteamWhereUniqueInput
    create: XOR<contestteamCreateWithoutContestInput, contestteamUncheckedCreateWithoutContestInput>
  }

  export type contestteamCreateManyContestInputEnvelope = {
    data: contestteamCreateManyContestInput | contestteamCreateManyContestInput[]
    skipDuplicates?: boolean
  }

  export type contestteamcategoryCreateWithoutContestInput = {
    team_category: team_categoryCreateNestedOneWithoutContestteamcategoryInput
  }

  export type contestteamcategoryUncheckedCreateWithoutContestInput = {
    categoryid: number
  }

  export type contestteamcategoryCreateOrConnectWithoutContestInput = {
    where: contestteamcategoryWhereUniqueInput
    create: XOR<contestteamcategoryCreateWithoutContestInput, contestteamcategoryUncheckedCreateWithoutContestInput>
  }

  export type contestteamcategoryCreateManyContestInputEnvelope = {
    data: contestteamcategoryCreateManyContestInput | contestteamcategoryCreateManyContestInput[]
    skipDuplicates?: boolean
  }

  export type contestteamcategoryformedalsCreateWithoutContestInput = {
    team_category: team_categoryCreateNestedOneWithoutContestteamcategoryformedalsInput
  }

  export type contestteamcategoryformedalsUncheckedCreateWithoutContestInput = {
    categoryid: number
  }

  export type contestteamcategoryformedalsCreateOrConnectWithoutContestInput = {
    where: contestteamcategoryformedalsWhereUniqueInput
    create: XOR<contestteamcategoryformedalsCreateWithoutContestInput, contestteamcategoryformedalsUncheckedCreateWithoutContestInput>
  }

  export type contestteamcategoryformedalsCreateManyContestInputEnvelope = {
    data: contestteamcategoryformedalsCreateManyContestInput | contestteamcategoryformedalsCreateManyContestInput[]
    skipDuplicates?: boolean
  }

  export type eventCreateWithoutContestInput = {
    eventtime: Decimal | DecimalJsLike | number | string
    endpointtype: string
    endpointid: string
    action: string
    content: Buffer
  }

  export type eventUncheckedCreateWithoutContestInput = {
    eventid?: number
    eventtime: Decimal | DecimalJsLike | number | string
    endpointtype: string
    endpointid: string
    action: string
    content: Buffer
  }

  export type eventCreateOrConnectWithoutContestInput = {
    where: eventWhereUniqueInput
    create: XOR<eventCreateWithoutContestInput, eventUncheckedCreateWithoutContestInput>
  }

  export type eventCreateManyContestInputEnvelope = {
    data: eventCreateManyContestInput | eventCreateManyContestInput[]
    skipDuplicates?: boolean
  }

  export type external_contest_sourceCreateWithoutContestInput = {
    type: string
    source: string
    username?: string | null
    password?: string | null
    last_event_id?: string | null
    last_poll_time?: Decimal | DecimalJsLike | number | string | null
    external_source_warning?: external_source_warningCreateNestedManyWithoutExternal_contest_sourceInput
  }

  export type external_contest_sourceUncheckedCreateWithoutContestInput = {
    extsourceid?: number
    type: string
    source: string
    username?: string | null
    password?: string | null
    last_event_id?: string | null
    last_poll_time?: Decimal | DecimalJsLike | number | string | null
    external_source_warning?: external_source_warningUncheckedCreateNestedManyWithoutExternal_contest_sourceInput
  }

  export type external_contest_sourceCreateOrConnectWithoutContestInput = {
    where: external_contest_sourceWhereUniqueInput
    create: XOR<external_contest_sourceCreateWithoutContestInput, external_contest_sourceUncheckedCreateWithoutContestInput>
  }

  export type external_judgementCreateWithoutContestInput = {
    externalid?: string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    valid?: boolean
    submission?: submissionCreateNestedOneWithoutExternal_judgementInput
    external_run?: external_runCreateNestedManyWithoutExternal_judgementInput
  }

  export type external_judgementUncheckedCreateWithoutContestInput = {
    extjudgementid?: number
    externalid?: string | null
    submitid?: number | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    valid?: boolean
    external_run?: external_runUncheckedCreateNestedManyWithoutExternal_judgementInput
  }

  export type external_judgementCreateOrConnectWithoutContestInput = {
    where: external_judgementWhereUniqueInput
    create: XOR<external_judgementCreateWithoutContestInput, external_judgementUncheckedCreateWithoutContestInput>
  }

  export type external_judgementCreateManyContestInputEnvelope = {
    data: external_judgementCreateManyContestInput | external_judgementCreateManyContestInput[]
    skipDuplicates?: boolean
  }

  export type external_runCreateWithoutContestInput = {
    externalid?: string | null
    result: string
    endtime: Decimal | DecimalJsLike | number | string
    runtime: number
    external_judgement?: external_judgementCreateNestedOneWithoutExternal_runInput
    testcase?: testcaseCreateNestedOneWithoutExternal_runInput
  }

  export type external_runUncheckedCreateWithoutContestInput = {
    extrunid?: number
    extjudgementid?: number | null
    testcaseid?: number | null
    externalid?: string | null
    result: string
    endtime: Decimal | DecimalJsLike | number | string
    runtime: number
  }

  export type external_runCreateOrConnectWithoutContestInput = {
    where: external_runWhereUniqueInput
    create: XOR<external_runCreateWithoutContestInput, external_runUncheckedCreateWithoutContestInput>
  }

  export type external_runCreateManyContestInputEnvelope = {
    data: external_runCreateManyContestInput | external_runCreateManyContestInput[]
    skipDuplicates?: boolean
  }

  export type internal_errorCreateWithoutContestInput = {
    description: string
    judgehostlog: string
    time: Decimal | DecimalJsLike | number | string
    disabled: string
    status?: $Enums.internal_error_status
    judging_internal_error_judgingidTojudging?: judgingCreateNestedOneWithoutInternal_error_internal_error_judgingidTojudgingInput
    judging_judging_erroridTointernal_error?: judgingCreateNestedManyWithoutInternal_error_judging_erroridTointernal_errorInput
  }

  export type internal_errorUncheckedCreateWithoutContestInput = {
    errorid?: number
    judgingid?: number | null
    description: string
    judgehostlog: string
    time: Decimal | DecimalJsLike | number | string
    disabled: string
    status?: $Enums.internal_error_status
    judging_judging_erroridTointernal_error?: judgingUncheckedCreateNestedManyWithoutInternal_error_judging_erroridTointernal_errorInput
  }

  export type internal_errorCreateOrConnectWithoutContestInput = {
    where: internal_errorWhereUniqueInput
    create: XOR<internal_errorCreateWithoutContestInput, internal_errorUncheckedCreateWithoutContestInput>
  }

  export type internal_errorCreateManyContestInputEnvelope = {
    data: internal_errorCreateManyContestInput | internal_errorCreateManyContestInput[]
    skipDuplicates?: boolean
  }

  export type judgingCreateWithoutContestInput = {
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    judge_completely?: boolean
    uuid: string
    metadata?: Buffer | null
    debug_package?: debug_packageCreateNestedManyWithoutJudgingInput
    internal_error_internal_error_judgingidTojudging?: internal_errorCreateNestedManyWithoutJudging_internal_error_judgingidTojudgingInput
    internal_error_judging_erroridTointernal_error?: internal_errorCreateNestedOneWithoutJudging_judging_erroridTointernal_errorInput
    submission?: submissionCreateNestedOneWithoutJudgingInput
    rejudging?: rejudgingCreateNestedOneWithoutJudgingInput
    judging?: judgingCreateNestedOneWithoutOther_judgingInput
    other_judging?: judgingCreateNestedManyWithoutJudgingInput
    judging_run?: judging_runCreateNestedManyWithoutJudgingInput
  }

  export type judgingUncheckedCreateWithoutContestInput = {
    judgingid?: number
    submitid?: number | null
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    rejudgingid?: number | null
    prevjudgingid?: number | null
    judge_completely?: boolean
    errorid?: number | null
    uuid: string
    metadata?: Buffer | null
    debug_package?: debug_packageUncheckedCreateNestedManyWithoutJudgingInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUncheckedCreateNestedManyWithoutJudging_internal_error_judgingidTojudgingInput
    other_judging?: judgingUncheckedCreateNestedManyWithoutJudgingInput
    judging_run?: judging_runUncheckedCreateNestedManyWithoutJudgingInput
  }

  export type judgingCreateOrConnectWithoutContestInput = {
    where: judgingWhereUniqueInput
    create: XOR<judgingCreateWithoutContestInput, judgingUncheckedCreateWithoutContestInput>
  }

  export type judgingCreateManyContestInputEnvelope = {
    data: judgingCreateManyContestInput | judgingCreateManyContestInput[]
    skipDuplicates?: boolean
  }

  export type rankcacheCreateWithoutContestInput = {
    points_restricted?: number
    totaltime_restricted?: number
    points_public?: number
    totaltime_public?: number
    team: teamCreateNestedOneWithoutRankcacheInput
  }

  export type rankcacheUncheckedCreateWithoutContestInput = {
    teamid: number
    points_restricted?: number
    totaltime_restricted?: number
    points_public?: number
    totaltime_public?: number
  }

  export type rankcacheCreateOrConnectWithoutContestInput = {
    where: rankcacheWhereUniqueInput
    create: XOR<rankcacheCreateWithoutContestInput, rankcacheUncheckedCreateWithoutContestInput>
  }

  export type rankcacheCreateManyContestInputEnvelope = {
    data: rankcacheCreateManyContestInput | rankcacheCreateManyContestInput[]
    skipDuplicates?: boolean
  }

  export type removed_intervalCreateWithoutContestInput = {
    starttime: Decimal | DecimalJsLike | number | string
    endtime: Decimal | DecimalJsLike | number | string
    starttime_string: string
    endtime_string: string
  }

  export type removed_intervalUncheckedCreateWithoutContestInput = {
    intervalid?: number
    starttime: Decimal | DecimalJsLike | number | string
    endtime: Decimal | DecimalJsLike | number | string
    starttime_string: string
    endtime_string: string
  }

  export type removed_intervalCreateOrConnectWithoutContestInput = {
    where: removed_intervalWhereUniqueInput
    create: XOR<removed_intervalCreateWithoutContestInput, removed_intervalUncheckedCreateWithoutContestInput>
  }

  export type removed_intervalCreateManyContestInputEnvelope = {
    data: removed_intervalCreateManyContestInput | removed_intervalCreateManyContestInput[]
    skipDuplicates?: boolean
  }

  export type scorecacheCreateWithoutContestInput = {
    submissions_restricted?: number
    pending_restricted?: number
    solvetime_restricted?: Decimal | DecimalJsLike | number | string
    is_correct_restricted?: boolean
    submissions_public?: number
    pending_public?: number
    solvetime_public?: Decimal | DecimalJsLike | number | string
    is_correct_public?: boolean
    is_first_to_solve?: boolean
    team: teamCreateNestedOneWithoutScorecacheInput
    problem: problemCreateNestedOneWithoutScorecacheInput
  }

  export type scorecacheUncheckedCreateWithoutContestInput = {
    teamid: number
    probid: number
    submissions_restricted?: number
    pending_restricted?: number
    solvetime_restricted?: Decimal | DecimalJsLike | number | string
    is_correct_restricted?: boolean
    submissions_public?: number
    pending_public?: number
    solvetime_public?: Decimal | DecimalJsLike | number | string
    is_correct_public?: boolean
    is_first_to_solve?: boolean
  }

  export type scorecacheCreateOrConnectWithoutContestInput = {
    where: scorecacheWhereUniqueInput
    create: XOR<scorecacheCreateWithoutContestInput, scorecacheUncheckedCreateWithoutContestInput>
  }

  export type scorecacheCreateManyContestInputEnvelope = {
    data: scorecacheCreateManyContestInput | scorecacheCreateManyContestInput[]
    skipDuplicates?: boolean
  }

  export type submissionCreateWithoutContestInput = {
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementCreateNestedManyWithoutSubmissionInput
    judging?: judgingCreateNestedManyWithoutSubmissionInput
    user?: userCreateNestedOneWithoutSubmissionInput
    team?: teamCreateNestedOneWithoutSubmissionInput
    problem?: problemCreateNestedOneWithoutSubmissionInput
    language?: languageCreateNestedOneWithoutSubmissionInput
    submission?: submissionCreateNestedOneWithoutOther_submissionInput
    other_submission?: submissionCreateNestedManyWithoutSubmissionInput
    rejudging?: rejudgingCreateNestedOneWithoutSubmissionInput
    contestproblem?: contestproblemCreateNestedOneWithoutSubmissionInput
    submission_file?: submission_fileCreateNestedManyWithoutSubmissionInput
  }

  export type submissionUncheckedCreateWithoutContestInput = {
    submitid?: number
    origsubmitid?: number | null
    teamid?: number | null
    userid?: number | null
    probid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonUncheckedCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutSubmissionInput
    judging?: judgingUncheckedCreateNestedManyWithoutSubmissionInput
    other_submission?: submissionUncheckedCreateNestedManyWithoutSubmissionInput
    submission_file?: submission_fileUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type submissionCreateOrConnectWithoutContestInput = {
    where: submissionWhereUniqueInput
    create: XOR<submissionCreateWithoutContestInput, submissionUncheckedCreateWithoutContestInput>
  }

  export type submissionCreateManyContestInputEnvelope = {
    data: submissionCreateManyContestInput | submissionCreateManyContestInput[]
    skipDuplicates?: boolean
  }

  export type clarificationUpsertWithWhereUniqueWithoutContestInput = {
    where: clarificationWhereUniqueInput
    update: XOR<clarificationUpdateWithoutContestInput, clarificationUncheckedUpdateWithoutContestInput>
    create: XOR<clarificationCreateWithoutContestInput, clarificationUncheckedCreateWithoutContestInput>
  }

  export type clarificationUpdateWithWhereUniqueWithoutContestInput = {
    where: clarificationWhereUniqueInput
    data: XOR<clarificationUpdateWithoutContestInput, clarificationUncheckedUpdateWithoutContestInput>
  }

  export type clarificationUpdateManyWithWhereWithoutContestInput = {
    where: clarificationScalarWhereInput
    data: XOR<clarificationUpdateManyMutationInput, clarificationUncheckedUpdateManyWithoutContestInput>
  }

  export type contestproblemUpsertWithWhereUniqueWithoutContestInput = {
    where: contestproblemWhereUniqueInput
    update: XOR<contestproblemUpdateWithoutContestInput, contestproblemUncheckedUpdateWithoutContestInput>
    create: XOR<contestproblemCreateWithoutContestInput, contestproblemUncheckedCreateWithoutContestInput>
  }

  export type contestproblemUpdateWithWhereUniqueWithoutContestInput = {
    where: contestproblemWhereUniqueInput
    data: XOR<contestproblemUpdateWithoutContestInput, contestproblemUncheckedUpdateWithoutContestInput>
  }

  export type contestproblemUpdateManyWithWhereWithoutContestInput = {
    where: contestproblemScalarWhereInput
    data: XOR<contestproblemUpdateManyMutationInput, contestproblemUncheckedUpdateManyWithoutContestInput>
  }

  export type contestproblemScalarWhereInput = {
    AND?: contestproblemScalarWhereInput | contestproblemScalarWhereInput[]
    OR?: contestproblemScalarWhereInput[]
    NOT?: contestproblemScalarWhereInput | contestproblemScalarWhereInput[]
    cid?: IntFilter<"contestproblem"> | number
    probid?: IntFilter<"contestproblem"> | number
    shortname?: StringFilter<"contestproblem"> | string
    points?: IntFilter<"contestproblem"> | number
    allow_submit?: BoolFilter<"contestproblem"> | boolean
    allow_judge?: BoolFilter<"contestproblem"> | boolean
    color?: StringNullableFilter<"contestproblem"> | string | null
    lazy_eval_results?: IntNullableFilter<"contestproblem"> | number | null
  }

  export type contestteamUpsertWithWhereUniqueWithoutContestInput = {
    where: contestteamWhereUniqueInput
    update: XOR<contestteamUpdateWithoutContestInput, contestteamUncheckedUpdateWithoutContestInput>
    create: XOR<contestteamCreateWithoutContestInput, contestteamUncheckedCreateWithoutContestInput>
  }

  export type contestteamUpdateWithWhereUniqueWithoutContestInput = {
    where: contestteamWhereUniqueInput
    data: XOR<contestteamUpdateWithoutContestInput, contestteamUncheckedUpdateWithoutContestInput>
  }

  export type contestteamUpdateManyWithWhereWithoutContestInput = {
    where: contestteamScalarWhereInput
    data: XOR<contestteamUpdateManyMutationInput, contestteamUncheckedUpdateManyWithoutContestInput>
  }

  export type contestteamScalarWhereInput = {
    AND?: contestteamScalarWhereInput | contestteamScalarWhereInput[]
    OR?: contestteamScalarWhereInput[]
    NOT?: contestteamScalarWhereInput | contestteamScalarWhereInput[]
    cid?: IntFilter<"contestteam"> | number
    teamid?: IntFilter<"contestteam"> | number
  }

  export type contestteamcategoryUpsertWithWhereUniqueWithoutContestInput = {
    where: contestteamcategoryWhereUniqueInput
    update: XOR<contestteamcategoryUpdateWithoutContestInput, contestteamcategoryUncheckedUpdateWithoutContestInput>
    create: XOR<contestteamcategoryCreateWithoutContestInput, contestteamcategoryUncheckedCreateWithoutContestInput>
  }

  export type contestteamcategoryUpdateWithWhereUniqueWithoutContestInput = {
    where: contestteamcategoryWhereUniqueInput
    data: XOR<contestteamcategoryUpdateWithoutContestInput, contestteamcategoryUncheckedUpdateWithoutContestInput>
  }

  export type contestteamcategoryUpdateManyWithWhereWithoutContestInput = {
    where: contestteamcategoryScalarWhereInput
    data: XOR<contestteamcategoryUpdateManyMutationInput, contestteamcategoryUncheckedUpdateManyWithoutContestInput>
  }

  export type contestteamcategoryScalarWhereInput = {
    AND?: contestteamcategoryScalarWhereInput | contestteamcategoryScalarWhereInput[]
    OR?: contestteamcategoryScalarWhereInput[]
    NOT?: contestteamcategoryScalarWhereInput | contestteamcategoryScalarWhereInput[]
    cid?: IntFilter<"contestteamcategory"> | number
    categoryid?: IntFilter<"contestteamcategory"> | number
  }

  export type contestteamcategoryformedalsUpsertWithWhereUniqueWithoutContestInput = {
    where: contestteamcategoryformedalsWhereUniqueInput
    update: XOR<contestteamcategoryformedalsUpdateWithoutContestInput, contestteamcategoryformedalsUncheckedUpdateWithoutContestInput>
    create: XOR<contestteamcategoryformedalsCreateWithoutContestInput, contestteamcategoryformedalsUncheckedCreateWithoutContestInput>
  }

  export type contestteamcategoryformedalsUpdateWithWhereUniqueWithoutContestInput = {
    where: contestteamcategoryformedalsWhereUniqueInput
    data: XOR<contestteamcategoryformedalsUpdateWithoutContestInput, contestteamcategoryformedalsUncheckedUpdateWithoutContestInput>
  }

  export type contestteamcategoryformedalsUpdateManyWithWhereWithoutContestInput = {
    where: contestteamcategoryformedalsScalarWhereInput
    data: XOR<contestteamcategoryformedalsUpdateManyMutationInput, contestteamcategoryformedalsUncheckedUpdateManyWithoutContestInput>
  }

  export type contestteamcategoryformedalsScalarWhereInput = {
    AND?: contestteamcategoryformedalsScalarWhereInput | contestteamcategoryformedalsScalarWhereInput[]
    OR?: contestteamcategoryformedalsScalarWhereInput[]
    NOT?: contestteamcategoryformedalsScalarWhereInput | contestteamcategoryformedalsScalarWhereInput[]
    cid?: IntFilter<"contestteamcategoryformedals"> | number
    categoryid?: IntFilter<"contestteamcategoryformedals"> | number
  }

  export type eventUpsertWithWhereUniqueWithoutContestInput = {
    where: eventWhereUniqueInput
    update: XOR<eventUpdateWithoutContestInput, eventUncheckedUpdateWithoutContestInput>
    create: XOR<eventCreateWithoutContestInput, eventUncheckedCreateWithoutContestInput>
  }

  export type eventUpdateWithWhereUniqueWithoutContestInput = {
    where: eventWhereUniqueInput
    data: XOR<eventUpdateWithoutContestInput, eventUncheckedUpdateWithoutContestInput>
  }

  export type eventUpdateManyWithWhereWithoutContestInput = {
    where: eventScalarWhereInput
    data: XOR<eventUpdateManyMutationInput, eventUncheckedUpdateManyWithoutContestInput>
  }

  export type eventScalarWhereInput = {
    AND?: eventScalarWhereInput | eventScalarWhereInput[]
    OR?: eventScalarWhereInput[]
    NOT?: eventScalarWhereInput | eventScalarWhereInput[]
    eventid?: IntFilter<"event"> | number
    eventtime?: DecimalFilter<"event"> | Decimal | DecimalJsLike | number | string
    cid?: IntNullableFilter<"event"> | number | null
    endpointtype?: StringFilter<"event"> | string
    endpointid?: StringFilter<"event"> | string
    action?: StringFilter<"event"> | string
    content?: BytesFilter<"event"> | Buffer
  }

  export type external_contest_sourceUpsertWithoutContestInput = {
    update: XOR<external_contest_sourceUpdateWithoutContestInput, external_contest_sourceUncheckedUpdateWithoutContestInput>
    create: XOR<external_contest_sourceCreateWithoutContestInput, external_contest_sourceUncheckedCreateWithoutContestInput>
    where?: external_contest_sourceWhereInput
  }

  export type external_contest_sourceUpdateToOneWithWhereWithoutContestInput = {
    where?: external_contest_sourceWhereInput
    data: XOR<external_contest_sourceUpdateWithoutContestInput, external_contest_sourceUncheckedUpdateWithoutContestInput>
  }

  export type external_contest_sourceUpdateWithoutContestInput = {
    type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    last_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_poll_time?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    external_source_warning?: external_source_warningUpdateManyWithoutExternal_contest_sourceNestedInput
  }

  export type external_contest_sourceUncheckedUpdateWithoutContestInput = {
    extsourceid?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    last_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_poll_time?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    external_source_warning?: external_source_warningUncheckedUpdateManyWithoutExternal_contest_sourceNestedInput
  }

  export type external_judgementUpsertWithWhereUniqueWithoutContestInput = {
    where: external_judgementWhereUniqueInput
    update: XOR<external_judgementUpdateWithoutContestInput, external_judgementUncheckedUpdateWithoutContestInput>
    create: XOR<external_judgementCreateWithoutContestInput, external_judgementUncheckedCreateWithoutContestInput>
  }

  export type external_judgementUpdateWithWhereUniqueWithoutContestInput = {
    where: external_judgementWhereUniqueInput
    data: XOR<external_judgementUpdateWithoutContestInput, external_judgementUncheckedUpdateWithoutContestInput>
  }

  export type external_judgementUpdateManyWithWhereWithoutContestInput = {
    where: external_judgementScalarWhereInput
    data: XOR<external_judgementUpdateManyMutationInput, external_judgementUncheckedUpdateManyWithoutContestInput>
  }

  export type external_judgementScalarWhereInput = {
    AND?: external_judgementScalarWhereInput | external_judgementScalarWhereInput[]
    OR?: external_judgementScalarWhereInput[]
    NOT?: external_judgementScalarWhereInput | external_judgementScalarWhereInput[]
    extjudgementid?: IntFilter<"external_judgement"> | number
    externalid?: StringNullableFilter<"external_judgement"> | string | null
    cid?: IntNullableFilter<"external_judgement"> | number | null
    submitid?: IntNullableFilter<"external_judgement"> | number | null
    result?: StringNullableFilter<"external_judgement"> | string | null
    verified?: BoolFilter<"external_judgement"> | boolean
    jury_member?: StringNullableFilter<"external_judgement"> | string | null
    verify_comment?: StringNullableFilter<"external_judgement"> | string | null
    starttime?: DecimalFilter<"external_judgement"> | Decimal | DecimalJsLike | number | string
    endtime?: DecimalNullableFilter<"external_judgement"> | Decimal | DecimalJsLike | number | string | null
    valid?: BoolFilter<"external_judgement"> | boolean
  }

  export type external_runUpsertWithWhereUniqueWithoutContestInput = {
    where: external_runWhereUniqueInput
    update: XOR<external_runUpdateWithoutContestInput, external_runUncheckedUpdateWithoutContestInput>
    create: XOR<external_runCreateWithoutContestInput, external_runUncheckedCreateWithoutContestInput>
  }

  export type external_runUpdateWithWhereUniqueWithoutContestInput = {
    where: external_runWhereUniqueInput
    data: XOR<external_runUpdateWithoutContestInput, external_runUncheckedUpdateWithoutContestInput>
  }

  export type external_runUpdateManyWithWhereWithoutContestInput = {
    where: external_runScalarWhereInput
    data: XOR<external_runUpdateManyMutationInput, external_runUncheckedUpdateManyWithoutContestInput>
  }

  export type external_runScalarWhereInput = {
    AND?: external_runScalarWhereInput | external_runScalarWhereInput[]
    OR?: external_runScalarWhereInput[]
    NOT?: external_runScalarWhereInput | external_runScalarWhereInput[]
    extrunid?: IntFilter<"external_run"> | number
    extjudgementid?: IntNullableFilter<"external_run"> | number | null
    testcaseid?: IntNullableFilter<"external_run"> | number | null
    externalid?: StringNullableFilter<"external_run"> | string | null
    cid?: IntNullableFilter<"external_run"> | number | null
    result?: StringFilter<"external_run"> | string
    endtime?: DecimalFilter<"external_run"> | Decimal | DecimalJsLike | number | string
    runtime?: FloatFilter<"external_run"> | number
  }

  export type internal_errorUpsertWithWhereUniqueWithoutContestInput = {
    where: internal_errorWhereUniqueInput
    update: XOR<internal_errorUpdateWithoutContestInput, internal_errorUncheckedUpdateWithoutContestInput>
    create: XOR<internal_errorCreateWithoutContestInput, internal_errorUncheckedCreateWithoutContestInput>
  }

  export type internal_errorUpdateWithWhereUniqueWithoutContestInput = {
    where: internal_errorWhereUniqueInput
    data: XOR<internal_errorUpdateWithoutContestInput, internal_errorUncheckedUpdateWithoutContestInput>
  }

  export type internal_errorUpdateManyWithWhereWithoutContestInput = {
    where: internal_errorScalarWhereInput
    data: XOR<internal_errorUpdateManyMutationInput, internal_errorUncheckedUpdateManyWithoutContestInput>
  }

  export type internal_errorScalarWhereInput = {
    AND?: internal_errorScalarWhereInput | internal_errorScalarWhereInput[]
    OR?: internal_errorScalarWhereInput[]
    NOT?: internal_errorScalarWhereInput | internal_errorScalarWhereInput[]
    errorid?: IntFilter<"internal_error"> | number
    judgingid?: IntNullableFilter<"internal_error"> | number | null
    cid?: IntNullableFilter<"internal_error"> | number | null
    description?: StringFilter<"internal_error"> | string
    judgehostlog?: StringFilter<"internal_error"> | string
    time?: DecimalFilter<"internal_error"> | Decimal | DecimalJsLike | number | string
    disabled?: StringFilter<"internal_error"> | string
    status?: Enuminternal_error_statusFilter<"internal_error"> | $Enums.internal_error_status
  }

  export type judgingUpsertWithWhereUniqueWithoutContestInput = {
    where: judgingWhereUniqueInput
    update: XOR<judgingUpdateWithoutContestInput, judgingUncheckedUpdateWithoutContestInput>
    create: XOR<judgingCreateWithoutContestInput, judgingUncheckedCreateWithoutContestInput>
  }

  export type judgingUpdateWithWhereUniqueWithoutContestInput = {
    where: judgingWhereUniqueInput
    data: XOR<judgingUpdateWithoutContestInput, judgingUncheckedUpdateWithoutContestInput>
  }

  export type judgingUpdateManyWithWhereWithoutContestInput = {
    where: judgingScalarWhereInput
    data: XOR<judgingUpdateManyMutationInput, judgingUncheckedUpdateManyWithoutContestInput>
  }

  export type judgingScalarWhereInput = {
    AND?: judgingScalarWhereInput | judgingScalarWhereInput[]
    OR?: judgingScalarWhereInput[]
    NOT?: judgingScalarWhereInput | judgingScalarWhereInput[]
    judgingid?: IntFilter<"judging"> | number
    cid?: IntNullableFilter<"judging"> | number | null
    submitid?: IntNullableFilter<"judging"> | number | null
    starttime?: DecimalNullableFilter<"judging"> | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalNullableFilter<"judging"> | Decimal | DecimalJsLike | number | string | null
    result?: StringNullableFilter<"judging"> | string | null
    verified?: BoolFilter<"judging"> | boolean
    jury_member?: StringNullableFilter<"judging"> | string | null
    verify_comment?: StringNullableFilter<"judging"> | string | null
    valid?: BoolFilter<"judging"> | boolean
    output_compile?: BytesNullableFilter<"judging"> | Buffer | null
    seen?: BoolFilter<"judging"> | boolean
    rejudgingid?: IntNullableFilter<"judging"> | number | null
    prevjudgingid?: IntNullableFilter<"judging"> | number | null
    judge_completely?: BoolFilter<"judging"> | boolean
    errorid?: IntNullableFilter<"judging"> | number | null
    uuid?: StringFilter<"judging"> | string
    metadata?: BytesNullableFilter<"judging"> | Buffer | null
  }

  export type rankcacheUpsertWithWhereUniqueWithoutContestInput = {
    where: rankcacheWhereUniqueInput
    update: XOR<rankcacheUpdateWithoutContestInput, rankcacheUncheckedUpdateWithoutContestInput>
    create: XOR<rankcacheCreateWithoutContestInput, rankcacheUncheckedCreateWithoutContestInput>
  }

  export type rankcacheUpdateWithWhereUniqueWithoutContestInput = {
    where: rankcacheWhereUniqueInput
    data: XOR<rankcacheUpdateWithoutContestInput, rankcacheUncheckedUpdateWithoutContestInput>
  }

  export type rankcacheUpdateManyWithWhereWithoutContestInput = {
    where: rankcacheScalarWhereInput
    data: XOR<rankcacheUpdateManyMutationInput, rankcacheUncheckedUpdateManyWithoutContestInput>
  }

  export type rankcacheScalarWhereInput = {
    AND?: rankcacheScalarWhereInput | rankcacheScalarWhereInput[]
    OR?: rankcacheScalarWhereInput[]
    NOT?: rankcacheScalarWhereInput | rankcacheScalarWhereInput[]
    cid?: IntFilter<"rankcache"> | number
    teamid?: IntFilter<"rankcache"> | number
    points_restricted?: IntFilter<"rankcache"> | number
    totaltime_restricted?: IntFilter<"rankcache"> | number
    points_public?: IntFilter<"rankcache"> | number
    totaltime_public?: IntFilter<"rankcache"> | number
  }

  export type removed_intervalUpsertWithWhereUniqueWithoutContestInput = {
    where: removed_intervalWhereUniqueInput
    update: XOR<removed_intervalUpdateWithoutContestInput, removed_intervalUncheckedUpdateWithoutContestInput>
    create: XOR<removed_intervalCreateWithoutContestInput, removed_intervalUncheckedCreateWithoutContestInput>
  }

  export type removed_intervalUpdateWithWhereUniqueWithoutContestInput = {
    where: removed_intervalWhereUniqueInput
    data: XOR<removed_intervalUpdateWithoutContestInput, removed_intervalUncheckedUpdateWithoutContestInput>
  }

  export type removed_intervalUpdateManyWithWhereWithoutContestInput = {
    where: removed_intervalScalarWhereInput
    data: XOR<removed_intervalUpdateManyMutationInput, removed_intervalUncheckedUpdateManyWithoutContestInput>
  }

  export type removed_intervalScalarWhereInput = {
    AND?: removed_intervalScalarWhereInput | removed_intervalScalarWhereInput[]
    OR?: removed_intervalScalarWhereInput[]
    NOT?: removed_intervalScalarWhereInput | removed_intervalScalarWhereInput[]
    intervalid?: IntFilter<"removed_interval"> | number
    cid?: IntNullableFilter<"removed_interval"> | number | null
    starttime?: DecimalFilter<"removed_interval"> | Decimal | DecimalJsLike | number | string
    endtime?: DecimalFilter<"removed_interval"> | Decimal | DecimalJsLike | number | string
    starttime_string?: StringFilter<"removed_interval"> | string
    endtime_string?: StringFilter<"removed_interval"> | string
  }

  export type scorecacheUpsertWithWhereUniqueWithoutContestInput = {
    where: scorecacheWhereUniqueInput
    update: XOR<scorecacheUpdateWithoutContestInput, scorecacheUncheckedUpdateWithoutContestInput>
    create: XOR<scorecacheCreateWithoutContestInput, scorecacheUncheckedCreateWithoutContestInput>
  }

  export type scorecacheUpdateWithWhereUniqueWithoutContestInput = {
    where: scorecacheWhereUniqueInput
    data: XOR<scorecacheUpdateWithoutContestInput, scorecacheUncheckedUpdateWithoutContestInput>
  }

  export type scorecacheUpdateManyWithWhereWithoutContestInput = {
    where: scorecacheScalarWhereInput
    data: XOR<scorecacheUpdateManyMutationInput, scorecacheUncheckedUpdateManyWithoutContestInput>
  }

  export type scorecacheScalarWhereInput = {
    AND?: scorecacheScalarWhereInput | scorecacheScalarWhereInput[]
    OR?: scorecacheScalarWhereInput[]
    NOT?: scorecacheScalarWhereInput | scorecacheScalarWhereInput[]
    cid?: IntFilter<"scorecache"> | number
    teamid?: IntFilter<"scorecache"> | number
    probid?: IntFilter<"scorecache"> | number
    submissions_restricted?: IntFilter<"scorecache"> | number
    pending_restricted?: IntFilter<"scorecache"> | number
    solvetime_restricted?: DecimalFilter<"scorecache"> | Decimal | DecimalJsLike | number | string
    is_correct_restricted?: BoolFilter<"scorecache"> | boolean
    submissions_public?: IntFilter<"scorecache"> | number
    pending_public?: IntFilter<"scorecache"> | number
    solvetime_public?: DecimalFilter<"scorecache"> | Decimal | DecimalJsLike | number | string
    is_correct_public?: BoolFilter<"scorecache"> | boolean
    is_first_to_solve?: BoolFilter<"scorecache"> | boolean
  }

  export type submissionUpsertWithWhereUniqueWithoutContestInput = {
    where: submissionWhereUniqueInput
    update: XOR<submissionUpdateWithoutContestInput, submissionUncheckedUpdateWithoutContestInput>
    create: XOR<submissionCreateWithoutContestInput, submissionUncheckedCreateWithoutContestInput>
  }

  export type submissionUpdateWithWhereUniqueWithoutContestInput = {
    where: submissionWhereUniqueInput
    data: XOR<submissionUpdateWithoutContestInput, submissionUncheckedUpdateWithoutContestInput>
  }

  export type submissionUpdateManyWithWhereWithoutContestInput = {
    where: submissionScalarWhereInput
    data: XOR<submissionUpdateManyMutationInput, submissionUncheckedUpdateManyWithoutContestInput>
  }

  export type submissionScalarWhereInput = {
    AND?: submissionScalarWhereInput | submissionScalarWhereInput[]
    OR?: submissionScalarWhereInput[]
    NOT?: submissionScalarWhereInput | submissionScalarWhereInput[]
    submitid?: IntFilter<"submission"> | number
    origsubmitid?: IntNullableFilter<"submission"> | number | null
    cid?: IntNullableFilter<"submission"> | number | null
    teamid?: IntNullableFilter<"submission"> | number | null
    userid?: IntNullableFilter<"submission"> | number | null
    probid?: IntNullableFilter<"submission"> | number | null
    langid?: StringNullableFilter<"submission"> | string | null
    submittime?: DecimalFilter<"submission"> | Decimal | DecimalJsLike | number | string
    valid?: BoolFilter<"submission"> | boolean
    rejudgingid?: IntNullableFilter<"submission"> | number | null
    expected_results?: StringNullableFilter<"submission"> | string | null
    externalid?: StringNullableFilter<"submission"> | string | null
    entry_point?: StringNullableFilter<"submission"> | string | null
  }

  export type contestCreateWithoutContestproblemInput = {
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationCreateNestedManyWithoutContestInput
    contestteam?: contestteamCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsCreateNestedManyWithoutContestInput
    event?: eventCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementCreateNestedManyWithoutContestInput
    external_run?: external_runCreateNestedManyWithoutContestInput
    internal_error?: internal_errorCreateNestedManyWithoutContestInput
    judging?: judgingCreateNestedManyWithoutContestInput
    rankcache?: rankcacheCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalCreateNestedManyWithoutContestInput
    scorecache?: scorecacheCreateNestedManyWithoutContestInput
    submission?: submissionCreateNestedManyWithoutContestInput
  }

  export type contestUncheckedCreateWithoutContestproblemInput = {
    cid?: number
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutContestInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryUncheckedCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedCreateNestedManyWithoutContestInput
    event?: eventUncheckedCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceUncheckedCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutContestInput
    external_run?: external_runUncheckedCreateNestedManyWithoutContestInput
    internal_error?: internal_errorUncheckedCreateNestedManyWithoutContestInput
    judging?: judgingUncheckedCreateNestedManyWithoutContestInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalUncheckedCreateNestedManyWithoutContestInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutContestInput
    submission?: submissionUncheckedCreateNestedManyWithoutContestInput
  }

  export type contestCreateOrConnectWithoutContestproblemInput = {
    where: contestWhereUniqueInput
    create: XOR<contestCreateWithoutContestproblemInput, contestUncheckedCreateWithoutContestproblemInput>
  }

  export type problemCreateWithoutContestproblemInput = {
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
    clarification?: clarificationCreateNestedManyWithoutProblemInput
    executable_problem_special_runToexecutable?: executableCreateNestedOneWithoutProblem_problem_special_runToexecutableInput
    executable_problem_special_compareToexecutable?: executableCreateNestedOneWithoutProblem_problem_special_compareToexecutableInput
    problem_attachment?: problem_attachmentCreateNestedManyWithoutProblemInput
    scorecache?: scorecacheCreateNestedManyWithoutProblemInput
    submission?: submissionCreateNestedManyWithoutProblemInput
    testcase?: testcaseCreateNestedManyWithoutProblemInput
  }

  export type problemUncheckedCreateWithoutContestproblemInput = {
    probid?: number
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_run?: string | null
    special_compare?: string | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutProblemInput
    problem_attachment?: problem_attachmentUncheckedCreateNestedManyWithoutProblemInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutProblemInput
    submission?: submissionUncheckedCreateNestedManyWithoutProblemInput
    testcase?: testcaseUncheckedCreateNestedManyWithoutProblemInput
  }

  export type problemCreateOrConnectWithoutContestproblemInput = {
    where: problemWhereUniqueInput
    create: XOR<problemCreateWithoutContestproblemInput, problemUncheckedCreateWithoutContestproblemInput>
  }

  export type submissionCreateWithoutContestproblemInput = {
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementCreateNestedManyWithoutSubmissionInput
    judging?: judgingCreateNestedManyWithoutSubmissionInput
    user?: userCreateNestedOneWithoutSubmissionInput
    contest?: contestCreateNestedOneWithoutSubmissionInput
    team?: teamCreateNestedOneWithoutSubmissionInput
    problem?: problemCreateNestedOneWithoutSubmissionInput
    language?: languageCreateNestedOneWithoutSubmissionInput
    submission?: submissionCreateNestedOneWithoutOther_submissionInput
    other_submission?: submissionCreateNestedManyWithoutSubmissionInput
    rejudging?: rejudgingCreateNestedOneWithoutSubmissionInput
    submission_file?: submission_fileCreateNestedManyWithoutSubmissionInput
  }

  export type submissionUncheckedCreateWithoutContestproblemInput = {
    submitid?: number
    origsubmitid?: number | null
    teamid?: number | null
    userid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonUncheckedCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutSubmissionInput
    judging?: judgingUncheckedCreateNestedManyWithoutSubmissionInput
    other_submission?: submissionUncheckedCreateNestedManyWithoutSubmissionInput
    submission_file?: submission_fileUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type submissionCreateOrConnectWithoutContestproblemInput = {
    where: submissionWhereUniqueInput
    create: XOR<submissionCreateWithoutContestproblemInput, submissionUncheckedCreateWithoutContestproblemInput>
  }

  export type submissionCreateManyContestproblemInputEnvelope = {
    data: submissionCreateManyContestproblemInput | submissionCreateManyContestproblemInput[]
    skipDuplicates?: boolean
  }

  export type contestUpsertWithoutContestproblemInput = {
    update: XOR<contestUpdateWithoutContestproblemInput, contestUncheckedUpdateWithoutContestproblemInput>
    create: XOR<contestCreateWithoutContestproblemInput, contestUncheckedCreateWithoutContestproblemInput>
    where?: contestWhereInput
  }

  export type contestUpdateToOneWithWhereWithoutContestproblemInput = {
    where?: contestWhereInput
    data: XOR<contestUpdateWithoutContestproblemInput, contestUncheckedUpdateWithoutContestproblemInput>
  }

  export type contestUpdateWithoutContestproblemInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUpdateManyWithoutContestNestedInput
    event?: eventUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUpdateManyWithoutContestNestedInput
    external_run?: external_runUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUpdateManyWithoutContestNestedInput
    judging?: judgingUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUpdateManyWithoutContestNestedInput
    submission?: submissionUpdateManyWithoutContestNestedInput
  }

  export type contestUncheckedUpdateWithoutContestproblemInput = {
    cid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedUpdateManyWithoutContestNestedInput
    event?: eventUncheckedUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUncheckedUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutContestNestedInput
    external_run?: external_runUncheckedUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUncheckedUpdateManyWithoutContestNestedInput
    judging?: judgingUncheckedUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUncheckedUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutContestNestedInput
    submission?: submissionUncheckedUpdateManyWithoutContestNestedInput
  }

  export type problemUpsertWithoutContestproblemInput = {
    update: XOR<problemUpdateWithoutContestproblemInput, problemUncheckedUpdateWithoutContestproblemInput>
    create: XOR<problemCreateWithoutContestproblemInput, problemUncheckedCreateWithoutContestproblemInput>
    where?: problemWhereInput
  }

  export type problemUpdateToOneWithWhereWithoutContestproblemInput = {
    where?: problemWhereInput
    data: XOR<problemUpdateWithoutContestproblemInput, problemUncheckedUpdateWithoutContestproblemInput>
  }

  export type problemUpdateWithoutContestproblemInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutProblemNestedInput
    executable_problem_special_runToexecutable?: executableUpdateOneWithoutProblem_problem_special_runToexecutableNestedInput
    executable_problem_special_compareToexecutable?: executableUpdateOneWithoutProblem_problem_special_compareToexecutableNestedInput
    problem_attachment?: problem_attachmentUpdateManyWithoutProblemNestedInput
    scorecache?: scorecacheUpdateManyWithoutProblemNestedInput
    submission?: submissionUpdateManyWithoutProblemNestedInput
    testcase?: testcaseUpdateManyWithoutProblemNestedInput
  }

  export type problemUncheckedUpdateWithoutContestproblemInput = {
    probid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_run?: NullableStringFieldUpdateOperationsInput | string | null
    special_compare?: NullableStringFieldUpdateOperationsInput | string | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutProblemNestedInput
    problem_attachment?: problem_attachmentUncheckedUpdateManyWithoutProblemNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutProblemNestedInput
    submission?: submissionUncheckedUpdateManyWithoutProblemNestedInput
    testcase?: testcaseUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type submissionUpsertWithWhereUniqueWithoutContestproblemInput = {
    where: submissionWhereUniqueInput
    update: XOR<submissionUpdateWithoutContestproblemInput, submissionUncheckedUpdateWithoutContestproblemInput>
    create: XOR<submissionCreateWithoutContestproblemInput, submissionUncheckedCreateWithoutContestproblemInput>
  }

  export type submissionUpdateWithWhereUniqueWithoutContestproblemInput = {
    where: submissionWhereUniqueInput
    data: XOR<submissionUpdateWithoutContestproblemInput, submissionUncheckedUpdateWithoutContestproblemInput>
  }

  export type submissionUpdateManyWithWhereWithoutContestproblemInput = {
    where: submissionScalarWhereInput
    data: XOR<submissionUpdateManyMutationInput, submissionUncheckedUpdateManyWithoutContestproblemInput>
  }

  export type contestCreateWithoutContestteamInput = {
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsCreateNestedManyWithoutContestInput
    event?: eventCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementCreateNestedManyWithoutContestInput
    external_run?: external_runCreateNestedManyWithoutContestInput
    internal_error?: internal_errorCreateNestedManyWithoutContestInput
    judging?: judgingCreateNestedManyWithoutContestInput
    rankcache?: rankcacheCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalCreateNestedManyWithoutContestInput
    scorecache?: scorecacheCreateNestedManyWithoutContestInput
    submission?: submissionCreateNestedManyWithoutContestInput
  }

  export type contestUncheckedCreateWithoutContestteamInput = {
    cid?: number
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryUncheckedCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedCreateNestedManyWithoutContestInput
    event?: eventUncheckedCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceUncheckedCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutContestInput
    external_run?: external_runUncheckedCreateNestedManyWithoutContestInput
    internal_error?: internal_errorUncheckedCreateNestedManyWithoutContestInput
    judging?: judgingUncheckedCreateNestedManyWithoutContestInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalUncheckedCreateNestedManyWithoutContestInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutContestInput
    submission?: submissionUncheckedCreateNestedManyWithoutContestInput
  }

  export type contestCreateOrConnectWithoutContestteamInput = {
    where: contestWhereUniqueInput
    create: XOR<contestCreateWithoutContestteamInput, contestUncheckedCreateWithoutContestteamInput>
  }

  export type teamCreateWithoutContestteamInput = {
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationCreateNestedManyWithoutTeam_clarification_senderToteamInput
    clarification_clarification_recipientToteam?: clarificationCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    queuetask?: queuetaskCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheCreateNestedManyWithoutTeamInput
    submission?: submissionCreateNestedManyWithoutTeamInput
    team_category?: team_categoryCreateNestedOneWithoutTeamInput
    team_affiliation?: team_affiliationCreateNestedOneWithoutTeamInput
    team_unread?: team_unreadCreateNestedManyWithoutTeamInput
    user?: userCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutContestteamInput = {
    teamid?: number
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    categoryid?: number | null
    affilid?: number | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_senderToteamInput
    clarification_clarification_recipientToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    queuetask?: queuetaskUncheckedCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutTeamInput
    submission?: submissionUncheckedCreateNestedManyWithoutTeamInput
    team_unread?: team_unreadUncheckedCreateNestedManyWithoutTeamInput
    user?: userUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutContestteamInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutContestteamInput, teamUncheckedCreateWithoutContestteamInput>
  }

  export type contestUpsertWithoutContestteamInput = {
    update: XOR<contestUpdateWithoutContestteamInput, contestUncheckedUpdateWithoutContestteamInput>
    create: XOR<contestCreateWithoutContestteamInput, contestUncheckedCreateWithoutContestteamInput>
    where?: contestWhereInput
  }

  export type contestUpdateToOneWithWhereWithoutContestteamInput = {
    where?: contestWhereInput
    data: XOR<contestUpdateWithoutContestteamInput, contestUncheckedUpdateWithoutContestteamInput>
  }

  export type contestUpdateWithoutContestteamInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUpdateManyWithoutContestNestedInput
    event?: eventUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUpdateManyWithoutContestNestedInput
    external_run?: external_runUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUpdateManyWithoutContestNestedInput
    judging?: judgingUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUpdateManyWithoutContestNestedInput
    submission?: submissionUpdateManyWithoutContestNestedInput
  }

  export type contestUncheckedUpdateWithoutContestteamInput = {
    cid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedUpdateManyWithoutContestNestedInput
    event?: eventUncheckedUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUncheckedUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutContestNestedInput
    external_run?: external_runUncheckedUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUncheckedUpdateManyWithoutContestNestedInput
    judging?: judgingUncheckedUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUncheckedUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutContestNestedInput
    submission?: submissionUncheckedUpdateManyWithoutContestNestedInput
  }

  export type teamUpsertWithoutContestteamInput = {
    update: XOR<teamUpdateWithoutContestteamInput, teamUncheckedUpdateWithoutContestteamInput>
    create: XOR<teamCreateWithoutContestteamInput, teamUncheckedCreateWithoutContestteamInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutContestteamInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutContestteamInput, teamUncheckedUpdateWithoutContestteamInput>
  }

  export type teamUpdateWithoutContestteamInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    clarification_clarification_recipientToteam?: clarificationUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    queuetask?: queuetaskUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUpdateManyWithoutTeamNestedInput
    submission?: submissionUpdateManyWithoutTeamNestedInput
    team_category?: team_categoryUpdateOneWithoutTeamNestedInput
    team_affiliation?: team_affiliationUpdateOneWithoutTeamNestedInput
    team_unread?: team_unreadUpdateManyWithoutTeamNestedInput
    user?: userUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutContestteamInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    categoryid?: NullableIntFieldUpdateOperationsInput | number | null
    affilid?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    clarification_clarification_recipientToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    queuetask?: queuetaskUncheckedUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutTeamNestedInput
    submission?: submissionUncheckedUpdateManyWithoutTeamNestedInput
    team_unread?: team_unreadUncheckedUpdateManyWithoutTeamNestedInput
    user?: userUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type contestCreateWithoutContestteamcategoryInput = {
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemCreateNestedManyWithoutContestInput
    contestteam?: contestteamCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsCreateNestedManyWithoutContestInput
    event?: eventCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementCreateNestedManyWithoutContestInput
    external_run?: external_runCreateNestedManyWithoutContestInput
    internal_error?: internal_errorCreateNestedManyWithoutContestInput
    judging?: judgingCreateNestedManyWithoutContestInput
    rankcache?: rankcacheCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalCreateNestedManyWithoutContestInput
    scorecache?: scorecacheCreateNestedManyWithoutContestInput
    submission?: submissionCreateNestedManyWithoutContestInput
  }

  export type contestUncheckedCreateWithoutContestteamcategoryInput = {
    cid?: number
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutContestInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedCreateNestedManyWithoutContestInput
    event?: eventUncheckedCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceUncheckedCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutContestInput
    external_run?: external_runUncheckedCreateNestedManyWithoutContestInput
    internal_error?: internal_errorUncheckedCreateNestedManyWithoutContestInput
    judging?: judgingUncheckedCreateNestedManyWithoutContestInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalUncheckedCreateNestedManyWithoutContestInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutContestInput
    submission?: submissionUncheckedCreateNestedManyWithoutContestInput
  }

  export type contestCreateOrConnectWithoutContestteamcategoryInput = {
    where: contestWhereUniqueInput
    create: XOR<contestCreateWithoutContestteamcategoryInput, contestUncheckedCreateWithoutContestteamcategoryInput>
  }

  export type team_categoryCreateWithoutContestteamcategoryInput = {
    externalid?: string | null
    icpcid?: string | null
    name: string
    sortorder?: boolean
    color?: string | null
    visible?: boolean
    allow_self_registration?: boolean
    contestteamcategoryformedals?: contestteamcategoryformedalsCreateNestedManyWithoutTeam_categoryInput
    team?: teamCreateNestedManyWithoutTeam_categoryInput
  }

  export type team_categoryUncheckedCreateWithoutContestteamcategoryInput = {
    categoryid?: number
    externalid?: string | null
    icpcid?: string | null
    name: string
    sortorder?: boolean
    color?: string | null
    visible?: boolean
    allow_self_registration?: boolean
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedCreateNestedManyWithoutTeam_categoryInput
    team?: teamUncheckedCreateNestedManyWithoutTeam_categoryInput
  }

  export type team_categoryCreateOrConnectWithoutContestteamcategoryInput = {
    where: team_categoryWhereUniqueInput
    create: XOR<team_categoryCreateWithoutContestteamcategoryInput, team_categoryUncheckedCreateWithoutContestteamcategoryInput>
  }

  export type contestUpsertWithoutContestteamcategoryInput = {
    update: XOR<contestUpdateWithoutContestteamcategoryInput, contestUncheckedUpdateWithoutContestteamcategoryInput>
    create: XOR<contestCreateWithoutContestteamcategoryInput, contestUncheckedCreateWithoutContestteamcategoryInput>
    where?: contestWhereInput
  }

  export type contestUpdateToOneWithWhereWithoutContestteamcategoryInput = {
    where?: contestWhereInput
    data: XOR<contestUpdateWithoutContestteamcategoryInput, contestUncheckedUpdateWithoutContestteamcategoryInput>
  }

  export type contestUpdateWithoutContestteamcategoryInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUpdateManyWithoutContestNestedInput
    event?: eventUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUpdateManyWithoutContestNestedInput
    external_run?: external_runUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUpdateManyWithoutContestNestedInput
    judging?: judgingUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUpdateManyWithoutContestNestedInput
    submission?: submissionUpdateManyWithoutContestNestedInput
  }

  export type contestUncheckedUpdateWithoutContestteamcategoryInput = {
    cid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedUpdateManyWithoutContestNestedInput
    event?: eventUncheckedUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUncheckedUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutContestNestedInput
    external_run?: external_runUncheckedUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUncheckedUpdateManyWithoutContestNestedInput
    judging?: judgingUncheckedUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUncheckedUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutContestNestedInput
    submission?: submissionUncheckedUpdateManyWithoutContestNestedInput
  }

  export type team_categoryUpsertWithoutContestteamcategoryInput = {
    update: XOR<team_categoryUpdateWithoutContestteamcategoryInput, team_categoryUncheckedUpdateWithoutContestteamcategoryInput>
    create: XOR<team_categoryCreateWithoutContestteamcategoryInput, team_categoryUncheckedCreateWithoutContestteamcategoryInput>
    where?: team_categoryWhereInput
  }

  export type team_categoryUpdateToOneWithWhereWithoutContestteamcategoryInput = {
    where?: team_categoryWhereInput
    data: XOR<team_categoryUpdateWithoutContestteamcategoryInput, team_categoryUncheckedUpdateWithoutContestteamcategoryInput>
  }

  export type team_categoryUpdateWithoutContestteamcategoryInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sortorder?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    allow_self_registration?: BoolFieldUpdateOperationsInput | boolean
    contestteamcategoryformedals?: contestteamcategoryformedalsUpdateManyWithoutTeam_categoryNestedInput
    team?: teamUpdateManyWithoutTeam_categoryNestedInput
  }

  export type team_categoryUncheckedUpdateWithoutContestteamcategoryInput = {
    categoryid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sortorder?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    allow_self_registration?: BoolFieldUpdateOperationsInput | boolean
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedUpdateManyWithoutTeam_categoryNestedInput
    team?: teamUncheckedUpdateManyWithoutTeam_categoryNestedInput
  }

  export type contestCreateWithoutContestteamcategoryformedalsInput = {
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemCreateNestedManyWithoutContestInput
    contestteam?: contestteamCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryCreateNestedManyWithoutContestInput
    event?: eventCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementCreateNestedManyWithoutContestInput
    external_run?: external_runCreateNestedManyWithoutContestInput
    internal_error?: internal_errorCreateNestedManyWithoutContestInput
    judging?: judgingCreateNestedManyWithoutContestInput
    rankcache?: rankcacheCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalCreateNestedManyWithoutContestInput
    scorecache?: scorecacheCreateNestedManyWithoutContestInput
    submission?: submissionCreateNestedManyWithoutContestInput
  }

  export type contestUncheckedCreateWithoutContestteamcategoryformedalsInput = {
    cid?: number
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutContestInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryUncheckedCreateNestedManyWithoutContestInput
    event?: eventUncheckedCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceUncheckedCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutContestInput
    external_run?: external_runUncheckedCreateNestedManyWithoutContestInput
    internal_error?: internal_errorUncheckedCreateNestedManyWithoutContestInput
    judging?: judgingUncheckedCreateNestedManyWithoutContestInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalUncheckedCreateNestedManyWithoutContestInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutContestInput
    submission?: submissionUncheckedCreateNestedManyWithoutContestInput
  }

  export type contestCreateOrConnectWithoutContestteamcategoryformedalsInput = {
    where: contestWhereUniqueInput
    create: XOR<contestCreateWithoutContestteamcategoryformedalsInput, contestUncheckedCreateWithoutContestteamcategoryformedalsInput>
  }

  export type team_categoryCreateWithoutContestteamcategoryformedalsInput = {
    externalid?: string | null
    icpcid?: string | null
    name: string
    sortorder?: boolean
    color?: string | null
    visible?: boolean
    allow_self_registration?: boolean
    contestteamcategory?: contestteamcategoryCreateNestedManyWithoutTeam_categoryInput
    team?: teamCreateNestedManyWithoutTeam_categoryInput
  }

  export type team_categoryUncheckedCreateWithoutContestteamcategoryformedalsInput = {
    categoryid?: number
    externalid?: string | null
    icpcid?: string | null
    name: string
    sortorder?: boolean
    color?: string | null
    visible?: boolean
    allow_self_registration?: boolean
    contestteamcategory?: contestteamcategoryUncheckedCreateNestedManyWithoutTeam_categoryInput
    team?: teamUncheckedCreateNestedManyWithoutTeam_categoryInput
  }

  export type team_categoryCreateOrConnectWithoutContestteamcategoryformedalsInput = {
    where: team_categoryWhereUniqueInput
    create: XOR<team_categoryCreateWithoutContestteamcategoryformedalsInput, team_categoryUncheckedCreateWithoutContestteamcategoryformedalsInput>
  }

  export type contestUpsertWithoutContestteamcategoryformedalsInput = {
    update: XOR<contestUpdateWithoutContestteamcategoryformedalsInput, contestUncheckedUpdateWithoutContestteamcategoryformedalsInput>
    create: XOR<contestCreateWithoutContestteamcategoryformedalsInput, contestUncheckedCreateWithoutContestteamcategoryformedalsInput>
    where?: contestWhereInput
  }

  export type contestUpdateToOneWithWhereWithoutContestteamcategoryformedalsInput = {
    where?: contestWhereInput
    data: XOR<contestUpdateWithoutContestteamcategoryformedalsInput, contestUncheckedUpdateWithoutContestteamcategoryformedalsInput>
  }

  export type contestUpdateWithoutContestteamcategoryformedalsInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUpdateManyWithoutContestNestedInput
    event?: eventUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUpdateManyWithoutContestNestedInput
    external_run?: external_runUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUpdateManyWithoutContestNestedInput
    judging?: judgingUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUpdateManyWithoutContestNestedInput
    submission?: submissionUpdateManyWithoutContestNestedInput
  }

  export type contestUncheckedUpdateWithoutContestteamcategoryformedalsInput = {
    cid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUncheckedUpdateManyWithoutContestNestedInput
    event?: eventUncheckedUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUncheckedUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutContestNestedInput
    external_run?: external_runUncheckedUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUncheckedUpdateManyWithoutContestNestedInput
    judging?: judgingUncheckedUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUncheckedUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutContestNestedInput
    submission?: submissionUncheckedUpdateManyWithoutContestNestedInput
  }

  export type team_categoryUpsertWithoutContestteamcategoryformedalsInput = {
    update: XOR<team_categoryUpdateWithoutContestteamcategoryformedalsInput, team_categoryUncheckedUpdateWithoutContestteamcategoryformedalsInput>
    create: XOR<team_categoryCreateWithoutContestteamcategoryformedalsInput, team_categoryUncheckedCreateWithoutContestteamcategoryformedalsInput>
    where?: team_categoryWhereInput
  }

  export type team_categoryUpdateToOneWithWhereWithoutContestteamcategoryformedalsInput = {
    where?: team_categoryWhereInput
    data: XOR<team_categoryUpdateWithoutContestteamcategoryformedalsInput, team_categoryUncheckedUpdateWithoutContestteamcategoryformedalsInput>
  }

  export type team_categoryUpdateWithoutContestteamcategoryformedalsInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sortorder?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    allow_self_registration?: BoolFieldUpdateOperationsInput | boolean
    contestteamcategory?: contestteamcategoryUpdateManyWithoutTeam_categoryNestedInput
    team?: teamUpdateManyWithoutTeam_categoryNestedInput
  }

  export type team_categoryUncheckedUpdateWithoutContestteamcategoryformedalsInput = {
    categoryid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sortorder?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    allow_self_registration?: BoolFieldUpdateOperationsInput | boolean
    contestteamcategory?: contestteamcategoryUncheckedUpdateManyWithoutTeam_categoryNestedInput
    team?: teamUncheckedUpdateManyWithoutTeam_categoryNestedInput
  }

  export type judgingCreateWithoutDebug_packageInput = {
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    judge_completely?: boolean
    uuid: string
    metadata?: Buffer | null
    internal_error_internal_error_judgingidTojudging?: internal_errorCreateNestedManyWithoutJudging_internal_error_judgingidTojudgingInput
    internal_error_judging_erroridTointernal_error?: internal_errorCreateNestedOneWithoutJudging_judging_erroridTointernal_errorInput
    contest?: contestCreateNestedOneWithoutJudgingInput
    submission?: submissionCreateNestedOneWithoutJudgingInput
    rejudging?: rejudgingCreateNestedOneWithoutJudgingInput
    judging?: judgingCreateNestedOneWithoutOther_judgingInput
    other_judging?: judgingCreateNestedManyWithoutJudgingInput
    judging_run?: judging_runCreateNestedManyWithoutJudgingInput
  }

  export type judgingUncheckedCreateWithoutDebug_packageInput = {
    judgingid?: number
    cid?: number | null
    submitid?: number | null
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    rejudgingid?: number | null
    prevjudgingid?: number | null
    judge_completely?: boolean
    errorid?: number | null
    uuid: string
    metadata?: Buffer | null
    internal_error_internal_error_judgingidTojudging?: internal_errorUncheckedCreateNestedManyWithoutJudging_internal_error_judgingidTojudgingInput
    other_judging?: judgingUncheckedCreateNestedManyWithoutJudgingInput
    judging_run?: judging_runUncheckedCreateNestedManyWithoutJudgingInput
  }

  export type judgingCreateOrConnectWithoutDebug_packageInput = {
    where: judgingWhereUniqueInput
    create: XOR<judgingCreateWithoutDebug_packageInput, judgingUncheckedCreateWithoutDebug_packageInput>
  }

  export type judgehostCreateWithoutDebug_packageInput = {
    hostname: string
    enabled?: boolean
    polltime?: Decimal | DecimalJsLike | number | string | null
    hidden?: boolean
    judgetask?: judgetaskCreateNestedManyWithoutJudgehostInput
  }

  export type judgehostUncheckedCreateWithoutDebug_packageInput = {
    judgehostid?: number
    hostname: string
    enabled?: boolean
    polltime?: Decimal | DecimalJsLike | number | string | null
    hidden?: boolean
    judgetask?: judgetaskUncheckedCreateNestedManyWithoutJudgehostInput
  }

  export type judgehostCreateOrConnectWithoutDebug_packageInput = {
    where: judgehostWhereUniqueInput
    create: XOR<judgehostCreateWithoutDebug_packageInput, judgehostUncheckedCreateWithoutDebug_packageInput>
  }

  export type judgingUpsertWithoutDebug_packageInput = {
    update: XOR<judgingUpdateWithoutDebug_packageInput, judgingUncheckedUpdateWithoutDebug_packageInput>
    create: XOR<judgingCreateWithoutDebug_packageInput, judgingUncheckedCreateWithoutDebug_packageInput>
    where?: judgingWhereInput
  }

  export type judgingUpdateToOneWithWhereWithoutDebug_packageInput = {
    where?: judgingWhereInput
    data: XOR<judgingUpdateWithoutDebug_packageInput, judgingUncheckedUpdateWithoutDebug_packageInput>
  }

  export type judgingUpdateWithoutDebug_packageInput = {
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    internal_error_internal_error_judgingidTojudging?: internal_errorUpdateManyWithoutJudging_internal_error_judgingidTojudgingNestedInput
    internal_error_judging_erroridTointernal_error?: internal_errorUpdateOneWithoutJudging_judging_erroridTointernal_errorNestedInput
    contest?: contestUpdateOneWithoutJudgingNestedInput
    submission?: submissionUpdateOneWithoutJudgingNestedInput
    rejudging?: rejudgingUpdateOneWithoutJudgingNestedInput
    judging?: judgingUpdateOneWithoutOther_judgingNestedInput
    other_judging?: judgingUpdateManyWithoutJudgingNestedInput
    judging_run?: judging_runUpdateManyWithoutJudgingNestedInput
  }

  export type judgingUncheckedUpdateWithoutDebug_packageInput = {
    judgingid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    prevjudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    errorid?: NullableIntFieldUpdateOperationsInput | number | null
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    internal_error_internal_error_judgingidTojudging?: internal_errorUncheckedUpdateManyWithoutJudging_internal_error_judgingidTojudgingNestedInput
    other_judging?: judgingUncheckedUpdateManyWithoutJudgingNestedInput
    judging_run?: judging_runUncheckedUpdateManyWithoutJudgingNestedInput
  }

  export type judgehostUpsertWithoutDebug_packageInput = {
    update: XOR<judgehostUpdateWithoutDebug_packageInput, judgehostUncheckedUpdateWithoutDebug_packageInput>
    create: XOR<judgehostCreateWithoutDebug_packageInput, judgehostUncheckedCreateWithoutDebug_packageInput>
    where?: judgehostWhereInput
  }

  export type judgehostUpdateToOneWithWhereWithoutDebug_packageInput = {
    where?: judgehostWhereInput
    data: XOR<judgehostUpdateWithoutDebug_packageInput, judgehostUncheckedUpdateWithoutDebug_packageInput>
  }

  export type judgehostUpdateWithoutDebug_packageInput = {
    hostname?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    polltime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    judgetask?: judgetaskUpdateManyWithoutJudgehostNestedInput
  }

  export type judgehostUncheckedUpdateWithoutDebug_packageInput = {
    judgehostid?: IntFieldUpdateOperationsInput | number
    hostname?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    polltime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    judgetask?: judgetaskUncheckedUpdateManyWithoutJudgehostNestedInput
  }

  export type contestCreateWithoutEventInput = {
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemCreateNestedManyWithoutContestInput
    contestteam?: contestteamCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementCreateNestedManyWithoutContestInput
    external_run?: external_runCreateNestedManyWithoutContestInput
    internal_error?: internal_errorCreateNestedManyWithoutContestInput
    judging?: judgingCreateNestedManyWithoutContestInput
    rankcache?: rankcacheCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalCreateNestedManyWithoutContestInput
    scorecache?: scorecacheCreateNestedManyWithoutContestInput
    submission?: submissionCreateNestedManyWithoutContestInput
  }

  export type contestUncheckedCreateWithoutEventInput = {
    cid?: number
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutContestInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryUncheckedCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceUncheckedCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutContestInput
    external_run?: external_runUncheckedCreateNestedManyWithoutContestInput
    internal_error?: internal_errorUncheckedCreateNestedManyWithoutContestInput
    judging?: judgingUncheckedCreateNestedManyWithoutContestInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalUncheckedCreateNestedManyWithoutContestInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutContestInput
    submission?: submissionUncheckedCreateNestedManyWithoutContestInput
  }

  export type contestCreateOrConnectWithoutEventInput = {
    where: contestWhereUniqueInput
    create: XOR<contestCreateWithoutEventInput, contestUncheckedCreateWithoutEventInput>
  }

  export type contestUpsertWithoutEventInput = {
    update: XOR<contestUpdateWithoutEventInput, contestUncheckedUpdateWithoutEventInput>
    create: XOR<contestCreateWithoutEventInput, contestUncheckedCreateWithoutEventInput>
    where?: contestWhereInput
  }

  export type contestUpdateToOneWithWhereWithoutEventInput = {
    where?: contestWhereInput
    data: XOR<contestUpdateWithoutEventInput, contestUncheckedUpdateWithoutEventInput>
  }

  export type contestUpdateWithoutEventInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUpdateManyWithoutContestNestedInput
    external_run?: external_runUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUpdateManyWithoutContestNestedInput
    judging?: judgingUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUpdateManyWithoutContestNestedInput
    submission?: submissionUpdateManyWithoutContestNestedInput
  }

  export type contestUncheckedUpdateWithoutEventInput = {
    cid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUncheckedUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutContestNestedInput
    external_run?: external_runUncheckedUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUncheckedUpdateManyWithoutContestNestedInput
    judging?: judgingUncheckedUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUncheckedUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutContestNestedInput
    submission?: submissionUncheckedUpdateManyWithoutContestNestedInput
  }

  export type immutable_executableCreateWithoutExecutableInput = {
    hash?: string | null
    executable_file?: executable_fileCreateNestedManyWithoutImmutable_executableInput
    user?: userCreateNestedOneWithoutImmutable_executableInput
  }

  export type immutable_executableUncheckedCreateWithoutExecutableInput = {
    immutable_execid?: number
    userid?: number | null
    hash?: string | null
    executable_file?: executable_fileUncheckedCreateNestedManyWithoutImmutable_executableInput
  }

  export type immutable_executableCreateOrConnectWithoutExecutableInput = {
    where: immutable_executableWhereUniqueInput
    create: XOR<immutable_executableCreateWithoutExecutableInput, immutable_executableUncheckedCreateWithoutExecutableInput>
  }

  export type languageCreateWithoutExecutableInput = {
    langid: string
    externalid?: string | null
    name: string
    extensions?: string | null
    require_entry_point?: boolean
    entry_point_description?: string | null
    allow_submit?: boolean
    allow_judge?: boolean
    time_factor?: number
    filter_compiler_files?: boolean
    submission?: submissionCreateNestedManyWithoutLanguageInput
  }

  export type languageUncheckedCreateWithoutExecutableInput = {
    langid: string
    externalid?: string | null
    name: string
    extensions?: string | null
    require_entry_point?: boolean
    entry_point_description?: string | null
    allow_submit?: boolean
    allow_judge?: boolean
    time_factor?: number
    filter_compiler_files?: boolean
    submission?: submissionUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type languageCreateOrConnectWithoutExecutableInput = {
    where: languageWhereUniqueInput
    create: XOR<languageCreateWithoutExecutableInput, languageUncheckedCreateWithoutExecutableInput>
  }

  export type languageCreateManyExecutableInputEnvelope = {
    data: languageCreateManyExecutableInput | languageCreateManyExecutableInput[]
    skipDuplicates?: boolean
  }

  export type problemCreateWithoutExecutable_problem_special_runToexecutableInput = {
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
    clarification?: clarificationCreateNestedManyWithoutProblemInput
    contestproblem?: contestproblemCreateNestedManyWithoutProblemInput
    executable_problem_special_compareToexecutable?: executableCreateNestedOneWithoutProblem_problem_special_compareToexecutableInput
    problem_attachment?: problem_attachmentCreateNestedManyWithoutProblemInput
    scorecache?: scorecacheCreateNestedManyWithoutProblemInput
    submission?: submissionCreateNestedManyWithoutProblemInput
    testcase?: testcaseCreateNestedManyWithoutProblemInput
  }

  export type problemUncheckedCreateWithoutExecutable_problem_special_runToexecutableInput = {
    probid?: number
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_compare?: string | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutProblemInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutProblemInput
    problem_attachment?: problem_attachmentUncheckedCreateNestedManyWithoutProblemInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutProblemInput
    submission?: submissionUncheckedCreateNestedManyWithoutProblemInput
    testcase?: testcaseUncheckedCreateNestedManyWithoutProblemInput
  }

  export type problemCreateOrConnectWithoutExecutable_problem_special_runToexecutableInput = {
    where: problemWhereUniqueInput
    create: XOR<problemCreateWithoutExecutable_problem_special_runToexecutableInput, problemUncheckedCreateWithoutExecutable_problem_special_runToexecutableInput>
  }

  export type problemCreateManyExecutable_problem_special_runToexecutableInputEnvelope = {
    data: problemCreateManyExecutable_problem_special_runToexecutableInput | problemCreateManyExecutable_problem_special_runToexecutableInput[]
    skipDuplicates?: boolean
  }

  export type problemCreateWithoutExecutable_problem_special_compareToexecutableInput = {
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
    clarification?: clarificationCreateNestedManyWithoutProblemInput
    contestproblem?: contestproblemCreateNestedManyWithoutProblemInput
    executable_problem_special_runToexecutable?: executableCreateNestedOneWithoutProblem_problem_special_runToexecutableInput
    problem_attachment?: problem_attachmentCreateNestedManyWithoutProblemInput
    scorecache?: scorecacheCreateNestedManyWithoutProblemInput
    submission?: submissionCreateNestedManyWithoutProblemInput
    testcase?: testcaseCreateNestedManyWithoutProblemInput
  }

  export type problemUncheckedCreateWithoutExecutable_problem_special_compareToexecutableInput = {
    probid?: number
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_run?: string | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutProblemInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutProblemInput
    problem_attachment?: problem_attachmentUncheckedCreateNestedManyWithoutProblemInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutProblemInput
    submission?: submissionUncheckedCreateNestedManyWithoutProblemInput
    testcase?: testcaseUncheckedCreateNestedManyWithoutProblemInput
  }

  export type problemCreateOrConnectWithoutExecutable_problem_special_compareToexecutableInput = {
    where: problemWhereUniqueInput
    create: XOR<problemCreateWithoutExecutable_problem_special_compareToexecutableInput, problemUncheckedCreateWithoutExecutable_problem_special_compareToexecutableInput>
  }

  export type problemCreateManyExecutable_problem_special_compareToexecutableInputEnvelope = {
    data: problemCreateManyExecutable_problem_special_compareToexecutableInput | problemCreateManyExecutable_problem_special_compareToexecutableInput[]
    skipDuplicates?: boolean
  }

  export type immutable_executableUpsertWithoutExecutableInput = {
    update: XOR<immutable_executableUpdateWithoutExecutableInput, immutable_executableUncheckedUpdateWithoutExecutableInput>
    create: XOR<immutable_executableCreateWithoutExecutableInput, immutable_executableUncheckedCreateWithoutExecutableInput>
    where?: immutable_executableWhereInput
  }

  export type immutable_executableUpdateToOneWithWhereWithoutExecutableInput = {
    where?: immutable_executableWhereInput
    data: XOR<immutable_executableUpdateWithoutExecutableInput, immutable_executableUncheckedUpdateWithoutExecutableInput>
  }

  export type immutable_executableUpdateWithoutExecutableInput = {
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    executable_file?: executable_fileUpdateManyWithoutImmutable_executableNestedInput
    user?: userUpdateOneWithoutImmutable_executableNestedInput
  }

  export type immutable_executableUncheckedUpdateWithoutExecutableInput = {
    immutable_execid?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    executable_file?: executable_fileUncheckedUpdateManyWithoutImmutable_executableNestedInput
  }

  export type languageUpsertWithWhereUniqueWithoutExecutableInput = {
    where: languageWhereUniqueInput
    update: XOR<languageUpdateWithoutExecutableInput, languageUncheckedUpdateWithoutExecutableInput>
    create: XOR<languageCreateWithoutExecutableInput, languageUncheckedCreateWithoutExecutableInput>
  }

  export type languageUpdateWithWhereUniqueWithoutExecutableInput = {
    where: languageWhereUniqueInput
    data: XOR<languageUpdateWithoutExecutableInput, languageUncheckedUpdateWithoutExecutableInput>
  }

  export type languageUpdateManyWithWhereWithoutExecutableInput = {
    where: languageScalarWhereInput
    data: XOR<languageUpdateManyMutationInput, languageUncheckedUpdateManyWithoutExecutableInput>
  }

  export type languageScalarWhereInput = {
    AND?: languageScalarWhereInput | languageScalarWhereInput[]
    OR?: languageScalarWhereInput[]
    NOT?: languageScalarWhereInput | languageScalarWhereInput[]
    langid?: StringFilter<"language"> | string
    externalid?: StringNullableFilter<"language"> | string | null
    name?: StringFilter<"language"> | string
    extensions?: StringNullableFilter<"language"> | string | null
    require_entry_point?: BoolFilter<"language"> | boolean
    entry_point_description?: StringNullableFilter<"language"> | string | null
    allow_submit?: BoolFilter<"language"> | boolean
    allow_judge?: BoolFilter<"language"> | boolean
    time_factor?: FloatFilter<"language"> | number
    compile_script?: StringNullableFilter<"language"> | string | null
    filter_compiler_files?: BoolFilter<"language"> | boolean
  }

  export type problemUpsertWithWhereUniqueWithoutExecutable_problem_special_runToexecutableInput = {
    where: problemWhereUniqueInput
    update: XOR<problemUpdateWithoutExecutable_problem_special_runToexecutableInput, problemUncheckedUpdateWithoutExecutable_problem_special_runToexecutableInput>
    create: XOR<problemCreateWithoutExecutable_problem_special_runToexecutableInput, problemUncheckedCreateWithoutExecutable_problem_special_runToexecutableInput>
  }

  export type problemUpdateWithWhereUniqueWithoutExecutable_problem_special_runToexecutableInput = {
    where: problemWhereUniqueInput
    data: XOR<problemUpdateWithoutExecutable_problem_special_runToexecutableInput, problemUncheckedUpdateWithoutExecutable_problem_special_runToexecutableInput>
  }

  export type problemUpdateManyWithWhereWithoutExecutable_problem_special_runToexecutableInput = {
    where: problemScalarWhereInput
    data: XOR<problemUpdateManyMutationInput, problemUncheckedUpdateManyWithoutExecutable_problem_special_runToexecutableInput>
  }

  export type problemScalarWhereInput = {
    AND?: problemScalarWhereInput | problemScalarWhereInput[]
    OR?: problemScalarWhereInput[]
    NOT?: problemScalarWhereInput | problemScalarWhereInput[]
    probid?: IntFilter<"problem"> | number
    externalid?: StringNullableFilter<"problem"> | string | null
    name?: StringFilter<"problem"> | string
    timelimit?: FloatFilter<"problem"> | number
    memlimit?: IntNullableFilter<"problem"> | number | null
    outputlimit?: IntNullableFilter<"problem"> | number | null
    special_run?: StringNullableFilter<"problem"> | string | null
    special_compare?: StringNullableFilter<"problem"> | string | null
    special_compare_args?: StringNullableFilter<"problem"> | string | null
    combined_run_compare?: BoolFilter<"problem"> | boolean
    problemtext?: BytesNullableFilter<"problem"> | Buffer | null
    problemtext_type?: StringNullableFilter<"problem"> | string | null
  }

  export type problemUpsertWithWhereUniqueWithoutExecutable_problem_special_compareToexecutableInput = {
    where: problemWhereUniqueInput
    update: XOR<problemUpdateWithoutExecutable_problem_special_compareToexecutableInput, problemUncheckedUpdateWithoutExecutable_problem_special_compareToexecutableInput>
    create: XOR<problemCreateWithoutExecutable_problem_special_compareToexecutableInput, problemUncheckedCreateWithoutExecutable_problem_special_compareToexecutableInput>
  }

  export type problemUpdateWithWhereUniqueWithoutExecutable_problem_special_compareToexecutableInput = {
    where: problemWhereUniqueInput
    data: XOR<problemUpdateWithoutExecutable_problem_special_compareToexecutableInput, problemUncheckedUpdateWithoutExecutable_problem_special_compareToexecutableInput>
  }

  export type problemUpdateManyWithWhereWithoutExecutable_problem_special_compareToexecutableInput = {
    where: problemScalarWhereInput
    data: XOR<problemUpdateManyMutationInput, problemUncheckedUpdateManyWithoutExecutable_problem_special_compareToexecutableInput>
  }

  export type immutable_executableCreateWithoutExecutable_fileInput = {
    hash?: string | null
    executable?: executableCreateNestedOneWithoutImmutable_executableInput
    user?: userCreateNestedOneWithoutImmutable_executableInput
  }

  export type immutable_executableUncheckedCreateWithoutExecutable_fileInput = {
    immutable_execid?: number
    userid?: number | null
    hash?: string | null
    executable?: executableUncheckedCreateNestedOneWithoutImmutable_executableInput
  }

  export type immutable_executableCreateOrConnectWithoutExecutable_fileInput = {
    where: immutable_executableWhereUniqueInput
    create: XOR<immutable_executableCreateWithoutExecutable_fileInput, immutable_executableUncheckedCreateWithoutExecutable_fileInput>
  }

  export type immutable_executableUpsertWithoutExecutable_fileInput = {
    update: XOR<immutable_executableUpdateWithoutExecutable_fileInput, immutable_executableUncheckedUpdateWithoutExecutable_fileInput>
    create: XOR<immutable_executableCreateWithoutExecutable_fileInput, immutable_executableUncheckedCreateWithoutExecutable_fileInput>
    where?: immutable_executableWhereInput
  }

  export type immutable_executableUpdateToOneWithWhereWithoutExecutable_fileInput = {
    where?: immutable_executableWhereInput
    data: XOR<immutable_executableUpdateWithoutExecutable_fileInput, immutable_executableUncheckedUpdateWithoutExecutable_fileInput>
  }

  export type immutable_executableUpdateWithoutExecutable_fileInput = {
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    executable?: executableUpdateOneWithoutImmutable_executableNestedInput
    user?: userUpdateOneWithoutImmutable_executableNestedInput
  }

  export type immutable_executableUncheckedUpdateWithoutExecutable_fileInput = {
    immutable_execid?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    executable?: executableUncheckedUpdateOneWithoutImmutable_executableNestedInput
  }

  export type contestCreateWithoutExternal_contest_sourceInput = {
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemCreateNestedManyWithoutContestInput
    contestteam?: contestteamCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsCreateNestedManyWithoutContestInput
    event?: eventCreateNestedManyWithoutContestInput
    external_judgement?: external_judgementCreateNestedManyWithoutContestInput
    external_run?: external_runCreateNestedManyWithoutContestInput
    internal_error?: internal_errorCreateNestedManyWithoutContestInput
    judging?: judgingCreateNestedManyWithoutContestInput
    rankcache?: rankcacheCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalCreateNestedManyWithoutContestInput
    scorecache?: scorecacheCreateNestedManyWithoutContestInput
    submission?: submissionCreateNestedManyWithoutContestInput
  }

  export type contestUncheckedCreateWithoutExternal_contest_sourceInput = {
    cid?: number
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutContestInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryUncheckedCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedCreateNestedManyWithoutContestInput
    event?: eventUncheckedCreateNestedManyWithoutContestInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutContestInput
    external_run?: external_runUncheckedCreateNestedManyWithoutContestInput
    internal_error?: internal_errorUncheckedCreateNestedManyWithoutContestInput
    judging?: judgingUncheckedCreateNestedManyWithoutContestInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalUncheckedCreateNestedManyWithoutContestInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutContestInput
    submission?: submissionUncheckedCreateNestedManyWithoutContestInput
  }

  export type contestCreateOrConnectWithoutExternal_contest_sourceInput = {
    where: contestWhereUniqueInput
    create: XOR<contestCreateWithoutExternal_contest_sourceInput, contestUncheckedCreateWithoutExternal_contest_sourceInput>
  }

  export type external_source_warningCreateWithoutExternal_contest_sourceInput = {
    last_event_id?: string | null
    time: Decimal | DecimalJsLike | number | string
    entity_type: string
    entity_id: string
    type: string
    hash: string
    content: string
  }

  export type external_source_warningUncheckedCreateWithoutExternal_contest_sourceInput = {
    extwarningid?: number
    last_event_id?: string | null
    time: Decimal | DecimalJsLike | number | string
    entity_type: string
    entity_id: string
    type: string
    hash: string
    content: string
  }

  export type external_source_warningCreateOrConnectWithoutExternal_contest_sourceInput = {
    where: external_source_warningWhereUniqueInput
    create: XOR<external_source_warningCreateWithoutExternal_contest_sourceInput, external_source_warningUncheckedCreateWithoutExternal_contest_sourceInput>
  }

  export type external_source_warningCreateManyExternal_contest_sourceInputEnvelope = {
    data: external_source_warningCreateManyExternal_contest_sourceInput | external_source_warningCreateManyExternal_contest_sourceInput[]
    skipDuplicates?: boolean
  }

  export type contestUpsertWithoutExternal_contest_sourceInput = {
    update: XOR<contestUpdateWithoutExternal_contest_sourceInput, contestUncheckedUpdateWithoutExternal_contest_sourceInput>
    create: XOR<contestCreateWithoutExternal_contest_sourceInput, contestUncheckedCreateWithoutExternal_contest_sourceInput>
    where?: contestWhereInput
  }

  export type contestUpdateToOneWithWhereWithoutExternal_contest_sourceInput = {
    where?: contestWhereInput
    data: XOR<contestUpdateWithoutExternal_contest_sourceInput, contestUncheckedUpdateWithoutExternal_contest_sourceInput>
  }

  export type contestUpdateWithoutExternal_contest_sourceInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUpdateManyWithoutContestNestedInput
    event?: eventUpdateManyWithoutContestNestedInput
    external_judgement?: external_judgementUpdateManyWithoutContestNestedInput
    external_run?: external_runUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUpdateManyWithoutContestNestedInput
    judging?: judgingUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUpdateManyWithoutContestNestedInput
    submission?: submissionUpdateManyWithoutContestNestedInput
  }

  export type contestUncheckedUpdateWithoutExternal_contest_sourceInput = {
    cid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedUpdateManyWithoutContestNestedInput
    event?: eventUncheckedUpdateManyWithoutContestNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutContestNestedInput
    external_run?: external_runUncheckedUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUncheckedUpdateManyWithoutContestNestedInput
    judging?: judgingUncheckedUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUncheckedUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutContestNestedInput
    submission?: submissionUncheckedUpdateManyWithoutContestNestedInput
  }

  export type external_source_warningUpsertWithWhereUniqueWithoutExternal_contest_sourceInput = {
    where: external_source_warningWhereUniqueInput
    update: XOR<external_source_warningUpdateWithoutExternal_contest_sourceInput, external_source_warningUncheckedUpdateWithoutExternal_contest_sourceInput>
    create: XOR<external_source_warningCreateWithoutExternal_contest_sourceInput, external_source_warningUncheckedCreateWithoutExternal_contest_sourceInput>
  }

  export type external_source_warningUpdateWithWhereUniqueWithoutExternal_contest_sourceInput = {
    where: external_source_warningWhereUniqueInput
    data: XOR<external_source_warningUpdateWithoutExternal_contest_sourceInput, external_source_warningUncheckedUpdateWithoutExternal_contest_sourceInput>
  }

  export type external_source_warningUpdateManyWithWhereWithoutExternal_contest_sourceInput = {
    where: external_source_warningScalarWhereInput
    data: XOR<external_source_warningUpdateManyMutationInput, external_source_warningUncheckedUpdateManyWithoutExternal_contest_sourceInput>
  }

  export type external_source_warningScalarWhereInput = {
    AND?: external_source_warningScalarWhereInput | external_source_warningScalarWhereInput[]
    OR?: external_source_warningScalarWhereInput[]
    NOT?: external_source_warningScalarWhereInput | external_source_warningScalarWhereInput[]
    extwarningid?: IntFilter<"external_source_warning"> | number
    extsourceid?: IntNullableFilter<"external_source_warning"> | number | null
    last_event_id?: StringNullableFilter<"external_source_warning"> | string | null
    time?: DecimalFilter<"external_source_warning"> | Decimal | DecimalJsLike | number | string
    entity_type?: StringFilter<"external_source_warning"> | string
    entity_id?: StringFilter<"external_source_warning"> | string
    type?: StringFilter<"external_source_warning"> | string
    hash?: StringFilter<"external_source_warning"> | string
    content?: StringFilter<"external_source_warning"> | string
  }

  export type submissionCreateWithoutExternal_judgementInput = {
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonCreateNestedManyWithoutSubmissionInput
    judging?: judgingCreateNestedManyWithoutSubmissionInput
    user?: userCreateNestedOneWithoutSubmissionInput
    contest?: contestCreateNestedOneWithoutSubmissionInput
    team?: teamCreateNestedOneWithoutSubmissionInput
    problem?: problemCreateNestedOneWithoutSubmissionInput
    language?: languageCreateNestedOneWithoutSubmissionInput
    submission?: submissionCreateNestedOneWithoutOther_submissionInput
    other_submission?: submissionCreateNestedManyWithoutSubmissionInput
    rejudging?: rejudgingCreateNestedOneWithoutSubmissionInput
    contestproblem?: contestproblemCreateNestedOneWithoutSubmissionInput
    submission_file?: submission_fileCreateNestedManyWithoutSubmissionInput
  }

  export type submissionUncheckedCreateWithoutExternal_judgementInput = {
    submitid?: number
    origsubmitid?: number | null
    cid?: number | null
    teamid?: number | null
    userid?: number | null
    probid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonUncheckedCreateNestedManyWithoutSubmissionInput
    judging?: judgingUncheckedCreateNestedManyWithoutSubmissionInput
    other_submission?: submissionUncheckedCreateNestedManyWithoutSubmissionInput
    submission_file?: submission_fileUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type submissionCreateOrConnectWithoutExternal_judgementInput = {
    where: submissionWhereUniqueInput
    create: XOR<submissionCreateWithoutExternal_judgementInput, submissionUncheckedCreateWithoutExternal_judgementInput>
  }

  export type contestCreateWithoutExternal_judgementInput = {
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemCreateNestedManyWithoutContestInput
    contestteam?: contestteamCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsCreateNestedManyWithoutContestInput
    event?: eventCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceCreateNestedOneWithoutContestInput
    external_run?: external_runCreateNestedManyWithoutContestInput
    internal_error?: internal_errorCreateNestedManyWithoutContestInput
    judging?: judgingCreateNestedManyWithoutContestInput
    rankcache?: rankcacheCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalCreateNestedManyWithoutContestInput
    scorecache?: scorecacheCreateNestedManyWithoutContestInput
    submission?: submissionCreateNestedManyWithoutContestInput
  }

  export type contestUncheckedCreateWithoutExternal_judgementInput = {
    cid?: number
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutContestInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryUncheckedCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedCreateNestedManyWithoutContestInput
    event?: eventUncheckedCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceUncheckedCreateNestedOneWithoutContestInput
    external_run?: external_runUncheckedCreateNestedManyWithoutContestInput
    internal_error?: internal_errorUncheckedCreateNestedManyWithoutContestInput
    judging?: judgingUncheckedCreateNestedManyWithoutContestInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalUncheckedCreateNestedManyWithoutContestInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutContestInput
    submission?: submissionUncheckedCreateNestedManyWithoutContestInput
  }

  export type contestCreateOrConnectWithoutExternal_judgementInput = {
    where: contestWhereUniqueInput
    create: XOR<contestCreateWithoutExternal_judgementInput, contestUncheckedCreateWithoutExternal_judgementInput>
  }

  export type external_runCreateWithoutExternal_judgementInput = {
    externalid?: string | null
    result: string
    endtime: Decimal | DecimalJsLike | number | string
    runtime: number
    testcase?: testcaseCreateNestedOneWithoutExternal_runInput
    contest?: contestCreateNestedOneWithoutExternal_runInput
  }

  export type external_runUncheckedCreateWithoutExternal_judgementInput = {
    extrunid?: number
    testcaseid?: number | null
    externalid?: string | null
    cid?: number | null
    result: string
    endtime: Decimal | DecimalJsLike | number | string
    runtime: number
  }

  export type external_runCreateOrConnectWithoutExternal_judgementInput = {
    where: external_runWhereUniqueInput
    create: XOR<external_runCreateWithoutExternal_judgementInput, external_runUncheckedCreateWithoutExternal_judgementInput>
  }

  export type external_runCreateManyExternal_judgementInputEnvelope = {
    data: external_runCreateManyExternal_judgementInput | external_runCreateManyExternal_judgementInput[]
    skipDuplicates?: boolean
  }

  export type submissionUpsertWithoutExternal_judgementInput = {
    update: XOR<submissionUpdateWithoutExternal_judgementInput, submissionUncheckedUpdateWithoutExternal_judgementInput>
    create: XOR<submissionCreateWithoutExternal_judgementInput, submissionUncheckedCreateWithoutExternal_judgementInput>
    where?: submissionWhereInput
  }

  export type submissionUpdateToOneWithWhereWithoutExternal_judgementInput = {
    where?: submissionWhereInput
    data: XOR<submissionUpdateWithoutExternal_judgementInput, submissionUncheckedUpdateWithoutExternal_judgementInput>
  }

  export type submissionUpdateWithoutExternal_judgementInput = {
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUpdateManyWithoutSubmissionNestedInput
    user?: userUpdateOneWithoutSubmissionNestedInput
    contest?: contestUpdateOneWithoutSubmissionNestedInput
    team?: teamUpdateOneWithoutSubmissionNestedInput
    problem?: problemUpdateOneWithoutSubmissionNestedInput
    language?: languageUpdateOneWithoutSubmissionNestedInput
    submission?: submissionUpdateOneWithoutOther_submissionNestedInput
    other_submission?: submissionUpdateManyWithoutSubmissionNestedInput
    rejudging?: rejudgingUpdateOneWithoutSubmissionNestedInput
    contestproblem?: contestproblemUpdateOneWithoutSubmissionNestedInput
    submission_file?: submission_fileUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateWithoutExternal_judgementInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUncheckedUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUncheckedUpdateManyWithoutSubmissionNestedInput
    other_submission?: submissionUncheckedUpdateManyWithoutSubmissionNestedInput
    submission_file?: submission_fileUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type contestUpsertWithoutExternal_judgementInput = {
    update: XOR<contestUpdateWithoutExternal_judgementInput, contestUncheckedUpdateWithoutExternal_judgementInput>
    create: XOR<contestCreateWithoutExternal_judgementInput, contestUncheckedCreateWithoutExternal_judgementInput>
    where?: contestWhereInput
  }

  export type contestUpdateToOneWithWhereWithoutExternal_judgementInput = {
    where?: contestWhereInput
    data: XOR<contestUpdateWithoutExternal_judgementInput, contestUncheckedUpdateWithoutExternal_judgementInput>
  }

  export type contestUpdateWithoutExternal_judgementInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUpdateManyWithoutContestNestedInput
    event?: eventUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUpdateOneWithoutContestNestedInput
    external_run?: external_runUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUpdateManyWithoutContestNestedInput
    judging?: judgingUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUpdateManyWithoutContestNestedInput
    submission?: submissionUpdateManyWithoutContestNestedInput
  }

  export type contestUncheckedUpdateWithoutExternal_judgementInput = {
    cid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedUpdateManyWithoutContestNestedInput
    event?: eventUncheckedUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUncheckedUpdateOneWithoutContestNestedInput
    external_run?: external_runUncheckedUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUncheckedUpdateManyWithoutContestNestedInput
    judging?: judgingUncheckedUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUncheckedUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutContestNestedInput
    submission?: submissionUncheckedUpdateManyWithoutContestNestedInput
  }

  export type external_runUpsertWithWhereUniqueWithoutExternal_judgementInput = {
    where: external_runWhereUniqueInput
    update: XOR<external_runUpdateWithoutExternal_judgementInput, external_runUncheckedUpdateWithoutExternal_judgementInput>
    create: XOR<external_runCreateWithoutExternal_judgementInput, external_runUncheckedCreateWithoutExternal_judgementInput>
  }

  export type external_runUpdateWithWhereUniqueWithoutExternal_judgementInput = {
    where: external_runWhereUniqueInput
    data: XOR<external_runUpdateWithoutExternal_judgementInput, external_runUncheckedUpdateWithoutExternal_judgementInput>
  }

  export type external_runUpdateManyWithWhereWithoutExternal_judgementInput = {
    where: external_runScalarWhereInput
    data: XOR<external_runUpdateManyMutationInput, external_runUncheckedUpdateManyWithoutExternal_judgementInput>
  }

  export type external_judgementCreateWithoutExternal_runInput = {
    externalid?: string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    valid?: boolean
    submission?: submissionCreateNestedOneWithoutExternal_judgementInput
    contest?: contestCreateNestedOneWithoutExternal_judgementInput
  }

  export type external_judgementUncheckedCreateWithoutExternal_runInput = {
    extjudgementid?: number
    externalid?: string | null
    cid?: number | null
    submitid?: number | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    valid?: boolean
  }

  export type external_judgementCreateOrConnectWithoutExternal_runInput = {
    where: external_judgementWhereUniqueInput
    create: XOR<external_judgementCreateWithoutExternal_runInput, external_judgementUncheckedCreateWithoutExternal_runInput>
  }

  export type testcaseCreateWithoutExternal_runInput = {
    md5sum_input?: string | null
    md5sum_output?: string | null
    ranknumber: number
    description?: Buffer | null
    image_type?: string | null
    sample?: boolean
    orig_input_filename?: string | null
    deleted?: boolean
    judging_run?: judging_runCreateNestedManyWithoutTestcaseInput
    problem?: problemCreateNestedOneWithoutTestcaseInput
    testcase_content?: testcase_contentCreateNestedManyWithoutTestcaseInput
  }

  export type testcaseUncheckedCreateWithoutExternal_runInput = {
    testcaseid?: number
    md5sum_input?: string | null
    md5sum_output?: string | null
    probid?: number | null
    ranknumber: number
    description?: Buffer | null
    image_type?: string | null
    sample?: boolean
    orig_input_filename?: string | null
    deleted?: boolean
    judging_run?: judging_runUncheckedCreateNestedManyWithoutTestcaseInput
    testcase_content?: testcase_contentUncheckedCreateNestedManyWithoutTestcaseInput
  }

  export type testcaseCreateOrConnectWithoutExternal_runInput = {
    where: testcaseWhereUniqueInput
    create: XOR<testcaseCreateWithoutExternal_runInput, testcaseUncheckedCreateWithoutExternal_runInput>
  }

  export type contestCreateWithoutExternal_runInput = {
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemCreateNestedManyWithoutContestInput
    contestteam?: contestteamCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsCreateNestedManyWithoutContestInput
    event?: eventCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementCreateNestedManyWithoutContestInput
    internal_error?: internal_errorCreateNestedManyWithoutContestInput
    judging?: judgingCreateNestedManyWithoutContestInput
    rankcache?: rankcacheCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalCreateNestedManyWithoutContestInput
    scorecache?: scorecacheCreateNestedManyWithoutContestInput
    submission?: submissionCreateNestedManyWithoutContestInput
  }

  export type contestUncheckedCreateWithoutExternal_runInput = {
    cid?: number
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutContestInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryUncheckedCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedCreateNestedManyWithoutContestInput
    event?: eventUncheckedCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceUncheckedCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutContestInput
    internal_error?: internal_errorUncheckedCreateNestedManyWithoutContestInput
    judging?: judgingUncheckedCreateNestedManyWithoutContestInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalUncheckedCreateNestedManyWithoutContestInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutContestInput
    submission?: submissionUncheckedCreateNestedManyWithoutContestInput
  }

  export type contestCreateOrConnectWithoutExternal_runInput = {
    where: contestWhereUniqueInput
    create: XOR<contestCreateWithoutExternal_runInput, contestUncheckedCreateWithoutExternal_runInput>
  }

  export type external_judgementUpsertWithoutExternal_runInput = {
    update: XOR<external_judgementUpdateWithoutExternal_runInput, external_judgementUncheckedUpdateWithoutExternal_runInput>
    create: XOR<external_judgementCreateWithoutExternal_runInput, external_judgementUncheckedCreateWithoutExternal_runInput>
    where?: external_judgementWhereInput
  }

  export type external_judgementUpdateToOneWithWhereWithoutExternal_runInput = {
    where?: external_judgementWhereInput
    data: XOR<external_judgementUpdateWithoutExternal_runInput, external_judgementUncheckedUpdateWithoutExternal_runInput>
  }

  export type external_judgementUpdateWithoutExternal_runInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    submission?: submissionUpdateOneWithoutExternal_judgementNestedInput
    contest?: contestUpdateOneWithoutExternal_judgementNestedInput
  }

  export type external_judgementUncheckedUpdateWithoutExternal_runInput = {
    extjudgementid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type testcaseUpsertWithoutExternal_runInput = {
    update: XOR<testcaseUpdateWithoutExternal_runInput, testcaseUncheckedUpdateWithoutExternal_runInput>
    create: XOR<testcaseCreateWithoutExternal_runInput, testcaseUncheckedCreateWithoutExternal_runInput>
    where?: testcaseWhereInput
  }

  export type testcaseUpdateToOneWithWhereWithoutExternal_runInput = {
    where?: testcaseWhereInput
    data: XOR<testcaseUpdateWithoutExternal_runInput, testcaseUncheckedUpdateWithoutExternal_runInput>
  }

  export type testcaseUpdateWithoutExternal_runInput = {
    md5sum_input?: NullableStringFieldUpdateOperationsInput | string | null
    md5sum_output?: NullableStringFieldUpdateOperationsInput | string | null
    ranknumber?: IntFieldUpdateOperationsInput | number
    description?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image_type?: NullableStringFieldUpdateOperationsInput | string | null
    sample?: BoolFieldUpdateOperationsInput | boolean
    orig_input_filename?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    judging_run?: judging_runUpdateManyWithoutTestcaseNestedInput
    problem?: problemUpdateOneWithoutTestcaseNestedInput
    testcase_content?: testcase_contentUpdateManyWithoutTestcaseNestedInput
  }

  export type testcaseUncheckedUpdateWithoutExternal_runInput = {
    testcaseid?: IntFieldUpdateOperationsInput | number
    md5sum_input?: NullableStringFieldUpdateOperationsInput | string | null
    md5sum_output?: NullableStringFieldUpdateOperationsInput | string | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    ranknumber?: IntFieldUpdateOperationsInput | number
    description?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image_type?: NullableStringFieldUpdateOperationsInput | string | null
    sample?: BoolFieldUpdateOperationsInput | boolean
    orig_input_filename?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    judging_run?: judging_runUncheckedUpdateManyWithoutTestcaseNestedInput
    testcase_content?: testcase_contentUncheckedUpdateManyWithoutTestcaseNestedInput
  }

  export type contestUpsertWithoutExternal_runInput = {
    update: XOR<contestUpdateWithoutExternal_runInput, contestUncheckedUpdateWithoutExternal_runInput>
    create: XOR<contestCreateWithoutExternal_runInput, contestUncheckedCreateWithoutExternal_runInput>
    where?: contestWhereInput
  }

  export type contestUpdateToOneWithWhereWithoutExternal_runInput = {
    where?: contestWhereInput
    data: XOR<contestUpdateWithoutExternal_runInput, contestUncheckedUpdateWithoutExternal_runInput>
  }

  export type contestUpdateWithoutExternal_runInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUpdateManyWithoutContestNestedInput
    event?: eventUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUpdateManyWithoutContestNestedInput
    judging?: judgingUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUpdateManyWithoutContestNestedInput
    submission?: submissionUpdateManyWithoutContestNestedInput
  }

  export type contestUncheckedUpdateWithoutExternal_runInput = {
    cid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedUpdateManyWithoutContestNestedInput
    event?: eventUncheckedUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUncheckedUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUncheckedUpdateManyWithoutContestNestedInput
    judging?: judgingUncheckedUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUncheckedUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutContestNestedInput
    submission?: submissionUncheckedUpdateManyWithoutContestNestedInput
  }

  export type external_contest_sourceCreateWithoutExternal_source_warningInput = {
    type: string
    source: string
    username?: string | null
    password?: string | null
    last_event_id?: string | null
    last_poll_time?: Decimal | DecimalJsLike | number | string | null
    contest?: contestCreateNestedOneWithoutExternal_contest_sourceInput
  }

  export type external_contest_sourceUncheckedCreateWithoutExternal_source_warningInput = {
    extsourceid?: number
    cid?: number | null
    type: string
    source: string
    username?: string | null
    password?: string | null
    last_event_id?: string | null
    last_poll_time?: Decimal | DecimalJsLike | number | string | null
  }

  export type external_contest_sourceCreateOrConnectWithoutExternal_source_warningInput = {
    where: external_contest_sourceWhereUniqueInput
    create: XOR<external_contest_sourceCreateWithoutExternal_source_warningInput, external_contest_sourceUncheckedCreateWithoutExternal_source_warningInput>
  }

  export type external_contest_sourceUpsertWithoutExternal_source_warningInput = {
    update: XOR<external_contest_sourceUpdateWithoutExternal_source_warningInput, external_contest_sourceUncheckedUpdateWithoutExternal_source_warningInput>
    create: XOR<external_contest_sourceCreateWithoutExternal_source_warningInput, external_contest_sourceUncheckedCreateWithoutExternal_source_warningInput>
    where?: external_contest_sourceWhereInput
  }

  export type external_contest_sourceUpdateToOneWithWhereWithoutExternal_source_warningInput = {
    where?: external_contest_sourceWhereInput
    data: XOR<external_contest_sourceUpdateWithoutExternal_source_warningInput, external_contest_sourceUncheckedUpdateWithoutExternal_source_warningInput>
  }

  export type external_contest_sourceUpdateWithoutExternal_source_warningInput = {
    type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    last_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_poll_time?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contest?: contestUpdateOneWithoutExternal_contest_sourceNestedInput
  }

  export type external_contest_sourceUncheckedUpdateWithoutExternal_source_warningInput = {
    extsourceid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    last_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_poll_time?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type executableCreateWithoutImmutable_executableInput = {
    execid: string
    description?: string | null
    type: string
    language?: languageCreateNestedManyWithoutExecutableInput
    problem_problem_special_runToexecutable?: problemCreateNestedManyWithoutExecutable_problem_special_runToexecutableInput
    problem_problem_special_compareToexecutable?: problemCreateNestedManyWithoutExecutable_problem_special_compareToexecutableInput
  }

  export type executableUncheckedCreateWithoutImmutable_executableInput = {
    execid: string
    description?: string | null
    type: string
    language?: languageUncheckedCreateNestedManyWithoutExecutableInput
    problem_problem_special_runToexecutable?: problemUncheckedCreateNestedManyWithoutExecutable_problem_special_runToexecutableInput
    problem_problem_special_compareToexecutable?: problemUncheckedCreateNestedManyWithoutExecutable_problem_special_compareToexecutableInput
  }

  export type executableCreateOrConnectWithoutImmutable_executableInput = {
    where: executableWhereUniqueInput
    create: XOR<executableCreateWithoutImmutable_executableInput, executableUncheckedCreateWithoutImmutable_executableInput>
  }

  export type executable_fileCreateWithoutImmutable_executableInput = {
    filename: string
    ranknumber: number
    file_content: Buffer
    hash?: string | null
    is_executable?: boolean
  }

  export type executable_fileUncheckedCreateWithoutImmutable_executableInput = {
    execfileid?: number
    filename: string
    ranknumber: number
    file_content: Buffer
    hash?: string | null
    is_executable?: boolean
  }

  export type executable_fileCreateOrConnectWithoutImmutable_executableInput = {
    where: executable_fileWhereUniqueInput
    create: XOR<executable_fileCreateWithoutImmutable_executableInput, executable_fileUncheckedCreateWithoutImmutable_executableInput>
  }

  export type executable_fileCreateManyImmutable_executableInputEnvelope = {
    data: executable_fileCreateManyImmutable_executableInput | executable_fileCreateManyImmutable_executableInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutImmutable_executableInput = {
    externalid?: string | null
    username: string
    name: string
    email?: string | null
    last_login?: Decimal | DecimalJsLike | number | string | null
    last_api_login?: Decimal | DecimalJsLike | number | string | null
    first_login?: Decimal | DecimalJsLike | number | string | null
    last_ip_address?: string | null
    password?: string | null
    ip_address?: string | null
    enabled?: boolean
    rejudging_rejudging_userid_startTouser?: rejudgingCreateNestedManyWithoutUser_rejudging_userid_startTouserInput
    rejudging_rejudging_userid_finishTouser?: rejudgingCreateNestedManyWithoutUser_rejudging_userid_finishTouserInput
    submission?: submissionCreateNestedManyWithoutUserInput
    team?: teamCreateNestedOneWithoutUserInput
    userrole?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutImmutable_executableInput = {
    userid?: number
    externalid?: string | null
    username: string
    name: string
    email?: string | null
    last_login?: Decimal | DecimalJsLike | number | string | null
    last_api_login?: Decimal | DecimalJsLike | number | string | null
    first_login?: Decimal | DecimalJsLike | number | string | null
    last_ip_address?: string | null
    password?: string | null
    ip_address?: string | null
    enabled?: boolean
    teamid?: number | null
    rejudging_rejudging_userid_startTouser?: rejudgingUncheckedCreateNestedManyWithoutUser_rejudging_userid_startTouserInput
    rejudging_rejudging_userid_finishTouser?: rejudgingUncheckedCreateNestedManyWithoutUser_rejudging_userid_finishTouserInput
    submission?: submissionUncheckedCreateNestedManyWithoutUserInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutImmutable_executableInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutImmutable_executableInput, userUncheckedCreateWithoutImmutable_executableInput>
  }

  export type executableUpsertWithoutImmutable_executableInput = {
    update: XOR<executableUpdateWithoutImmutable_executableInput, executableUncheckedUpdateWithoutImmutable_executableInput>
    create: XOR<executableCreateWithoutImmutable_executableInput, executableUncheckedCreateWithoutImmutable_executableInput>
    where?: executableWhereInput
  }

  export type executableUpdateToOneWithWhereWithoutImmutable_executableInput = {
    where?: executableWhereInput
    data: XOR<executableUpdateWithoutImmutable_executableInput, executableUncheckedUpdateWithoutImmutable_executableInput>
  }

  export type executableUpdateWithoutImmutable_executableInput = {
    execid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    language?: languageUpdateManyWithoutExecutableNestedInput
    problem_problem_special_runToexecutable?: problemUpdateManyWithoutExecutable_problem_special_runToexecutableNestedInput
    problem_problem_special_compareToexecutable?: problemUpdateManyWithoutExecutable_problem_special_compareToexecutableNestedInput
  }

  export type executableUncheckedUpdateWithoutImmutable_executableInput = {
    execid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    language?: languageUncheckedUpdateManyWithoutExecutableNestedInput
    problem_problem_special_runToexecutable?: problemUncheckedUpdateManyWithoutExecutable_problem_special_runToexecutableNestedInput
    problem_problem_special_compareToexecutable?: problemUncheckedUpdateManyWithoutExecutable_problem_special_compareToexecutableNestedInput
  }

  export type executable_fileUpsertWithWhereUniqueWithoutImmutable_executableInput = {
    where: executable_fileWhereUniqueInput
    update: XOR<executable_fileUpdateWithoutImmutable_executableInput, executable_fileUncheckedUpdateWithoutImmutable_executableInput>
    create: XOR<executable_fileCreateWithoutImmutable_executableInput, executable_fileUncheckedCreateWithoutImmutable_executableInput>
  }

  export type executable_fileUpdateWithWhereUniqueWithoutImmutable_executableInput = {
    where: executable_fileWhereUniqueInput
    data: XOR<executable_fileUpdateWithoutImmutable_executableInput, executable_fileUncheckedUpdateWithoutImmutable_executableInput>
  }

  export type executable_fileUpdateManyWithWhereWithoutImmutable_executableInput = {
    where: executable_fileScalarWhereInput
    data: XOR<executable_fileUpdateManyMutationInput, executable_fileUncheckedUpdateManyWithoutImmutable_executableInput>
  }

  export type executable_fileScalarWhereInput = {
    AND?: executable_fileScalarWhereInput | executable_fileScalarWhereInput[]
    OR?: executable_fileScalarWhereInput[]
    NOT?: executable_fileScalarWhereInput | executable_fileScalarWhereInput[]
    execfileid?: IntFilter<"executable_file"> | number
    immutable_execid?: IntNullableFilter<"executable_file"> | number | null
    filename?: StringFilter<"executable_file"> | string
    ranknumber?: IntFilter<"executable_file"> | number
    file_content?: BytesFilter<"executable_file"> | Buffer
    hash?: StringNullableFilter<"executable_file"> | string | null
    is_executable?: BoolFilter<"executable_file"> | boolean
  }

  export type userUpsertWithoutImmutable_executableInput = {
    update: XOR<userUpdateWithoutImmutable_executableInput, userUncheckedUpdateWithoutImmutable_executableInput>
    create: XOR<userCreateWithoutImmutable_executableInput, userUncheckedCreateWithoutImmutable_executableInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutImmutable_executableInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutImmutable_executableInput, userUncheckedUpdateWithoutImmutable_executableInput>
  }

  export type userUpdateWithoutImmutable_executableInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_api_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    rejudging_rejudging_userid_startTouser?: rejudgingUpdateManyWithoutUser_rejudging_userid_startTouserNestedInput
    rejudging_rejudging_userid_finishTouser?: rejudgingUpdateManyWithoutUser_rejudging_userid_finishTouserNestedInput
    submission?: submissionUpdateManyWithoutUserNestedInput
    team?: teamUpdateOneWithoutUserNestedInput
    userrole?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutImmutable_executableInput = {
    userid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_api_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    rejudging_rejudging_userid_startTouser?: rejudgingUncheckedUpdateManyWithoutUser_rejudging_userid_startTouserNestedInput
    rejudging_rejudging_userid_finishTouser?: rejudgingUncheckedUpdateManyWithoutUser_rejudging_userid_finishTouserNestedInput
    submission?: submissionUncheckedUpdateManyWithoutUserNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type judgingCreateWithoutInternal_error_internal_error_judgingidTojudgingInput = {
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    judge_completely?: boolean
    uuid: string
    metadata?: Buffer | null
    debug_package?: debug_packageCreateNestedManyWithoutJudgingInput
    internal_error_judging_erroridTointernal_error?: internal_errorCreateNestedOneWithoutJudging_judging_erroridTointernal_errorInput
    contest?: contestCreateNestedOneWithoutJudgingInput
    submission?: submissionCreateNestedOneWithoutJudgingInput
    rejudging?: rejudgingCreateNestedOneWithoutJudgingInput
    judging?: judgingCreateNestedOneWithoutOther_judgingInput
    other_judging?: judgingCreateNestedManyWithoutJudgingInput
    judging_run?: judging_runCreateNestedManyWithoutJudgingInput
  }

  export type judgingUncheckedCreateWithoutInternal_error_internal_error_judgingidTojudgingInput = {
    judgingid?: number
    cid?: number | null
    submitid?: number | null
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    rejudgingid?: number | null
    prevjudgingid?: number | null
    judge_completely?: boolean
    errorid?: number | null
    uuid: string
    metadata?: Buffer | null
    debug_package?: debug_packageUncheckedCreateNestedManyWithoutJudgingInput
    other_judging?: judgingUncheckedCreateNestedManyWithoutJudgingInput
    judging_run?: judging_runUncheckedCreateNestedManyWithoutJudgingInput
  }

  export type judgingCreateOrConnectWithoutInternal_error_internal_error_judgingidTojudgingInput = {
    where: judgingWhereUniqueInput
    create: XOR<judgingCreateWithoutInternal_error_internal_error_judgingidTojudgingInput, judgingUncheckedCreateWithoutInternal_error_internal_error_judgingidTojudgingInput>
  }

  export type contestCreateWithoutInternal_errorInput = {
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemCreateNestedManyWithoutContestInput
    contestteam?: contestteamCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsCreateNestedManyWithoutContestInput
    event?: eventCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementCreateNestedManyWithoutContestInput
    external_run?: external_runCreateNestedManyWithoutContestInput
    judging?: judgingCreateNestedManyWithoutContestInput
    rankcache?: rankcacheCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalCreateNestedManyWithoutContestInput
    scorecache?: scorecacheCreateNestedManyWithoutContestInput
    submission?: submissionCreateNestedManyWithoutContestInput
  }

  export type contestUncheckedCreateWithoutInternal_errorInput = {
    cid?: number
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutContestInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryUncheckedCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedCreateNestedManyWithoutContestInput
    event?: eventUncheckedCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceUncheckedCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutContestInput
    external_run?: external_runUncheckedCreateNestedManyWithoutContestInput
    judging?: judgingUncheckedCreateNestedManyWithoutContestInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalUncheckedCreateNestedManyWithoutContestInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutContestInput
    submission?: submissionUncheckedCreateNestedManyWithoutContestInput
  }

  export type contestCreateOrConnectWithoutInternal_errorInput = {
    where: contestWhereUniqueInput
    create: XOR<contestCreateWithoutInternal_errorInput, contestUncheckedCreateWithoutInternal_errorInput>
  }

  export type judgingCreateWithoutInternal_error_judging_erroridTointernal_errorInput = {
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    judge_completely?: boolean
    uuid: string
    metadata?: Buffer | null
    debug_package?: debug_packageCreateNestedManyWithoutJudgingInput
    internal_error_internal_error_judgingidTojudging?: internal_errorCreateNestedManyWithoutJudging_internal_error_judgingidTojudgingInput
    contest?: contestCreateNestedOneWithoutJudgingInput
    submission?: submissionCreateNestedOneWithoutJudgingInput
    rejudging?: rejudgingCreateNestedOneWithoutJudgingInput
    judging?: judgingCreateNestedOneWithoutOther_judgingInput
    other_judging?: judgingCreateNestedManyWithoutJudgingInput
    judging_run?: judging_runCreateNestedManyWithoutJudgingInput
  }

  export type judgingUncheckedCreateWithoutInternal_error_judging_erroridTointernal_errorInput = {
    judgingid?: number
    cid?: number | null
    submitid?: number | null
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    rejudgingid?: number | null
    prevjudgingid?: number | null
    judge_completely?: boolean
    uuid: string
    metadata?: Buffer | null
    debug_package?: debug_packageUncheckedCreateNestedManyWithoutJudgingInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUncheckedCreateNestedManyWithoutJudging_internal_error_judgingidTojudgingInput
    other_judging?: judgingUncheckedCreateNestedManyWithoutJudgingInput
    judging_run?: judging_runUncheckedCreateNestedManyWithoutJudgingInput
  }

  export type judgingCreateOrConnectWithoutInternal_error_judging_erroridTointernal_errorInput = {
    where: judgingWhereUniqueInput
    create: XOR<judgingCreateWithoutInternal_error_judging_erroridTointernal_errorInput, judgingUncheckedCreateWithoutInternal_error_judging_erroridTointernal_errorInput>
  }

  export type judgingCreateManyInternal_error_judging_erroridTointernal_errorInputEnvelope = {
    data: judgingCreateManyInternal_error_judging_erroridTointernal_errorInput | judgingCreateManyInternal_error_judging_erroridTointernal_errorInput[]
    skipDuplicates?: boolean
  }

  export type judgingUpsertWithoutInternal_error_internal_error_judgingidTojudgingInput = {
    update: XOR<judgingUpdateWithoutInternal_error_internal_error_judgingidTojudgingInput, judgingUncheckedUpdateWithoutInternal_error_internal_error_judgingidTojudgingInput>
    create: XOR<judgingCreateWithoutInternal_error_internal_error_judgingidTojudgingInput, judgingUncheckedCreateWithoutInternal_error_internal_error_judgingidTojudgingInput>
    where?: judgingWhereInput
  }

  export type judgingUpdateToOneWithWhereWithoutInternal_error_internal_error_judgingidTojudgingInput = {
    where?: judgingWhereInput
    data: XOR<judgingUpdateWithoutInternal_error_internal_error_judgingidTojudgingInput, judgingUncheckedUpdateWithoutInternal_error_internal_error_judgingidTojudgingInput>
  }

  export type judgingUpdateWithoutInternal_error_internal_error_judgingidTojudgingInput = {
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    debug_package?: debug_packageUpdateManyWithoutJudgingNestedInput
    internal_error_judging_erroridTointernal_error?: internal_errorUpdateOneWithoutJudging_judging_erroridTointernal_errorNestedInput
    contest?: contestUpdateOneWithoutJudgingNestedInput
    submission?: submissionUpdateOneWithoutJudgingNestedInput
    rejudging?: rejudgingUpdateOneWithoutJudgingNestedInput
    judging?: judgingUpdateOneWithoutOther_judgingNestedInput
    other_judging?: judgingUpdateManyWithoutJudgingNestedInput
    judging_run?: judging_runUpdateManyWithoutJudgingNestedInput
  }

  export type judgingUncheckedUpdateWithoutInternal_error_internal_error_judgingidTojudgingInput = {
    judgingid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    prevjudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    errorid?: NullableIntFieldUpdateOperationsInput | number | null
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    debug_package?: debug_packageUncheckedUpdateManyWithoutJudgingNestedInput
    other_judging?: judgingUncheckedUpdateManyWithoutJudgingNestedInput
    judging_run?: judging_runUncheckedUpdateManyWithoutJudgingNestedInput
  }

  export type contestUpsertWithoutInternal_errorInput = {
    update: XOR<contestUpdateWithoutInternal_errorInput, contestUncheckedUpdateWithoutInternal_errorInput>
    create: XOR<contestCreateWithoutInternal_errorInput, contestUncheckedCreateWithoutInternal_errorInput>
    where?: contestWhereInput
  }

  export type contestUpdateToOneWithWhereWithoutInternal_errorInput = {
    where?: contestWhereInput
    data: XOR<contestUpdateWithoutInternal_errorInput, contestUncheckedUpdateWithoutInternal_errorInput>
  }

  export type contestUpdateWithoutInternal_errorInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUpdateManyWithoutContestNestedInput
    event?: eventUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUpdateManyWithoutContestNestedInput
    external_run?: external_runUpdateManyWithoutContestNestedInput
    judging?: judgingUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUpdateManyWithoutContestNestedInput
    submission?: submissionUpdateManyWithoutContestNestedInput
  }

  export type contestUncheckedUpdateWithoutInternal_errorInput = {
    cid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedUpdateManyWithoutContestNestedInput
    event?: eventUncheckedUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUncheckedUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutContestNestedInput
    external_run?: external_runUncheckedUpdateManyWithoutContestNestedInput
    judging?: judgingUncheckedUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUncheckedUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutContestNestedInput
    submission?: submissionUncheckedUpdateManyWithoutContestNestedInput
  }

  export type judgingUpsertWithWhereUniqueWithoutInternal_error_judging_erroridTointernal_errorInput = {
    where: judgingWhereUniqueInput
    update: XOR<judgingUpdateWithoutInternal_error_judging_erroridTointernal_errorInput, judgingUncheckedUpdateWithoutInternal_error_judging_erroridTointernal_errorInput>
    create: XOR<judgingCreateWithoutInternal_error_judging_erroridTointernal_errorInput, judgingUncheckedCreateWithoutInternal_error_judging_erroridTointernal_errorInput>
  }

  export type judgingUpdateWithWhereUniqueWithoutInternal_error_judging_erroridTointernal_errorInput = {
    where: judgingWhereUniqueInput
    data: XOR<judgingUpdateWithoutInternal_error_judging_erroridTointernal_errorInput, judgingUncheckedUpdateWithoutInternal_error_judging_erroridTointernal_errorInput>
  }

  export type judgingUpdateManyWithWhereWithoutInternal_error_judging_erroridTointernal_errorInput = {
    where: judgingScalarWhereInput
    data: XOR<judgingUpdateManyMutationInput, judgingUncheckedUpdateManyWithoutInternal_error_judging_erroridTointernal_errorInput>
  }

  export type debug_packageCreateWithoutJudgehostInput = {
    filename: string
    judging?: judgingCreateNestedOneWithoutDebug_packageInput
  }

  export type debug_packageUncheckedCreateWithoutJudgehostInput = {
    debug_package_id?: number
    judgingid?: number | null
    filename: string
  }

  export type debug_packageCreateOrConnectWithoutJudgehostInput = {
    where: debug_packageWhereUniqueInput
    create: XOR<debug_packageCreateWithoutJudgehostInput, debug_packageUncheckedCreateWithoutJudgehostInput>
  }

  export type debug_packageCreateManyJudgehostInputEnvelope = {
    data: debug_packageCreateManyJudgehostInput | debug_packageCreateManyJudgehostInput[]
    skipDuplicates?: boolean
  }

  export type judgetaskCreateWithoutJudgehostInput = {
    type?: $Enums.judgetask_type
    priority: number
    jobid?: number | null
    submitid?: number | null
    compile_script_id?: number | null
    run_script_id?: number | null
    compare_script_id?: number | null
    testcase_id?: number | null
    compile_config?: string | null
    run_config?: string | null
    compare_config?: string | null
    valid?: boolean
    starttime?: Decimal | DecimalJsLike | number | string | null
    uuid?: string | null
    testcase_hash?: string | null
    judging_run?: judging_runCreateNestedManyWithoutJudgetaskInput
  }

  export type judgetaskUncheckedCreateWithoutJudgehostInput = {
    judgetaskid?: number
    type?: $Enums.judgetask_type
    priority: number
    jobid?: number | null
    submitid?: number | null
    compile_script_id?: number | null
    run_script_id?: number | null
    compare_script_id?: number | null
    testcase_id?: number | null
    compile_config?: string | null
    run_config?: string | null
    compare_config?: string | null
    valid?: boolean
    starttime?: Decimal | DecimalJsLike | number | string | null
    uuid?: string | null
    testcase_hash?: string | null
    judging_run?: judging_runUncheckedCreateNestedManyWithoutJudgetaskInput
  }

  export type judgetaskCreateOrConnectWithoutJudgehostInput = {
    where: judgetaskWhereUniqueInput
    create: XOR<judgetaskCreateWithoutJudgehostInput, judgetaskUncheckedCreateWithoutJudgehostInput>
  }

  export type judgetaskCreateManyJudgehostInputEnvelope = {
    data: judgetaskCreateManyJudgehostInput | judgetaskCreateManyJudgehostInput[]
    skipDuplicates?: boolean
  }

  export type debug_packageUpsertWithWhereUniqueWithoutJudgehostInput = {
    where: debug_packageWhereUniqueInput
    update: XOR<debug_packageUpdateWithoutJudgehostInput, debug_packageUncheckedUpdateWithoutJudgehostInput>
    create: XOR<debug_packageCreateWithoutJudgehostInput, debug_packageUncheckedCreateWithoutJudgehostInput>
  }

  export type debug_packageUpdateWithWhereUniqueWithoutJudgehostInput = {
    where: debug_packageWhereUniqueInput
    data: XOR<debug_packageUpdateWithoutJudgehostInput, debug_packageUncheckedUpdateWithoutJudgehostInput>
  }

  export type debug_packageUpdateManyWithWhereWithoutJudgehostInput = {
    where: debug_packageScalarWhereInput
    data: XOR<debug_packageUpdateManyMutationInput, debug_packageUncheckedUpdateManyWithoutJudgehostInput>
  }

  export type debug_packageScalarWhereInput = {
    AND?: debug_packageScalarWhereInput | debug_packageScalarWhereInput[]
    OR?: debug_packageScalarWhereInput[]
    NOT?: debug_packageScalarWhereInput | debug_packageScalarWhereInput[]
    debug_package_id?: IntFilter<"debug_package"> | number
    judgingid?: IntNullableFilter<"debug_package"> | number | null
    judgehostid?: IntNullableFilter<"debug_package"> | number | null
    filename?: StringFilter<"debug_package"> | string
  }

  export type judgetaskUpsertWithWhereUniqueWithoutJudgehostInput = {
    where: judgetaskWhereUniqueInput
    update: XOR<judgetaskUpdateWithoutJudgehostInput, judgetaskUncheckedUpdateWithoutJudgehostInput>
    create: XOR<judgetaskCreateWithoutJudgehostInput, judgetaskUncheckedCreateWithoutJudgehostInput>
  }

  export type judgetaskUpdateWithWhereUniqueWithoutJudgehostInput = {
    where: judgetaskWhereUniqueInput
    data: XOR<judgetaskUpdateWithoutJudgehostInput, judgetaskUncheckedUpdateWithoutJudgehostInput>
  }

  export type judgetaskUpdateManyWithWhereWithoutJudgehostInput = {
    where: judgetaskScalarWhereInput
    data: XOR<judgetaskUpdateManyMutationInput, judgetaskUncheckedUpdateManyWithoutJudgehostInput>
  }

  export type judgetaskScalarWhereInput = {
    AND?: judgetaskScalarWhereInput | judgetaskScalarWhereInput[]
    OR?: judgetaskScalarWhereInput[]
    NOT?: judgetaskScalarWhereInput | judgetaskScalarWhereInput[]
    judgetaskid?: IntFilter<"judgetask"> | number
    judgehostid?: IntNullableFilter<"judgetask"> | number | null
    type?: Enumjudgetask_typeFilter<"judgetask"> | $Enums.judgetask_type
    priority?: IntFilter<"judgetask"> | number
    jobid?: IntNullableFilter<"judgetask"> | number | null
    submitid?: IntNullableFilter<"judgetask"> | number | null
    compile_script_id?: IntNullableFilter<"judgetask"> | number | null
    run_script_id?: IntNullableFilter<"judgetask"> | number | null
    compare_script_id?: IntNullableFilter<"judgetask"> | number | null
    testcase_id?: IntNullableFilter<"judgetask"> | number | null
    compile_config?: StringNullableFilter<"judgetask"> | string | null
    run_config?: StringNullableFilter<"judgetask"> | string | null
    compare_config?: StringNullableFilter<"judgetask"> | string | null
    valid?: BoolFilter<"judgetask"> | boolean
    starttime?: DecimalNullableFilter<"judgetask"> | Decimal | DecimalJsLike | number | string | null
    uuid?: StringNullableFilter<"judgetask"> | string | null
    testcase_hash?: StringNullableFilter<"judgetask"> | string | null
  }

  export type judgehostCreateWithoutJudgetaskInput = {
    hostname: string
    enabled?: boolean
    polltime?: Decimal | DecimalJsLike | number | string | null
    hidden?: boolean
    debug_package?: debug_packageCreateNestedManyWithoutJudgehostInput
  }

  export type judgehostUncheckedCreateWithoutJudgetaskInput = {
    judgehostid?: number
    hostname: string
    enabled?: boolean
    polltime?: Decimal | DecimalJsLike | number | string | null
    hidden?: boolean
    debug_package?: debug_packageUncheckedCreateNestedManyWithoutJudgehostInput
  }

  export type judgehostCreateOrConnectWithoutJudgetaskInput = {
    where: judgehostWhereUniqueInput
    create: XOR<judgehostCreateWithoutJudgetaskInput, judgehostUncheckedCreateWithoutJudgetaskInput>
  }

  export type judging_runCreateWithoutJudgetaskInput = {
    runresult?: string | null
    runtime?: number | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    testcase?: testcaseCreateNestedOneWithoutJudging_runInput
    judging?: judgingCreateNestedOneWithoutJudging_runInput
    judging_run_output?: judging_run_outputCreateNestedOneWithoutJudging_runInput
  }

  export type judging_runUncheckedCreateWithoutJudgetaskInput = {
    runid?: number
    judgingid?: number | null
    testcaseid?: number | null
    runresult?: string | null
    runtime?: number | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    judging_run_output?: judging_run_outputUncheckedCreateNestedOneWithoutJudging_runInput
  }

  export type judging_runCreateOrConnectWithoutJudgetaskInput = {
    where: judging_runWhereUniqueInput
    create: XOR<judging_runCreateWithoutJudgetaskInput, judging_runUncheckedCreateWithoutJudgetaskInput>
  }

  export type judging_runCreateManyJudgetaskInputEnvelope = {
    data: judging_runCreateManyJudgetaskInput | judging_runCreateManyJudgetaskInput[]
    skipDuplicates?: boolean
  }

  export type judgehostUpsertWithoutJudgetaskInput = {
    update: XOR<judgehostUpdateWithoutJudgetaskInput, judgehostUncheckedUpdateWithoutJudgetaskInput>
    create: XOR<judgehostCreateWithoutJudgetaskInput, judgehostUncheckedCreateWithoutJudgetaskInput>
    where?: judgehostWhereInput
  }

  export type judgehostUpdateToOneWithWhereWithoutJudgetaskInput = {
    where?: judgehostWhereInput
    data: XOR<judgehostUpdateWithoutJudgetaskInput, judgehostUncheckedUpdateWithoutJudgetaskInput>
  }

  export type judgehostUpdateWithoutJudgetaskInput = {
    hostname?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    polltime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    debug_package?: debug_packageUpdateManyWithoutJudgehostNestedInput
  }

  export type judgehostUncheckedUpdateWithoutJudgetaskInput = {
    judgehostid?: IntFieldUpdateOperationsInput | number
    hostname?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    polltime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    debug_package?: debug_packageUncheckedUpdateManyWithoutJudgehostNestedInput
  }

  export type judging_runUpsertWithWhereUniqueWithoutJudgetaskInput = {
    where: judging_runWhereUniqueInput
    update: XOR<judging_runUpdateWithoutJudgetaskInput, judging_runUncheckedUpdateWithoutJudgetaskInput>
    create: XOR<judging_runCreateWithoutJudgetaskInput, judging_runUncheckedCreateWithoutJudgetaskInput>
  }

  export type judging_runUpdateWithWhereUniqueWithoutJudgetaskInput = {
    where: judging_runWhereUniqueInput
    data: XOR<judging_runUpdateWithoutJudgetaskInput, judging_runUncheckedUpdateWithoutJudgetaskInput>
  }

  export type judging_runUpdateManyWithWhereWithoutJudgetaskInput = {
    where: judging_runScalarWhereInput
    data: XOR<judging_runUpdateManyMutationInput, judging_runUncheckedUpdateManyWithoutJudgetaskInput>
  }

  export type judging_runScalarWhereInput = {
    AND?: judging_runScalarWhereInput | judging_runScalarWhereInput[]
    OR?: judging_runScalarWhereInput[]
    NOT?: judging_runScalarWhereInput | judging_runScalarWhereInput[]
    runid?: IntFilter<"judging_run"> | number
    judgingid?: IntNullableFilter<"judging_run"> | number | null
    testcaseid?: IntNullableFilter<"judging_run"> | number | null
    runresult?: StringNullableFilter<"judging_run"> | string | null
    runtime?: FloatNullableFilter<"judging_run"> | number | null
    endtime?: DecimalNullableFilter<"judging_run"> | Decimal | DecimalJsLike | number | string | null
    judgetaskid?: IntNullableFilter<"judging_run"> | number | null
  }

  export type debug_packageCreateWithoutJudgingInput = {
    filename: string
    judgehost?: judgehostCreateNestedOneWithoutDebug_packageInput
  }

  export type debug_packageUncheckedCreateWithoutJudgingInput = {
    debug_package_id?: number
    judgehostid?: number | null
    filename: string
  }

  export type debug_packageCreateOrConnectWithoutJudgingInput = {
    where: debug_packageWhereUniqueInput
    create: XOR<debug_packageCreateWithoutJudgingInput, debug_packageUncheckedCreateWithoutJudgingInput>
  }

  export type debug_packageCreateManyJudgingInputEnvelope = {
    data: debug_packageCreateManyJudgingInput | debug_packageCreateManyJudgingInput[]
    skipDuplicates?: boolean
  }

  export type internal_errorCreateWithoutJudging_internal_error_judgingidTojudgingInput = {
    description: string
    judgehostlog: string
    time: Decimal | DecimalJsLike | number | string
    disabled: string
    status?: $Enums.internal_error_status
    contest?: contestCreateNestedOneWithoutInternal_errorInput
    judging_judging_erroridTointernal_error?: judgingCreateNestedManyWithoutInternal_error_judging_erroridTointernal_errorInput
  }

  export type internal_errorUncheckedCreateWithoutJudging_internal_error_judgingidTojudgingInput = {
    errorid?: number
    cid?: number | null
    description: string
    judgehostlog: string
    time: Decimal | DecimalJsLike | number | string
    disabled: string
    status?: $Enums.internal_error_status
    judging_judging_erroridTointernal_error?: judgingUncheckedCreateNestedManyWithoutInternal_error_judging_erroridTointernal_errorInput
  }

  export type internal_errorCreateOrConnectWithoutJudging_internal_error_judgingidTojudgingInput = {
    where: internal_errorWhereUniqueInput
    create: XOR<internal_errorCreateWithoutJudging_internal_error_judgingidTojudgingInput, internal_errorUncheckedCreateWithoutJudging_internal_error_judgingidTojudgingInput>
  }

  export type internal_errorCreateManyJudging_internal_error_judgingidTojudgingInputEnvelope = {
    data: internal_errorCreateManyJudging_internal_error_judgingidTojudgingInput | internal_errorCreateManyJudging_internal_error_judgingidTojudgingInput[]
    skipDuplicates?: boolean
  }

  export type internal_errorCreateWithoutJudging_judging_erroridTointernal_errorInput = {
    description: string
    judgehostlog: string
    time: Decimal | DecimalJsLike | number | string
    disabled: string
    status?: $Enums.internal_error_status
    judging_internal_error_judgingidTojudging?: judgingCreateNestedOneWithoutInternal_error_internal_error_judgingidTojudgingInput
    contest?: contestCreateNestedOneWithoutInternal_errorInput
  }

  export type internal_errorUncheckedCreateWithoutJudging_judging_erroridTointernal_errorInput = {
    errorid?: number
    judgingid?: number | null
    cid?: number | null
    description: string
    judgehostlog: string
    time: Decimal | DecimalJsLike | number | string
    disabled: string
    status?: $Enums.internal_error_status
  }

  export type internal_errorCreateOrConnectWithoutJudging_judging_erroridTointernal_errorInput = {
    where: internal_errorWhereUniqueInput
    create: XOR<internal_errorCreateWithoutJudging_judging_erroridTointernal_errorInput, internal_errorUncheckedCreateWithoutJudging_judging_erroridTointernal_errorInput>
  }

  export type contestCreateWithoutJudgingInput = {
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemCreateNestedManyWithoutContestInput
    contestteam?: contestteamCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsCreateNestedManyWithoutContestInput
    event?: eventCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementCreateNestedManyWithoutContestInput
    external_run?: external_runCreateNestedManyWithoutContestInput
    internal_error?: internal_errorCreateNestedManyWithoutContestInput
    rankcache?: rankcacheCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalCreateNestedManyWithoutContestInput
    scorecache?: scorecacheCreateNestedManyWithoutContestInput
    submission?: submissionCreateNestedManyWithoutContestInput
  }

  export type contestUncheckedCreateWithoutJudgingInput = {
    cid?: number
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutContestInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryUncheckedCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedCreateNestedManyWithoutContestInput
    event?: eventUncheckedCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceUncheckedCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutContestInput
    external_run?: external_runUncheckedCreateNestedManyWithoutContestInput
    internal_error?: internal_errorUncheckedCreateNestedManyWithoutContestInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalUncheckedCreateNestedManyWithoutContestInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutContestInput
    submission?: submissionUncheckedCreateNestedManyWithoutContestInput
  }

  export type contestCreateOrConnectWithoutJudgingInput = {
    where: contestWhereUniqueInput
    create: XOR<contestCreateWithoutJudgingInput, contestUncheckedCreateWithoutJudgingInput>
  }

  export type submissionCreateWithoutJudgingInput = {
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementCreateNestedManyWithoutSubmissionInput
    user?: userCreateNestedOneWithoutSubmissionInput
    contest?: contestCreateNestedOneWithoutSubmissionInput
    team?: teamCreateNestedOneWithoutSubmissionInput
    problem?: problemCreateNestedOneWithoutSubmissionInput
    language?: languageCreateNestedOneWithoutSubmissionInput
    submission?: submissionCreateNestedOneWithoutOther_submissionInput
    other_submission?: submissionCreateNestedManyWithoutSubmissionInput
    rejudging?: rejudgingCreateNestedOneWithoutSubmissionInput
    contestproblem?: contestproblemCreateNestedOneWithoutSubmissionInput
    submission_file?: submission_fileCreateNestedManyWithoutSubmissionInput
  }

  export type submissionUncheckedCreateWithoutJudgingInput = {
    submitid?: number
    origsubmitid?: number | null
    cid?: number | null
    teamid?: number | null
    userid?: number | null
    probid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonUncheckedCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutSubmissionInput
    other_submission?: submissionUncheckedCreateNestedManyWithoutSubmissionInput
    submission_file?: submission_fileUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type submissionCreateOrConnectWithoutJudgingInput = {
    where: submissionWhereUniqueInput
    create: XOR<submissionCreateWithoutJudgingInput, submissionUncheckedCreateWithoutJudgingInput>
  }

  export type rejudgingCreateWithoutJudgingInput = {
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    reason: string
    valid?: boolean
    auto_apply?: boolean
    repeat?: number | null
    rejudging?: rejudgingCreateNestedOneWithoutOther_rejudgingInput
    other_rejudging?: rejudgingCreateNestedManyWithoutRejudgingInput
    user_rejudging_userid_startTouser?: userCreateNestedOneWithoutRejudging_rejudging_userid_startTouserInput
    user_rejudging_userid_finishTouser?: userCreateNestedOneWithoutRejudging_rejudging_userid_finishTouserInput
    submission?: submissionCreateNestedManyWithoutRejudgingInput
  }

  export type rejudgingUncheckedCreateWithoutJudgingInput = {
    rejudgingid?: number
    userid_start?: number | null
    userid_finish?: number | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    reason: string
    valid?: boolean
    auto_apply?: boolean
    repeat?: number | null
    repeat_rejudgingid?: number | null
    other_rejudging?: rejudgingUncheckedCreateNestedManyWithoutRejudgingInput
    submission?: submissionUncheckedCreateNestedManyWithoutRejudgingInput
  }

  export type rejudgingCreateOrConnectWithoutJudgingInput = {
    where: rejudgingWhereUniqueInput
    create: XOR<rejudgingCreateWithoutJudgingInput, rejudgingUncheckedCreateWithoutJudgingInput>
  }

  export type judgingCreateWithoutOther_judgingInput = {
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    judge_completely?: boolean
    uuid: string
    metadata?: Buffer | null
    debug_package?: debug_packageCreateNestedManyWithoutJudgingInput
    internal_error_internal_error_judgingidTojudging?: internal_errorCreateNestedManyWithoutJudging_internal_error_judgingidTojudgingInput
    internal_error_judging_erroridTointernal_error?: internal_errorCreateNestedOneWithoutJudging_judging_erroridTointernal_errorInput
    contest?: contestCreateNestedOneWithoutJudgingInput
    submission?: submissionCreateNestedOneWithoutJudgingInput
    rejudging?: rejudgingCreateNestedOneWithoutJudgingInput
    judging?: judgingCreateNestedOneWithoutOther_judgingInput
    judging_run?: judging_runCreateNestedManyWithoutJudgingInput
  }

  export type judgingUncheckedCreateWithoutOther_judgingInput = {
    judgingid?: number
    cid?: number | null
    submitid?: number | null
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    rejudgingid?: number | null
    prevjudgingid?: number | null
    judge_completely?: boolean
    errorid?: number | null
    uuid: string
    metadata?: Buffer | null
    debug_package?: debug_packageUncheckedCreateNestedManyWithoutJudgingInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUncheckedCreateNestedManyWithoutJudging_internal_error_judgingidTojudgingInput
    judging_run?: judging_runUncheckedCreateNestedManyWithoutJudgingInput
  }

  export type judgingCreateOrConnectWithoutOther_judgingInput = {
    where: judgingWhereUniqueInput
    create: XOR<judgingCreateWithoutOther_judgingInput, judgingUncheckedCreateWithoutOther_judgingInput>
  }

  export type judgingCreateWithoutJudgingInput = {
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    judge_completely?: boolean
    uuid: string
    metadata?: Buffer | null
    debug_package?: debug_packageCreateNestedManyWithoutJudgingInput
    internal_error_internal_error_judgingidTojudging?: internal_errorCreateNestedManyWithoutJudging_internal_error_judgingidTojudgingInput
    internal_error_judging_erroridTointernal_error?: internal_errorCreateNestedOneWithoutJudging_judging_erroridTointernal_errorInput
    contest?: contestCreateNestedOneWithoutJudgingInput
    submission?: submissionCreateNestedOneWithoutJudgingInput
    rejudging?: rejudgingCreateNestedOneWithoutJudgingInput
    other_judging?: judgingCreateNestedManyWithoutJudgingInput
    judging_run?: judging_runCreateNestedManyWithoutJudgingInput
  }

  export type judgingUncheckedCreateWithoutJudgingInput = {
    judgingid?: number
    cid?: number | null
    submitid?: number | null
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    rejudgingid?: number | null
    judge_completely?: boolean
    errorid?: number | null
    uuid: string
    metadata?: Buffer | null
    debug_package?: debug_packageUncheckedCreateNestedManyWithoutJudgingInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUncheckedCreateNestedManyWithoutJudging_internal_error_judgingidTojudgingInput
    other_judging?: judgingUncheckedCreateNestedManyWithoutJudgingInput
    judging_run?: judging_runUncheckedCreateNestedManyWithoutJudgingInput
  }

  export type judgingCreateOrConnectWithoutJudgingInput = {
    where: judgingWhereUniqueInput
    create: XOR<judgingCreateWithoutJudgingInput, judgingUncheckedCreateWithoutJudgingInput>
  }

  export type judgingCreateManyJudgingInputEnvelope = {
    data: judgingCreateManyJudgingInput | judgingCreateManyJudgingInput[]
    skipDuplicates?: boolean
  }

  export type judging_runCreateWithoutJudgingInput = {
    runresult?: string | null
    runtime?: number | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    judgetask?: judgetaskCreateNestedOneWithoutJudging_runInput
    testcase?: testcaseCreateNestedOneWithoutJudging_runInput
    judging_run_output?: judging_run_outputCreateNestedOneWithoutJudging_runInput
  }

  export type judging_runUncheckedCreateWithoutJudgingInput = {
    runid?: number
    testcaseid?: number | null
    runresult?: string | null
    runtime?: number | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    judgetaskid?: number | null
    judging_run_output?: judging_run_outputUncheckedCreateNestedOneWithoutJudging_runInput
  }

  export type judging_runCreateOrConnectWithoutJudgingInput = {
    where: judging_runWhereUniqueInput
    create: XOR<judging_runCreateWithoutJudgingInput, judging_runUncheckedCreateWithoutJudgingInput>
  }

  export type judging_runCreateManyJudgingInputEnvelope = {
    data: judging_runCreateManyJudgingInput | judging_runCreateManyJudgingInput[]
    skipDuplicates?: boolean
  }

  export type debug_packageUpsertWithWhereUniqueWithoutJudgingInput = {
    where: debug_packageWhereUniqueInput
    update: XOR<debug_packageUpdateWithoutJudgingInput, debug_packageUncheckedUpdateWithoutJudgingInput>
    create: XOR<debug_packageCreateWithoutJudgingInput, debug_packageUncheckedCreateWithoutJudgingInput>
  }

  export type debug_packageUpdateWithWhereUniqueWithoutJudgingInput = {
    where: debug_packageWhereUniqueInput
    data: XOR<debug_packageUpdateWithoutJudgingInput, debug_packageUncheckedUpdateWithoutJudgingInput>
  }

  export type debug_packageUpdateManyWithWhereWithoutJudgingInput = {
    where: debug_packageScalarWhereInput
    data: XOR<debug_packageUpdateManyMutationInput, debug_packageUncheckedUpdateManyWithoutJudgingInput>
  }

  export type internal_errorUpsertWithWhereUniqueWithoutJudging_internal_error_judgingidTojudgingInput = {
    where: internal_errorWhereUniqueInput
    update: XOR<internal_errorUpdateWithoutJudging_internal_error_judgingidTojudgingInput, internal_errorUncheckedUpdateWithoutJudging_internal_error_judgingidTojudgingInput>
    create: XOR<internal_errorCreateWithoutJudging_internal_error_judgingidTojudgingInput, internal_errorUncheckedCreateWithoutJudging_internal_error_judgingidTojudgingInput>
  }

  export type internal_errorUpdateWithWhereUniqueWithoutJudging_internal_error_judgingidTojudgingInput = {
    where: internal_errorWhereUniqueInput
    data: XOR<internal_errorUpdateWithoutJudging_internal_error_judgingidTojudgingInput, internal_errorUncheckedUpdateWithoutJudging_internal_error_judgingidTojudgingInput>
  }

  export type internal_errorUpdateManyWithWhereWithoutJudging_internal_error_judgingidTojudgingInput = {
    where: internal_errorScalarWhereInput
    data: XOR<internal_errorUpdateManyMutationInput, internal_errorUncheckedUpdateManyWithoutJudging_internal_error_judgingidTojudgingInput>
  }

  export type internal_errorUpsertWithoutJudging_judging_erroridTointernal_errorInput = {
    update: XOR<internal_errorUpdateWithoutJudging_judging_erroridTointernal_errorInput, internal_errorUncheckedUpdateWithoutJudging_judging_erroridTointernal_errorInput>
    create: XOR<internal_errorCreateWithoutJudging_judging_erroridTointernal_errorInput, internal_errorUncheckedCreateWithoutJudging_judging_erroridTointernal_errorInput>
    where?: internal_errorWhereInput
  }

  export type internal_errorUpdateToOneWithWhereWithoutJudging_judging_erroridTointernal_errorInput = {
    where?: internal_errorWhereInput
    data: XOR<internal_errorUpdateWithoutJudging_judging_erroridTointernal_errorInput, internal_errorUncheckedUpdateWithoutJudging_judging_erroridTointernal_errorInput>
  }

  export type internal_errorUpdateWithoutJudging_judging_erroridTointernal_errorInput = {
    description?: StringFieldUpdateOperationsInput | string
    judgehostlog?: StringFieldUpdateOperationsInput | string
    time?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disabled?: StringFieldUpdateOperationsInput | string
    status?: Enuminternal_error_statusFieldUpdateOperationsInput | $Enums.internal_error_status
    judging_internal_error_judgingidTojudging?: judgingUpdateOneWithoutInternal_error_internal_error_judgingidTojudgingNestedInput
    contest?: contestUpdateOneWithoutInternal_errorNestedInput
  }

  export type internal_errorUncheckedUpdateWithoutJudging_judging_erroridTointernal_errorInput = {
    errorid?: IntFieldUpdateOperationsInput | number
    judgingid?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    judgehostlog?: StringFieldUpdateOperationsInput | string
    time?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disabled?: StringFieldUpdateOperationsInput | string
    status?: Enuminternal_error_statusFieldUpdateOperationsInput | $Enums.internal_error_status
  }

  export type contestUpsertWithoutJudgingInput = {
    update: XOR<contestUpdateWithoutJudgingInput, contestUncheckedUpdateWithoutJudgingInput>
    create: XOR<contestCreateWithoutJudgingInput, contestUncheckedCreateWithoutJudgingInput>
    where?: contestWhereInput
  }

  export type contestUpdateToOneWithWhereWithoutJudgingInput = {
    where?: contestWhereInput
    data: XOR<contestUpdateWithoutJudgingInput, contestUncheckedUpdateWithoutJudgingInput>
  }

  export type contestUpdateWithoutJudgingInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUpdateManyWithoutContestNestedInput
    event?: eventUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUpdateManyWithoutContestNestedInput
    external_run?: external_runUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUpdateManyWithoutContestNestedInput
    submission?: submissionUpdateManyWithoutContestNestedInput
  }

  export type contestUncheckedUpdateWithoutJudgingInput = {
    cid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedUpdateManyWithoutContestNestedInput
    event?: eventUncheckedUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUncheckedUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutContestNestedInput
    external_run?: external_runUncheckedUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUncheckedUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUncheckedUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutContestNestedInput
    submission?: submissionUncheckedUpdateManyWithoutContestNestedInput
  }

  export type submissionUpsertWithoutJudgingInput = {
    update: XOR<submissionUpdateWithoutJudgingInput, submissionUncheckedUpdateWithoutJudgingInput>
    create: XOR<submissionCreateWithoutJudgingInput, submissionUncheckedCreateWithoutJudgingInput>
    where?: submissionWhereInput
  }

  export type submissionUpdateToOneWithWhereWithoutJudgingInput = {
    where?: submissionWhereInput
    data: XOR<submissionUpdateWithoutJudgingInput, submissionUncheckedUpdateWithoutJudgingInput>
  }

  export type submissionUpdateWithoutJudgingInput = {
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUpdateManyWithoutSubmissionNestedInput
    user?: userUpdateOneWithoutSubmissionNestedInput
    contest?: contestUpdateOneWithoutSubmissionNestedInput
    team?: teamUpdateOneWithoutSubmissionNestedInput
    problem?: problemUpdateOneWithoutSubmissionNestedInput
    language?: languageUpdateOneWithoutSubmissionNestedInput
    submission?: submissionUpdateOneWithoutOther_submissionNestedInput
    other_submission?: submissionUpdateManyWithoutSubmissionNestedInput
    rejudging?: rejudgingUpdateOneWithoutSubmissionNestedInput
    contestproblem?: contestproblemUpdateOneWithoutSubmissionNestedInput
    submission_file?: submission_fileUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateWithoutJudgingInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUncheckedUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutSubmissionNestedInput
    other_submission?: submissionUncheckedUpdateManyWithoutSubmissionNestedInput
    submission_file?: submission_fileUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type rejudgingUpsertWithoutJudgingInput = {
    update: XOR<rejudgingUpdateWithoutJudgingInput, rejudgingUncheckedUpdateWithoutJudgingInput>
    create: XOR<rejudgingCreateWithoutJudgingInput, rejudgingUncheckedCreateWithoutJudgingInput>
    where?: rejudgingWhereInput
  }

  export type rejudgingUpdateToOneWithWhereWithoutJudgingInput = {
    where?: rejudgingWhereInput
    data: XOR<rejudgingUpdateWithoutJudgingInput, rejudgingUncheckedUpdateWithoutJudgingInput>
  }

  export type rejudgingUpdateWithoutJudgingInput = {
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    auto_apply?: BoolFieldUpdateOperationsInput | boolean
    repeat?: NullableIntFieldUpdateOperationsInput | number | null
    rejudging?: rejudgingUpdateOneWithoutOther_rejudgingNestedInput
    other_rejudging?: rejudgingUpdateManyWithoutRejudgingNestedInput
    user_rejudging_userid_startTouser?: userUpdateOneWithoutRejudging_rejudging_userid_startTouserNestedInput
    user_rejudging_userid_finishTouser?: userUpdateOneWithoutRejudging_rejudging_userid_finishTouserNestedInput
    submission?: submissionUpdateManyWithoutRejudgingNestedInput
  }

  export type rejudgingUncheckedUpdateWithoutJudgingInput = {
    rejudgingid?: IntFieldUpdateOperationsInput | number
    userid_start?: NullableIntFieldUpdateOperationsInput | number | null
    userid_finish?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    auto_apply?: BoolFieldUpdateOperationsInput | boolean
    repeat?: NullableIntFieldUpdateOperationsInput | number | null
    repeat_rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    other_rejudging?: rejudgingUncheckedUpdateManyWithoutRejudgingNestedInput
    submission?: submissionUncheckedUpdateManyWithoutRejudgingNestedInput
  }

  export type judgingUpsertWithoutOther_judgingInput = {
    update: XOR<judgingUpdateWithoutOther_judgingInput, judgingUncheckedUpdateWithoutOther_judgingInput>
    create: XOR<judgingCreateWithoutOther_judgingInput, judgingUncheckedCreateWithoutOther_judgingInput>
    where?: judgingWhereInput
  }

  export type judgingUpdateToOneWithWhereWithoutOther_judgingInput = {
    where?: judgingWhereInput
    data: XOR<judgingUpdateWithoutOther_judgingInput, judgingUncheckedUpdateWithoutOther_judgingInput>
  }

  export type judgingUpdateWithoutOther_judgingInput = {
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    debug_package?: debug_packageUpdateManyWithoutJudgingNestedInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUpdateManyWithoutJudging_internal_error_judgingidTojudgingNestedInput
    internal_error_judging_erroridTointernal_error?: internal_errorUpdateOneWithoutJudging_judging_erroridTointernal_errorNestedInput
    contest?: contestUpdateOneWithoutJudgingNestedInput
    submission?: submissionUpdateOneWithoutJudgingNestedInput
    rejudging?: rejudgingUpdateOneWithoutJudgingNestedInput
    judging?: judgingUpdateOneWithoutOther_judgingNestedInput
    judging_run?: judging_runUpdateManyWithoutJudgingNestedInput
  }

  export type judgingUncheckedUpdateWithoutOther_judgingInput = {
    judgingid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    prevjudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    errorid?: NullableIntFieldUpdateOperationsInput | number | null
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    debug_package?: debug_packageUncheckedUpdateManyWithoutJudgingNestedInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUncheckedUpdateManyWithoutJudging_internal_error_judgingidTojudgingNestedInput
    judging_run?: judging_runUncheckedUpdateManyWithoutJudgingNestedInput
  }

  export type judgingUpsertWithWhereUniqueWithoutJudgingInput = {
    where: judgingWhereUniqueInput
    update: XOR<judgingUpdateWithoutJudgingInput, judgingUncheckedUpdateWithoutJudgingInput>
    create: XOR<judgingCreateWithoutJudgingInput, judgingUncheckedCreateWithoutJudgingInput>
  }

  export type judgingUpdateWithWhereUniqueWithoutJudgingInput = {
    where: judgingWhereUniqueInput
    data: XOR<judgingUpdateWithoutJudgingInput, judgingUncheckedUpdateWithoutJudgingInput>
  }

  export type judgingUpdateManyWithWhereWithoutJudgingInput = {
    where: judgingScalarWhereInput
    data: XOR<judgingUpdateManyMutationInput, judgingUncheckedUpdateManyWithoutJudgingInput>
  }

  export type judging_runUpsertWithWhereUniqueWithoutJudgingInput = {
    where: judging_runWhereUniqueInput
    update: XOR<judging_runUpdateWithoutJudgingInput, judging_runUncheckedUpdateWithoutJudgingInput>
    create: XOR<judging_runCreateWithoutJudgingInput, judging_runUncheckedCreateWithoutJudgingInput>
  }

  export type judging_runUpdateWithWhereUniqueWithoutJudgingInput = {
    where: judging_runWhereUniqueInput
    data: XOR<judging_runUpdateWithoutJudgingInput, judging_runUncheckedUpdateWithoutJudgingInput>
  }

  export type judging_runUpdateManyWithWhereWithoutJudgingInput = {
    where: judging_runScalarWhereInput
    data: XOR<judging_runUpdateManyMutationInput, judging_runUncheckedUpdateManyWithoutJudgingInput>
  }

  export type judgetaskCreateWithoutJudging_runInput = {
    type?: $Enums.judgetask_type
    priority: number
    jobid?: number | null
    submitid?: number | null
    compile_script_id?: number | null
    run_script_id?: number | null
    compare_script_id?: number | null
    testcase_id?: number | null
    compile_config?: string | null
    run_config?: string | null
    compare_config?: string | null
    valid?: boolean
    starttime?: Decimal | DecimalJsLike | number | string | null
    uuid?: string | null
    testcase_hash?: string | null
    judgehost?: judgehostCreateNestedOneWithoutJudgetaskInput
  }

  export type judgetaskUncheckedCreateWithoutJudging_runInput = {
    judgetaskid?: number
    judgehostid?: number | null
    type?: $Enums.judgetask_type
    priority: number
    jobid?: number | null
    submitid?: number | null
    compile_script_id?: number | null
    run_script_id?: number | null
    compare_script_id?: number | null
    testcase_id?: number | null
    compile_config?: string | null
    run_config?: string | null
    compare_config?: string | null
    valid?: boolean
    starttime?: Decimal | DecimalJsLike | number | string | null
    uuid?: string | null
    testcase_hash?: string | null
  }

  export type judgetaskCreateOrConnectWithoutJudging_runInput = {
    where: judgetaskWhereUniqueInput
    create: XOR<judgetaskCreateWithoutJudging_runInput, judgetaskUncheckedCreateWithoutJudging_runInput>
  }

  export type testcaseCreateWithoutJudging_runInput = {
    md5sum_input?: string | null
    md5sum_output?: string | null
    ranknumber: number
    description?: Buffer | null
    image_type?: string | null
    sample?: boolean
    orig_input_filename?: string | null
    deleted?: boolean
    external_run?: external_runCreateNestedManyWithoutTestcaseInput
    problem?: problemCreateNestedOneWithoutTestcaseInput
    testcase_content?: testcase_contentCreateNestedManyWithoutTestcaseInput
  }

  export type testcaseUncheckedCreateWithoutJudging_runInput = {
    testcaseid?: number
    md5sum_input?: string | null
    md5sum_output?: string | null
    probid?: number | null
    ranknumber: number
    description?: Buffer | null
    image_type?: string | null
    sample?: boolean
    orig_input_filename?: string | null
    deleted?: boolean
    external_run?: external_runUncheckedCreateNestedManyWithoutTestcaseInput
    testcase_content?: testcase_contentUncheckedCreateNestedManyWithoutTestcaseInput
  }

  export type testcaseCreateOrConnectWithoutJudging_runInput = {
    where: testcaseWhereUniqueInput
    create: XOR<testcaseCreateWithoutJudging_runInput, testcaseUncheckedCreateWithoutJudging_runInput>
  }

  export type judgingCreateWithoutJudging_runInput = {
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    judge_completely?: boolean
    uuid: string
    metadata?: Buffer | null
    debug_package?: debug_packageCreateNestedManyWithoutJudgingInput
    internal_error_internal_error_judgingidTojudging?: internal_errorCreateNestedManyWithoutJudging_internal_error_judgingidTojudgingInput
    internal_error_judging_erroridTointernal_error?: internal_errorCreateNestedOneWithoutJudging_judging_erroridTointernal_errorInput
    contest?: contestCreateNestedOneWithoutJudgingInput
    submission?: submissionCreateNestedOneWithoutJudgingInput
    rejudging?: rejudgingCreateNestedOneWithoutJudgingInput
    judging?: judgingCreateNestedOneWithoutOther_judgingInput
    other_judging?: judgingCreateNestedManyWithoutJudgingInput
  }

  export type judgingUncheckedCreateWithoutJudging_runInput = {
    judgingid?: number
    cid?: number | null
    submitid?: number | null
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    rejudgingid?: number | null
    prevjudgingid?: number | null
    judge_completely?: boolean
    errorid?: number | null
    uuid: string
    metadata?: Buffer | null
    debug_package?: debug_packageUncheckedCreateNestedManyWithoutJudgingInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUncheckedCreateNestedManyWithoutJudging_internal_error_judgingidTojudgingInput
    other_judging?: judgingUncheckedCreateNestedManyWithoutJudgingInput
  }

  export type judgingCreateOrConnectWithoutJudging_runInput = {
    where: judgingWhereUniqueInput
    create: XOR<judgingCreateWithoutJudging_runInput, judgingUncheckedCreateWithoutJudging_runInput>
  }

  export type judging_run_outputCreateWithoutJudging_runInput = {
    output_run?: Buffer | null
    output_diff?: Buffer | null
    output_error?: Buffer | null
    output_system?: Buffer | null
    metadata?: Buffer | null
  }

  export type judging_run_outputUncheckedCreateWithoutJudging_runInput = {
    output_run?: Buffer | null
    output_diff?: Buffer | null
    output_error?: Buffer | null
    output_system?: Buffer | null
    metadata?: Buffer | null
  }

  export type judging_run_outputCreateOrConnectWithoutJudging_runInput = {
    where: judging_run_outputWhereUniqueInput
    create: XOR<judging_run_outputCreateWithoutJudging_runInput, judging_run_outputUncheckedCreateWithoutJudging_runInput>
  }

  export type judgetaskUpsertWithoutJudging_runInput = {
    update: XOR<judgetaskUpdateWithoutJudging_runInput, judgetaskUncheckedUpdateWithoutJudging_runInput>
    create: XOR<judgetaskCreateWithoutJudging_runInput, judgetaskUncheckedCreateWithoutJudging_runInput>
    where?: judgetaskWhereInput
  }

  export type judgetaskUpdateToOneWithWhereWithoutJudging_runInput = {
    where?: judgetaskWhereInput
    data: XOR<judgetaskUpdateWithoutJudging_runInput, judgetaskUncheckedUpdateWithoutJudging_runInput>
  }

  export type judgetaskUpdateWithoutJudging_runInput = {
    type?: Enumjudgetask_typeFieldUpdateOperationsInput | $Enums.judgetask_type
    priority?: IntFieldUpdateOperationsInput | number
    jobid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    compile_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    run_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    compare_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    testcase_id?: NullableIntFieldUpdateOperationsInput | number | null
    compile_config?: NullableStringFieldUpdateOperationsInput | string | null
    run_config?: NullableStringFieldUpdateOperationsInput | string | null
    compare_config?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    testcase_hash?: NullableStringFieldUpdateOperationsInput | string | null
    judgehost?: judgehostUpdateOneWithoutJudgetaskNestedInput
  }

  export type judgetaskUncheckedUpdateWithoutJudging_runInput = {
    judgetaskid?: IntFieldUpdateOperationsInput | number
    judgehostid?: NullableIntFieldUpdateOperationsInput | number | null
    type?: Enumjudgetask_typeFieldUpdateOperationsInput | $Enums.judgetask_type
    priority?: IntFieldUpdateOperationsInput | number
    jobid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    compile_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    run_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    compare_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    testcase_id?: NullableIntFieldUpdateOperationsInput | number | null
    compile_config?: NullableStringFieldUpdateOperationsInput | string | null
    run_config?: NullableStringFieldUpdateOperationsInput | string | null
    compare_config?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    testcase_hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type testcaseUpsertWithoutJudging_runInput = {
    update: XOR<testcaseUpdateWithoutJudging_runInput, testcaseUncheckedUpdateWithoutJudging_runInput>
    create: XOR<testcaseCreateWithoutJudging_runInput, testcaseUncheckedCreateWithoutJudging_runInput>
    where?: testcaseWhereInput
  }

  export type testcaseUpdateToOneWithWhereWithoutJudging_runInput = {
    where?: testcaseWhereInput
    data: XOR<testcaseUpdateWithoutJudging_runInput, testcaseUncheckedUpdateWithoutJudging_runInput>
  }

  export type testcaseUpdateWithoutJudging_runInput = {
    md5sum_input?: NullableStringFieldUpdateOperationsInput | string | null
    md5sum_output?: NullableStringFieldUpdateOperationsInput | string | null
    ranknumber?: IntFieldUpdateOperationsInput | number
    description?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image_type?: NullableStringFieldUpdateOperationsInput | string | null
    sample?: BoolFieldUpdateOperationsInput | boolean
    orig_input_filename?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    external_run?: external_runUpdateManyWithoutTestcaseNestedInput
    problem?: problemUpdateOneWithoutTestcaseNestedInput
    testcase_content?: testcase_contentUpdateManyWithoutTestcaseNestedInput
  }

  export type testcaseUncheckedUpdateWithoutJudging_runInput = {
    testcaseid?: IntFieldUpdateOperationsInput | number
    md5sum_input?: NullableStringFieldUpdateOperationsInput | string | null
    md5sum_output?: NullableStringFieldUpdateOperationsInput | string | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    ranknumber?: IntFieldUpdateOperationsInput | number
    description?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image_type?: NullableStringFieldUpdateOperationsInput | string | null
    sample?: BoolFieldUpdateOperationsInput | boolean
    orig_input_filename?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    external_run?: external_runUncheckedUpdateManyWithoutTestcaseNestedInput
    testcase_content?: testcase_contentUncheckedUpdateManyWithoutTestcaseNestedInput
  }

  export type judgingUpsertWithoutJudging_runInput = {
    update: XOR<judgingUpdateWithoutJudging_runInput, judgingUncheckedUpdateWithoutJudging_runInput>
    create: XOR<judgingCreateWithoutJudging_runInput, judgingUncheckedCreateWithoutJudging_runInput>
    where?: judgingWhereInput
  }

  export type judgingUpdateToOneWithWhereWithoutJudging_runInput = {
    where?: judgingWhereInput
    data: XOR<judgingUpdateWithoutJudging_runInput, judgingUncheckedUpdateWithoutJudging_runInput>
  }

  export type judgingUpdateWithoutJudging_runInput = {
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    debug_package?: debug_packageUpdateManyWithoutJudgingNestedInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUpdateManyWithoutJudging_internal_error_judgingidTojudgingNestedInput
    internal_error_judging_erroridTointernal_error?: internal_errorUpdateOneWithoutJudging_judging_erroridTointernal_errorNestedInput
    contest?: contestUpdateOneWithoutJudgingNestedInput
    submission?: submissionUpdateOneWithoutJudgingNestedInput
    rejudging?: rejudgingUpdateOneWithoutJudgingNestedInput
    judging?: judgingUpdateOneWithoutOther_judgingNestedInput
    other_judging?: judgingUpdateManyWithoutJudgingNestedInput
  }

  export type judgingUncheckedUpdateWithoutJudging_runInput = {
    judgingid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    prevjudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    errorid?: NullableIntFieldUpdateOperationsInput | number | null
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    debug_package?: debug_packageUncheckedUpdateManyWithoutJudgingNestedInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUncheckedUpdateManyWithoutJudging_internal_error_judgingidTojudgingNestedInput
    other_judging?: judgingUncheckedUpdateManyWithoutJudgingNestedInput
  }

  export type judging_run_outputUpsertWithoutJudging_runInput = {
    update: XOR<judging_run_outputUpdateWithoutJudging_runInput, judging_run_outputUncheckedUpdateWithoutJudging_runInput>
    create: XOR<judging_run_outputCreateWithoutJudging_runInput, judging_run_outputUncheckedCreateWithoutJudging_runInput>
    where?: judging_run_outputWhereInput
  }

  export type judging_run_outputUpdateToOneWithWhereWithoutJudging_runInput = {
    where?: judging_run_outputWhereInput
    data: XOR<judging_run_outputUpdateWithoutJudging_runInput, judging_run_outputUncheckedUpdateWithoutJudging_runInput>
  }

  export type judging_run_outputUpdateWithoutJudging_runInput = {
    output_run?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output_diff?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output_error?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output_system?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type judging_run_outputUncheckedUpdateWithoutJudging_runInput = {
    output_run?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output_diff?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output_error?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output_system?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type judging_runCreateWithoutJudging_run_outputInput = {
    runresult?: string | null
    runtime?: number | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    judgetask?: judgetaskCreateNestedOneWithoutJudging_runInput
    testcase?: testcaseCreateNestedOneWithoutJudging_runInput
    judging?: judgingCreateNestedOneWithoutJudging_runInput
  }

  export type judging_runUncheckedCreateWithoutJudging_run_outputInput = {
    runid?: number
    judgingid?: number | null
    testcaseid?: number | null
    runresult?: string | null
    runtime?: number | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    judgetaskid?: number | null
  }

  export type judging_runCreateOrConnectWithoutJudging_run_outputInput = {
    where: judging_runWhereUniqueInput
    create: XOR<judging_runCreateWithoutJudging_run_outputInput, judging_runUncheckedCreateWithoutJudging_run_outputInput>
  }

  export type judging_runUpsertWithoutJudging_run_outputInput = {
    update: XOR<judging_runUpdateWithoutJudging_run_outputInput, judging_runUncheckedUpdateWithoutJudging_run_outputInput>
    create: XOR<judging_runCreateWithoutJudging_run_outputInput, judging_runUncheckedCreateWithoutJudging_run_outputInput>
    where?: judging_runWhereInput
  }

  export type judging_runUpdateToOneWithWhereWithoutJudging_run_outputInput = {
    where?: judging_runWhereInput
    data: XOR<judging_runUpdateWithoutJudging_run_outputInput, judging_runUncheckedUpdateWithoutJudging_run_outputInput>
  }

  export type judging_runUpdateWithoutJudging_run_outputInput = {
    runresult?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableFloatFieldUpdateOperationsInput | number | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    judgetask?: judgetaskUpdateOneWithoutJudging_runNestedInput
    testcase?: testcaseUpdateOneWithoutJudging_runNestedInput
    judging?: judgingUpdateOneWithoutJudging_runNestedInput
  }

  export type judging_runUncheckedUpdateWithoutJudging_run_outputInput = {
    runid?: IntFieldUpdateOperationsInput | number
    judgingid?: NullableIntFieldUpdateOperationsInput | number | null
    testcaseid?: NullableIntFieldUpdateOperationsInput | number | null
    runresult?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableFloatFieldUpdateOperationsInput | number | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    judgetaskid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type executableCreateWithoutLanguageInput = {
    execid: string
    description?: string | null
    type: string
    immutable_executable?: immutable_executableCreateNestedOneWithoutExecutableInput
    problem_problem_special_runToexecutable?: problemCreateNestedManyWithoutExecutable_problem_special_runToexecutableInput
    problem_problem_special_compareToexecutable?: problemCreateNestedManyWithoutExecutable_problem_special_compareToexecutableInput
  }

  export type executableUncheckedCreateWithoutLanguageInput = {
    execid: string
    description?: string | null
    type: string
    immutable_execid?: number | null
    problem_problem_special_runToexecutable?: problemUncheckedCreateNestedManyWithoutExecutable_problem_special_runToexecutableInput
    problem_problem_special_compareToexecutable?: problemUncheckedCreateNestedManyWithoutExecutable_problem_special_compareToexecutableInput
  }

  export type executableCreateOrConnectWithoutLanguageInput = {
    where: executableWhereUniqueInput
    create: XOR<executableCreateWithoutLanguageInput, executableUncheckedCreateWithoutLanguageInput>
  }

  export type submissionCreateWithoutLanguageInput = {
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementCreateNestedManyWithoutSubmissionInput
    judging?: judgingCreateNestedManyWithoutSubmissionInput
    user?: userCreateNestedOneWithoutSubmissionInput
    contest?: contestCreateNestedOneWithoutSubmissionInput
    team?: teamCreateNestedOneWithoutSubmissionInput
    problem?: problemCreateNestedOneWithoutSubmissionInput
    submission?: submissionCreateNestedOneWithoutOther_submissionInput
    other_submission?: submissionCreateNestedManyWithoutSubmissionInput
    rejudging?: rejudgingCreateNestedOneWithoutSubmissionInput
    contestproblem?: contestproblemCreateNestedOneWithoutSubmissionInput
    submission_file?: submission_fileCreateNestedManyWithoutSubmissionInput
  }

  export type submissionUncheckedCreateWithoutLanguageInput = {
    submitid?: number
    origsubmitid?: number | null
    cid?: number | null
    teamid?: number | null
    userid?: number | null
    probid?: number | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonUncheckedCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutSubmissionInput
    judging?: judgingUncheckedCreateNestedManyWithoutSubmissionInput
    other_submission?: submissionUncheckedCreateNestedManyWithoutSubmissionInput
    submission_file?: submission_fileUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type submissionCreateOrConnectWithoutLanguageInput = {
    where: submissionWhereUniqueInput
    create: XOR<submissionCreateWithoutLanguageInput, submissionUncheckedCreateWithoutLanguageInput>
  }

  export type submissionCreateManyLanguageInputEnvelope = {
    data: submissionCreateManyLanguageInput | submissionCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type executableUpsertWithoutLanguageInput = {
    update: XOR<executableUpdateWithoutLanguageInput, executableUncheckedUpdateWithoutLanguageInput>
    create: XOR<executableCreateWithoutLanguageInput, executableUncheckedCreateWithoutLanguageInput>
    where?: executableWhereInput
  }

  export type executableUpdateToOneWithWhereWithoutLanguageInput = {
    where?: executableWhereInput
    data: XOR<executableUpdateWithoutLanguageInput, executableUncheckedUpdateWithoutLanguageInput>
  }

  export type executableUpdateWithoutLanguageInput = {
    execid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    immutable_executable?: immutable_executableUpdateOneWithoutExecutableNestedInput
    problem_problem_special_runToexecutable?: problemUpdateManyWithoutExecutable_problem_special_runToexecutableNestedInput
    problem_problem_special_compareToexecutable?: problemUpdateManyWithoutExecutable_problem_special_compareToexecutableNestedInput
  }

  export type executableUncheckedUpdateWithoutLanguageInput = {
    execid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    immutable_execid?: NullableIntFieldUpdateOperationsInput | number | null
    problem_problem_special_runToexecutable?: problemUncheckedUpdateManyWithoutExecutable_problem_special_runToexecutableNestedInput
    problem_problem_special_compareToexecutable?: problemUncheckedUpdateManyWithoutExecutable_problem_special_compareToexecutableNestedInput
  }

  export type submissionUpsertWithWhereUniqueWithoutLanguageInput = {
    where: submissionWhereUniqueInput
    update: XOR<submissionUpdateWithoutLanguageInput, submissionUncheckedUpdateWithoutLanguageInput>
    create: XOR<submissionCreateWithoutLanguageInput, submissionUncheckedCreateWithoutLanguageInput>
  }

  export type submissionUpdateWithWhereUniqueWithoutLanguageInput = {
    where: submissionWhereUniqueInput
    data: XOR<submissionUpdateWithoutLanguageInput, submissionUncheckedUpdateWithoutLanguageInput>
  }

  export type submissionUpdateManyWithWhereWithoutLanguageInput = {
    where: submissionScalarWhereInput
    data: XOR<submissionUpdateManyMutationInput, submissionUncheckedUpdateManyWithoutLanguageInput>
  }

  export type clarificationCreateWithoutProblemInput = {
    externalid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    jury_member?: string | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
    contest?: contestCreateNestedOneWithoutClarificationInput
    clarification?: clarificationCreateNestedOneWithoutOther_clarificationInput
    other_clarification?: clarificationCreateNestedManyWithoutClarificationInput
    team_clarification_senderToteam?: teamCreateNestedOneWithoutClarification_clarification_senderToteamInput
    team_clarification_recipientToteam?: teamCreateNestedOneWithoutClarification_clarification_recipientToteamInput
    team_unread?: team_unreadCreateNestedManyWithoutClarificationInput
  }

  export type clarificationUncheckedCreateWithoutProblemInput = {
    clarid?: number
    externalid?: string | null
    cid?: number | null
    respid?: number | null
    submittime: Decimal | DecimalJsLike | number | string
    sender?: number | null
    recipient?: number | null
    jury_member?: string | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
    other_clarification?: clarificationUncheckedCreateNestedManyWithoutClarificationInput
    team_unread?: team_unreadUncheckedCreateNestedManyWithoutClarificationInput
  }

  export type clarificationCreateOrConnectWithoutProblemInput = {
    where: clarificationWhereUniqueInput
    create: XOR<clarificationCreateWithoutProblemInput, clarificationUncheckedCreateWithoutProblemInput>
  }

  export type clarificationCreateManyProblemInputEnvelope = {
    data: clarificationCreateManyProblemInput | clarificationCreateManyProblemInput[]
    skipDuplicates?: boolean
  }

  export type contestproblemCreateWithoutProblemInput = {
    shortname: string
    points?: number
    allow_submit?: boolean
    allow_judge?: boolean
    color?: string | null
    lazy_eval_results?: number | null
    contest: contestCreateNestedOneWithoutContestproblemInput
    submission?: submissionCreateNestedManyWithoutContestproblemInput
  }

  export type contestproblemUncheckedCreateWithoutProblemInput = {
    cid: number
    shortname: string
    points?: number
    allow_submit?: boolean
    allow_judge?: boolean
    color?: string | null
    lazy_eval_results?: number | null
    submission?: submissionUncheckedCreateNestedManyWithoutContestproblemInput
  }

  export type contestproblemCreateOrConnectWithoutProblemInput = {
    where: contestproblemWhereUniqueInput
    create: XOR<contestproblemCreateWithoutProblemInput, contestproblemUncheckedCreateWithoutProblemInput>
  }

  export type contestproblemCreateManyProblemInputEnvelope = {
    data: contestproblemCreateManyProblemInput | contestproblemCreateManyProblemInput[]
    skipDuplicates?: boolean
  }

  export type executableCreateWithoutProblem_problem_special_runToexecutableInput = {
    execid: string
    description?: string | null
    type: string
    immutable_executable?: immutable_executableCreateNestedOneWithoutExecutableInput
    language?: languageCreateNestedManyWithoutExecutableInput
    problem_problem_special_compareToexecutable?: problemCreateNestedManyWithoutExecutable_problem_special_compareToexecutableInput
  }

  export type executableUncheckedCreateWithoutProblem_problem_special_runToexecutableInput = {
    execid: string
    description?: string | null
    type: string
    immutable_execid?: number | null
    language?: languageUncheckedCreateNestedManyWithoutExecutableInput
    problem_problem_special_compareToexecutable?: problemUncheckedCreateNestedManyWithoutExecutable_problem_special_compareToexecutableInput
  }

  export type executableCreateOrConnectWithoutProblem_problem_special_runToexecutableInput = {
    where: executableWhereUniqueInput
    create: XOR<executableCreateWithoutProblem_problem_special_runToexecutableInput, executableUncheckedCreateWithoutProblem_problem_special_runToexecutableInput>
  }

  export type executableCreateWithoutProblem_problem_special_compareToexecutableInput = {
    execid: string
    description?: string | null
    type: string
    immutable_executable?: immutable_executableCreateNestedOneWithoutExecutableInput
    language?: languageCreateNestedManyWithoutExecutableInput
    problem_problem_special_runToexecutable?: problemCreateNestedManyWithoutExecutable_problem_special_runToexecutableInput
  }

  export type executableUncheckedCreateWithoutProblem_problem_special_compareToexecutableInput = {
    execid: string
    description?: string | null
    type: string
    immutable_execid?: number | null
    language?: languageUncheckedCreateNestedManyWithoutExecutableInput
    problem_problem_special_runToexecutable?: problemUncheckedCreateNestedManyWithoutExecutable_problem_special_runToexecutableInput
  }

  export type executableCreateOrConnectWithoutProblem_problem_special_compareToexecutableInput = {
    where: executableWhereUniqueInput
    create: XOR<executableCreateWithoutProblem_problem_special_compareToexecutableInput, executableUncheckedCreateWithoutProblem_problem_special_compareToexecutableInput>
  }

  export type problem_attachmentCreateWithoutProblemInput = {
    name: string
    type: string
    problem_attachment_content?: problem_attachment_contentCreateNestedOneWithoutProblem_attachmentInput
  }

  export type problem_attachmentUncheckedCreateWithoutProblemInput = {
    attachmentid?: number
    name: string
    type: string
    problem_attachment_content?: problem_attachment_contentUncheckedCreateNestedOneWithoutProblem_attachmentInput
  }

  export type problem_attachmentCreateOrConnectWithoutProblemInput = {
    where: problem_attachmentWhereUniqueInput
    create: XOR<problem_attachmentCreateWithoutProblemInput, problem_attachmentUncheckedCreateWithoutProblemInput>
  }

  export type problem_attachmentCreateManyProblemInputEnvelope = {
    data: problem_attachmentCreateManyProblemInput | problem_attachmentCreateManyProblemInput[]
    skipDuplicates?: boolean
  }

  export type scorecacheCreateWithoutProblemInput = {
    submissions_restricted?: number
    pending_restricted?: number
    solvetime_restricted?: Decimal | DecimalJsLike | number | string
    is_correct_restricted?: boolean
    submissions_public?: number
    pending_public?: number
    solvetime_public?: Decimal | DecimalJsLike | number | string
    is_correct_public?: boolean
    is_first_to_solve?: boolean
    contest: contestCreateNestedOneWithoutScorecacheInput
    team: teamCreateNestedOneWithoutScorecacheInput
  }

  export type scorecacheUncheckedCreateWithoutProblemInput = {
    cid: number
    teamid: number
    submissions_restricted?: number
    pending_restricted?: number
    solvetime_restricted?: Decimal | DecimalJsLike | number | string
    is_correct_restricted?: boolean
    submissions_public?: number
    pending_public?: number
    solvetime_public?: Decimal | DecimalJsLike | number | string
    is_correct_public?: boolean
    is_first_to_solve?: boolean
  }

  export type scorecacheCreateOrConnectWithoutProblemInput = {
    where: scorecacheWhereUniqueInput
    create: XOR<scorecacheCreateWithoutProblemInput, scorecacheUncheckedCreateWithoutProblemInput>
  }

  export type scorecacheCreateManyProblemInputEnvelope = {
    data: scorecacheCreateManyProblemInput | scorecacheCreateManyProblemInput[]
    skipDuplicates?: boolean
  }

  export type submissionCreateWithoutProblemInput = {
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementCreateNestedManyWithoutSubmissionInput
    judging?: judgingCreateNestedManyWithoutSubmissionInput
    user?: userCreateNestedOneWithoutSubmissionInput
    contest?: contestCreateNestedOneWithoutSubmissionInput
    team?: teamCreateNestedOneWithoutSubmissionInput
    language?: languageCreateNestedOneWithoutSubmissionInput
    submission?: submissionCreateNestedOneWithoutOther_submissionInput
    other_submission?: submissionCreateNestedManyWithoutSubmissionInput
    rejudging?: rejudgingCreateNestedOneWithoutSubmissionInput
    contestproblem?: contestproblemCreateNestedOneWithoutSubmissionInput
    submission_file?: submission_fileCreateNestedManyWithoutSubmissionInput
  }

  export type submissionUncheckedCreateWithoutProblemInput = {
    submitid?: number
    origsubmitid?: number | null
    cid?: number | null
    teamid?: number | null
    userid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonUncheckedCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutSubmissionInput
    judging?: judgingUncheckedCreateNestedManyWithoutSubmissionInput
    other_submission?: submissionUncheckedCreateNestedManyWithoutSubmissionInput
    submission_file?: submission_fileUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type submissionCreateOrConnectWithoutProblemInput = {
    where: submissionWhereUniqueInput
    create: XOR<submissionCreateWithoutProblemInput, submissionUncheckedCreateWithoutProblemInput>
  }

  export type submissionCreateManyProblemInputEnvelope = {
    data: submissionCreateManyProblemInput | submissionCreateManyProblemInput[]
    skipDuplicates?: boolean
  }

  export type testcaseCreateWithoutProblemInput = {
    md5sum_input?: string | null
    md5sum_output?: string | null
    ranknumber: number
    description?: Buffer | null
    image_type?: string | null
    sample?: boolean
    orig_input_filename?: string | null
    deleted?: boolean
    external_run?: external_runCreateNestedManyWithoutTestcaseInput
    judging_run?: judging_runCreateNestedManyWithoutTestcaseInput
    testcase_content?: testcase_contentCreateNestedManyWithoutTestcaseInput
  }

  export type testcaseUncheckedCreateWithoutProblemInput = {
    testcaseid?: number
    md5sum_input?: string | null
    md5sum_output?: string | null
    ranknumber: number
    description?: Buffer | null
    image_type?: string | null
    sample?: boolean
    orig_input_filename?: string | null
    deleted?: boolean
    external_run?: external_runUncheckedCreateNestedManyWithoutTestcaseInput
    judging_run?: judging_runUncheckedCreateNestedManyWithoutTestcaseInput
    testcase_content?: testcase_contentUncheckedCreateNestedManyWithoutTestcaseInput
  }

  export type testcaseCreateOrConnectWithoutProblemInput = {
    where: testcaseWhereUniqueInput
    create: XOR<testcaseCreateWithoutProblemInput, testcaseUncheckedCreateWithoutProblemInput>
  }

  export type testcaseCreateManyProblemInputEnvelope = {
    data: testcaseCreateManyProblemInput | testcaseCreateManyProblemInput[]
    skipDuplicates?: boolean
  }

  export type clarificationUpsertWithWhereUniqueWithoutProblemInput = {
    where: clarificationWhereUniqueInput
    update: XOR<clarificationUpdateWithoutProblemInput, clarificationUncheckedUpdateWithoutProblemInput>
    create: XOR<clarificationCreateWithoutProblemInput, clarificationUncheckedCreateWithoutProblemInput>
  }

  export type clarificationUpdateWithWhereUniqueWithoutProblemInput = {
    where: clarificationWhereUniqueInput
    data: XOR<clarificationUpdateWithoutProblemInput, clarificationUncheckedUpdateWithoutProblemInput>
  }

  export type clarificationUpdateManyWithWhereWithoutProblemInput = {
    where: clarificationScalarWhereInput
    data: XOR<clarificationUpdateManyMutationInput, clarificationUncheckedUpdateManyWithoutProblemInput>
  }

  export type contestproblemUpsertWithWhereUniqueWithoutProblemInput = {
    where: contestproblemWhereUniqueInput
    update: XOR<contestproblemUpdateWithoutProblemInput, contestproblemUncheckedUpdateWithoutProblemInput>
    create: XOR<contestproblemCreateWithoutProblemInput, contestproblemUncheckedCreateWithoutProblemInput>
  }

  export type contestproblemUpdateWithWhereUniqueWithoutProblemInput = {
    where: contestproblemWhereUniqueInput
    data: XOR<contestproblemUpdateWithoutProblemInput, contestproblemUncheckedUpdateWithoutProblemInput>
  }

  export type contestproblemUpdateManyWithWhereWithoutProblemInput = {
    where: contestproblemScalarWhereInput
    data: XOR<contestproblemUpdateManyMutationInput, contestproblemUncheckedUpdateManyWithoutProblemInput>
  }

  export type executableUpsertWithoutProblem_problem_special_runToexecutableInput = {
    update: XOR<executableUpdateWithoutProblem_problem_special_runToexecutableInput, executableUncheckedUpdateWithoutProblem_problem_special_runToexecutableInput>
    create: XOR<executableCreateWithoutProblem_problem_special_runToexecutableInput, executableUncheckedCreateWithoutProblem_problem_special_runToexecutableInput>
    where?: executableWhereInput
  }

  export type executableUpdateToOneWithWhereWithoutProblem_problem_special_runToexecutableInput = {
    where?: executableWhereInput
    data: XOR<executableUpdateWithoutProblem_problem_special_runToexecutableInput, executableUncheckedUpdateWithoutProblem_problem_special_runToexecutableInput>
  }

  export type executableUpdateWithoutProblem_problem_special_runToexecutableInput = {
    execid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    immutable_executable?: immutable_executableUpdateOneWithoutExecutableNestedInput
    language?: languageUpdateManyWithoutExecutableNestedInput
    problem_problem_special_compareToexecutable?: problemUpdateManyWithoutExecutable_problem_special_compareToexecutableNestedInput
  }

  export type executableUncheckedUpdateWithoutProblem_problem_special_runToexecutableInput = {
    execid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    immutable_execid?: NullableIntFieldUpdateOperationsInput | number | null
    language?: languageUncheckedUpdateManyWithoutExecutableNestedInput
    problem_problem_special_compareToexecutable?: problemUncheckedUpdateManyWithoutExecutable_problem_special_compareToexecutableNestedInput
  }

  export type executableUpsertWithoutProblem_problem_special_compareToexecutableInput = {
    update: XOR<executableUpdateWithoutProblem_problem_special_compareToexecutableInput, executableUncheckedUpdateWithoutProblem_problem_special_compareToexecutableInput>
    create: XOR<executableCreateWithoutProblem_problem_special_compareToexecutableInput, executableUncheckedCreateWithoutProblem_problem_special_compareToexecutableInput>
    where?: executableWhereInput
  }

  export type executableUpdateToOneWithWhereWithoutProblem_problem_special_compareToexecutableInput = {
    where?: executableWhereInput
    data: XOR<executableUpdateWithoutProblem_problem_special_compareToexecutableInput, executableUncheckedUpdateWithoutProblem_problem_special_compareToexecutableInput>
  }

  export type executableUpdateWithoutProblem_problem_special_compareToexecutableInput = {
    execid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    immutable_executable?: immutable_executableUpdateOneWithoutExecutableNestedInput
    language?: languageUpdateManyWithoutExecutableNestedInput
    problem_problem_special_runToexecutable?: problemUpdateManyWithoutExecutable_problem_special_runToexecutableNestedInput
  }

  export type executableUncheckedUpdateWithoutProblem_problem_special_compareToexecutableInput = {
    execid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    immutable_execid?: NullableIntFieldUpdateOperationsInput | number | null
    language?: languageUncheckedUpdateManyWithoutExecutableNestedInput
    problem_problem_special_runToexecutable?: problemUncheckedUpdateManyWithoutExecutable_problem_special_runToexecutableNestedInput
  }

  export type problem_attachmentUpsertWithWhereUniqueWithoutProblemInput = {
    where: problem_attachmentWhereUniqueInput
    update: XOR<problem_attachmentUpdateWithoutProblemInput, problem_attachmentUncheckedUpdateWithoutProblemInput>
    create: XOR<problem_attachmentCreateWithoutProblemInput, problem_attachmentUncheckedCreateWithoutProblemInput>
  }

  export type problem_attachmentUpdateWithWhereUniqueWithoutProblemInput = {
    where: problem_attachmentWhereUniqueInput
    data: XOR<problem_attachmentUpdateWithoutProblemInput, problem_attachmentUncheckedUpdateWithoutProblemInput>
  }

  export type problem_attachmentUpdateManyWithWhereWithoutProblemInput = {
    where: problem_attachmentScalarWhereInput
    data: XOR<problem_attachmentUpdateManyMutationInput, problem_attachmentUncheckedUpdateManyWithoutProblemInput>
  }

  export type problem_attachmentScalarWhereInput = {
    AND?: problem_attachmentScalarWhereInput | problem_attachmentScalarWhereInput[]
    OR?: problem_attachmentScalarWhereInput[]
    NOT?: problem_attachmentScalarWhereInput | problem_attachmentScalarWhereInput[]
    attachmentid?: IntFilter<"problem_attachment"> | number
    probid?: IntNullableFilter<"problem_attachment"> | number | null
    name?: StringFilter<"problem_attachment"> | string
    type?: StringFilter<"problem_attachment"> | string
  }

  export type scorecacheUpsertWithWhereUniqueWithoutProblemInput = {
    where: scorecacheWhereUniqueInput
    update: XOR<scorecacheUpdateWithoutProblemInput, scorecacheUncheckedUpdateWithoutProblemInput>
    create: XOR<scorecacheCreateWithoutProblemInput, scorecacheUncheckedCreateWithoutProblemInput>
  }

  export type scorecacheUpdateWithWhereUniqueWithoutProblemInput = {
    where: scorecacheWhereUniqueInput
    data: XOR<scorecacheUpdateWithoutProblemInput, scorecacheUncheckedUpdateWithoutProblemInput>
  }

  export type scorecacheUpdateManyWithWhereWithoutProblemInput = {
    where: scorecacheScalarWhereInput
    data: XOR<scorecacheUpdateManyMutationInput, scorecacheUncheckedUpdateManyWithoutProblemInput>
  }

  export type submissionUpsertWithWhereUniqueWithoutProblemInput = {
    where: submissionWhereUniqueInput
    update: XOR<submissionUpdateWithoutProblemInput, submissionUncheckedUpdateWithoutProblemInput>
    create: XOR<submissionCreateWithoutProblemInput, submissionUncheckedCreateWithoutProblemInput>
  }

  export type submissionUpdateWithWhereUniqueWithoutProblemInput = {
    where: submissionWhereUniqueInput
    data: XOR<submissionUpdateWithoutProblemInput, submissionUncheckedUpdateWithoutProblemInput>
  }

  export type submissionUpdateManyWithWhereWithoutProblemInput = {
    where: submissionScalarWhereInput
    data: XOR<submissionUpdateManyMutationInput, submissionUncheckedUpdateManyWithoutProblemInput>
  }

  export type testcaseUpsertWithWhereUniqueWithoutProblemInput = {
    where: testcaseWhereUniqueInput
    update: XOR<testcaseUpdateWithoutProblemInput, testcaseUncheckedUpdateWithoutProblemInput>
    create: XOR<testcaseCreateWithoutProblemInput, testcaseUncheckedCreateWithoutProblemInput>
  }

  export type testcaseUpdateWithWhereUniqueWithoutProblemInput = {
    where: testcaseWhereUniqueInput
    data: XOR<testcaseUpdateWithoutProblemInput, testcaseUncheckedUpdateWithoutProblemInput>
  }

  export type testcaseUpdateManyWithWhereWithoutProblemInput = {
    where: testcaseScalarWhereInput
    data: XOR<testcaseUpdateManyMutationInput, testcaseUncheckedUpdateManyWithoutProblemInput>
  }

  export type testcaseScalarWhereInput = {
    AND?: testcaseScalarWhereInput | testcaseScalarWhereInput[]
    OR?: testcaseScalarWhereInput[]
    NOT?: testcaseScalarWhereInput | testcaseScalarWhereInput[]
    testcaseid?: IntFilter<"testcase"> | number
    md5sum_input?: StringNullableFilter<"testcase"> | string | null
    md5sum_output?: StringNullableFilter<"testcase"> | string | null
    probid?: IntNullableFilter<"testcase"> | number | null
    ranknumber?: IntFilter<"testcase"> | number
    description?: BytesNullableFilter<"testcase"> | Buffer | null
    image_type?: StringNullableFilter<"testcase"> | string | null
    sample?: BoolFilter<"testcase"> | boolean
    orig_input_filename?: StringNullableFilter<"testcase"> | string | null
    deleted?: BoolFilter<"testcase"> | boolean
  }

  export type problemCreateWithoutProblem_attachmentInput = {
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
    clarification?: clarificationCreateNestedManyWithoutProblemInput
    contestproblem?: contestproblemCreateNestedManyWithoutProblemInput
    executable_problem_special_runToexecutable?: executableCreateNestedOneWithoutProblem_problem_special_runToexecutableInput
    executable_problem_special_compareToexecutable?: executableCreateNestedOneWithoutProblem_problem_special_compareToexecutableInput
    scorecache?: scorecacheCreateNestedManyWithoutProblemInput
    submission?: submissionCreateNestedManyWithoutProblemInput
    testcase?: testcaseCreateNestedManyWithoutProblemInput
  }

  export type problemUncheckedCreateWithoutProblem_attachmentInput = {
    probid?: number
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_run?: string | null
    special_compare?: string | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutProblemInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutProblemInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutProblemInput
    submission?: submissionUncheckedCreateNestedManyWithoutProblemInput
    testcase?: testcaseUncheckedCreateNestedManyWithoutProblemInput
  }

  export type problemCreateOrConnectWithoutProblem_attachmentInput = {
    where: problemWhereUniqueInput
    create: XOR<problemCreateWithoutProblem_attachmentInput, problemUncheckedCreateWithoutProblem_attachmentInput>
  }

  export type problem_attachment_contentCreateWithoutProblem_attachmentInput = {
    content: Buffer
  }

  export type problem_attachment_contentUncheckedCreateWithoutProblem_attachmentInput = {
    content: Buffer
  }

  export type problem_attachment_contentCreateOrConnectWithoutProblem_attachmentInput = {
    where: problem_attachment_contentWhereUniqueInput
    create: XOR<problem_attachment_contentCreateWithoutProblem_attachmentInput, problem_attachment_contentUncheckedCreateWithoutProblem_attachmentInput>
  }

  export type problemUpsertWithoutProblem_attachmentInput = {
    update: XOR<problemUpdateWithoutProblem_attachmentInput, problemUncheckedUpdateWithoutProblem_attachmentInput>
    create: XOR<problemCreateWithoutProblem_attachmentInput, problemUncheckedCreateWithoutProblem_attachmentInput>
    where?: problemWhereInput
  }

  export type problemUpdateToOneWithWhereWithoutProblem_attachmentInput = {
    where?: problemWhereInput
    data: XOR<problemUpdateWithoutProblem_attachmentInput, problemUncheckedUpdateWithoutProblem_attachmentInput>
  }

  export type problemUpdateWithoutProblem_attachmentInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutProblemNestedInput
    contestproblem?: contestproblemUpdateManyWithoutProblemNestedInput
    executable_problem_special_runToexecutable?: executableUpdateOneWithoutProblem_problem_special_runToexecutableNestedInput
    executable_problem_special_compareToexecutable?: executableUpdateOneWithoutProblem_problem_special_compareToexecutableNestedInput
    scorecache?: scorecacheUpdateManyWithoutProblemNestedInput
    submission?: submissionUpdateManyWithoutProblemNestedInput
    testcase?: testcaseUpdateManyWithoutProblemNestedInput
  }

  export type problemUncheckedUpdateWithoutProblem_attachmentInput = {
    probid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_run?: NullableStringFieldUpdateOperationsInput | string | null
    special_compare?: NullableStringFieldUpdateOperationsInput | string | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutProblemNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutProblemNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutProblemNestedInput
    submission?: submissionUncheckedUpdateManyWithoutProblemNestedInput
    testcase?: testcaseUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type problem_attachment_contentUpsertWithoutProblem_attachmentInput = {
    update: XOR<problem_attachment_contentUpdateWithoutProblem_attachmentInput, problem_attachment_contentUncheckedUpdateWithoutProblem_attachmentInput>
    create: XOR<problem_attachment_contentCreateWithoutProblem_attachmentInput, problem_attachment_contentUncheckedCreateWithoutProblem_attachmentInput>
    where?: problem_attachment_contentWhereInput
  }

  export type problem_attachment_contentUpdateToOneWithWhereWithoutProblem_attachmentInput = {
    where?: problem_attachment_contentWhereInput
    data: XOR<problem_attachment_contentUpdateWithoutProblem_attachmentInput, problem_attachment_contentUncheckedUpdateWithoutProblem_attachmentInput>
  }

  export type problem_attachment_contentUpdateWithoutProblem_attachmentInput = {
    content?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type problem_attachment_contentUncheckedUpdateWithoutProblem_attachmentInput = {
    content?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type problem_attachmentCreateWithoutProblem_attachment_contentInput = {
    name: string
    type: string
    problem?: problemCreateNestedOneWithoutProblem_attachmentInput
  }

  export type problem_attachmentUncheckedCreateWithoutProblem_attachment_contentInput = {
    attachmentid?: number
    probid?: number | null
    name: string
    type: string
  }

  export type problem_attachmentCreateOrConnectWithoutProblem_attachment_contentInput = {
    where: problem_attachmentWhereUniqueInput
    create: XOR<problem_attachmentCreateWithoutProblem_attachment_contentInput, problem_attachmentUncheckedCreateWithoutProblem_attachment_contentInput>
  }

  export type problem_attachmentUpsertWithoutProblem_attachment_contentInput = {
    update: XOR<problem_attachmentUpdateWithoutProblem_attachment_contentInput, problem_attachmentUncheckedUpdateWithoutProblem_attachment_contentInput>
    create: XOR<problem_attachmentCreateWithoutProblem_attachment_contentInput, problem_attachmentUncheckedCreateWithoutProblem_attachment_contentInput>
    where?: problem_attachmentWhereInput
  }

  export type problem_attachmentUpdateToOneWithWhereWithoutProblem_attachment_contentInput = {
    where?: problem_attachmentWhereInput
    data: XOR<problem_attachmentUpdateWithoutProblem_attachment_contentInput, problem_attachmentUncheckedUpdateWithoutProblem_attachment_contentInput>
  }

  export type problem_attachmentUpdateWithoutProblem_attachment_contentInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    problem?: problemUpdateOneWithoutProblem_attachmentNestedInput
  }

  export type problem_attachmentUncheckedUpdateWithoutProblem_attachment_contentInput = {
    attachmentid?: IntFieldUpdateOperationsInput | number
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type teamCreateWithoutQueuetaskInput = {
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationCreateNestedManyWithoutTeam_clarification_senderToteamInput
    clarification_clarification_recipientToteam?: clarificationCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    contestteam?: contestteamCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheCreateNestedManyWithoutTeamInput
    submission?: submissionCreateNestedManyWithoutTeamInput
    team_category?: team_categoryCreateNestedOneWithoutTeamInput
    team_affiliation?: team_affiliationCreateNestedOneWithoutTeamInput
    team_unread?: team_unreadCreateNestedManyWithoutTeamInput
    user?: userCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutQueuetaskInput = {
    teamid?: number
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    categoryid?: number | null
    affilid?: number | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_senderToteamInput
    clarification_clarification_recipientToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutTeamInput
    submission?: submissionUncheckedCreateNestedManyWithoutTeamInput
    team_unread?: team_unreadUncheckedCreateNestedManyWithoutTeamInput
    user?: userUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutQueuetaskInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutQueuetaskInput, teamUncheckedCreateWithoutQueuetaskInput>
  }

  export type teamUpsertWithoutQueuetaskInput = {
    update: XOR<teamUpdateWithoutQueuetaskInput, teamUncheckedUpdateWithoutQueuetaskInput>
    create: XOR<teamCreateWithoutQueuetaskInput, teamUncheckedCreateWithoutQueuetaskInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutQueuetaskInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutQueuetaskInput, teamUncheckedUpdateWithoutQueuetaskInput>
  }

  export type teamUpdateWithoutQueuetaskInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    clarification_clarification_recipientToteam?: clarificationUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    contestteam?: contestteamUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUpdateManyWithoutTeamNestedInput
    submission?: submissionUpdateManyWithoutTeamNestedInput
    team_category?: team_categoryUpdateOneWithoutTeamNestedInput
    team_affiliation?: team_affiliationUpdateOneWithoutTeamNestedInput
    team_unread?: team_unreadUpdateManyWithoutTeamNestedInput
    user?: userUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutQueuetaskInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    categoryid?: NullableIntFieldUpdateOperationsInput | number | null
    affilid?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    clarification_clarification_recipientToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutTeamNestedInput
    submission?: submissionUncheckedUpdateManyWithoutTeamNestedInput
    team_unread?: team_unreadUncheckedUpdateManyWithoutTeamNestedInput
    user?: userUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type contestCreateWithoutRankcacheInput = {
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemCreateNestedManyWithoutContestInput
    contestteam?: contestteamCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsCreateNestedManyWithoutContestInput
    event?: eventCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementCreateNestedManyWithoutContestInput
    external_run?: external_runCreateNestedManyWithoutContestInput
    internal_error?: internal_errorCreateNestedManyWithoutContestInput
    judging?: judgingCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalCreateNestedManyWithoutContestInput
    scorecache?: scorecacheCreateNestedManyWithoutContestInput
    submission?: submissionCreateNestedManyWithoutContestInput
  }

  export type contestUncheckedCreateWithoutRankcacheInput = {
    cid?: number
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutContestInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryUncheckedCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedCreateNestedManyWithoutContestInput
    event?: eventUncheckedCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceUncheckedCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutContestInput
    external_run?: external_runUncheckedCreateNestedManyWithoutContestInput
    internal_error?: internal_errorUncheckedCreateNestedManyWithoutContestInput
    judging?: judgingUncheckedCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalUncheckedCreateNestedManyWithoutContestInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutContestInput
    submission?: submissionUncheckedCreateNestedManyWithoutContestInput
  }

  export type contestCreateOrConnectWithoutRankcacheInput = {
    where: contestWhereUniqueInput
    create: XOR<contestCreateWithoutRankcacheInput, contestUncheckedCreateWithoutRankcacheInput>
  }

  export type teamCreateWithoutRankcacheInput = {
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationCreateNestedManyWithoutTeam_clarification_senderToteamInput
    clarification_clarification_recipientToteam?: clarificationCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    contestteam?: contestteamCreateNestedManyWithoutTeamInput
    queuetask?: queuetaskCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheCreateNestedManyWithoutTeamInput
    submission?: submissionCreateNestedManyWithoutTeamInput
    team_category?: team_categoryCreateNestedOneWithoutTeamInput
    team_affiliation?: team_affiliationCreateNestedOneWithoutTeamInput
    team_unread?: team_unreadCreateNestedManyWithoutTeamInput
    user?: userCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutRankcacheInput = {
    teamid?: number
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    categoryid?: number | null
    affilid?: number | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_senderToteamInput
    clarification_clarification_recipientToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutTeamInput
    queuetask?: queuetaskUncheckedCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutTeamInput
    submission?: submissionUncheckedCreateNestedManyWithoutTeamInput
    team_unread?: team_unreadUncheckedCreateNestedManyWithoutTeamInput
    user?: userUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutRankcacheInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutRankcacheInput, teamUncheckedCreateWithoutRankcacheInput>
  }

  export type contestUpsertWithoutRankcacheInput = {
    update: XOR<contestUpdateWithoutRankcacheInput, contestUncheckedUpdateWithoutRankcacheInput>
    create: XOR<contestCreateWithoutRankcacheInput, contestUncheckedCreateWithoutRankcacheInput>
    where?: contestWhereInput
  }

  export type contestUpdateToOneWithWhereWithoutRankcacheInput = {
    where?: contestWhereInput
    data: XOR<contestUpdateWithoutRankcacheInput, contestUncheckedUpdateWithoutRankcacheInput>
  }

  export type contestUpdateWithoutRankcacheInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUpdateManyWithoutContestNestedInput
    event?: eventUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUpdateManyWithoutContestNestedInput
    external_run?: external_runUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUpdateManyWithoutContestNestedInput
    judging?: judgingUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUpdateManyWithoutContestNestedInput
    submission?: submissionUpdateManyWithoutContestNestedInput
  }

  export type contestUncheckedUpdateWithoutRankcacheInput = {
    cid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedUpdateManyWithoutContestNestedInput
    event?: eventUncheckedUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUncheckedUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutContestNestedInput
    external_run?: external_runUncheckedUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUncheckedUpdateManyWithoutContestNestedInput
    judging?: judgingUncheckedUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUncheckedUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutContestNestedInput
    submission?: submissionUncheckedUpdateManyWithoutContestNestedInput
  }

  export type teamUpsertWithoutRankcacheInput = {
    update: XOR<teamUpdateWithoutRankcacheInput, teamUncheckedUpdateWithoutRankcacheInput>
    create: XOR<teamCreateWithoutRankcacheInput, teamUncheckedCreateWithoutRankcacheInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutRankcacheInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutRankcacheInput, teamUncheckedUpdateWithoutRankcacheInput>
  }

  export type teamUpdateWithoutRankcacheInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    clarification_clarification_recipientToteam?: clarificationUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    contestteam?: contestteamUpdateManyWithoutTeamNestedInput
    queuetask?: queuetaskUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUpdateManyWithoutTeamNestedInput
    submission?: submissionUpdateManyWithoutTeamNestedInput
    team_category?: team_categoryUpdateOneWithoutTeamNestedInput
    team_affiliation?: team_affiliationUpdateOneWithoutTeamNestedInput
    team_unread?: team_unreadUpdateManyWithoutTeamNestedInput
    user?: userUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutRankcacheInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    categoryid?: NullableIntFieldUpdateOperationsInput | number | null
    affilid?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    clarification_clarification_recipientToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutTeamNestedInput
    queuetask?: queuetaskUncheckedUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutTeamNestedInput
    submission?: submissionUncheckedUpdateManyWithoutTeamNestedInput
    team_unread?: team_unreadUncheckedUpdateManyWithoutTeamNestedInput
    user?: userUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type judgingCreateWithoutRejudgingInput = {
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    judge_completely?: boolean
    uuid: string
    metadata?: Buffer | null
    debug_package?: debug_packageCreateNestedManyWithoutJudgingInput
    internal_error_internal_error_judgingidTojudging?: internal_errorCreateNestedManyWithoutJudging_internal_error_judgingidTojudgingInput
    internal_error_judging_erroridTointernal_error?: internal_errorCreateNestedOneWithoutJudging_judging_erroridTointernal_errorInput
    contest?: contestCreateNestedOneWithoutJudgingInput
    submission?: submissionCreateNestedOneWithoutJudgingInput
    judging?: judgingCreateNestedOneWithoutOther_judgingInput
    other_judging?: judgingCreateNestedManyWithoutJudgingInput
    judging_run?: judging_runCreateNestedManyWithoutJudgingInput
  }

  export type judgingUncheckedCreateWithoutRejudgingInput = {
    judgingid?: number
    cid?: number | null
    submitid?: number | null
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    prevjudgingid?: number | null
    judge_completely?: boolean
    errorid?: number | null
    uuid: string
    metadata?: Buffer | null
    debug_package?: debug_packageUncheckedCreateNestedManyWithoutJudgingInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUncheckedCreateNestedManyWithoutJudging_internal_error_judgingidTojudgingInput
    other_judging?: judgingUncheckedCreateNestedManyWithoutJudgingInput
    judging_run?: judging_runUncheckedCreateNestedManyWithoutJudgingInput
  }

  export type judgingCreateOrConnectWithoutRejudgingInput = {
    where: judgingWhereUniqueInput
    create: XOR<judgingCreateWithoutRejudgingInput, judgingUncheckedCreateWithoutRejudgingInput>
  }

  export type judgingCreateManyRejudgingInputEnvelope = {
    data: judgingCreateManyRejudgingInput | judgingCreateManyRejudgingInput[]
    skipDuplicates?: boolean
  }

  export type rejudgingCreateWithoutOther_rejudgingInput = {
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    reason: string
    valid?: boolean
    auto_apply?: boolean
    repeat?: number | null
    judging?: judgingCreateNestedManyWithoutRejudgingInput
    rejudging?: rejudgingCreateNestedOneWithoutOther_rejudgingInput
    user_rejudging_userid_startTouser?: userCreateNestedOneWithoutRejudging_rejudging_userid_startTouserInput
    user_rejudging_userid_finishTouser?: userCreateNestedOneWithoutRejudging_rejudging_userid_finishTouserInput
    submission?: submissionCreateNestedManyWithoutRejudgingInput
  }

  export type rejudgingUncheckedCreateWithoutOther_rejudgingInput = {
    rejudgingid?: number
    userid_start?: number | null
    userid_finish?: number | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    reason: string
    valid?: boolean
    auto_apply?: boolean
    repeat?: number | null
    repeat_rejudgingid?: number | null
    judging?: judgingUncheckedCreateNestedManyWithoutRejudgingInput
    submission?: submissionUncheckedCreateNestedManyWithoutRejudgingInput
  }

  export type rejudgingCreateOrConnectWithoutOther_rejudgingInput = {
    where: rejudgingWhereUniqueInput
    create: XOR<rejudgingCreateWithoutOther_rejudgingInput, rejudgingUncheckedCreateWithoutOther_rejudgingInput>
  }

  export type rejudgingCreateWithoutRejudgingInput = {
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    reason: string
    valid?: boolean
    auto_apply?: boolean
    repeat?: number | null
    judging?: judgingCreateNestedManyWithoutRejudgingInput
    other_rejudging?: rejudgingCreateNestedManyWithoutRejudgingInput
    user_rejudging_userid_startTouser?: userCreateNestedOneWithoutRejudging_rejudging_userid_startTouserInput
    user_rejudging_userid_finishTouser?: userCreateNestedOneWithoutRejudging_rejudging_userid_finishTouserInput
    submission?: submissionCreateNestedManyWithoutRejudgingInput
  }

  export type rejudgingUncheckedCreateWithoutRejudgingInput = {
    rejudgingid?: number
    userid_start?: number | null
    userid_finish?: number | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    reason: string
    valid?: boolean
    auto_apply?: boolean
    repeat?: number | null
    judging?: judgingUncheckedCreateNestedManyWithoutRejudgingInput
    other_rejudging?: rejudgingUncheckedCreateNestedManyWithoutRejudgingInput
    submission?: submissionUncheckedCreateNestedManyWithoutRejudgingInput
  }

  export type rejudgingCreateOrConnectWithoutRejudgingInput = {
    where: rejudgingWhereUniqueInput
    create: XOR<rejudgingCreateWithoutRejudgingInput, rejudgingUncheckedCreateWithoutRejudgingInput>
  }

  export type rejudgingCreateManyRejudgingInputEnvelope = {
    data: rejudgingCreateManyRejudgingInput | rejudgingCreateManyRejudgingInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutRejudging_rejudging_userid_startTouserInput = {
    externalid?: string | null
    username: string
    name: string
    email?: string | null
    last_login?: Decimal | DecimalJsLike | number | string | null
    last_api_login?: Decimal | DecimalJsLike | number | string | null
    first_login?: Decimal | DecimalJsLike | number | string | null
    last_ip_address?: string | null
    password?: string | null
    ip_address?: string | null
    enabled?: boolean
    immutable_executable?: immutable_executableCreateNestedManyWithoutUserInput
    rejudging_rejudging_userid_finishTouser?: rejudgingCreateNestedManyWithoutUser_rejudging_userid_finishTouserInput
    submission?: submissionCreateNestedManyWithoutUserInput
    team?: teamCreateNestedOneWithoutUserInput
    userrole?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutRejudging_rejudging_userid_startTouserInput = {
    userid?: number
    externalid?: string | null
    username: string
    name: string
    email?: string | null
    last_login?: Decimal | DecimalJsLike | number | string | null
    last_api_login?: Decimal | DecimalJsLike | number | string | null
    first_login?: Decimal | DecimalJsLike | number | string | null
    last_ip_address?: string | null
    password?: string | null
    ip_address?: string | null
    enabled?: boolean
    teamid?: number | null
    immutable_executable?: immutable_executableUncheckedCreateNestedManyWithoutUserInput
    rejudging_rejudging_userid_finishTouser?: rejudgingUncheckedCreateNestedManyWithoutUser_rejudging_userid_finishTouserInput
    submission?: submissionUncheckedCreateNestedManyWithoutUserInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutRejudging_rejudging_userid_startTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRejudging_rejudging_userid_startTouserInput, userUncheckedCreateWithoutRejudging_rejudging_userid_startTouserInput>
  }

  export type userCreateWithoutRejudging_rejudging_userid_finishTouserInput = {
    externalid?: string | null
    username: string
    name: string
    email?: string | null
    last_login?: Decimal | DecimalJsLike | number | string | null
    last_api_login?: Decimal | DecimalJsLike | number | string | null
    first_login?: Decimal | DecimalJsLike | number | string | null
    last_ip_address?: string | null
    password?: string | null
    ip_address?: string | null
    enabled?: boolean
    immutable_executable?: immutable_executableCreateNestedManyWithoutUserInput
    rejudging_rejudging_userid_startTouser?: rejudgingCreateNestedManyWithoutUser_rejudging_userid_startTouserInput
    submission?: submissionCreateNestedManyWithoutUserInput
    team?: teamCreateNestedOneWithoutUserInput
    userrole?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutRejudging_rejudging_userid_finishTouserInput = {
    userid?: number
    externalid?: string | null
    username: string
    name: string
    email?: string | null
    last_login?: Decimal | DecimalJsLike | number | string | null
    last_api_login?: Decimal | DecimalJsLike | number | string | null
    first_login?: Decimal | DecimalJsLike | number | string | null
    last_ip_address?: string | null
    password?: string | null
    ip_address?: string | null
    enabled?: boolean
    teamid?: number | null
    immutable_executable?: immutable_executableUncheckedCreateNestedManyWithoutUserInput
    rejudging_rejudging_userid_startTouser?: rejudgingUncheckedCreateNestedManyWithoutUser_rejudging_userid_startTouserInput
    submission?: submissionUncheckedCreateNestedManyWithoutUserInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutRejudging_rejudging_userid_finishTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRejudging_rejudging_userid_finishTouserInput, userUncheckedCreateWithoutRejudging_rejudging_userid_finishTouserInput>
  }

  export type submissionCreateWithoutRejudgingInput = {
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementCreateNestedManyWithoutSubmissionInput
    judging?: judgingCreateNestedManyWithoutSubmissionInput
    user?: userCreateNestedOneWithoutSubmissionInput
    contest?: contestCreateNestedOneWithoutSubmissionInput
    team?: teamCreateNestedOneWithoutSubmissionInput
    problem?: problemCreateNestedOneWithoutSubmissionInput
    language?: languageCreateNestedOneWithoutSubmissionInput
    submission?: submissionCreateNestedOneWithoutOther_submissionInput
    other_submission?: submissionCreateNestedManyWithoutSubmissionInput
    contestproblem?: contestproblemCreateNestedOneWithoutSubmissionInput
    submission_file?: submission_fileCreateNestedManyWithoutSubmissionInput
  }

  export type submissionUncheckedCreateWithoutRejudgingInput = {
    submitid?: number
    origsubmitid?: number | null
    cid?: number | null
    teamid?: number | null
    userid?: number | null
    probid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonUncheckedCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutSubmissionInput
    judging?: judgingUncheckedCreateNestedManyWithoutSubmissionInput
    other_submission?: submissionUncheckedCreateNestedManyWithoutSubmissionInput
    submission_file?: submission_fileUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type submissionCreateOrConnectWithoutRejudgingInput = {
    where: submissionWhereUniqueInput
    create: XOR<submissionCreateWithoutRejudgingInput, submissionUncheckedCreateWithoutRejudgingInput>
  }

  export type submissionCreateManyRejudgingInputEnvelope = {
    data: submissionCreateManyRejudgingInput | submissionCreateManyRejudgingInput[]
    skipDuplicates?: boolean
  }

  export type judgingUpsertWithWhereUniqueWithoutRejudgingInput = {
    where: judgingWhereUniqueInput
    update: XOR<judgingUpdateWithoutRejudgingInput, judgingUncheckedUpdateWithoutRejudgingInput>
    create: XOR<judgingCreateWithoutRejudgingInput, judgingUncheckedCreateWithoutRejudgingInput>
  }

  export type judgingUpdateWithWhereUniqueWithoutRejudgingInput = {
    where: judgingWhereUniqueInput
    data: XOR<judgingUpdateWithoutRejudgingInput, judgingUncheckedUpdateWithoutRejudgingInput>
  }

  export type judgingUpdateManyWithWhereWithoutRejudgingInput = {
    where: judgingScalarWhereInput
    data: XOR<judgingUpdateManyMutationInput, judgingUncheckedUpdateManyWithoutRejudgingInput>
  }

  export type rejudgingUpsertWithoutOther_rejudgingInput = {
    update: XOR<rejudgingUpdateWithoutOther_rejudgingInput, rejudgingUncheckedUpdateWithoutOther_rejudgingInput>
    create: XOR<rejudgingCreateWithoutOther_rejudgingInput, rejudgingUncheckedCreateWithoutOther_rejudgingInput>
    where?: rejudgingWhereInput
  }

  export type rejudgingUpdateToOneWithWhereWithoutOther_rejudgingInput = {
    where?: rejudgingWhereInput
    data: XOR<rejudgingUpdateWithoutOther_rejudgingInput, rejudgingUncheckedUpdateWithoutOther_rejudgingInput>
  }

  export type rejudgingUpdateWithoutOther_rejudgingInput = {
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    auto_apply?: BoolFieldUpdateOperationsInput | boolean
    repeat?: NullableIntFieldUpdateOperationsInput | number | null
    judging?: judgingUpdateManyWithoutRejudgingNestedInput
    rejudging?: rejudgingUpdateOneWithoutOther_rejudgingNestedInput
    user_rejudging_userid_startTouser?: userUpdateOneWithoutRejudging_rejudging_userid_startTouserNestedInput
    user_rejudging_userid_finishTouser?: userUpdateOneWithoutRejudging_rejudging_userid_finishTouserNestedInput
    submission?: submissionUpdateManyWithoutRejudgingNestedInput
  }

  export type rejudgingUncheckedUpdateWithoutOther_rejudgingInput = {
    rejudgingid?: IntFieldUpdateOperationsInput | number
    userid_start?: NullableIntFieldUpdateOperationsInput | number | null
    userid_finish?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    auto_apply?: BoolFieldUpdateOperationsInput | boolean
    repeat?: NullableIntFieldUpdateOperationsInput | number | null
    repeat_rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judging?: judgingUncheckedUpdateManyWithoutRejudgingNestedInput
    submission?: submissionUncheckedUpdateManyWithoutRejudgingNestedInput
  }

  export type rejudgingUpsertWithWhereUniqueWithoutRejudgingInput = {
    where: rejudgingWhereUniqueInput
    update: XOR<rejudgingUpdateWithoutRejudgingInput, rejudgingUncheckedUpdateWithoutRejudgingInput>
    create: XOR<rejudgingCreateWithoutRejudgingInput, rejudgingUncheckedCreateWithoutRejudgingInput>
  }

  export type rejudgingUpdateWithWhereUniqueWithoutRejudgingInput = {
    where: rejudgingWhereUniqueInput
    data: XOR<rejudgingUpdateWithoutRejudgingInput, rejudgingUncheckedUpdateWithoutRejudgingInput>
  }

  export type rejudgingUpdateManyWithWhereWithoutRejudgingInput = {
    where: rejudgingScalarWhereInput
    data: XOR<rejudgingUpdateManyMutationInput, rejudgingUncheckedUpdateManyWithoutRejudgingInput>
  }

  export type rejudgingScalarWhereInput = {
    AND?: rejudgingScalarWhereInput | rejudgingScalarWhereInput[]
    OR?: rejudgingScalarWhereInput[]
    NOT?: rejudgingScalarWhereInput | rejudgingScalarWhereInput[]
    rejudgingid?: IntFilter<"rejudging"> | number
    userid_start?: IntNullableFilter<"rejudging"> | number | null
    userid_finish?: IntNullableFilter<"rejudging"> | number | null
    starttime?: DecimalFilter<"rejudging"> | Decimal | DecimalJsLike | number | string
    endtime?: DecimalNullableFilter<"rejudging"> | Decimal | DecimalJsLike | number | string | null
    reason?: StringFilter<"rejudging"> | string
    valid?: BoolFilter<"rejudging"> | boolean
    auto_apply?: BoolFilter<"rejudging"> | boolean
    repeat?: IntNullableFilter<"rejudging"> | number | null
    repeat_rejudgingid?: IntNullableFilter<"rejudging"> | number | null
  }

  export type userUpsertWithoutRejudging_rejudging_userid_startTouserInput = {
    update: XOR<userUpdateWithoutRejudging_rejudging_userid_startTouserInput, userUncheckedUpdateWithoutRejudging_rejudging_userid_startTouserInput>
    create: XOR<userCreateWithoutRejudging_rejudging_userid_startTouserInput, userUncheckedCreateWithoutRejudging_rejudging_userid_startTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutRejudging_rejudging_userid_startTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutRejudging_rejudging_userid_startTouserInput, userUncheckedUpdateWithoutRejudging_rejudging_userid_startTouserInput>
  }

  export type userUpdateWithoutRejudging_rejudging_userid_startTouserInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_api_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    immutable_executable?: immutable_executableUpdateManyWithoutUserNestedInput
    rejudging_rejudging_userid_finishTouser?: rejudgingUpdateManyWithoutUser_rejudging_userid_finishTouserNestedInput
    submission?: submissionUpdateManyWithoutUserNestedInput
    team?: teamUpdateOneWithoutUserNestedInput
    userrole?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutRejudging_rejudging_userid_startTouserInput = {
    userid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_api_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    immutable_executable?: immutable_executableUncheckedUpdateManyWithoutUserNestedInput
    rejudging_rejudging_userid_finishTouser?: rejudgingUncheckedUpdateManyWithoutUser_rejudging_userid_finishTouserNestedInput
    submission?: submissionUncheckedUpdateManyWithoutUserNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithoutRejudging_rejudging_userid_finishTouserInput = {
    update: XOR<userUpdateWithoutRejudging_rejudging_userid_finishTouserInput, userUncheckedUpdateWithoutRejudging_rejudging_userid_finishTouserInput>
    create: XOR<userCreateWithoutRejudging_rejudging_userid_finishTouserInput, userUncheckedCreateWithoutRejudging_rejudging_userid_finishTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutRejudging_rejudging_userid_finishTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutRejudging_rejudging_userid_finishTouserInput, userUncheckedUpdateWithoutRejudging_rejudging_userid_finishTouserInput>
  }

  export type userUpdateWithoutRejudging_rejudging_userid_finishTouserInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_api_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    immutable_executable?: immutable_executableUpdateManyWithoutUserNestedInput
    rejudging_rejudging_userid_startTouser?: rejudgingUpdateManyWithoutUser_rejudging_userid_startTouserNestedInput
    submission?: submissionUpdateManyWithoutUserNestedInput
    team?: teamUpdateOneWithoutUserNestedInput
    userrole?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutRejudging_rejudging_userid_finishTouserInput = {
    userid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_api_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    immutable_executable?: immutable_executableUncheckedUpdateManyWithoutUserNestedInput
    rejudging_rejudging_userid_startTouser?: rejudgingUncheckedUpdateManyWithoutUser_rejudging_userid_startTouserNestedInput
    submission?: submissionUncheckedUpdateManyWithoutUserNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type submissionUpsertWithWhereUniqueWithoutRejudgingInput = {
    where: submissionWhereUniqueInput
    update: XOR<submissionUpdateWithoutRejudgingInput, submissionUncheckedUpdateWithoutRejudgingInput>
    create: XOR<submissionCreateWithoutRejudgingInput, submissionUncheckedCreateWithoutRejudgingInput>
  }

  export type submissionUpdateWithWhereUniqueWithoutRejudgingInput = {
    where: submissionWhereUniqueInput
    data: XOR<submissionUpdateWithoutRejudgingInput, submissionUncheckedUpdateWithoutRejudgingInput>
  }

  export type submissionUpdateManyWithWhereWithoutRejudgingInput = {
    where: submissionScalarWhereInput
    data: XOR<submissionUpdateManyMutationInput, submissionUncheckedUpdateManyWithoutRejudgingInput>
  }

  export type contestCreateWithoutRemoved_intervalInput = {
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemCreateNestedManyWithoutContestInput
    contestteam?: contestteamCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsCreateNestedManyWithoutContestInput
    event?: eventCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementCreateNestedManyWithoutContestInput
    external_run?: external_runCreateNestedManyWithoutContestInput
    internal_error?: internal_errorCreateNestedManyWithoutContestInput
    judging?: judgingCreateNestedManyWithoutContestInput
    rankcache?: rankcacheCreateNestedManyWithoutContestInput
    scorecache?: scorecacheCreateNestedManyWithoutContestInput
    submission?: submissionCreateNestedManyWithoutContestInput
  }

  export type contestUncheckedCreateWithoutRemoved_intervalInput = {
    cid?: number
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutContestInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryUncheckedCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedCreateNestedManyWithoutContestInput
    event?: eventUncheckedCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceUncheckedCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutContestInput
    external_run?: external_runUncheckedCreateNestedManyWithoutContestInput
    internal_error?: internal_errorUncheckedCreateNestedManyWithoutContestInput
    judging?: judgingUncheckedCreateNestedManyWithoutContestInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutContestInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutContestInput
    submission?: submissionUncheckedCreateNestedManyWithoutContestInput
  }

  export type contestCreateOrConnectWithoutRemoved_intervalInput = {
    where: contestWhereUniqueInput
    create: XOR<contestCreateWithoutRemoved_intervalInput, contestUncheckedCreateWithoutRemoved_intervalInput>
  }

  export type contestUpsertWithoutRemoved_intervalInput = {
    update: XOR<contestUpdateWithoutRemoved_intervalInput, contestUncheckedUpdateWithoutRemoved_intervalInput>
    create: XOR<contestCreateWithoutRemoved_intervalInput, contestUncheckedCreateWithoutRemoved_intervalInput>
    where?: contestWhereInput
  }

  export type contestUpdateToOneWithWhereWithoutRemoved_intervalInput = {
    where?: contestWhereInput
    data: XOR<contestUpdateWithoutRemoved_intervalInput, contestUncheckedUpdateWithoutRemoved_intervalInput>
  }

  export type contestUpdateWithoutRemoved_intervalInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUpdateManyWithoutContestNestedInput
    event?: eventUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUpdateManyWithoutContestNestedInput
    external_run?: external_runUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUpdateManyWithoutContestNestedInput
    judging?: judgingUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUpdateManyWithoutContestNestedInput
    submission?: submissionUpdateManyWithoutContestNestedInput
  }

  export type contestUncheckedUpdateWithoutRemoved_intervalInput = {
    cid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedUpdateManyWithoutContestNestedInput
    event?: eventUncheckedUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUncheckedUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutContestNestedInput
    external_run?: external_runUncheckedUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUncheckedUpdateManyWithoutContestNestedInput
    judging?: judgingUncheckedUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutContestNestedInput
    submission?: submissionUncheckedUpdateManyWithoutContestNestedInput
  }

  export type userroleCreateWithoutRoleInput = {
    user: userCreateNestedOneWithoutUserroleInput
  }

  export type userroleUncheckedCreateWithoutRoleInput = {
    userid: number
  }

  export type userroleCreateOrConnectWithoutRoleInput = {
    where: userroleWhereUniqueInput
    create: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput>
  }

  export type userroleCreateManyRoleInputEnvelope = {
    data: userroleCreateManyRoleInput | userroleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type userroleUpsertWithWhereUniqueWithoutRoleInput = {
    where: userroleWhereUniqueInput
    update: XOR<userroleUpdateWithoutRoleInput, userroleUncheckedUpdateWithoutRoleInput>
    create: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput>
  }

  export type userroleUpdateWithWhereUniqueWithoutRoleInput = {
    where: userroleWhereUniqueInput
    data: XOR<userroleUpdateWithoutRoleInput, userroleUncheckedUpdateWithoutRoleInput>
  }

  export type userroleUpdateManyWithWhereWithoutRoleInput = {
    where: userroleScalarWhereInput
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyWithoutRoleInput>
  }

  export type userroleScalarWhereInput = {
    AND?: userroleScalarWhereInput | userroleScalarWhereInput[]
    OR?: userroleScalarWhereInput[]
    NOT?: userroleScalarWhereInput | userroleScalarWhereInput[]
    userid?: IntFilter<"userrole"> | number
    roleid?: IntFilter<"userrole"> | number
  }

  export type contestCreateWithoutScorecacheInput = {
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemCreateNestedManyWithoutContestInput
    contestteam?: contestteamCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsCreateNestedManyWithoutContestInput
    event?: eventCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementCreateNestedManyWithoutContestInput
    external_run?: external_runCreateNestedManyWithoutContestInput
    internal_error?: internal_errorCreateNestedManyWithoutContestInput
    judging?: judgingCreateNestedManyWithoutContestInput
    rankcache?: rankcacheCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalCreateNestedManyWithoutContestInput
    submission?: submissionCreateNestedManyWithoutContestInput
  }

  export type contestUncheckedCreateWithoutScorecacheInput = {
    cid?: number
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutContestInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryUncheckedCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedCreateNestedManyWithoutContestInput
    event?: eventUncheckedCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceUncheckedCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutContestInput
    external_run?: external_runUncheckedCreateNestedManyWithoutContestInput
    internal_error?: internal_errorUncheckedCreateNestedManyWithoutContestInput
    judging?: judgingUncheckedCreateNestedManyWithoutContestInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalUncheckedCreateNestedManyWithoutContestInput
    submission?: submissionUncheckedCreateNestedManyWithoutContestInput
  }

  export type contestCreateOrConnectWithoutScorecacheInput = {
    where: contestWhereUniqueInput
    create: XOR<contestCreateWithoutScorecacheInput, contestUncheckedCreateWithoutScorecacheInput>
  }

  export type teamCreateWithoutScorecacheInput = {
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationCreateNestedManyWithoutTeam_clarification_senderToteamInput
    clarification_clarification_recipientToteam?: clarificationCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    contestteam?: contestteamCreateNestedManyWithoutTeamInput
    queuetask?: queuetaskCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheCreateNestedManyWithoutTeamInput
    submission?: submissionCreateNestedManyWithoutTeamInput
    team_category?: team_categoryCreateNestedOneWithoutTeamInput
    team_affiliation?: team_affiliationCreateNestedOneWithoutTeamInput
    team_unread?: team_unreadCreateNestedManyWithoutTeamInput
    user?: userCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutScorecacheInput = {
    teamid?: number
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    categoryid?: number | null
    affilid?: number | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_senderToteamInput
    clarification_clarification_recipientToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutTeamInput
    queuetask?: queuetaskUncheckedCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutTeamInput
    submission?: submissionUncheckedCreateNestedManyWithoutTeamInput
    team_unread?: team_unreadUncheckedCreateNestedManyWithoutTeamInput
    user?: userUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutScorecacheInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutScorecacheInput, teamUncheckedCreateWithoutScorecacheInput>
  }

  export type problemCreateWithoutScorecacheInput = {
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
    clarification?: clarificationCreateNestedManyWithoutProblemInput
    contestproblem?: contestproblemCreateNestedManyWithoutProblemInput
    executable_problem_special_runToexecutable?: executableCreateNestedOneWithoutProblem_problem_special_runToexecutableInput
    executable_problem_special_compareToexecutable?: executableCreateNestedOneWithoutProblem_problem_special_compareToexecutableInput
    problem_attachment?: problem_attachmentCreateNestedManyWithoutProblemInput
    submission?: submissionCreateNestedManyWithoutProblemInput
    testcase?: testcaseCreateNestedManyWithoutProblemInput
  }

  export type problemUncheckedCreateWithoutScorecacheInput = {
    probid?: number
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_run?: string | null
    special_compare?: string | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutProblemInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutProblemInput
    problem_attachment?: problem_attachmentUncheckedCreateNestedManyWithoutProblemInput
    submission?: submissionUncheckedCreateNestedManyWithoutProblemInput
    testcase?: testcaseUncheckedCreateNestedManyWithoutProblemInput
  }

  export type problemCreateOrConnectWithoutScorecacheInput = {
    where: problemWhereUniqueInput
    create: XOR<problemCreateWithoutScorecacheInput, problemUncheckedCreateWithoutScorecacheInput>
  }

  export type contestUpsertWithoutScorecacheInput = {
    update: XOR<contestUpdateWithoutScorecacheInput, contestUncheckedUpdateWithoutScorecacheInput>
    create: XOR<contestCreateWithoutScorecacheInput, contestUncheckedCreateWithoutScorecacheInput>
    where?: contestWhereInput
  }

  export type contestUpdateToOneWithWhereWithoutScorecacheInput = {
    where?: contestWhereInput
    data: XOR<contestUpdateWithoutScorecacheInput, contestUncheckedUpdateWithoutScorecacheInput>
  }

  export type contestUpdateWithoutScorecacheInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUpdateManyWithoutContestNestedInput
    event?: eventUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUpdateManyWithoutContestNestedInput
    external_run?: external_runUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUpdateManyWithoutContestNestedInput
    judging?: judgingUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUpdateManyWithoutContestNestedInput
    submission?: submissionUpdateManyWithoutContestNestedInput
  }

  export type contestUncheckedUpdateWithoutScorecacheInput = {
    cid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedUpdateManyWithoutContestNestedInput
    event?: eventUncheckedUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUncheckedUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutContestNestedInput
    external_run?: external_runUncheckedUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUncheckedUpdateManyWithoutContestNestedInput
    judging?: judgingUncheckedUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUncheckedUpdateManyWithoutContestNestedInput
    submission?: submissionUncheckedUpdateManyWithoutContestNestedInput
  }

  export type teamUpsertWithoutScorecacheInput = {
    update: XOR<teamUpdateWithoutScorecacheInput, teamUncheckedUpdateWithoutScorecacheInput>
    create: XOR<teamCreateWithoutScorecacheInput, teamUncheckedCreateWithoutScorecacheInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutScorecacheInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutScorecacheInput, teamUncheckedUpdateWithoutScorecacheInput>
  }

  export type teamUpdateWithoutScorecacheInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    clarification_clarification_recipientToteam?: clarificationUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    contestteam?: contestteamUpdateManyWithoutTeamNestedInput
    queuetask?: queuetaskUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUpdateManyWithoutTeamNestedInput
    submission?: submissionUpdateManyWithoutTeamNestedInput
    team_category?: team_categoryUpdateOneWithoutTeamNestedInput
    team_affiliation?: team_affiliationUpdateOneWithoutTeamNestedInput
    team_unread?: team_unreadUpdateManyWithoutTeamNestedInput
    user?: userUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutScorecacheInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    categoryid?: NullableIntFieldUpdateOperationsInput | number | null
    affilid?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    clarification_clarification_recipientToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutTeamNestedInput
    queuetask?: queuetaskUncheckedUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutTeamNestedInput
    submission?: submissionUncheckedUpdateManyWithoutTeamNestedInput
    team_unread?: team_unreadUncheckedUpdateManyWithoutTeamNestedInput
    user?: userUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type problemUpsertWithoutScorecacheInput = {
    update: XOR<problemUpdateWithoutScorecacheInput, problemUncheckedUpdateWithoutScorecacheInput>
    create: XOR<problemCreateWithoutScorecacheInput, problemUncheckedCreateWithoutScorecacheInput>
    where?: problemWhereInput
  }

  export type problemUpdateToOneWithWhereWithoutScorecacheInput = {
    where?: problemWhereInput
    data: XOR<problemUpdateWithoutScorecacheInput, problemUncheckedUpdateWithoutScorecacheInput>
  }

  export type problemUpdateWithoutScorecacheInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutProblemNestedInput
    contestproblem?: contestproblemUpdateManyWithoutProblemNestedInput
    executable_problem_special_runToexecutable?: executableUpdateOneWithoutProblem_problem_special_runToexecutableNestedInput
    executable_problem_special_compareToexecutable?: executableUpdateOneWithoutProblem_problem_special_compareToexecutableNestedInput
    problem_attachment?: problem_attachmentUpdateManyWithoutProblemNestedInput
    submission?: submissionUpdateManyWithoutProblemNestedInput
    testcase?: testcaseUpdateManyWithoutProblemNestedInput
  }

  export type problemUncheckedUpdateWithoutScorecacheInput = {
    probid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_run?: NullableStringFieldUpdateOperationsInput | string | null
    special_compare?: NullableStringFieldUpdateOperationsInput | string | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutProblemNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutProblemNestedInput
    problem_attachment?: problem_attachmentUncheckedUpdateManyWithoutProblemNestedInput
    submission?: submissionUncheckedUpdateManyWithoutProblemNestedInput
    testcase?: testcaseUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type balloonCreateWithoutSubmissionInput = {
    done?: boolean
  }

  export type balloonUncheckedCreateWithoutSubmissionInput = {
    balloonid?: number
    done?: boolean
  }

  export type balloonCreateOrConnectWithoutSubmissionInput = {
    where: balloonWhereUniqueInput
    create: XOR<balloonCreateWithoutSubmissionInput, balloonUncheckedCreateWithoutSubmissionInput>
  }

  export type balloonCreateManySubmissionInputEnvelope = {
    data: balloonCreateManySubmissionInput | balloonCreateManySubmissionInput[]
    skipDuplicates?: boolean
  }

  export type external_judgementCreateWithoutSubmissionInput = {
    externalid?: string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    valid?: boolean
    contest?: contestCreateNestedOneWithoutExternal_judgementInput
    external_run?: external_runCreateNestedManyWithoutExternal_judgementInput
  }

  export type external_judgementUncheckedCreateWithoutSubmissionInput = {
    extjudgementid?: number
    externalid?: string | null
    cid?: number | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    valid?: boolean
    external_run?: external_runUncheckedCreateNestedManyWithoutExternal_judgementInput
  }

  export type external_judgementCreateOrConnectWithoutSubmissionInput = {
    where: external_judgementWhereUniqueInput
    create: XOR<external_judgementCreateWithoutSubmissionInput, external_judgementUncheckedCreateWithoutSubmissionInput>
  }

  export type external_judgementCreateManySubmissionInputEnvelope = {
    data: external_judgementCreateManySubmissionInput | external_judgementCreateManySubmissionInput[]
    skipDuplicates?: boolean
  }

  export type judgingCreateWithoutSubmissionInput = {
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    judge_completely?: boolean
    uuid: string
    metadata?: Buffer | null
    debug_package?: debug_packageCreateNestedManyWithoutJudgingInput
    internal_error_internal_error_judgingidTojudging?: internal_errorCreateNestedManyWithoutJudging_internal_error_judgingidTojudgingInput
    internal_error_judging_erroridTointernal_error?: internal_errorCreateNestedOneWithoutJudging_judging_erroridTointernal_errorInput
    contest?: contestCreateNestedOneWithoutJudgingInput
    rejudging?: rejudgingCreateNestedOneWithoutJudgingInput
    judging?: judgingCreateNestedOneWithoutOther_judgingInput
    other_judging?: judgingCreateNestedManyWithoutJudgingInput
    judging_run?: judging_runCreateNestedManyWithoutJudgingInput
  }

  export type judgingUncheckedCreateWithoutSubmissionInput = {
    judgingid?: number
    cid?: number | null
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    rejudgingid?: number | null
    prevjudgingid?: number | null
    judge_completely?: boolean
    errorid?: number | null
    uuid: string
    metadata?: Buffer | null
    debug_package?: debug_packageUncheckedCreateNestedManyWithoutJudgingInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUncheckedCreateNestedManyWithoutJudging_internal_error_judgingidTojudgingInput
    other_judging?: judgingUncheckedCreateNestedManyWithoutJudgingInput
    judging_run?: judging_runUncheckedCreateNestedManyWithoutJudgingInput
  }

  export type judgingCreateOrConnectWithoutSubmissionInput = {
    where: judgingWhereUniqueInput
    create: XOR<judgingCreateWithoutSubmissionInput, judgingUncheckedCreateWithoutSubmissionInput>
  }

  export type judgingCreateManySubmissionInputEnvelope = {
    data: judgingCreateManySubmissionInput | judgingCreateManySubmissionInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutSubmissionInput = {
    externalid?: string | null
    username: string
    name: string
    email?: string | null
    last_login?: Decimal | DecimalJsLike | number | string | null
    last_api_login?: Decimal | DecimalJsLike | number | string | null
    first_login?: Decimal | DecimalJsLike | number | string | null
    last_ip_address?: string | null
    password?: string | null
    ip_address?: string | null
    enabled?: boolean
    immutable_executable?: immutable_executableCreateNestedManyWithoutUserInput
    rejudging_rejudging_userid_startTouser?: rejudgingCreateNestedManyWithoutUser_rejudging_userid_startTouserInput
    rejudging_rejudging_userid_finishTouser?: rejudgingCreateNestedManyWithoutUser_rejudging_userid_finishTouserInput
    team?: teamCreateNestedOneWithoutUserInput
    userrole?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutSubmissionInput = {
    userid?: number
    externalid?: string | null
    username: string
    name: string
    email?: string | null
    last_login?: Decimal | DecimalJsLike | number | string | null
    last_api_login?: Decimal | DecimalJsLike | number | string | null
    first_login?: Decimal | DecimalJsLike | number | string | null
    last_ip_address?: string | null
    password?: string | null
    ip_address?: string | null
    enabled?: boolean
    teamid?: number | null
    immutable_executable?: immutable_executableUncheckedCreateNestedManyWithoutUserInput
    rejudging_rejudging_userid_startTouser?: rejudgingUncheckedCreateNestedManyWithoutUser_rejudging_userid_startTouserInput
    rejudging_rejudging_userid_finishTouser?: rejudgingUncheckedCreateNestedManyWithoutUser_rejudging_userid_finishTouserInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutSubmissionInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutSubmissionInput, userUncheckedCreateWithoutSubmissionInput>
  }

  export type contestCreateWithoutSubmissionInput = {
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemCreateNestedManyWithoutContestInput
    contestteam?: contestteamCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsCreateNestedManyWithoutContestInput
    event?: eventCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementCreateNestedManyWithoutContestInput
    external_run?: external_runCreateNestedManyWithoutContestInput
    internal_error?: internal_errorCreateNestedManyWithoutContestInput
    judging?: judgingCreateNestedManyWithoutContestInput
    rankcache?: rankcacheCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalCreateNestedManyWithoutContestInput
    scorecache?: scorecacheCreateNestedManyWithoutContestInput
  }

  export type contestUncheckedCreateWithoutSubmissionInput = {
    cid?: number
    externalid?: string | null
    name: string
    shortname: string
    activatetime: Decimal | DecimalJsLike | number | string
    starttime: Decimal | DecimalJsLike | number | string
    freezetime?: Decimal | DecimalJsLike | number | string | null
    endtime: Decimal | DecimalJsLike | number | string
    unfreezetime?: Decimal | DecimalJsLike | number | string | null
    deactivatetime?: Decimal | DecimalJsLike | number | string | null
    activatetime_string: string
    starttime_string: string
    freezetime_string?: string | null
    endtime_string: string
    unfreezetime_string?: string | null
    deactivatetime_string?: string | null
    finalizetime?: Decimal | DecimalJsLike | number | string | null
    finalizecomment?: string | null
    b?: number
    enabled?: boolean
    starttime_enabled?: boolean
    process_balloons?: boolean
    public?: boolean
    open_to_all_teams?: boolean
    medals_enabled?: boolean
    gold_medals?: number
    silver_medals?: number
    bronze_medals?: number
    is_locked?: boolean
    allow_submit?: boolean
    warning_message?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutContestInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutContestInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutContestInput
    contestteamcategory?: contestteamcategoryUncheckedCreateNestedManyWithoutContestInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedCreateNestedManyWithoutContestInput
    event?: eventUncheckedCreateNestedManyWithoutContestInput
    external_contest_source?: external_contest_sourceUncheckedCreateNestedOneWithoutContestInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutContestInput
    external_run?: external_runUncheckedCreateNestedManyWithoutContestInput
    internal_error?: internal_errorUncheckedCreateNestedManyWithoutContestInput
    judging?: judgingUncheckedCreateNestedManyWithoutContestInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutContestInput
    removed_interval?: removed_intervalUncheckedCreateNestedManyWithoutContestInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutContestInput
  }

  export type contestCreateOrConnectWithoutSubmissionInput = {
    where: contestWhereUniqueInput
    create: XOR<contestCreateWithoutSubmissionInput, contestUncheckedCreateWithoutSubmissionInput>
  }

  export type teamCreateWithoutSubmissionInput = {
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationCreateNestedManyWithoutTeam_clarification_senderToteamInput
    clarification_clarification_recipientToteam?: clarificationCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    contestteam?: contestteamCreateNestedManyWithoutTeamInput
    queuetask?: queuetaskCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheCreateNestedManyWithoutTeamInput
    team_category?: team_categoryCreateNestedOneWithoutTeamInput
    team_affiliation?: team_affiliationCreateNestedOneWithoutTeamInput
    team_unread?: team_unreadCreateNestedManyWithoutTeamInput
    user?: userCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutSubmissionInput = {
    teamid?: number
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    categoryid?: number | null
    affilid?: number | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_senderToteamInput
    clarification_clarification_recipientToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutTeamInput
    queuetask?: queuetaskUncheckedCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutTeamInput
    team_unread?: team_unreadUncheckedCreateNestedManyWithoutTeamInput
    user?: userUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutSubmissionInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutSubmissionInput, teamUncheckedCreateWithoutSubmissionInput>
  }

  export type problemCreateWithoutSubmissionInput = {
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
    clarification?: clarificationCreateNestedManyWithoutProblemInput
    contestproblem?: contestproblemCreateNestedManyWithoutProblemInput
    executable_problem_special_runToexecutable?: executableCreateNestedOneWithoutProblem_problem_special_runToexecutableInput
    executable_problem_special_compareToexecutable?: executableCreateNestedOneWithoutProblem_problem_special_compareToexecutableInput
    problem_attachment?: problem_attachmentCreateNestedManyWithoutProblemInput
    scorecache?: scorecacheCreateNestedManyWithoutProblemInput
    testcase?: testcaseCreateNestedManyWithoutProblemInput
  }

  export type problemUncheckedCreateWithoutSubmissionInput = {
    probid?: number
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_run?: string | null
    special_compare?: string | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutProblemInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutProblemInput
    problem_attachment?: problem_attachmentUncheckedCreateNestedManyWithoutProblemInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutProblemInput
    testcase?: testcaseUncheckedCreateNestedManyWithoutProblemInput
  }

  export type problemCreateOrConnectWithoutSubmissionInput = {
    where: problemWhereUniqueInput
    create: XOR<problemCreateWithoutSubmissionInput, problemUncheckedCreateWithoutSubmissionInput>
  }

  export type languageCreateWithoutSubmissionInput = {
    langid: string
    externalid?: string | null
    name: string
    extensions?: string | null
    require_entry_point?: boolean
    entry_point_description?: string | null
    allow_submit?: boolean
    allow_judge?: boolean
    time_factor?: number
    filter_compiler_files?: boolean
    executable?: executableCreateNestedOneWithoutLanguageInput
  }

  export type languageUncheckedCreateWithoutSubmissionInput = {
    langid: string
    externalid?: string | null
    name: string
    extensions?: string | null
    require_entry_point?: boolean
    entry_point_description?: string | null
    allow_submit?: boolean
    allow_judge?: boolean
    time_factor?: number
    compile_script?: string | null
    filter_compiler_files?: boolean
  }

  export type languageCreateOrConnectWithoutSubmissionInput = {
    where: languageWhereUniqueInput
    create: XOR<languageCreateWithoutSubmissionInput, languageUncheckedCreateWithoutSubmissionInput>
  }

  export type submissionCreateWithoutOther_submissionInput = {
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementCreateNestedManyWithoutSubmissionInput
    judging?: judgingCreateNestedManyWithoutSubmissionInput
    user?: userCreateNestedOneWithoutSubmissionInput
    contest?: contestCreateNestedOneWithoutSubmissionInput
    team?: teamCreateNestedOneWithoutSubmissionInput
    problem?: problemCreateNestedOneWithoutSubmissionInput
    language?: languageCreateNestedOneWithoutSubmissionInput
    submission?: submissionCreateNestedOneWithoutOther_submissionInput
    rejudging?: rejudgingCreateNestedOneWithoutSubmissionInput
    contestproblem?: contestproblemCreateNestedOneWithoutSubmissionInput
    submission_file?: submission_fileCreateNestedManyWithoutSubmissionInput
  }

  export type submissionUncheckedCreateWithoutOther_submissionInput = {
    submitid?: number
    origsubmitid?: number | null
    cid?: number | null
    teamid?: number | null
    userid?: number | null
    probid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonUncheckedCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutSubmissionInput
    judging?: judgingUncheckedCreateNestedManyWithoutSubmissionInput
    submission_file?: submission_fileUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type submissionCreateOrConnectWithoutOther_submissionInput = {
    where: submissionWhereUniqueInput
    create: XOR<submissionCreateWithoutOther_submissionInput, submissionUncheckedCreateWithoutOther_submissionInput>
  }

  export type submissionCreateWithoutSubmissionInput = {
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementCreateNestedManyWithoutSubmissionInput
    judging?: judgingCreateNestedManyWithoutSubmissionInput
    user?: userCreateNestedOneWithoutSubmissionInput
    contest?: contestCreateNestedOneWithoutSubmissionInput
    team?: teamCreateNestedOneWithoutSubmissionInput
    problem?: problemCreateNestedOneWithoutSubmissionInput
    language?: languageCreateNestedOneWithoutSubmissionInput
    other_submission?: submissionCreateNestedManyWithoutSubmissionInput
    rejudging?: rejudgingCreateNestedOneWithoutSubmissionInput
    contestproblem?: contestproblemCreateNestedOneWithoutSubmissionInput
    submission_file?: submission_fileCreateNestedManyWithoutSubmissionInput
  }

  export type submissionUncheckedCreateWithoutSubmissionInput = {
    submitid?: number
    cid?: number | null
    teamid?: number | null
    userid?: number | null
    probid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonUncheckedCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutSubmissionInput
    judging?: judgingUncheckedCreateNestedManyWithoutSubmissionInput
    other_submission?: submissionUncheckedCreateNestedManyWithoutSubmissionInput
    submission_file?: submission_fileUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type submissionCreateOrConnectWithoutSubmissionInput = {
    where: submissionWhereUniqueInput
    create: XOR<submissionCreateWithoutSubmissionInput, submissionUncheckedCreateWithoutSubmissionInput>
  }

  export type submissionCreateManySubmissionInputEnvelope = {
    data: submissionCreateManySubmissionInput | submissionCreateManySubmissionInput[]
    skipDuplicates?: boolean
  }

  export type rejudgingCreateWithoutSubmissionInput = {
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    reason: string
    valid?: boolean
    auto_apply?: boolean
    repeat?: number | null
    judging?: judgingCreateNestedManyWithoutRejudgingInput
    rejudging?: rejudgingCreateNestedOneWithoutOther_rejudgingInput
    other_rejudging?: rejudgingCreateNestedManyWithoutRejudgingInput
    user_rejudging_userid_startTouser?: userCreateNestedOneWithoutRejudging_rejudging_userid_startTouserInput
    user_rejudging_userid_finishTouser?: userCreateNestedOneWithoutRejudging_rejudging_userid_finishTouserInput
  }

  export type rejudgingUncheckedCreateWithoutSubmissionInput = {
    rejudgingid?: number
    userid_start?: number | null
    userid_finish?: number | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    reason: string
    valid?: boolean
    auto_apply?: boolean
    repeat?: number | null
    repeat_rejudgingid?: number | null
    judging?: judgingUncheckedCreateNestedManyWithoutRejudgingInput
    other_rejudging?: rejudgingUncheckedCreateNestedManyWithoutRejudgingInput
  }

  export type rejudgingCreateOrConnectWithoutSubmissionInput = {
    where: rejudgingWhereUniqueInput
    create: XOR<rejudgingCreateWithoutSubmissionInput, rejudgingUncheckedCreateWithoutSubmissionInput>
  }

  export type contestproblemCreateWithoutSubmissionInput = {
    shortname: string
    points?: number
    allow_submit?: boolean
    allow_judge?: boolean
    color?: string | null
    lazy_eval_results?: number | null
    contest: contestCreateNestedOneWithoutContestproblemInput
    problem: problemCreateNestedOneWithoutContestproblemInput
  }

  export type contestproblemUncheckedCreateWithoutSubmissionInput = {
    cid: number
    probid: number
    shortname: string
    points?: number
    allow_submit?: boolean
    allow_judge?: boolean
    color?: string | null
    lazy_eval_results?: number | null
  }

  export type contestproblemCreateOrConnectWithoutSubmissionInput = {
    where: contestproblemWhereUniqueInput
    create: XOR<contestproblemCreateWithoutSubmissionInput, contestproblemUncheckedCreateWithoutSubmissionInput>
  }

  export type submission_fileCreateWithoutSubmissionInput = {
    sourcecode: Buffer
    filename: string
    ranknumber: number
  }

  export type submission_fileUncheckedCreateWithoutSubmissionInput = {
    submitfileid?: number
    sourcecode: Buffer
    filename: string
    ranknumber: number
  }

  export type submission_fileCreateOrConnectWithoutSubmissionInput = {
    where: submission_fileWhereUniqueInput
    create: XOR<submission_fileCreateWithoutSubmissionInput, submission_fileUncheckedCreateWithoutSubmissionInput>
  }

  export type submission_fileCreateManySubmissionInputEnvelope = {
    data: submission_fileCreateManySubmissionInput | submission_fileCreateManySubmissionInput[]
    skipDuplicates?: boolean
  }

  export type balloonUpsertWithWhereUniqueWithoutSubmissionInput = {
    where: balloonWhereUniqueInput
    update: XOR<balloonUpdateWithoutSubmissionInput, balloonUncheckedUpdateWithoutSubmissionInput>
    create: XOR<balloonCreateWithoutSubmissionInput, balloonUncheckedCreateWithoutSubmissionInput>
  }

  export type balloonUpdateWithWhereUniqueWithoutSubmissionInput = {
    where: balloonWhereUniqueInput
    data: XOR<balloonUpdateWithoutSubmissionInput, balloonUncheckedUpdateWithoutSubmissionInput>
  }

  export type balloonUpdateManyWithWhereWithoutSubmissionInput = {
    where: balloonScalarWhereInput
    data: XOR<balloonUpdateManyMutationInput, balloonUncheckedUpdateManyWithoutSubmissionInput>
  }

  export type balloonScalarWhereInput = {
    AND?: balloonScalarWhereInput | balloonScalarWhereInput[]
    OR?: balloonScalarWhereInput[]
    NOT?: balloonScalarWhereInput | balloonScalarWhereInput[]
    balloonid?: IntFilter<"balloon"> | number
    submitid?: IntNullableFilter<"balloon"> | number | null
    done?: BoolFilter<"balloon"> | boolean
  }

  export type external_judgementUpsertWithWhereUniqueWithoutSubmissionInput = {
    where: external_judgementWhereUniqueInput
    update: XOR<external_judgementUpdateWithoutSubmissionInput, external_judgementUncheckedUpdateWithoutSubmissionInput>
    create: XOR<external_judgementCreateWithoutSubmissionInput, external_judgementUncheckedCreateWithoutSubmissionInput>
  }

  export type external_judgementUpdateWithWhereUniqueWithoutSubmissionInput = {
    where: external_judgementWhereUniqueInput
    data: XOR<external_judgementUpdateWithoutSubmissionInput, external_judgementUncheckedUpdateWithoutSubmissionInput>
  }

  export type external_judgementUpdateManyWithWhereWithoutSubmissionInput = {
    where: external_judgementScalarWhereInput
    data: XOR<external_judgementUpdateManyMutationInput, external_judgementUncheckedUpdateManyWithoutSubmissionInput>
  }

  export type judgingUpsertWithWhereUniqueWithoutSubmissionInput = {
    where: judgingWhereUniqueInput
    update: XOR<judgingUpdateWithoutSubmissionInput, judgingUncheckedUpdateWithoutSubmissionInput>
    create: XOR<judgingCreateWithoutSubmissionInput, judgingUncheckedCreateWithoutSubmissionInput>
  }

  export type judgingUpdateWithWhereUniqueWithoutSubmissionInput = {
    where: judgingWhereUniqueInput
    data: XOR<judgingUpdateWithoutSubmissionInput, judgingUncheckedUpdateWithoutSubmissionInput>
  }

  export type judgingUpdateManyWithWhereWithoutSubmissionInput = {
    where: judgingScalarWhereInput
    data: XOR<judgingUpdateManyMutationInput, judgingUncheckedUpdateManyWithoutSubmissionInput>
  }

  export type userUpsertWithoutSubmissionInput = {
    update: XOR<userUpdateWithoutSubmissionInput, userUncheckedUpdateWithoutSubmissionInput>
    create: XOR<userCreateWithoutSubmissionInput, userUncheckedCreateWithoutSubmissionInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutSubmissionInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutSubmissionInput, userUncheckedUpdateWithoutSubmissionInput>
  }

  export type userUpdateWithoutSubmissionInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_api_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    immutable_executable?: immutable_executableUpdateManyWithoutUserNestedInput
    rejudging_rejudging_userid_startTouser?: rejudgingUpdateManyWithoutUser_rejudging_userid_startTouserNestedInput
    rejudging_rejudging_userid_finishTouser?: rejudgingUpdateManyWithoutUser_rejudging_userid_finishTouserNestedInput
    team?: teamUpdateOneWithoutUserNestedInput
    userrole?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutSubmissionInput = {
    userid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_api_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    immutable_executable?: immutable_executableUncheckedUpdateManyWithoutUserNestedInput
    rejudging_rejudging_userid_startTouser?: rejudgingUncheckedUpdateManyWithoutUser_rejudging_userid_startTouserNestedInput
    rejudging_rejudging_userid_finishTouser?: rejudgingUncheckedUpdateManyWithoutUser_rejudging_userid_finishTouserNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type contestUpsertWithoutSubmissionInput = {
    update: XOR<contestUpdateWithoutSubmissionInput, contestUncheckedUpdateWithoutSubmissionInput>
    create: XOR<contestCreateWithoutSubmissionInput, contestUncheckedCreateWithoutSubmissionInput>
    where?: contestWhereInput
  }

  export type contestUpdateToOneWithWhereWithoutSubmissionInput = {
    where?: contestWhereInput
    data: XOR<contestUpdateWithoutSubmissionInput, contestUncheckedUpdateWithoutSubmissionInput>
  }

  export type contestUpdateWithoutSubmissionInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUpdateManyWithoutContestNestedInput
    event?: eventUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUpdateManyWithoutContestNestedInput
    external_run?: external_runUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUpdateManyWithoutContestNestedInput
    judging?: judgingUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUpdateManyWithoutContestNestedInput
  }

  export type contestUncheckedUpdateWithoutSubmissionInput = {
    cid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shortname?: StringFieldUpdateOperationsInput | string
    activatetime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    freezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unfreezetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deactivatetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    activatetime_string?: StringFieldUpdateOperationsInput | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    freezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    endtime_string?: StringFieldUpdateOperationsInput | string
    unfreezetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatetime_string?: NullableStringFieldUpdateOperationsInput | string | null
    finalizetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizecomment?: NullableStringFieldUpdateOperationsInput | string | null
    b?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    starttime_enabled?: BoolFieldUpdateOperationsInput | boolean
    process_balloons?: BoolFieldUpdateOperationsInput | boolean
    public?: BoolFieldUpdateOperationsInput | boolean
    open_to_all_teams?: BoolFieldUpdateOperationsInput | boolean
    medals_enabled?: BoolFieldUpdateOperationsInput | boolean
    gold_medals?: IntFieldUpdateOperationsInput | number
    silver_medals?: IntFieldUpdateOperationsInput | number
    bronze_medals?: IntFieldUpdateOperationsInput | number
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    warning_message?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutContestNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutContestNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategory?: contestteamcategoryUncheckedUpdateManyWithoutContestNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedUpdateManyWithoutContestNestedInput
    event?: eventUncheckedUpdateManyWithoutContestNestedInput
    external_contest_source?: external_contest_sourceUncheckedUpdateOneWithoutContestNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutContestNestedInput
    external_run?: external_runUncheckedUpdateManyWithoutContestNestedInput
    internal_error?: internal_errorUncheckedUpdateManyWithoutContestNestedInput
    judging?: judgingUncheckedUpdateManyWithoutContestNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutContestNestedInput
    removed_interval?: removed_intervalUncheckedUpdateManyWithoutContestNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutContestNestedInput
  }

  export type teamUpsertWithoutSubmissionInput = {
    update: XOR<teamUpdateWithoutSubmissionInput, teamUncheckedUpdateWithoutSubmissionInput>
    create: XOR<teamCreateWithoutSubmissionInput, teamUncheckedCreateWithoutSubmissionInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutSubmissionInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutSubmissionInput, teamUncheckedUpdateWithoutSubmissionInput>
  }

  export type teamUpdateWithoutSubmissionInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    clarification_clarification_recipientToteam?: clarificationUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    contestteam?: contestteamUpdateManyWithoutTeamNestedInput
    queuetask?: queuetaskUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUpdateManyWithoutTeamNestedInput
    team_category?: team_categoryUpdateOneWithoutTeamNestedInput
    team_affiliation?: team_affiliationUpdateOneWithoutTeamNestedInput
    team_unread?: team_unreadUpdateManyWithoutTeamNestedInput
    user?: userUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutSubmissionInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    categoryid?: NullableIntFieldUpdateOperationsInput | number | null
    affilid?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    clarification_clarification_recipientToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutTeamNestedInput
    queuetask?: queuetaskUncheckedUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutTeamNestedInput
    team_unread?: team_unreadUncheckedUpdateManyWithoutTeamNestedInput
    user?: userUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type problemUpsertWithoutSubmissionInput = {
    update: XOR<problemUpdateWithoutSubmissionInput, problemUncheckedUpdateWithoutSubmissionInput>
    create: XOR<problemCreateWithoutSubmissionInput, problemUncheckedCreateWithoutSubmissionInput>
    where?: problemWhereInput
  }

  export type problemUpdateToOneWithWhereWithoutSubmissionInput = {
    where?: problemWhereInput
    data: XOR<problemUpdateWithoutSubmissionInput, problemUncheckedUpdateWithoutSubmissionInput>
  }

  export type problemUpdateWithoutSubmissionInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutProblemNestedInput
    contestproblem?: contestproblemUpdateManyWithoutProblemNestedInput
    executable_problem_special_runToexecutable?: executableUpdateOneWithoutProblem_problem_special_runToexecutableNestedInput
    executable_problem_special_compareToexecutable?: executableUpdateOneWithoutProblem_problem_special_compareToexecutableNestedInput
    problem_attachment?: problem_attachmentUpdateManyWithoutProblemNestedInput
    scorecache?: scorecacheUpdateManyWithoutProblemNestedInput
    testcase?: testcaseUpdateManyWithoutProblemNestedInput
  }

  export type problemUncheckedUpdateWithoutSubmissionInput = {
    probid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_run?: NullableStringFieldUpdateOperationsInput | string | null
    special_compare?: NullableStringFieldUpdateOperationsInput | string | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutProblemNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutProblemNestedInput
    problem_attachment?: problem_attachmentUncheckedUpdateManyWithoutProblemNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutProblemNestedInput
    testcase?: testcaseUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type languageUpsertWithoutSubmissionInput = {
    update: XOR<languageUpdateWithoutSubmissionInput, languageUncheckedUpdateWithoutSubmissionInput>
    create: XOR<languageCreateWithoutSubmissionInput, languageUncheckedCreateWithoutSubmissionInput>
    where?: languageWhereInput
  }

  export type languageUpdateToOneWithWhereWithoutSubmissionInput = {
    where?: languageWhereInput
    data: XOR<languageUpdateWithoutSubmissionInput, languageUncheckedUpdateWithoutSubmissionInput>
  }

  export type languageUpdateWithoutSubmissionInput = {
    langid?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    extensions?: NullableStringFieldUpdateOperationsInput | string | null
    require_entry_point?: BoolFieldUpdateOperationsInput | boolean
    entry_point_description?: NullableStringFieldUpdateOperationsInput | string | null
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    time_factor?: FloatFieldUpdateOperationsInput | number
    filter_compiler_files?: BoolFieldUpdateOperationsInput | boolean
    executable?: executableUpdateOneWithoutLanguageNestedInput
  }

  export type languageUncheckedUpdateWithoutSubmissionInput = {
    langid?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    extensions?: NullableStringFieldUpdateOperationsInput | string | null
    require_entry_point?: BoolFieldUpdateOperationsInput | boolean
    entry_point_description?: NullableStringFieldUpdateOperationsInput | string | null
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    time_factor?: FloatFieldUpdateOperationsInput | number
    compile_script?: NullableStringFieldUpdateOperationsInput | string | null
    filter_compiler_files?: BoolFieldUpdateOperationsInput | boolean
  }

  export type submissionUpsertWithoutOther_submissionInput = {
    update: XOR<submissionUpdateWithoutOther_submissionInput, submissionUncheckedUpdateWithoutOther_submissionInput>
    create: XOR<submissionCreateWithoutOther_submissionInput, submissionUncheckedCreateWithoutOther_submissionInput>
    where?: submissionWhereInput
  }

  export type submissionUpdateToOneWithWhereWithoutOther_submissionInput = {
    where?: submissionWhereInput
    data: XOR<submissionUpdateWithoutOther_submissionInput, submissionUncheckedUpdateWithoutOther_submissionInput>
  }

  export type submissionUpdateWithoutOther_submissionInput = {
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUpdateManyWithoutSubmissionNestedInput
    user?: userUpdateOneWithoutSubmissionNestedInput
    contest?: contestUpdateOneWithoutSubmissionNestedInput
    team?: teamUpdateOneWithoutSubmissionNestedInput
    problem?: problemUpdateOneWithoutSubmissionNestedInput
    language?: languageUpdateOneWithoutSubmissionNestedInput
    submission?: submissionUpdateOneWithoutOther_submissionNestedInput
    rejudging?: rejudgingUpdateOneWithoutSubmissionNestedInput
    contestproblem?: contestproblemUpdateOneWithoutSubmissionNestedInput
    submission_file?: submission_fileUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateWithoutOther_submissionInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUncheckedUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUncheckedUpdateManyWithoutSubmissionNestedInput
    submission_file?: submission_fileUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUpsertWithWhereUniqueWithoutSubmissionInput = {
    where: submissionWhereUniqueInput
    update: XOR<submissionUpdateWithoutSubmissionInput, submissionUncheckedUpdateWithoutSubmissionInput>
    create: XOR<submissionCreateWithoutSubmissionInput, submissionUncheckedCreateWithoutSubmissionInput>
  }

  export type submissionUpdateWithWhereUniqueWithoutSubmissionInput = {
    where: submissionWhereUniqueInput
    data: XOR<submissionUpdateWithoutSubmissionInput, submissionUncheckedUpdateWithoutSubmissionInput>
  }

  export type submissionUpdateManyWithWhereWithoutSubmissionInput = {
    where: submissionScalarWhereInput
    data: XOR<submissionUpdateManyMutationInput, submissionUncheckedUpdateManyWithoutSubmissionInput>
  }

  export type rejudgingUpsertWithoutSubmissionInput = {
    update: XOR<rejudgingUpdateWithoutSubmissionInput, rejudgingUncheckedUpdateWithoutSubmissionInput>
    create: XOR<rejudgingCreateWithoutSubmissionInput, rejudgingUncheckedCreateWithoutSubmissionInput>
    where?: rejudgingWhereInput
  }

  export type rejudgingUpdateToOneWithWhereWithoutSubmissionInput = {
    where?: rejudgingWhereInput
    data: XOR<rejudgingUpdateWithoutSubmissionInput, rejudgingUncheckedUpdateWithoutSubmissionInput>
  }

  export type rejudgingUpdateWithoutSubmissionInput = {
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    auto_apply?: BoolFieldUpdateOperationsInput | boolean
    repeat?: NullableIntFieldUpdateOperationsInput | number | null
    judging?: judgingUpdateManyWithoutRejudgingNestedInput
    rejudging?: rejudgingUpdateOneWithoutOther_rejudgingNestedInput
    other_rejudging?: rejudgingUpdateManyWithoutRejudgingNestedInput
    user_rejudging_userid_startTouser?: userUpdateOneWithoutRejudging_rejudging_userid_startTouserNestedInput
    user_rejudging_userid_finishTouser?: userUpdateOneWithoutRejudging_rejudging_userid_finishTouserNestedInput
  }

  export type rejudgingUncheckedUpdateWithoutSubmissionInput = {
    rejudgingid?: IntFieldUpdateOperationsInput | number
    userid_start?: NullableIntFieldUpdateOperationsInput | number | null
    userid_finish?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    auto_apply?: BoolFieldUpdateOperationsInput | boolean
    repeat?: NullableIntFieldUpdateOperationsInput | number | null
    repeat_rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judging?: judgingUncheckedUpdateManyWithoutRejudgingNestedInput
    other_rejudging?: rejudgingUncheckedUpdateManyWithoutRejudgingNestedInput
  }

  export type contestproblemUpsertWithoutSubmissionInput = {
    update: XOR<contestproblemUpdateWithoutSubmissionInput, contestproblemUncheckedUpdateWithoutSubmissionInput>
    create: XOR<contestproblemCreateWithoutSubmissionInput, contestproblemUncheckedCreateWithoutSubmissionInput>
    where?: contestproblemWhereInput
  }

  export type contestproblemUpdateToOneWithWhereWithoutSubmissionInput = {
    where?: contestproblemWhereInput
    data: XOR<contestproblemUpdateWithoutSubmissionInput, contestproblemUncheckedUpdateWithoutSubmissionInput>
  }

  export type contestproblemUpdateWithoutSubmissionInput = {
    shortname?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    lazy_eval_results?: NullableIntFieldUpdateOperationsInput | number | null
    contest?: contestUpdateOneRequiredWithoutContestproblemNestedInput
    problem?: problemUpdateOneRequiredWithoutContestproblemNestedInput
  }

  export type contestproblemUncheckedUpdateWithoutSubmissionInput = {
    cid?: IntFieldUpdateOperationsInput | number
    probid?: IntFieldUpdateOperationsInput | number
    shortname?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    lazy_eval_results?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type submission_fileUpsertWithWhereUniqueWithoutSubmissionInput = {
    where: submission_fileWhereUniqueInput
    update: XOR<submission_fileUpdateWithoutSubmissionInput, submission_fileUncheckedUpdateWithoutSubmissionInput>
    create: XOR<submission_fileCreateWithoutSubmissionInput, submission_fileUncheckedCreateWithoutSubmissionInput>
  }

  export type submission_fileUpdateWithWhereUniqueWithoutSubmissionInput = {
    where: submission_fileWhereUniqueInput
    data: XOR<submission_fileUpdateWithoutSubmissionInput, submission_fileUncheckedUpdateWithoutSubmissionInput>
  }

  export type submission_fileUpdateManyWithWhereWithoutSubmissionInput = {
    where: submission_fileScalarWhereInput
    data: XOR<submission_fileUpdateManyMutationInput, submission_fileUncheckedUpdateManyWithoutSubmissionInput>
  }

  export type submission_fileScalarWhereInput = {
    AND?: submission_fileScalarWhereInput | submission_fileScalarWhereInput[]
    OR?: submission_fileScalarWhereInput[]
    NOT?: submission_fileScalarWhereInput | submission_fileScalarWhereInput[]
    submitfileid?: IntFilter<"submission_file"> | number
    submitid?: IntNullableFilter<"submission_file"> | number | null
    sourcecode?: BytesFilter<"submission_file"> | Buffer
    filename?: StringFilter<"submission_file"> | string
    ranknumber?: IntFilter<"submission_file"> | number
  }

  export type submissionCreateWithoutSubmission_fileInput = {
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementCreateNestedManyWithoutSubmissionInput
    judging?: judgingCreateNestedManyWithoutSubmissionInput
    user?: userCreateNestedOneWithoutSubmissionInput
    contest?: contestCreateNestedOneWithoutSubmissionInput
    team?: teamCreateNestedOneWithoutSubmissionInput
    problem?: problemCreateNestedOneWithoutSubmissionInput
    language?: languageCreateNestedOneWithoutSubmissionInput
    submission?: submissionCreateNestedOneWithoutOther_submissionInput
    other_submission?: submissionCreateNestedManyWithoutSubmissionInput
    rejudging?: rejudgingCreateNestedOneWithoutSubmissionInput
    contestproblem?: contestproblemCreateNestedOneWithoutSubmissionInput
  }

  export type submissionUncheckedCreateWithoutSubmission_fileInput = {
    submitid?: number
    origsubmitid?: number | null
    cid?: number | null
    teamid?: number | null
    userid?: number | null
    probid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonUncheckedCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutSubmissionInput
    judging?: judgingUncheckedCreateNestedManyWithoutSubmissionInput
    other_submission?: submissionUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type submissionCreateOrConnectWithoutSubmission_fileInput = {
    where: submissionWhereUniqueInput
    create: XOR<submissionCreateWithoutSubmission_fileInput, submissionUncheckedCreateWithoutSubmission_fileInput>
  }

  export type submissionUpsertWithoutSubmission_fileInput = {
    update: XOR<submissionUpdateWithoutSubmission_fileInput, submissionUncheckedUpdateWithoutSubmission_fileInput>
    create: XOR<submissionCreateWithoutSubmission_fileInput, submissionUncheckedCreateWithoutSubmission_fileInput>
    where?: submissionWhereInput
  }

  export type submissionUpdateToOneWithWhereWithoutSubmission_fileInput = {
    where?: submissionWhereInput
    data: XOR<submissionUpdateWithoutSubmission_fileInput, submissionUncheckedUpdateWithoutSubmission_fileInput>
  }

  export type submissionUpdateWithoutSubmission_fileInput = {
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUpdateManyWithoutSubmissionNestedInput
    user?: userUpdateOneWithoutSubmissionNestedInput
    contest?: contestUpdateOneWithoutSubmissionNestedInput
    team?: teamUpdateOneWithoutSubmissionNestedInput
    problem?: problemUpdateOneWithoutSubmissionNestedInput
    language?: languageUpdateOneWithoutSubmissionNestedInput
    submission?: submissionUpdateOneWithoutOther_submissionNestedInput
    other_submission?: submissionUpdateManyWithoutSubmissionNestedInput
    rejudging?: rejudgingUpdateOneWithoutSubmissionNestedInput
    contestproblem?: contestproblemUpdateOneWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateWithoutSubmission_fileInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUncheckedUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUncheckedUpdateManyWithoutSubmissionNestedInput
    other_submission?: submissionUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type clarificationCreateWithoutTeam_clarification_senderToteamInput = {
    externalid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    jury_member?: string | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
    contest?: contestCreateNestedOneWithoutClarificationInput
    clarification?: clarificationCreateNestedOneWithoutOther_clarificationInput
    other_clarification?: clarificationCreateNestedManyWithoutClarificationInput
    problem?: problemCreateNestedOneWithoutClarificationInput
    team_clarification_recipientToteam?: teamCreateNestedOneWithoutClarification_clarification_recipientToteamInput
    team_unread?: team_unreadCreateNestedManyWithoutClarificationInput
  }

  export type clarificationUncheckedCreateWithoutTeam_clarification_senderToteamInput = {
    clarid?: number
    externalid?: string | null
    cid?: number | null
    respid?: number | null
    submittime: Decimal | DecimalJsLike | number | string
    recipient?: number | null
    jury_member?: string | null
    probid?: number | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
    other_clarification?: clarificationUncheckedCreateNestedManyWithoutClarificationInput
    team_unread?: team_unreadUncheckedCreateNestedManyWithoutClarificationInput
  }

  export type clarificationCreateOrConnectWithoutTeam_clarification_senderToteamInput = {
    where: clarificationWhereUniqueInput
    create: XOR<clarificationCreateWithoutTeam_clarification_senderToteamInput, clarificationUncheckedCreateWithoutTeam_clarification_senderToteamInput>
  }

  export type clarificationCreateManyTeam_clarification_senderToteamInputEnvelope = {
    data: clarificationCreateManyTeam_clarification_senderToteamInput | clarificationCreateManyTeam_clarification_senderToteamInput[]
    skipDuplicates?: boolean
  }

  export type clarificationCreateWithoutTeam_clarification_recipientToteamInput = {
    externalid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    jury_member?: string | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
    contest?: contestCreateNestedOneWithoutClarificationInput
    clarification?: clarificationCreateNestedOneWithoutOther_clarificationInput
    other_clarification?: clarificationCreateNestedManyWithoutClarificationInput
    problem?: problemCreateNestedOneWithoutClarificationInput
    team_clarification_senderToteam?: teamCreateNestedOneWithoutClarification_clarification_senderToteamInput
    team_unread?: team_unreadCreateNestedManyWithoutClarificationInput
  }

  export type clarificationUncheckedCreateWithoutTeam_clarification_recipientToteamInput = {
    clarid?: number
    externalid?: string | null
    cid?: number | null
    respid?: number | null
    submittime: Decimal | DecimalJsLike | number | string
    sender?: number | null
    jury_member?: string | null
    probid?: number | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
    other_clarification?: clarificationUncheckedCreateNestedManyWithoutClarificationInput
    team_unread?: team_unreadUncheckedCreateNestedManyWithoutClarificationInput
  }

  export type clarificationCreateOrConnectWithoutTeam_clarification_recipientToteamInput = {
    where: clarificationWhereUniqueInput
    create: XOR<clarificationCreateWithoutTeam_clarification_recipientToteamInput, clarificationUncheckedCreateWithoutTeam_clarification_recipientToteamInput>
  }

  export type clarificationCreateManyTeam_clarification_recipientToteamInputEnvelope = {
    data: clarificationCreateManyTeam_clarification_recipientToteamInput | clarificationCreateManyTeam_clarification_recipientToteamInput[]
    skipDuplicates?: boolean
  }

  export type contestteamCreateWithoutTeamInput = {
    contest: contestCreateNestedOneWithoutContestteamInput
  }

  export type contestteamUncheckedCreateWithoutTeamInput = {
    cid: number
  }

  export type contestteamCreateOrConnectWithoutTeamInput = {
    where: contestteamWhereUniqueInput
    create: XOR<contestteamCreateWithoutTeamInput, contestteamUncheckedCreateWithoutTeamInput>
  }

  export type contestteamCreateManyTeamInputEnvelope = {
    data: contestteamCreateManyTeamInput | contestteamCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type queuetaskCreateWithoutTeamInput = {
    jobid?: number | null
    priority: number
    teampriority: number
    starttime?: Decimal | DecimalJsLike | number | string | null
  }

  export type queuetaskUncheckedCreateWithoutTeamInput = {
    queuetaskid?: number
    jobid?: number | null
    priority: number
    teampriority: number
    starttime?: Decimal | DecimalJsLike | number | string | null
  }

  export type queuetaskCreateOrConnectWithoutTeamInput = {
    where: queuetaskWhereUniqueInput
    create: XOR<queuetaskCreateWithoutTeamInput, queuetaskUncheckedCreateWithoutTeamInput>
  }

  export type queuetaskCreateManyTeamInputEnvelope = {
    data: queuetaskCreateManyTeamInput | queuetaskCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type rankcacheCreateWithoutTeamInput = {
    points_restricted?: number
    totaltime_restricted?: number
    points_public?: number
    totaltime_public?: number
    contest: contestCreateNestedOneWithoutRankcacheInput
  }

  export type rankcacheUncheckedCreateWithoutTeamInput = {
    cid: number
    points_restricted?: number
    totaltime_restricted?: number
    points_public?: number
    totaltime_public?: number
  }

  export type rankcacheCreateOrConnectWithoutTeamInput = {
    where: rankcacheWhereUniqueInput
    create: XOR<rankcacheCreateWithoutTeamInput, rankcacheUncheckedCreateWithoutTeamInput>
  }

  export type rankcacheCreateManyTeamInputEnvelope = {
    data: rankcacheCreateManyTeamInput | rankcacheCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type scorecacheCreateWithoutTeamInput = {
    submissions_restricted?: number
    pending_restricted?: number
    solvetime_restricted?: Decimal | DecimalJsLike | number | string
    is_correct_restricted?: boolean
    submissions_public?: number
    pending_public?: number
    solvetime_public?: Decimal | DecimalJsLike | number | string
    is_correct_public?: boolean
    is_first_to_solve?: boolean
    contest: contestCreateNestedOneWithoutScorecacheInput
    problem: problemCreateNestedOneWithoutScorecacheInput
  }

  export type scorecacheUncheckedCreateWithoutTeamInput = {
    cid: number
    probid: number
    submissions_restricted?: number
    pending_restricted?: number
    solvetime_restricted?: Decimal | DecimalJsLike | number | string
    is_correct_restricted?: boolean
    submissions_public?: number
    pending_public?: number
    solvetime_public?: Decimal | DecimalJsLike | number | string
    is_correct_public?: boolean
    is_first_to_solve?: boolean
  }

  export type scorecacheCreateOrConnectWithoutTeamInput = {
    where: scorecacheWhereUniqueInput
    create: XOR<scorecacheCreateWithoutTeamInput, scorecacheUncheckedCreateWithoutTeamInput>
  }

  export type scorecacheCreateManyTeamInputEnvelope = {
    data: scorecacheCreateManyTeamInput | scorecacheCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type submissionCreateWithoutTeamInput = {
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementCreateNestedManyWithoutSubmissionInput
    judging?: judgingCreateNestedManyWithoutSubmissionInput
    user?: userCreateNestedOneWithoutSubmissionInput
    contest?: contestCreateNestedOneWithoutSubmissionInput
    problem?: problemCreateNestedOneWithoutSubmissionInput
    language?: languageCreateNestedOneWithoutSubmissionInput
    submission?: submissionCreateNestedOneWithoutOther_submissionInput
    other_submission?: submissionCreateNestedManyWithoutSubmissionInput
    rejudging?: rejudgingCreateNestedOneWithoutSubmissionInput
    contestproblem?: contestproblemCreateNestedOneWithoutSubmissionInput
    submission_file?: submission_fileCreateNestedManyWithoutSubmissionInput
  }

  export type submissionUncheckedCreateWithoutTeamInput = {
    submitid?: number
    origsubmitid?: number | null
    cid?: number | null
    userid?: number | null
    probid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonUncheckedCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutSubmissionInput
    judging?: judgingUncheckedCreateNestedManyWithoutSubmissionInput
    other_submission?: submissionUncheckedCreateNestedManyWithoutSubmissionInput
    submission_file?: submission_fileUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type submissionCreateOrConnectWithoutTeamInput = {
    where: submissionWhereUniqueInput
    create: XOR<submissionCreateWithoutTeamInput, submissionUncheckedCreateWithoutTeamInput>
  }

  export type submissionCreateManyTeamInputEnvelope = {
    data: submissionCreateManyTeamInput | submissionCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type team_categoryCreateWithoutTeamInput = {
    externalid?: string | null
    icpcid?: string | null
    name: string
    sortorder?: boolean
    color?: string | null
    visible?: boolean
    allow_self_registration?: boolean
    contestteamcategory?: contestteamcategoryCreateNestedManyWithoutTeam_categoryInput
    contestteamcategoryformedals?: contestteamcategoryformedalsCreateNestedManyWithoutTeam_categoryInput
  }

  export type team_categoryUncheckedCreateWithoutTeamInput = {
    categoryid?: number
    externalid?: string | null
    icpcid?: string | null
    name: string
    sortorder?: boolean
    color?: string | null
    visible?: boolean
    allow_self_registration?: boolean
    contestteamcategory?: contestteamcategoryUncheckedCreateNestedManyWithoutTeam_categoryInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedCreateNestedManyWithoutTeam_categoryInput
  }

  export type team_categoryCreateOrConnectWithoutTeamInput = {
    where: team_categoryWhereUniqueInput
    create: XOR<team_categoryCreateWithoutTeamInput, team_categoryUncheckedCreateWithoutTeamInput>
  }

  export type team_affiliationCreateWithoutTeamInput = {
    externalid?: string | null
    icpcid?: string | null
    shortname: string
    name: string
    country?: string | null
    internalcomments?: string | null
  }

  export type team_affiliationUncheckedCreateWithoutTeamInput = {
    affilid?: number
    externalid?: string | null
    icpcid?: string | null
    shortname: string
    name: string
    country?: string | null
    internalcomments?: string | null
  }

  export type team_affiliationCreateOrConnectWithoutTeamInput = {
    where: team_affiliationWhereUniqueInput
    create: XOR<team_affiliationCreateWithoutTeamInput, team_affiliationUncheckedCreateWithoutTeamInput>
  }

  export type team_unreadCreateWithoutTeamInput = {
    clarification: clarificationCreateNestedOneWithoutTeam_unreadInput
  }

  export type team_unreadUncheckedCreateWithoutTeamInput = {
    mesgid: number
  }

  export type team_unreadCreateOrConnectWithoutTeamInput = {
    where: team_unreadWhereUniqueInput
    create: XOR<team_unreadCreateWithoutTeamInput, team_unreadUncheckedCreateWithoutTeamInput>
  }

  export type team_unreadCreateManyTeamInputEnvelope = {
    data: team_unreadCreateManyTeamInput | team_unreadCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutTeamInput = {
    externalid?: string | null
    username: string
    name: string
    email?: string | null
    last_login?: Decimal | DecimalJsLike | number | string | null
    last_api_login?: Decimal | DecimalJsLike | number | string | null
    first_login?: Decimal | DecimalJsLike | number | string | null
    last_ip_address?: string | null
    password?: string | null
    ip_address?: string | null
    enabled?: boolean
    immutable_executable?: immutable_executableCreateNestedManyWithoutUserInput
    rejudging_rejudging_userid_startTouser?: rejudgingCreateNestedManyWithoutUser_rejudging_userid_startTouserInput
    rejudging_rejudging_userid_finishTouser?: rejudgingCreateNestedManyWithoutUser_rejudging_userid_finishTouserInput
    submission?: submissionCreateNestedManyWithoutUserInput
    userrole?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutTeamInput = {
    userid?: number
    externalid?: string | null
    username: string
    name: string
    email?: string | null
    last_login?: Decimal | DecimalJsLike | number | string | null
    last_api_login?: Decimal | DecimalJsLike | number | string | null
    first_login?: Decimal | DecimalJsLike | number | string | null
    last_ip_address?: string | null
    password?: string | null
    ip_address?: string | null
    enabled?: boolean
    immutable_executable?: immutable_executableUncheckedCreateNestedManyWithoutUserInput
    rejudging_rejudging_userid_startTouser?: rejudgingUncheckedCreateNestedManyWithoutUser_rejudging_userid_startTouserInput
    rejudging_rejudging_userid_finishTouser?: rejudgingUncheckedCreateNestedManyWithoutUser_rejudging_userid_finishTouserInput
    submission?: submissionUncheckedCreateNestedManyWithoutUserInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutTeamInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTeamInput, userUncheckedCreateWithoutTeamInput>
  }

  export type userCreateManyTeamInputEnvelope = {
    data: userCreateManyTeamInput | userCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type clarificationUpsertWithWhereUniqueWithoutTeam_clarification_senderToteamInput = {
    where: clarificationWhereUniqueInput
    update: XOR<clarificationUpdateWithoutTeam_clarification_senderToteamInput, clarificationUncheckedUpdateWithoutTeam_clarification_senderToteamInput>
    create: XOR<clarificationCreateWithoutTeam_clarification_senderToteamInput, clarificationUncheckedCreateWithoutTeam_clarification_senderToteamInput>
  }

  export type clarificationUpdateWithWhereUniqueWithoutTeam_clarification_senderToteamInput = {
    where: clarificationWhereUniqueInput
    data: XOR<clarificationUpdateWithoutTeam_clarification_senderToteamInput, clarificationUncheckedUpdateWithoutTeam_clarification_senderToteamInput>
  }

  export type clarificationUpdateManyWithWhereWithoutTeam_clarification_senderToteamInput = {
    where: clarificationScalarWhereInput
    data: XOR<clarificationUpdateManyMutationInput, clarificationUncheckedUpdateManyWithoutTeam_clarification_senderToteamInput>
  }

  export type clarificationUpsertWithWhereUniqueWithoutTeam_clarification_recipientToteamInput = {
    where: clarificationWhereUniqueInput
    update: XOR<clarificationUpdateWithoutTeam_clarification_recipientToteamInput, clarificationUncheckedUpdateWithoutTeam_clarification_recipientToteamInput>
    create: XOR<clarificationCreateWithoutTeam_clarification_recipientToteamInput, clarificationUncheckedCreateWithoutTeam_clarification_recipientToteamInput>
  }

  export type clarificationUpdateWithWhereUniqueWithoutTeam_clarification_recipientToteamInput = {
    where: clarificationWhereUniqueInput
    data: XOR<clarificationUpdateWithoutTeam_clarification_recipientToteamInput, clarificationUncheckedUpdateWithoutTeam_clarification_recipientToteamInput>
  }

  export type clarificationUpdateManyWithWhereWithoutTeam_clarification_recipientToteamInput = {
    where: clarificationScalarWhereInput
    data: XOR<clarificationUpdateManyMutationInput, clarificationUncheckedUpdateManyWithoutTeam_clarification_recipientToteamInput>
  }

  export type contestteamUpsertWithWhereUniqueWithoutTeamInput = {
    where: contestteamWhereUniqueInput
    update: XOR<contestteamUpdateWithoutTeamInput, contestteamUncheckedUpdateWithoutTeamInput>
    create: XOR<contestteamCreateWithoutTeamInput, contestteamUncheckedCreateWithoutTeamInput>
  }

  export type contestteamUpdateWithWhereUniqueWithoutTeamInput = {
    where: contestteamWhereUniqueInput
    data: XOR<contestteamUpdateWithoutTeamInput, contestteamUncheckedUpdateWithoutTeamInput>
  }

  export type contestteamUpdateManyWithWhereWithoutTeamInput = {
    where: contestteamScalarWhereInput
    data: XOR<contestteamUpdateManyMutationInput, contestteamUncheckedUpdateManyWithoutTeamInput>
  }

  export type queuetaskUpsertWithWhereUniqueWithoutTeamInput = {
    where: queuetaskWhereUniqueInput
    update: XOR<queuetaskUpdateWithoutTeamInput, queuetaskUncheckedUpdateWithoutTeamInput>
    create: XOR<queuetaskCreateWithoutTeamInput, queuetaskUncheckedCreateWithoutTeamInput>
  }

  export type queuetaskUpdateWithWhereUniqueWithoutTeamInput = {
    where: queuetaskWhereUniqueInput
    data: XOR<queuetaskUpdateWithoutTeamInput, queuetaskUncheckedUpdateWithoutTeamInput>
  }

  export type queuetaskUpdateManyWithWhereWithoutTeamInput = {
    where: queuetaskScalarWhereInput
    data: XOR<queuetaskUpdateManyMutationInput, queuetaskUncheckedUpdateManyWithoutTeamInput>
  }

  export type queuetaskScalarWhereInput = {
    AND?: queuetaskScalarWhereInput | queuetaskScalarWhereInput[]
    OR?: queuetaskScalarWhereInput[]
    NOT?: queuetaskScalarWhereInput | queuetaskScalarWhereInput[]
    queuetaskid?: IntFilter<"queuetask"> | number
    teamid?: IntNullableFilter<"queuetask"> | number | null
    jobid?: IntNullableFilter<"queuetask"> | number | null
    priority?: IntFilter<"queuetask"> | number
    teampriority?: IntFilter<"queuetask"> | number
    starttime?: DecimalNullableFilter<"queuetask"> | Decimal | DecimalJsLike | number | string | null
  }

  export type rankcacheUpsertWithWhereUniqueWithoutTeamInput = {
    where: rankcacheWhereUniqueInput
    update: XOR<rankcacheUpdateWithoutTeamInput, rankcacheUncheckedUpdateWithoutTeamInput>
    create: XOR<rankcacheCreateWithoutTeamInput, rankcacheUncheckedCreateWithoutTeamInput>
  }

  export type rankcacheUpdateWithWhereUniqueWithoutTeamInput = {
    where: rankcacheWhereUniqueInput
    data: XOR<rankcacheUpdateWithoutTeamInput, rankcacheUncheckedUpdateWithoutTeamInput>
  }

  export type rankcacheUpdateManyWithWhereWithoutTeamInput = {
    where: rankcacheScalarWhereInput
    data: XOR<rankcacheUpdateManyMutationInput, rankcacheUncheckedUpdateManyWithoutTeamInput>
  }

  export type scorecacheUpsertWithWhereUniqueWithoutTeamInput = {
    where: scorecacheWhereUniqueInput
    update: XOR<scorecacheUpdateWithoutTeamInput, scorecacheUncheckedUpdateWithoutTeamInput>
    create: XOR<scorecacheCreateWithoutTeamInput, scorecacheUncheckedCreateWithoutTeamInput>
  }

  export type scorecacheUpdateWithWhereUniqueWithoutTeamInput = {
    where: scorecacheWhereUniqueInput
    data: XOR<scorecacheUpdateWithoutTeamInput, scorecacheUncheckedUpdateWithoutTeamInput>
  }

  export type scorecacheUpdateManyWithWhereWithoutTeamInput = {
    where: scorecacheScalarWhereInput
    data: XOR<scorecacheUpdateManyMutationInput, scorecacheUncheckedUpdateManyWithoutTeamInput>
  }

  export type submissionUpsertWithWhereUniqueWithoutTeamInput = {
    where: submissionWhereUniqueInput
    update: XOR<submissionUpdateWithoutTeamInput, submissionUncheckedUpdateWithoutTeamInput>
    create: XOR<submissionCreateWithoutTeamInput, submissionUncheckedCreateWithoutTeamInput>
  }

  export type submissionUpdateWithWhereUniqueWithoutTeamInput = {
    where: submissionWhereUniqueInput
    data: XOR<submissionUpdateWithoutTeamInput, submissionUncheckedUpdateWithoutTeamInput>
  }

  export type submissionUpdateManyWithWhereWithoutTeamInput = {
    where: submissionScalarWhereInput
    data: XOR<submissionUpdateManyMutationInput, submissionUncheckedUpdateManyWithoutTeamInput>
  }

  export type team_categoryUpsertWithoutTeamInput = {
    update: XOR<team_categoryUpdateWithoutTeamInput, team_categoryUncheckedUpdateWithoutTeamInput>
    create: XOR<team_categoryCreateWithoutTeamInput, team_categoryUncheckedCreateWithoutTeamInput>
    where?: team_categoryWhereInput
  }

  export type team_categoryUpdateToOneWithWhereWithoutTeamInput = {
    where?: team_categoryWhereInput
    data: XOR<team_categoryUpdateWithoutTeamInput, team_categoryUncheckedUpdateWithoutTeamInput>
  }

  export type team_categoryUpdateWithoutTeamInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sortorder?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    allow_self_registration?: BoolFieldUpdateOperationsInput | boolean
    contestteamcategory?: contestteamcategoryUpdateManyWithoutTeam_categoryNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUpdateManyWithoutTeam_categoryNestedInput
  }

  export type team_categoryUncheckedUpdateWithoutTeamInput = {
    categoryid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sortorder?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    allow_self_registration?: BoolFieldUpdateOperationsInput | boolean
    contestteamcategory?: contestteamcategoryUncheckedUpdateManyWithoutTeam_categoryNestedInput
    contestteamcategoryformedals?: contestteamcategoryformedalsUncheckedUpdateManyWithoutTeam_categoryNestedInput
  }

  export type team_affiliationUpsertWithoutTeamInput = {
    update: XOR<team_affiliationUpdateWithoutTeamInput, team_affiliationUncheckedUpdateWithoutTeamInput>
    create: XOR<team_affiliationCreateWithoutTeamInput, team_affiliationUncheckedCreateWithoutTeamInput>
    where?: team_affiliationWhereInput
  }

  export type team_affiliationUpdateToOneWithWhereWithoutTeamInput = {
    where?: team_affiliationWhereInput
    data: XOR<team_affiliationUpdateWithoutTeamInput, team_affiliationUncheckedUpdateWithoutTeamInput>
  }

  export type team_affiliationUpdateWithoutTeamInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    shortname?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type team_affiliationUncheckedUpdateWithoutTeamInput = {
    affilid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    shortname?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type team_unreadUpsertWithWhereUniqueWithoutTeamInput = {
    where: team_unreadWhereUniqueInput
    update: XOR<team_unreadUpdateWithoutTeamInput, team_unreadUncheckedUpdateWithoutTeamInput>
    create: XOR<team_unreadCreateWithoutTeamInput, team_unreadUncheckedCreateWithoutTeamInput>
  }

  export type team_unreadUpdateWithWhereUniqueWithoutTeamInput = {
    where: team_unreadWhereUniqueInput
    data: XOR<team_unreadUpdateWithoutTeamInput, team_unreadUncheckedUpdateWithoutTeamInput>
  }

  export type team_unreadUpdateManyWithWhereWithoutTeamInput = {
    where: team_unreadScalarWhereInput
    data: XOR<team_unreadUpdateManyMutationInput, team_unreadUncheckedUpdateManyWithoutTeamInput>
  }

  export type userUpsertWithWhereUniqueWithoutTeamInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutTeamInput, userUncheckedUpdateWithoutTeamInput>
    create: XOR<userCreateWithoutTeamInput, userUncheckedCreateWithoutTeamInput>
  }

  export type userUpdateWithWhereUniqueWithoutTeamInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutTeamInput, userUncheckedUpdateWithoutTeamInput>
  }

  export type userUpdateManyWithWhereWithoutTeamInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutTeamInput>
  }

  export type userScalarWhereInput = {
    AND?: userScalarWhereInput | userScalarWhereInput[]
    OR?: userScalarWhereInput[]
    NOT?: userScalarWhereInput | userScalarWhereInput[]
    userid?: IntFilter<"user"> | number
    externalid?: StringNullableFilter<"user"> | string | null
    username?: StringFilter<"user"> | string
    name?: StringFilter<"user"> | string
    email?: StringNullableFilter<"user"> | string | null
    last_login?: DecimalNullableFilter<"user"> | Decimal | DecimalJsLike | number | string | null
    last_api_login?: DecimalNullableFilter<"user"> | Decimal | DecimalJsLike | number | string | null
    first_login?: DecimalNullableFilter<"user"> | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: StringNullableFilter<"user"> | string | null
    password?: StringNullableFilter<"user"> | string | null
    ip_address?: StringNullableFilter<"user"> | string | null
    enabled?: BoolFilter<"user"> | boolean
    teamid?: IntNullableFilter<"user"> | number | null
  }

  export type teamCreateWithoutTeam_affiliationInput = {
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationCreateNestedManyWithoutTeam_clarification_senderToteamInput
    clarification_clarification_recipientToteam?: clarificationCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    contestteam?: contestteamCreateNestedManyWithoutTeamInput
    queuetask?: queuetaskCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheCreateNestedManyWithoutTeamInput
    submission?: submissionCreateNestedManyWithoutTeamInput
    team_category?: team_categoryCreateNestedOneWithoutTeamInput
    team_unread?: team_unreadCreateNestedManyWithoutTeamInput
    user?: userCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutTeam_affiliationInput = {
    teamid?: number
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    categoryid?: number | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_senderToteamInput
    clarification_clarification_recipientToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutTeamInput
    queuetask?: queuetaskUncheckedCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutTeamInput
    submission?: submissionUncheckedCreateNestedManyWithoutTeamInput
    team_unread?: team_unreadUncheckedCreateNestedManyWithoutTeamInput
    user?: userUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutTeam_affiliationInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutTeam_affiliationInput, teamUncheckedCreateWithoutTeam_affiliationInput>
  }

  export type teamCreateManyTeam_affiliationInputEnvelope = {
    data: teamCreateManyTeam_affiliationInput | teamCreateManyTeam_affiliationInput[]
    skipDuplicates?: boolean
  }

  export type teamUpsertWithWhereUniqueWithoutTeam_affiliationInput = {
    where: teamWhereUniqueInput
    update: XOR<teamUpdateWithoutTeam_affiliationInput, teamUncheckedUpdateWithoutTeam_affiliationInput>
    create: XOR<teamCreateWithoutTeam_affiliationInput, teamUncheckedCreateWithoutTeam_affiliationInput>
  }

  export type teamUpdateWithWhereUniqueWithoutTeam_affiliationInput = {
    where: teamWhereUniqueInput
    data: XOR<teamUpdateWithoutTeam_affiliationInput, teamUncheckedUpdateWithoutTeam_affiliationInput>
  }

  export type teamUpdateManyWithWhereWithoutTeam_affiliationInput = {
    where: teamScalarWhereInput
    data: XOR<teamUpdateManyMutationInput, teamUncheckedUpdateManyWithoutTeam_affiliationInput>
  }

  export type teamScalarWhereInput = {
    AND?: teamScalarWhereInput | teamScalarWhereInput[]
    OR?: teamScalarWhereInput[]
    NOT?: teamScalarWhereInput | teamScalarWhereInput[]
    teamid?: IntFilter<"team"> | number
    externalid?: StringNullableFilter<"team"> | string | null
    icpcid?: StringNullableFilter<"team"> | string | null
    name?: StringFilter<"team"> | string
    display_name?: StringNullableFilter<"team"> | string | null
    categoryid?: IntNullableFilter<"team"> | number | null
    affilid?: IntNullableFilter<"team"> | number | null
    enabled?: BoolFilter<"team"> | boolean
    publicdescription?: StringNullableFilter<"team"> | string | null
    room?: StringNullableFilter<"team"> | string | null
    internalcomments?: StringNullableFilter<"team"> | string | null
    judging_last_started?: DecimalNullableFilter<"team"> | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFilter<"team"> | number
  }

  export type contestteamcategoryCreateWithoutTeam_categoryInput = {
    contest: contestCreateNestedOneWithoutContestteamcategoryInput
  }

  export type contestteamcategoryUncheckedCreateWithoutTeam_categoryInput = {
    cid: number
  }

  export type contestteamcategoryCreateOrConnectWithoutTeam_categoryInput = {
    where: contestteamcategoryWhereUniqueInput
    create: XOR<contestteamcategoryCreateWithoutTeam_categoryInput, contestteamcategoryUncheckedCreateWithoutTeam_categoryInput>
  }

  export type contestteamcategoryCreateManyTeam_categoryInputEnvelope = {
    data: contestteamcategoryCreateManyTeam_categoryInput | contestteamcategoryCreateManyTeam_categoryInput[]
    skipDuplicates?: boolean
  }

  export type contestteamcategoryformedalsCreateWithoutTeam_categoryInput = {
    contest: contestCreateNestedOneWithoutContestteamcategoryformedalsInput
  }

  export type contestteamcategoryformedalsUncheckedCreateWithoutTeam_categoryInput = {
    cid: number
  }

  export type contestteamcategoryformedalsCreateOrConnectWithoutTeam_categoryInput = {
    where: contestteamcategoryformedalsWhereUniqueInput
    create: XOR<contestteamcategoryformedalsCreateWithoutTeam_categoryInput, contestteamcategoryformedalsUncheckedCreateWithoutTeam_categoryInput>
  }

  export type contestteamcategoryformedalsCreateManyTeam_categoryInputEnvelope = {
    data: contestteamcategoryformedalsCreateManyTeam_categoryInput | contestteamcategoryformedalsCreateManyTeam_categoryInput[]
    skipDuplicates?: boolean
  }

  export type teamCreateWithoutTeam_categoryInput = {
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationCreateNestedManyWithoutTeam_clarification_senderToteamInput
    clarification_clarification_recipientToteam?: clarificationCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    contestteam?: contestteamCreateNestedManyWithoutTeamInput
    queuetask?: queuetaskCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheCreateNestedManyWithoutTeamInput
    submission?: submissionCreateNestedManyWithoutTeamInput
    team_affiliation?: team_affiliationCreateNestedOneWithoutTeamInput
    team_unread?: team_unreadCreateNestedManyWithoutTeamInput
    user?: userCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutTeam_categoryInput = {
    teamid?: number
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    affilid?: number | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_senderToteamInput
    clarification_clarification_recipientToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutTeamInput
    queuetask?: queuetaskUncheckedCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutTeamInput
    submission?: submissionUncheckedCreateNestedManyWithoutTeamInput
    team_unread?: team_unreadUncheckedCreateNestedManyWithoutTeamInput
    user?: userUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutTeam_categoryInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutTeam_categoryInput, teamUncheckedCreateWithoutTeam_categoryInput>
  }

  export type teamCreateManyTeam_categoryInputEnvelope = {
    data: teamCreateManyTeam_categoryInput | teamCreateManyTeam_categoryInput[]
    skipDuplicates?: boolean
  }

  export type contestteamcategoryUpsertWithWhereUniqueWithoutTeam_categoryInput = {
    where: contestteamcategoryWhereUniqueInput
    update: XOR<contestteamcategoryUpdateWithoutTeam_categoryInput, contestteamcategoryUncheckedUpdateWithoutTeam_categoryInput>
    create: XOR<contestteamcategoryCreateWithoutTeam_categoryInput, contestteamcategoryUncheckedCreateWithoutTeam_categoryInput>
  }

  export type contestteamcategoryUpdateWithWhereUniqueWithoutTeam_categoryInput = {
    where: contestteamcategoryWhereUniqueInput
    data: XOR<contestteamcategoryUpdateWithoutTeam_categoryInput, contestteamcategoryUncheckedUpdateWithoutTeam_categoryInput>
  }

  export type contestteamcategoryUpdateManyWithWhereWithoutTeam_categoryInput = {
    where: contestteamcategoryScalarWhereInput
    data: XOR<contestteamcategoryUpdateManyMutationInput, contestteamcategoryUncheckedUpdateManyWithoutTeam_categoryInput>
  }

  export type contestteamcategoryformedalsUpsertWithWhereUniqueWithoutTeam_categoryInput = {
    where: contestteamcategoryformedalsWhereUniqueInput
    update: XOR<contestteamcategoryformedalsUpdateWithoutTeam_categoryInput, contestteamcategoryformedalsUncheckedUpdateWithoutTeam_categoryInput>
    create: XOR<contestteamcategoryformedalsCreateWithoutTeam_categoryInput, contestteamcategoryformedalsUncheckedCreateWithoutTeam_categoryInput>
  }

  export type contestteamcategoryformedalsUpdateWithWhereUniqueWithoutTeam_categoryInput = {
    where: contestteamcategoryformedalsWhereUniqueInput
    data: XOR<contestteamcategoryformedalsUpdateWithoutTeam_categoryInput, contestteamcategoryformedalsUncheckedUpdateWithoutTeam_categoryInput>
  }

  export type contestteamcategoryformedalsUpdateManyWithWhereWithoutTeam_categoryInput = {
    where: contestteamcategoryformedalsScalarWhereInput
    data: XOR<contestteamcategoryformedalsUpdateManyMutationInput, contestteamcategoryformedalsUncheckedUpdateManyWithoutTeam_categoryInput>
  }

  export type teamUpsertWithWhereUniqueWithoutTeam_categoryInput = {
    where: teamWhereUniqueInput
    update: XOR<teamUpdateWithoutTeam_categoryInput, teamUncheckedUpdateWithoutTeam_categoryInput>
    create: XOR<teamCreateWithoutTeam_categoryInput, teamUncheckedCreateWithoutTeam_categoryInput>
  }

  export type teamUpdateWithWhereUniqueWithoutTeam_categoryInput = {
    where: teamWhereUniqueInput
    data: XOR<teamUpdateWithoutTeam_categoryInput, teamUncheckedUpdateWithoutTeam_categoryInput>
  }

  export type teamUpdateManyWithWhereWithoutTeam_categoryInput = {
    where: teamScalarWhereInput
    data: XOR<teamUpdateManyMutationInput, teamUncheckedUpdateManyWithoutTeam_categoryInput>
  }

  export type teamCreateWithoutTeam_unreadInput = {
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationCreateNestedManyWithoutTeam_clarification_senderToteamInput
    clarification_clarification_recipientToteam?: clarificationCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    contestteam?: contestteamCreateNestedManyWithoutTeamInput
    queuetask?: queuetaskCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheCreateNestedManyWithoutTeamInput
    submission?: submissionCreateNestedManyWithoutTeamInput
    team_category?: team_categoryCreateNestedOneWithoutTeamInput
    team_affiliation?: team_affiliationCreateNestedOneWithoutTeamInput
    user?: userCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutTeam_unreadInput = {
    teamid?: number
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    categoryid?: number | null
    affilid?: number | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_senderToteamInput
    clarification_clarification_recipientToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutTeamInput
    queuetask?: queuetaskUncheckedCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutTeamInput
    submission?: submissionUncheckedCreateNestedManyWithoutTeamInput
    user?: userUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutTeam_unreadInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutTeam_unreadInput, teamUncheckedCreateWithoutTeam_unreadInput>
  }

  export type clarificationCreateWithoutTeam_unreadInput = {
    externalid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    jury_member?: string | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
    contest?: contestCreateNestedOneWithoutClarificationInput
    clarification?: clarificationCreateNestedOneWithoutOther_clarificationInput
    other_clarification?: clarificationCreateNestedManyWithoutClarificationInput
    problem?: problemCreateNestedOneWithoutClarificationInput
    team_clarification_senderToteam?: teamCreateNestedOneWithoutClarification_clarification_senderToteamInput
    team_clarification_recipientToteam?: teamCreateNestedOneWithoutClarification_clarification_recipientToteamInput
  }

  export type clarificationUncheckedCreateWithoutTeam_unreadInput = {
    clarid?: number
    externalid?: string | null
    cid?: number | null
    respid?: number | null
    submittime: Decimal | DecimalJsLike | number | string
    sender?: number | null
    recipient?: number | null
    jury_member?: string | null
    probid?: number | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
    other_clarification?: clarificationUncheckedCreateNestedManyWithoutClarificationInput
  }

  export type clarificationCreateOrConnectWithoutTeam_unreadInput = {
    where: clarificationWhereUniqueInput
    create: XOR<clarificationCreateWithoutTeam_unreadInput, clarificationUncheckedCreateWithoutTeam_unreadInput>
  }

  export type teamUpsertWithoutTeam_unreadInput = {
    update: XOR<teamUpdateWithoutTeam_unreadInput, teamUncheckedUpdateWithoutTeam_unreadInput>
    create: XOR<teamCreateWithoutTeam_unreadInput, teamUncheckedCreateWithoutTeam_unreadInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutTeam_unreadInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutTeam_unreadInput, teamUncheckedUpdateWithoutTeam_unreadInput>
  }

  export type teamUpdateWithoutTeam_unreadInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    clarification_clarification_recipientToteam?: clarificationUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    contestteam?: contestteamUpdateManyWithoutTeamNestedInput
    queuetask?: queuetaskUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUpdateManyWithoutTeamNestedInput
    submission?: submissionUpdateManyWithoutTeamNestedInput
    team_category?: team_categoryUpdateOneWithoutTeamNestedInput
    team_affiliation?: team_affiliationUpdateOneWithoutTeamNestedInput
    user?: userUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutTeam_unreadInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    categoryid?: NullableIntFieldUpdateOperationsInput | number | null
    affilid?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    clarification_clarification_recipientToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutTeamNestedInput
    queuetask?: queuetaskUncheckedUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutTeamNestedInput
    submission?: submissionUncheckedUpdateManyWithoutTeamNestedInput
    user?: userUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type clarificationUpsertWithoutTeam_unreadInput = {
    update: XOR<clarificationUpdateWithoutTeam_unreadInput, clarificationUncheckedUpdateWithoutTeam_unreadInput>
    create: XOR<clarificationCreateWithoutTeam_unreadInput, clarificationUncheckedCreateWithoutTeam_unreadInput>
    where?: clarificationWhereInput
  }

  export type clarificationUpdateToOneWithWhereWithoutTeam_unreadInput = {
    where?: clarificationWhereInput
    data: XOR<clarificationUpdateWithoutTeam_unreadInput, clarificationUncheckedUpdateWithoutTeam_unreadInput>
  }

  export type clarificationUpdateWithoutTeam_unreadInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    contest?: contestUpdateOneWithoutClarificationNestedInput
    clarification?: clarificationUpdateOneWithoutOther_clarificationNestedInput
    other_clarification?: clarificationUpdateManyWithoutClarificationNestedInput
    problem?: problemUpdateOneWithoutClarificationNestedInput
    team_clarification_senderToteam?: teamUpdateOneWithoutClarification_clarification_senderToteamNestedInput
    team_clarification_recipientToteam?: teamUpdateOneWithoutClarification_clarification_recipientToteamNestedInput
  }

  export type clarificationUncheckedUpdateWithoutTeam_unreadInput = {
    clarid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    respid?: NullableIntFieldUpdateOperationsInput | number | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sender?: NullableIntFieldUpdateOperationsInput | number | null
    recipient?: NullableIntFieldUpdateOperationsInput | number | null
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    other_clarification?: clarificationUncheckedUpdateManyWithoutClarificationNestedInput
  }

  export type external_runCreateWithoutTestcaseInput = {
    externalid?: string | null
    result: string
    endtime: Decimal | DecimalJsLike | number | string
    runtime: number
    external_judgement?: external_judgementCreateNestedOneWithoutExternal_runInput
    contest?: contestCreateNestedOneWithoutExternal_runInput
  }

  export type external_runUncheckedCreateWithoutTestcaseInput = {
    extrunid?: number
    extjudgementid?: number | null
    externalid?: string | null
    cid?: number | null
    result: string
    endtime: Decimal | DecimalJsLike | number | string
    runtime: number
  }

  export type external_runCreateOrConnectWithoutTestcaseInput = {
    where: external_runWhereUniqueInput
    create: XOR<external_runCreateWithoutTestcaseInput, external_runUncheckedCreateWithoutTestcaseInput>
  }

  export type external_runCreateManyTestcaseInputEnvelope = {
    data: external_runCreateManyTestcaseInput | external_runCreateManyTestcaseInput[]
    skipDuplicates?: boolean
  }

  export type judging_runCreateWithoutTestcaseInput = {
    runresult?: string | null
    runtime?: number | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    judgetask?: judgetaskCreateNestedOneWithoutJudging_runInput
    judging?: judgingCreateNestedOneWithoutJudging_runInput
    judging_run_output?: judging_run_outputCreateNestedOneWithoutJudging_runInput
  }

  export type judging_runUncheckedCreateWithoutTestcaseInput = {
    runid?: number
    judgingid?: number | null
    runresult?: string | null
    runtime?: number | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    judgetaskid?: number | null
    judging_run_output?: judging_run_outputUncheckedCreateNestedOneWithoutJudging_runInput
  }

  export type judging_runCreateOrConnectWithoutTestcaseInput = {
    where: judging_runWhereUniqueInput
    create: XOR<judging_runCreateWithoutTestcaseInput, judging_runUncheckedCreateWithoutTestcaseInput>
  }

  export type judging_runCreateManyTestcaseInputEnvelope = {
    data: judging_runCreateManyTestcaseInput | judging_runCreateManyTestcaseInput[]
    skipDuplicates?: boolean
  }

  export type problemCreateWithoutTestcaseInput = {
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
    clarification?: clarificationCreateNestedManyWithoutProblemInput
    contestproblem?: contestproblemCreateNestedManyWithoutProblemInput
    executable_problem_special_runToexecutable?: executableCreateNestedOneWithoutProblem_problem_special_runToexecutableInput
    executable_problem_special_compareToexecutable?: executableCreateNestedOneWithoutProblem_problem_special_compareToexecutableInput
    problem_attachment?: problem_attachmentCreateNestedManyWithoutProblemInput
    scorecache?: scorecacheCreateNestedManyWithoutProblemInput
    submission?: submissionCreateNestedManyWithoutProblemInput
  }

  export type problemUncheckedCreateWithoutTestcaseInput = {
    probid?: number
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_run?: string | null
    special_compare?: string | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
    clarification?: clarificationUncheckedCreateNestedManyWithoutProblemInput
    contestproblem?: contestproblemUncheckedCreateNestedManyWithoutProblemInput
    problem_attachment?: problem_attachmentUncheckedCreateNestedManyWithoutProblemInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutProblemInput
    submission?: submissionUncheckedCreateNestedManyWithoutProblemInput
  }

  export type problemCreateOrConnectWithoutTestcaseInput = {
    where: problemWhereUniqueInput
    create: XOR<problemCreateWithoutTestcaseInput, problemUncheckedCreateWithoutTestcaseInput>
  }

  export type testcase_contentCreateWithoutTestcaseInput = {
    input?: Buffer | null
    output?: Buffer | null
    image?: Buffer | null
    image_thumb?: Buffer | null
  }

  export type testcase_contentUncheckedCreateWithoutTestcaseInput = {
    input?: Buffer | null
    output?: Buffer | null
    image?: Buffer | null
    image_thumb?: Buffer | null
    tc_contentid?: number
  }

  export type testcase_contentCreateOrConnectWithoutTestcaseInput = {
    where: testcase_contentWhereUniqueInput
    create: XOR<testcase_contentCreateWithoutTestcaseInput, testcase_contentUncheckedCreateWithoutTestcaseInput>
  }

  export type testcase_contentCreateManyTestcaseInputEnvelope = {
    data: testcase_contentCreateManyTestcaseInput | testcase_contentCreateManyTestcaseInput[]
    skipDuplicates?: boolean
  }

  export type external_runUpsertWithWhereUniqueWithoutTestcaseInput = {
    where: external_runWhereUniqueInput
    update: XOR<external_runUpdateWithoutTestcaseInput, external_runUncheckedUpdateWithoutTestcaseInput>
    create: XOR<external_runCreateWithoutTestcaseInput, external_runUncheckedCreateWithoutTestcaseInput>
  }

  export type external_runUpdateWithWhereUniqueWithoutTestcaseInput = {
    where: external_runWhereUniqueInput
    data: XOR<external_runUpdateWithoutTestcaseInput, external_runUncheckedUpdateWithoutTestcaseInput>
  }

  export type external_runUpdateManyWithWhereWithoutTestcaseInput = {
    where: external_runScalarWhereInput
    data: XOR<external_runUpdateManyMutationInput, external_runUncheckedUpdateManyWithoutTestcaseInput>
  }

  export type judging_runUpsertWithWhereUniqueWithoutTestcaseInput = {
    where: judging_runWhereUniqueInput
    update: XOR<judging_runUpdateWithoutTestcaseInput, judging_runUncheckedUpdateWithoutTestcaseInput>
    create: XOR<judging_runCreateWithoutTestcaseInput, judging_runUncheckedCreateWithoutTestcaseInput>
  }

  export type judging_runUpdateWithWhereUniqueWithoutTestcaseInput = {
    where: judging_runWhereUniqueInput
    data: XOR<judging_runUpdateWithoutTestcaseInput, judging_runUncheckedUpdateWithoutTestcaseInput>
  }

  export type judging_runUpdateManyWithWhereWithoutTestcaseInput = {
    where: judging_runScalarWhereInput
    data: XOR<judging_runUpdateManyMutationInput, judging_runUncheckedUpdateManyWithoutTestcaseInput>
  }

  export type problemUpsertWithoutTestcaseInput = {
    update: XOR<problemUpdateWithoutTestcaseInput, problemUncheckedUpdateWithoutTestcaseInput>
    create: XOR<problemCreateWithoutTestcaseInput, problemUncheckedCreateWithoutTestcaseInput>
    where?: problemWhereInput
  }

  export type problemUpdateToOneWithWhereWithoutTestcaseInput = {
    where?: problemWhereInput
    data: XOR<problemUpdateWithoutTestcaseInput, problemUncheckedUpdateWithoutTestcaseInput>
  }

  export type problemUpdateWithoutTestcaseInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutProblemNestedInput
    contestproblem?: contestproblemUpdateManyWithoutProblemNestedInput
    executable_problem_special_runToexecutable?: executableUpdateOneWithoutProblem_problem_special_runToexecutableNestedInput
    executable_problem_special_compareToexecutable?: executableUpdateOneWithoutProblem_problem_special_compareToexecutableNestedInput
    problem_attachment?: problem_attachmentUpdateManyWithoutProblemNestedInput
    scorecache?: scorecacheUpdateManyWithoutProblemNestedInput
    submission?: submissionUpdateManyWithoutProblemNestedInput
  }

  export type problemUncheckedUpdateWithoutTestcaseInput = {
    probid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_run?: NullableStringFieldUpdateOperationsInput | string | null
    special_compare?: NullableStringFieldUpdateOperationsInput | string | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutProblemNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutProblemNestedInput
    problem_attachment?: problem_attachmentUncheckedUpdateManyWithoutProblemNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutProblemNestedInput
    submission?: submissionUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type testcase_contentUpsertWithWhereUniqueWithoutTestcaseInput = {
    where: testcase_contentWhereUniqueInput
    update: XOR<testcase_contentUpdateWithoutTestcaseInput, testcase_contentUncheckedUpdateWithoutTestcaseInput>
    create: XOR<testcase_contentCreateWithoutTestcaseInput, testcase_contentUncheckedCreateWithoutTestcaseInput>
  }

  export type testcase_contentUpdateWithWhereUniqueWithoutTestcaseInput = {
    where: testcase_contentWhereUniqueInput
    data: XOR<testcase_contentUpdateWithoutTestcaseInput, testcase_contentUncheckedUpdateWithoutTestcaseInput>
  }

  export type testcase_contentUpdateManyWithWhereWithoutTestcaseInput = {
    where: testcase_contentScalarWhereInput
    data: XOR<testcase_contentUpdateManyMutationInput, testcase_contentUncheckedUpdateManyWithoutTestcaseInput>
  }

  export type testcase_contentScalarWhereInput = {
    AND?: testcase_contentScalarWhereInput | testcase_contentScalarWhereInput[]
    OR?: testcase_contentScalarWhereInput[]
    NOT?: testcase_contentScalarWhereInput | testcase_contentScalarWhereInput[]
    testcaseid?: IntNullableFilter<"testcase_content"> | number | null
    input?: BytesNullableFilter<"testcase_content"> | Buffer | null
    output?: BytesNullableFilter<"testcase_content"> | Buffer | null
    image?: BytesNullableFilter<"testcase_content"> | Buffer | null
    image_thumb?: BytesNullableFilter<"testcase_content"> | Buffer | null
    tc_contentid?: IntFilter<"testcase_content"> | number
  }

  export type testcaseCreateWithoutTestcase_contentInput = {
    md5sum_input?: string | null
    md5sum_output?: string | null
    ranknumber: number
    description?: Buffer | null
    image_type?: string | null
    sample?: boolean
    orig_input_filename?: string | null
    deleted?: boolean
    external_run?: external_runCreateNestedManyWithoutTestcaseInput
    judging_run?: judging_runCreateNestedManyWithoutTestcaseInput
    problem?: problemCreateNestedOneWithoutTestcaseInput
  }

  export type testcaseUncheckedCreateWithoutTestcase_contentInput = {
    testcaseid?: number
    md5sum_input?: string | null
    md5sum_output?: string | null
    probid?: number | null
    ranknumber: number
    description?: Buffer | null
    image_type?: string | null
    sample?: boolean
    orig_input_filename?: string | null
    deleted?: boolean
    external_run?: external_runUncheckedCreateNestedManyWithoutTestcaseInput
    judging_run?: judging_runUncheckedCreateNestedManyWithoutTestcaseInput
  }

  export type testcaseCreateOrConnectWithoutTestcase_contentInput = {
    where: testcaseWhereUniqueInput
    create: XOR<testcaseCreateWithoutTestcase_contentInput, testcaseUncheckedCreateWithoutTestcase_contentInput>
  }

  export type testcaseUpsertWithoutTestcase_contentInput = {
    update: XOR<testcaseUpdateWithoutTestcase_contentInput, testcaseUncheckedUpdateWithoutTestcase_contentInput>
    create: XOR<testcaseCreateWithoutTestcase_contentInput, testcaseUncheckedCreateWithoutTestcase_contentInput>
    where?: testcaseWhereInput
  }

  export type testcaseUpdateToOneWithWhereWithoutTestcase_contentInput = {
    where?: testcaseWhereInput
    data: XOR<testcaseUpdateWithoutTestcase_contentInput, testcaseUncheckedUpdateWithoutTestcase_contentInput>
  }

  export type testcaseUpdateWithoutTestcase_contentInput = {
    md5sum_input?: NullableStringFieldUpdateOperationsInput | string | null
    md5sum_output?: NullableStringFieldUpdateOperationsInput | string | null
    ranknumber?: IntFieldUpdateOperationsInput | number
    description?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image_type?: NullableStringFieldUpdateOperationsInput | string | null
    sample?: BoolFieldUpdateOperationsInput | boolean
    orig_input_filename?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    external_run?: external_runUpdateManyWithoutTestcaseNestedInput
    judging_run?: judging_runUpdateManyWithoutTestcaseNestedInput
    problem?: problemUpdateOneWithoutTestcaseNestedInput
  }

  export type testcaseUncheckedUpdateWithoutTestcase_contentInput = {
    testcaseid?: IntFieldUpdateOperationsInput | number
    md5sum_input?: NullableStringFieldUpdateOperationsInput | string | null
    md5sum_output?: NullableStringFieldUpdateOperationsInput | string | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    ranknumber?: IntFieldUpdateOperationsInput | number
    description?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image_type?: NullableStringFieldUpdateOperationsInput | string | null
    sample?: BoolFieldUpdateOperationsInput | boolean
    orig_input_filename?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    external_run?: external_runUncheckedUpdateManyWithoutTestcaseNestedInput
    judging_run?: judging_runUncheckedUpdateManyWithoutTestcaseNestedInput
  }

  export type immutable_executableCreateWithoutUserInput = {
    hash?: string | null
    executable?: executableCreateNestedOneWithoutImmutable_executableInput
    executable_file?: executable_fileCreateNestedManyWithoutImmutable_executableInput
  }

  export type immutable_executableUncheckedCreateWithoutUserInput = {
    immutable_execid?: number
    hash?: string | null
    executable?: executableUncheckedCreateNestedOneWithoutImmutable_executableInput
    executable_file?: executable_fileUncheckedCreateNestedManyWithoutImmutable_executableInput
  }

  export type immutable_executableCreateOrConnectWithoutUserInput = {
    where: immutable_executableWhereUniqueInput
    create: XOR<immutable_executableCreateWithoutUserInput, immutable_executableUncheckedCreateWithoutUserInput>
  }

  export type immutable_executableCreateManyUserInputEnvelope = {
    data: immutable_executableCreateManyUserInput | immutable_executableCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type rejudgingCreateWithoutUser_rejudging_userid_startTouserInput = {
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    reason: string
    valid?: boolean
    auto_apply?: boolean
    repeat?: number | null
    judging?: judgingCreateNestedManyWithoutRejudgingInput
    rejudging?: rejudgingCreateNestedOneWithoutOther_rejudgingInput
    other_rejudging?: rejudgingCreateNestedManyWithoutRejudgingInput
    user_rejudging_userid_finishTouser?: userCreateNestedOneWithoutRejudging_rejudging_userid_finishTouserInput
    submission?: submissionCreateNestedManyWithoutRejudgingInput
  }

  export type rejudgingUncheckedCreateWithoutUser_rejudging_userid_startTouserInput = {
    rejudgingid?: number
    userid_finish?: number | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    reason: string
    valid?: boolean
    auto_apply?: boolean
    repeat?: number | null
    repeat_rejudgingid?: number | null
    judging?: judgingUncheckedCreateNestedManyWithoutRejudgingInput
    other_rejudging?: rejudgingUncheckedCreateNestedManyWithoutRejudgingInput
    submission?: submissionUncheckedCreateNestedManyWithoutRejudgingInput
  }

  export type rejudgingCreateOrConnectWithoutUser_rejudging_userid_startTouserInput = {
    where: rejudgingWhereUniqueInput
    create: XOR<rejudgingCreateWithoutUser_rejudging_userid_startTouserInput, rejudgingUncheckedCreateWithoutUser_rejudging_userid_startTouserInput>
  }

  export type rejudgingCreateManyUser_rejudging_userid_startTouserInputEnvelope = {
    data: rejudgingCreateManyUser_rejudging_userid_startTouserInput | rejudgingCreateManyUser_rejudging_userid_startTouserInput[]
    skipDuplicates?: boolean
  }

  export type rejudgingCreateWithoutUser_rejudging_userid_finishTouserInput = {
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    reason: string
    valid?: boolean
    auto_apply?: boolean
    repeat?: number | null
    judging?: judgingCreateNestedManyWithoutRejudgingInput
    rejudging?: rejudgingCreateNestedOneWithoutOther_rejudgingInput
    other_rejudging?: rejudgingCreateNestedManyWithoutRejudgingInput
    user_rejudging_userid_startTouser?: userCreateNestedOneWithoutRejudging_rejudging_userid_startTouserInput
    submission?: submissionCreateNestedManyWithoutRejudgingInput
  }

  export type rejudgingUncheckedCreateWithoutUser_rejudging_userid_finishTouserInput = {
    rejudgingid?: number
    userid_start?: number | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    reason: string
    valid?: boolean
    auto_apply?: boolean
    repeat?: number | null
    repeat_rejudgingid?: number | null
    judging?: judgingUncheckedCreateNestedManyWithoutRejudgingInput
    other_rejudging?: rejudgingUncheckedCreateNestedManyWithoutRejudgingInput
    submission?: submissionUncheckedCreateNestedManyWithoutRejudgingInput
  }

  export type rejudgingCreateOrConnectWithoutUser_rejudging_userid_finishTouserInput = {
    where: rejudgingWhereUniqueInput
    create: XOR<rejudgingCreateWithoutUser_rejudging_userid_finishTouserInput, rejudgingUncheckedCreateWithoutUser_rejudging_userid_finishTouserInput>
  }

  export type rejudgingCreateManyUser_rejudging_userid_finishTouserInputEnvelope = {
    data: rejudgingCreateManyUser_rejudging_userid_finishTouserInput | rejudgingCreateManyUser_rejudging_userid_finishTouserInput[]
    skipDuplicates?: boolean
  }

  export type submissionCreateWithoutUserInput = {
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementCreateNestedManyWithoutSubmissionInput
    judging?: judgingCreateNestedManyWithoutSubmissionInput
    contest?: contestCreateNestedOneWithoutSubmissionInput
    team?: teamCreateNestedOneWithoutSubmissionInput
    problem?: problemCreateNestedOneWithoutSubmissionInput
    language?: languageCreateNestedOneWithoutSubmissionInput
    submission?: submissionCreateNestedOneWithoutOther_submissionInput
    other_submission?: submissionCreateNestedManyWithoutSubmissionInput
    rejudging?: rejudgingCreateNestedOneWithoutSubmissionInput
    contestproblem?: contestproblemCreateNestedOneWithoutSubmissionInput
    submission_file?: submission_fileCreateNestedManyWithoutSubmissionInput
  }

  export type submissionUncheckedCreateWithoutUserInput = {
    submitid?: number
    origsubmitid?: number | null
    cid?: number | null
    teamid?: number | null
    probid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
    balloon?: balloonUncheckedCreateNestedManyWithoutSubmissionInput
    external_judgement?: external_judgementUncheckedCreateNestedManyWithoutSubmissionInput
    judging?: judgingUncheckedCreateNestedManyWithoutSubmissionInput
    other_submission?: submissionUncheckedCreateNestedManyWithoutSubmissionInput
    submission_file?: submission_fileUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type submissionCreateOrConnectWithoutUserInput = {
    where: submissionWhereUniqueInput
    create: XOR<submissionCreateWithoutUserInput, submissionUncheckedCreateWithoutUserInput>
  }

  export type submissionCreateManyUserInputEnvelope = {
    data: submissionCreateManyUserInput | submissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type teamCreateWithoutUserInput = {
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationCreateNestedManyWithoutTeam_clarification_senderToteamInput
    clarification_clarification_recipientToteam?: clarificationCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    contestteam?: contestteamCreateNestedManyWithoutTeamInput
    queuetask?: queuetaskCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheCreateNestedManyWithoutTeamInput
    submission?: submissionCreateNestedManyWithoutTeamInput
    team_category?: team_categoryCreateNestedOneWithoutTeamInput
    team_affiliation?: team_affiliationCreateNestedOneWithoutTeamInput
    team_unread?: team_unreadCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutUserInput = {
    teamid?: number
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    categoryid?: number | null
    affilid?: number | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
    clarification_clarification_senderToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_senderToteamInput
    clarification_clarification_recipientToteam?: clarificationUncheckedCreateNestedManyWithoutTeam_clarification_recipientToteamInput
    contestteam?: contestteamUncheckedCreateNestedManyWithoutTeamInput
    queuetask?: queuetaskUncheckedCreateNestedManyWithoutTeamInput
    rankcache?: rankcacheUncheckedCreateNestedManyWithoutTeamInput
    scorecache?: scorecacheUncheckedCreateNestedManyWithoutTeamInput
    submission?: submissionUncheckedCreateNestedManyWithoutTeamInput
    team_unread?: team_unreadUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutUserInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutUserInput, teamUncheckedCreateWithoutUserInput>
  }

  export type userroleCreateWithoutUserInput = {
    role: roleCreateNestedOneWithoutUserroleInput
  }

  export type userroleUncheckedCreateWithoutUserInput = {
    roleid: number
  }

  export type userroleCreateOrConnectWithoutUserInput = {
    where: userroleWhereUniqueInput
    create: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput>
  }

  export type userroleCreateManyUserInputEnvelope = {
    data: userroleCreateManyUserInput | userroleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type immutable_executableUpsertWithWhereUniqueWithoutUserInput = {
    where: immutable_executableWhereUniqueInput
    update: XOR<immutable_executableUpdateWithoutUserInput, immutable_executableUncheckedUpdateWithoutUserInput>
    create: XOR<immutable_executableCreateWithoutUserInput, immutable_executableUncheckedCreateWithoutUserInput>
  }

  export type immutable_executableUpdateWithWhereUniqueWithoutUserInput = {
    where: immutable_executableWhereUniqueInput
    data: XOR<immutable_executableUpdateWithoutUserInput, immutable_executableUncheckedUpdateWithoutUserInput>
  }

  export type immutable_executableUpdateManyWithWhereWithoutUserInput = {
    where: immutable_executableScalarWhereInput
    data: XOR<immutable_executableUpdateManyMutationInput, immutable_executableUncheckedUpdateManyWithoutUserInput>
  }

  export type immutable_executableScalarWhereInput = {
    AND?: immutable_executableScalarWhereInput | immutable_executableScalarWhereInput[]
    OR?: immutable_executableScalarWhereInput[]
    NOT?: immutable_executableScalarWhereInput | immutable_executableScalarWhereInput[]
    immutable_execid?: IntFilter<"immutable_executable"> | number
    userid?: IntNullableFilter<"immutable_executable"> | number | null
    hash?: StringNullableFilter<"immutable_executable"> | string | null
  }

  export type rejudgingUpsertWithWhereUniqueWithoutUser_rejudging_userid_startTouserInput = {
    where: rejudgingWhereUniqueInput
    update: XOR<rejudgingUpdateWithoutUser_rejudging_userid_startTouserInput, rejudgingUncheckedUpdateWithoutUser_rejudging_userid_startTouserInput>
    create: XOR<rejudgingCreateWithoutUser_rejudging_userid_startTouserInput, rejudgingUncheckedCreateWithoutUser_rejudging_userid_startTouserInput>
  }

  export type rejudgingUpdateWithWhereUniqueWithoutUser_rejudging_userid_startTouserInput = {
    where: rejudgingWhereUniqueInput
    data: XOR<rejudgingUpdateWithoutUser_rejudging_userid_startTouserInput, rejudgingUncheckedUpdateWithoutUser_rejudging_userid_startTouserInput>
  }

  export type rejudgingUpdateManyWithWhereWithoutUser_rejudging_userid_startTouserInput = {
    where: rejudgingScalarWhereInput
    data: XOR<rejudgingUpdateManyMutationInput, rejudgingUncheckedUpdateManyWithoutUser_rejudging_userid_startTouserInput>
  }

  export type rejudgingUpsertWithWhereUniqueWithoutUser_rejudging_userid_finishTouserInput = {
    where: rejudgingWhereUniqueInput
    update: XOR<rejudgingUpdateWithoutUser_rejudging_userid_finishTouserInput, rejudgingUncheckedUpdateWithoutUser_rejudging_userid_finishTouserInput>
    create: XOR<rejudgingCreateWithoutUser_rejudging_userid_finishTouserInput, rejudgingUncheckedCreateWithoutUser_rejudging_userid_finishTouserInput>
  }

  export type rejudgingUpdateWithWhereUniqueWithoutUser_rejudging_userid_finishTouserInput = {
    where: rejudgingWhereUniqueInput
    data: XOR<rejudgingUpdateWithoutUser_rejudging_userid_finishTouserInput, rejudgingUncheckedUpdateWithoutUser_rejudging_userid_finishTouserInput>
  }

  export type rejudgingUpdateManyWithWhereWithoutUser_rejudging_userid_finishTouserInput = {
    where: rejudgingScalarWhereInput
    data: XOR<rejudgingUpdateManyMutationInput, rejudgingUncheckedUpdateManyWithoutUser_rejudging_userid_finishTouserInput>
  }

  export type submissionUpsertWithWhereUniqueWithoutUserInput = {
    where: submissionWhereUniqueInput
    update: XOR<submissionUpdateWithoutUserInput, submissionUncheckedUpdateWithoutUserInput>
    create: XOR<submissionCreateWithoutUserInput, submissionUncheckedCreateWithoutUserInput>
  }

  export type submissionUpdateWithWhereUniqueWithoutUserInput = {
    where: submissionWhereUniqueInput
    data: XOR<submissionUpdateWithoutUserInput, submissionUncheckedUpdateWithoutUserInput>
  }

  export type submissionUpdateManyWithWhereWithoutUserInput = {
    where: submissionScalarWhereInput
    data: XOR<submissionUpdateManyMutationInput, submissionUncheckedUpdateManyWithoutUserInput>
  }

  export type teamUpsertWithoutUserInput = {
    update: XOR<teamUpdateWithoutUserInput, teamUncheckedUpdateWithoutUserInput>
    create: XOR<teamCreateWithoutUserInput, teamUncheckedCreateWithoutUserInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutUserInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutUserInput, teamUncheckedUpdateWithoutUserInput>
  }

  export type teamUpdateWithoutUserInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    clarification_clarification_recipientToteam?: clarificationUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    contestteam?: contestteamUpdateManyWithoutTeamNestedInput
    queuetask?: queuetaskUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUpdateManyWithoutTeamNestedInput
    submission?: submissionUpdateManyWithoutTeamNestedInput
    team_category?: team_categoryUpdateOneWithoutTeamNestedInput
    team_affiliation?: team_affiliationUpdateOneWithoutTeamNestedInput
    team_unread?: team_unreadUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutUserInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    categoryid?: NullableIntFieldUpdateOperationsInput | number | null
    affilid?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    clarification_clarification_recipientToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutTeamNestedInput
    queuetask?: queuetaskUncheckedUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutTeamNestedInput
    submission?: submissionUncheckedUpdateManyWithoutTeamNestedInput
    team_unread?: team_unreadUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type userroleUpsertWithWhereUniqueWithoutUserInput = {
    where: userroleWhereUniqueInput
    update: XOR<userroleUpdateWithoutUserInput, userroleUncheckedUpdateWithoutUserInput>
    create: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput>
  }

  export type userroleUpdateWithWhereUniqueWithoutUserInput = {
    where: userroleWhereUniqueInput
    data: XOR<userroleUpdateWithoutUserInput, userroleUncheckedUpdateWithoutUserInput>
  }

  export type userroleUpdateManyWithWhereWithoutUserInput = {
    where: userroleScalarWhereInput
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyWithoutUserInput>
  }

  export type userCreateWithoutUserroleInput = {
    externalid?: string | null
    username: string
    name: string
    email?: string | null
    last_login?: Decimal | DecimalJsLike | number | string | null
    last_api_login?: Decimal | DecimalJsLike | number | string | null
    first_login?: Decimal | DecimalJsLike | number | string | null
    last_ip_address?: string | null
    password?: string | null
    ip_address?: string | null
    enabled?: boolean
    immutable_executable?: immutable_executableCreateNestedManyWithoutUserInput
    rejudging_rejudging_userid_startTouser?: rejudgingCreateNestedManyWithoutUser_rejudging_userid_startTouserInput
    rejudging_rejudging_userid_finishTouser?: rejudgingCreateNestedManyWithoutUser_rejudging_userid_finishTouserInput
    submission?: submissionCreateNestedManyWithoutUserInput
    team?: teamCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutUserroleInput = {
    userid?: number
    externalid?: string | null
    username: string
    name: string
    email?: string | null
    last_login?: Decimal | DecimalJsLike | number | string | null
    last_api_login?: Decimal | DecimalJsLike | number | string | null
    first_login?: Decimal | DecimalJsLike | number | string | null
    last_ip_address?: string | null
    password?: string | null
    ip_address?: string | null
    enabled?: boolean
    teamid?: number | null
    immutable_executable?: immutable_executableUncheckedCreateNestedManyWithoutUserInput
    rejudging_rejudging_userid_startTouser?: rejudgingUncheckedCreateNestedManyWithoutUser_rejudging_userid_startTouserInput
    rejudging_rejudging_userid_finishTouser?: rejudgingUncheckedCreateNestedManyWithoutUser_rejudging_userid_finishTouserInput
    submission?: submissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUserroleInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUserroleInput, userUncheckedCreateWithoutUserroleInput>
  }

  export type roleCreateWithoutUserroleInput = {
    role: string
    description: string
  }

  export type roleUncheckedCreateWithoutUserroleInput = {
    roleid?: number
    role: string
    description: string
  }

  export type roleCreateOrConnectWithoutUserroleInput = {
    where: roleWhereUniqueInput
    create: XOR<roleCreateWithoutUserroleInput, roleUncheckedCreateWithoutUserroleInput>
  }

  export type userUpsertWithoutUserroleInput = {
    update: XOR<userUpdateWithoutUserroleInput, userUncheckedUpdateWithoutUserroleInput>
    create: XOR<userCreateWithoutUserroleInput, userUncheckedCreateWithoutUserroleInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUserroleInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUserroleInput, userUncheckedUpdateWithoutUserroleInput>
  }

  export type userUpdateWithoutUserroleInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_api_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    immutable_executable?: immutable_executableUpdateManyWithoutUserNestedInput
    rejudging_rejudging_userid_startTouser?: rejudgingUpdateManyWithoutUser_rejudging_userid_startTouserNestedInput
    rejudging_rejudging_userid_finishTouser?: rejudgingUpdateManyWithoutUser_rejudging_userid_finishTouserNestedInput
    submission?: submissionUpdateManyWithoutUserNestedInput
    team?: teamUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUserroleInput = {
    userid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_api_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    immutable_executable?: immutable_executableUncheckedUpdateManyWithoutUserNestedInput
    rejudging_rejudging_userid_startTouser?: rejudgingUncheckedUpdateManyWithoutUser_rejudging_userid_startTouserNestedInput
    rejudging_rejudging_userid_finishTouser?: rejudgingUncheckedUpdateManyWithoutUser_rejudging_userid_finishTouserNestedInput
    submission?: submissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type roleUpsertWithoutUserroleInput = {
    update: XOR<roleUpdateWithoutUserroleInput, roleUncheckedUpdateWithoutUserroleInput>
    create: XOR<roleCreateWithoutUserroleInput, roleUncheckedCreateWithoutUserroleInput>
    where?: roleWhereInput
  }

  export type roleUpdateToOneWithWhereWithoutUserroleInput = {
    where?: roleWhereInput
    data: XOR<roleUpdateWithoutUserroleInput, roleUncheckedUpdateWithoutUserroleInput>
  }

  export type roleUpdateWithoutUserroleInput = {
    role?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type roleUncheckedUpdateWithoutUserroleInput = {
    roleid?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type clarificationCreateManyClarificationInput = {
    clarid?: number
    externalid?: string | null
    cid?: number | null
    submittime: Decimal | DecimalJsLike | number | string
    sender?: number | null
    recipient?: number | null
    jury_member?: string | null
    probid?: number | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
  }

  export type team_unreadCreateManyClarificationInput = {
    teamid: number
  }

  export type clarificationUpdateWithoutClarificationInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    contest?: contestUpdateOneWithoutClarificationNestedInput
    other_clarification?: clarificationUpdateManyWithoutClarificationNestedInput
    problem?: problemUpdateOneWithoutClarificationNestedInput
    team_clarification_senderToteam?: teamUpdateOneWithoutClarification_clarification_senderToteamNestedInput
    team_clarification_recipientToteam?: teamUpdateOneWithoutClarification_clarification_recipientToteamNestedInput
    team_unread?: team_unreadUpdateManyWithoutClarificationNestedInput
  }

  export type clarificationUncheckedUpdateWithoutClarificationInput = {
    clarid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sender?: NullableIntFieldUpdateOperationsInput | number | null
    recipient?: NullableIntFieldUpdateOperationsInput | number | null
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    other_clarification?: clarificationUncheckedUpdateManyWithoutClarificationNestedInput
    team_unread?: team_unreadUncheckedUpdateManyWithoutClarificationNestedInput
  }

  export type clarificationUncheckedUpdateManyWithoutClarificationInput = {
    clarid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sender?: NullableIntFieldUpdateOperationsInput | number | null
    recipient?: NullableIntFieldUpdateOperationsInput | number | null
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
  }

  export type team_unreadUpdateWithoutClarificationInput = {
    team?: teamUpdateOneRequiredWithoutTeam_unreadNestedInput
  }

  export type team_unreadUncheckedUpdateWithoutClarificationInput = {
    teamid?: IntFieldUpdateOperationsInput | number
  }

  export type team_unreadUncheckedUpdateManyWithoutClarificationInput = {
    teamid?: IntFieldUpdateOperationsInput | number
  }

  export type clarificationCreateManyContestInput = {
    clarid?: number
    externalid?: string | null
    respid?: number | null
    submittime: Decimal | DecimalJsLike | number | string
    sender?: number | null
    recipient?: number | null
    jury_member?: string | null
    probid?: number | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
  }

  export type contestproblemCreateManyContestInput = {
    probid: number
    shortname: string
    points?: number
    allow_submit?: boolean
    allow_judge?: boolean
    color?: string | null
    lazy_eval_results?: number | null
  }

  export type contestteamCreateManyContestInput = {
    teamid: number
  }

  export type contestteamcategoryCreateManyContestInput = {
    categoryid: number
  }

  export type contestteamcategoryformedalsCreateManyContestInput = {
    categoryid: number
  }

  export type eventCreateManyContestInput = {
    eventid?: number
    eventtime: Decimal | DecimalJsLike | number | string
    endpointtype: string
    endpointid: string
    action: string
    content: Buffer
  }

  export type external_judgementCreateManyContestInput = {
    extjudgementid?: number
    externalid?: string | null
    submitid?: number | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    valid?: boolean
  }

  export type external_runCreateManyContestInput = {
    extrunid?: number
    extjudgementid?: number | null
    testcaseid?: number | null
    externalid?: string | null
    result: string
    endtime: Decimal | DecimalJsLike | number | string
    runtime: number
  }

  export type internal_errorCreateManyContestInput = {
    errorid?: number
    judgingid?: number | null
    description: string
    judgehostlog: string
    time: Decimal | DecimalJsLike | number | string
    disabled: string
    status?: $Enums.internal_error_status
  }

  export type judgingCreateManyContestInput = {
    judgingid?: number
    submitid?: number | null
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    rejudgingid?: number | null
    prevjudgingid?: number | null
    judge_completely?: boolean
    errorid?: number | null
    uuid: string
    metadata?: Buffer | null
  }

  export type rankcacheCreateManyContestInput = {
    teamid: number
    points_restricted?: number
    totaltime_restricted?: number
    points_public?: number
    totaltime_public?: number
  }

  export type removed_intervalCreateManyContestInput = {
    intervalid?: number
    starttime: Decimal | DecimalJsLike | number | string
    endtime: Decimal | DecimalJsLike | number | string
    starttime_string: string
    endtime_string: string
  }

  export type scorecacheCreateManyContestInput = {
    teamid: number
    probid: number
    submissions_restricted?: number
    pending_restricted?: number
    solvetime_restricted?: Decimal | DecimalJsLike | number | string
    is_correct_restricted?: boolean
    submissions_public?: number
    pending_public?: number
    solvetime_public?: Decimal | DecimalJsLike | number | string
    is_correct_public?: boolean
    is_first_to_solve?: boolean
  }

  export type submissionCreateManyContestInput = {
    submitid?: number
    origsubmitid?: number | null
    teamid?: number | null
    userid?: number | null
    probid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
  }

  export type clarificationUpdateWithoutContestInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    clarification?: clarificationUpdateOneWithoutOther_clarificationNestedInput
    other_clarification?: clarificationUpdateManyWithoutClarificationNestedInput
    problem?: problemUpdateOneWithoutClarificationNestedInput
    team_clarification_senderToteam?: teamUpdateOneWithoutClarification_clarification_senderToteamNestedInput
    team_clarification_recipientToteam?: teamUpdateOneWithoutClarification_clarification_recipientToteamNestedInput
    team_unread?: team_unreadUpdateManyWithoutClarificationNestedInput
  }

  export type clarificationUncheckedUpdateWithoutContestInput = {
    clarid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    respid?: NullableIntFieldUpdateOperationsInput | number | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sender?: NullableIntFieldUpdateOperationsInput | number | null
    recipient?: NullableIntFieldUpdateOperationsInput | number | null
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    other_clarification?: clarificationUncheckedUpdateManyWithoutClarificationNestedInput
    team_unread?: team_unreadUncheckedUpdateManyWithoutClarificationNestedInput
  }

  export type clarificationUncheckedUpdateManyWithoutContestInput = {
    clarid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    respid?: NullableIntFieldUpdateOperationsInput | number | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sender?: NullableIntFieldUpdateOperationsInput | number | null
    recipient?: NullableIntFieldUpdateOperationsInput | number | null
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
  }

  export type contestproblemUpdateWithoutContestInput = {
    shortname?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    lazy_eval_results?: NullableIntFieldUpdateOperationsInput | number | null
    problem?: problemUpdateOneRequiredWithoutContestproblemNestedInput
    submission?: submissionUpdateManyWithoutContestproblemNestedInput
  }

  export type contestproblemUncheckedUpdateWithoutContestInput = {
    probid?: IntFieldUpdateOperationsInput | number
    shortname?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    lazy_eval_results?: NullableIntFieldUpdateOperationsInput | number | null
    submission?: submissionUncheckedUpdateManyWithoutContestproblemNestedInput
  }

  export type contestproblemUncheckedUpdateManyWithoutContestInput = {
    probid?: IntFieldUpdateOperationsInput | number
    shortname?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    lazy_eval_results?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type contestteamUpdateWithoutContestInput = {
    team?: teamUpdateOneRequiredWithoutContestteamNestedInput
  }

  export type contestteamUncheckedUpdateWithoutContestInput = {
    teamid?: IntFieldUpdateOperationsInput | number
  }

  export type contestteamUncheckedUpdateManyWithoutContestInput = {
    teamid?: IntFieldUpdateOperationsInput | number
  }

  export type contestteamcategoryUpdateWithoutContestInput = {
    team_category?: team_categoryUpdateOneRequiredWithoutContestteamcategoryNestedInput
  }

  export type contestteamcategoryUncheckedUpdateWithoutContestInput = {
    categoryid?: IntFieldUpdateOperationsInput | number
  }

  export type contestteamcategoryUncheckedUpdateManyWithoutContestInput = {
    categoryid?: IntFieldUpdateOperationsInput | number
  }

  export type contestteamcategoryformedalsUpdateWithoutContestInput = {
    team_category?: team_categoryUpdateOneRequiredWithoutContestteamcategoryformedalsNestedInput
  }

  export type contestteamcategoryformedalsUncheckedUpdateWithoutContestInput = {
    categoryid?: IntFieldUpdateOperationsInput | number
  }

  export type contestteamcategoryformedalsUncheckedUpdateManyWithoutContestInput = {
    categoryid?: IntFieldUpdateOperationsInput | number
  }

  export type eventUpdateWithoutContestInput = {
    eventtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endpointtype?: StringFieldUpdateOperationsInput | string
    endpointid?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type eventUncheckedUpdateWithoutContestInput = {
    eventid?: IntFieldUpdateOperationsInput | number
    eventtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endpointtype?: StringFieldUpdateOperationsInput | string
    endpointid?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type eventUncheckedUpdateManyWithoutContestInput = {
    eventid?: IntFieldUpdateOperationsInput | number
    eventtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endpointtype?: StringFieldUpdateOperationsInput | string
    endpointid?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type external_judgementUpdateWithoutContestInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    submission?: submissionUpdateOneWithoutExternal_judgementNestedInput
    external_run?: external_runUpdateManyWithoutExternal_judgementNestedInput
  }

  export type external_judgementUncheckedUpdateWithoutContestInput = {
    extjudgementid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    external_run?: external_runUncheckedUpdateManyWithoutExternal_judgementNestedInput
  }

  export type external_judgementUncheckedUpdateManyWithoutContestInput = {
    extjudgementid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type external_runUpdateWithoutContestInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    result?: StringFieldUpdateOperationsInput | string
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runtime?: FloatFieldUpdateOperationsInput | number
    external_judgement?: external_judgementUpdateOneWithoutExternal_runNestedInput
    testcase?: testcaseUpdateOneWithoutExternal_runNestedInput
  }

  export type external_runUncheckedUpdateWithoutContestInput = {
    extrunid?: IntFieldUpdateOperationsInput | number
    extjudgementid?: NullableIntFieldUpdateOperationsInput | number | null
    testcaseid?: NullableIntFieldUpdateOperationsInput | number | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    result?: StringFieldUpdateOperationsInput | string
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runtime?: FloatFieldUpdateOperationsInput | number
  }

  export type external_runUncheckedUpdateManyWithoutContestInput = {
    extrunid?: IntFieldUpdateOperationsInput | number
    extjudgementid?: NullableIntFieldUpdateOperationsInput | number | null
    testcaseid?: NullableIntFieldUpdateOperationsInput | number | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    result?: StringFieldUpdateOperationsInput | string
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runtime?: FloatFieldUpdateOperationsInput | number
  }

  export type internal_errorUpdateWithoutContestInput = {
    description?: StringFieldUpdateOperationsInput | string
    judgehostlog?: StringFieldUpdateOperationsInput | string
    time?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disabled?: StringFieldUpdateOperationsInput | string
    status?: Enuminternal_error_statusFieldUpdateOperationsInput | $Enums.internal_error_status
    judging_internal_error_judgingidTojudging?: judgingUpdateOneWithoutInternal_error_internal_error_judgingidTojudgingNestedInput
    judging_judging_erroridTointernal_error?: judgingUpdateManyWithoutInternal_error_judging_erroridTointernal_errorNestedInput
  }

  export type internal_errorUncheckedUpdateWithoutContestInput = {
    errorid?: IntFieldUpdateOperationsInput | number
    judgingid?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    judgehostlog?: StringFieldUpdateOperationsInput | string
    time?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disabled?: StringFieldUpdateOperationsInput | string
    status?: Enuminternal_error_statusFieldUpdateOperationsInput | $Enums.internal_error_status
    judging_judging_erroridTointernal_error?: judgingUncheckedUpdateManyWithoutInternal_error_judging_erroridTointernal_errorNestedInput
  }

  export type internal_errorUncheckedUpdateManyWithoutContestInput = {
    errorid?: IntFieldUpdateOperationsInput | number
    judgingid?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    judgehostlog?: StringFieldUpdateOperationsInput | string
    time?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disabled?: StringFieldUpdateOperationsInput | string
    status?: Enuminternal_error_statusFieldUpdateOperationsInput | $Enums.internal_error_status
  }

  export type judgingUpdateWithoutContestInput = {
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    debug_package?: debug_packageUpdateManyWithoutJudgingNestedInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUpdateManyWithoutJudging_internal_error_judgingidTojudgingNestedInput
    internal_error_judging_erroridTointernal_error?: internal_errorUpdateOneWithoutJudging_judging_erroridTointernal_errorNestedInput
    submission?: submissionUpdateOneWithoutJudgingNestedInput
    rejudging?: rejudgingUpdateOneWithoutJudgingNestedInput
    judging?: judgingUpdateOneWithoutOther_judgingNestedInput
    other_judging?: judgingUpdateManyWithoutJudgingNestedInput
    judging_run?: judging_runUpdateManyWithoutJudgingNestedInput
  }

  export type judgingUncheckedUpdateWithoutContestInput = {
    judgingid?: IntFieldUpdateOperationsInput | number
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    prevjudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    errorid?: NullableIntFieldUpdateOperationsInput | number | null
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    debug_package?: debug_packageUncheckedUpdateManyWithoutJudgingNestedInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUncheckedUpdateManyWithoutJudging_internal_error_judgingidTojudgingNestedInput
    other_judging?: judgingUncheckedUpdateManyWithoutJudgingNestedInput
    judging_run?: judging_runUncheckedUpdateManyWithoutJudgingNestedInput
  }

  export type judgingUncheckedUpdateManyWithoutContestInput = {
    judgingid?: IntFieldUpdateOperationsInput | number
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    prevjudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    errorid?: NullableIntFieldUpdateOperationsInput | number | null
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type rankcacheUpdateWithoutContestInput = {
    points_restricted?: IntFieldUpdateOperationsInput | number
    totaltime_restricted?: IntFieldUpdateOperationsInput | number
    points_public?: IntFieldUpdateOperationsInput | number
    totaltime_public?: IntFieldUpdateOperationsInput | number
    team?: teamUpdateOneRequiredWithoutRankcacheNestedInput
  }

  export type rankcacheUncheckedUpdateWithoutContestInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    points_restricted?: IntFieldUpdateOperationsInput | number
    totaltime_restricted?: IntFieldUpdateOperationsInput | number
    points_public?: IntFieldUpdateOperationsInput | number
    totaltime_public?: IntFieldUpdateOperationsInput | number
  }

  export type rankcacheUncheckedUpdateManyWithoutContestInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    points_restricted?: IntFieldUpdateOperationsInput | number
    totaltime_restricted?: IntFieldUpdateOperationsInput | number
    points_public?: IntFieldUpdateOperationsInput | number
    totaltime_public?: IntFieldUpdateOperationsInput | number
  }

  export type removed_intervalUpdateWithoutContestInput = {
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    endtime_string?: StringFieldUpdateOperationsInput | string
  }

  export type removed_intervalUncheckedUpdateWithoutContestInput = {
    intervalid?: IntFieldUpdateOperationsInput | number
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    endtime_string?: StringFieldUpdateOperationsInput | string
  }

  export type removed_intervalUncheckedUpdateManyWithoutContestInput = {
    intervalid?: IntFieldUpdateOperationsInput | number
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    starttime_string?: StringFieldUpdateOperationsInput | string
    endtime_string?: StringFieldUpdateOperationsInput | string
  }

  export type scorecacheUpdateWithoutContestInput = {
    submissions_restricted?: IntFieldUpdateOperationsInput | number
    pending_restricted?: IntFieldUpdateOperationsInput | number
    solvetime_restricted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_restricted?: BoolFieldUpdateOperationsInput | boolean
    submissions_public?: IntFieldUpdateOperationsInput | number
    pending_public?: IntFieldUpdateOperationsInput | number
    solvetime_public?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_public?: BoolFieldUpdateOperationsInput | boolean
    is_first_to_solve?: BoolFieldUpdateOperationsInput | boolean
    team?: teamUpdateOneRequiredWithoutScorecacheNestedInput
    problem?: problemUpdateOneRequiredWithoutScorecacheNestedInput
  }

  export type scorecacheUncheckedUpdateWithoutContestInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    probid?: IntFieldUpdateOperationsInput | number
    submissions_restricted?: IntFieldUpdateOperationsInput | number
    pending_restricted?: IntFieldUpdateOperationsInput | number
    solvetime_restricted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_restricted?: BoolFieldUpdateOperationsInput | boolean
    submissions_public?: IntFieldUpdateOperationsInput | number
    pending_public?: IntFieldUpdateOperationsInput | number
    solvetime_public?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_public?: BoolFieldUpdateOperationsInput | boolean
    is_first_to_solve?: BoolFieldUpdateOperationsInput | boolean
  }

  export type scorecacheUncheckedUpdateManyWithoutContestInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    probid?: IntFieldUpdateOperationsInput | number
    submissions_restricted?: IntFieldUpdateOperationsInput | number
    pending_restricted?: IntFieldUpdateOperationsInput | number
    solvetime_restricted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_restricted?: BoolFieldUpdateOperationsInput | boolean
    submissions_public?: IntFieldUpdateOperationsInput | number
    pending_public?: IntFieldUpdateOperationsInput | number
    solvetime_public?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_public?: BoolFieldUpdateOperationsInput | boolean
    is_first_to_solve?: BoolFieldUpdateOperationsInput | boolean
  }

  export type submissionUpdateWithoutContestInput = {
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUpdateManyWithoutSubmissionNestedInput
    user?: userUpdateOneWithoutSubmissionNestedInput
    team?: teamUpdateOneWithoutSubmissionNestedInput
    problem?: problemUpdateOneWithoutSubmissionNestedInput
    language?: languageUpdateOneWithoutSubmissionNestedInput
    submission?: submissionUpdateOneWithoutOther_submissionNestedInput
    other_submission?: submissionUpdateManyWithoutSubmissionNestedInput
    rejudging?: rejudgingUpdateOneWithoutSubmissionNestedInput
    contestproblem?: contestproblemUpdateOneWithoutSubmissionNestedInput
    submission_file?: submission_fileUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateWithoutContestInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUncheckedUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUncheckedUpdateManyWithoutSubmissionNestedInput
    other_submission?: submissionUncheckedUpdateManyWithoutSubmissionNestedInput
    submission_file?: submission_fileUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateManyWithoutContestInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type submissionCreateManyContestproblemInput = {
    submitid?: number
    origsubmitid?: number | null
    teamid?: number | null
    userid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
  }

  export type submissionUpdateWithoutContestproblemInput = {
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUpdateManyWithoutSubmissionNestedInput
    user?: userUpdateOneWithoutSubmissionNestedInput
    contest?: contestUpdateOneWithoutSubmissionNestedInput
    team?: teamUpdateOneWithoutSubmissionNestedInput
    problem?: problemUpdateOneWithoutSubmissionNestedInput
    language?: languageUpdateOneWithoutSubmissionNestedInput
    submission?: submissionUpdateOneWithoutOther_submissionNestedInput
    other_submission?: submissionUpdateManyWithoutSubmissionNestedInput
    rejudging?: rejudgingUpdateOneWithoutSubmissionNestedInput
    submission_file?: submission_fileUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateWithoutContestproblemInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUncheckedUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUncheckedUpdateManyWithoutSubmissionNestedInput
    other_submission?: submissionUncheckedUpdateManyWithoutSubmissionNestedInput
    submission_file?: submission_fileUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateManyWithoutContestproblemInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type languageCreateManyExecutableInput = {
    langid: string
    externalid?: string | null
    name: string
    extensions?: string | null
    require_entry_point?: boolean
    entry_point_description?: string | null
    allow_submit?: boolean
    allow_judge?: boolean
    time_factor?: number
    filter_compiler_files?: boolean
  }

  export type problemCreateManyExecutable_problem_special_runToexecutableInput = {
    probid?: number
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_compare?: string | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
  }

  export type problemCreateManyExecutable_problem_special_compareToexecutableInput = {
    probid?: number
    externalid?: string | null
    name: string
    timelimit?: number
    memlimit?: number | null
    outputlimit?: number | null
    special_run?: string | null
    special_compare_args?: string | null
    combined_run_compare?: boolean
    problemtext?: Buffer | null
    problemtext_type?: string | null
  }

  export type languageUpdateWithoutExecutableInput = {
    langid?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    extensions?: NullableStringFieldUpdateOperationsInput | string | null
    require_entry_point?: BoolFieldUpdateOperationsInput | boolean
    entry_point_description?: NullableStringFieldUpdateOperationsInput | string | null
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    time_factor?: FloatFieldUpdateOperationsInput | number
    filter_compiler_files?: BoolFieldUpdateOperationsInput | boolean
    submission?: submissionUpdateManyWithoutLanguageNestedInput
  }

  export type languageUncheckedUpdateWithoutExecutableInput = {
    langid?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    extensions?: NullableStringFieldUpdateOperationsInput | string | null
    require_entry_point?: BoolFieldUpdateOperationsInput | boolean
    entry_point_description?: NullableStringFieldUpdateOperationsInput | string | null
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    time_factor?: FloatFieldUpdateOperationsInput | number
    filter_compiler_files?: BoolFieldUpdateOperationsInput | boolean
    submission?: submissionUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type languageUncheckedUpdateManyWithoutExecutableInput = {
    langid?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    extensions?: NullableStringFieldUpdateOperationsInput | string | null
    require_entry_point?: BoolFieldUpdateOperationsInput | boolean
    entry_point_description?: NullableStringFieldUpdateOperationsInput | string | null
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    time_factor?: FloatFieldUpdateOperationsInput | number
    filter_compiler_files?: BoolFieldUpdateOperationsInput | boolean
  }

  export type problemUpdateWithoutExecutable_problem_special_runToexecutableInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutProblemNestedInput
    contestproblem?: contestproblemUpdateManyWithoutProblemNestedInput
    executable_problem_special_compareToexecutable?: executableUpdateOneWithoutProblem_problem_special_compareToexecutableNestedInput
    problem_attachment?: problem_attachmentUpdateManyWithoutProblemNestedInput
    scorecache?: scorecacheUpdateManyWithoutProblemNestedInput
    submission?: submissionUpdateManyWithoutProblemNestedInput
    testcase?: testcaseUpdateManyWithoutProblemNestedInput
  }

  export type problemUncheckedUpdateWithoutExecutable_problem_special_runToexecutableInput = {
    probid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_compare?: NullableStringFieldUpdateOperationsInput | string | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutProblemNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutProblemNestedInput
    problem_attachment?: problem_attachmentUncheckedUpdateManyWithoutProblemNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutProblemNestedInput
    submission?: submissionUncheckedUpdateManyWithoutProblemNestedInput
    testcase?: testcaseUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type problemUncheckedUpdateManyWithoutExecutable_problem_special_runToexecutableInput = {
    probid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_compare?: NullableStringFieldUpdateOperationsInput | string | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type problemUpdateWithoutExecutable_problem_special_compareToexecutableInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUpdateManyWithoutProblemNestedInput
    contestproblem?: contestproblemUpdateManyWithoutProblemNestedInput
    executable_problem_special_runToexecutable?: executableUpdateOneWithoutProblem_problem_special_runToexecutableNestedInput
    problem_attachment?: problem_attachmentUpdateManyWithoutProblemNestedInput
    scorecache?: scorecacheUpdateManyWithoutProblemNestedInput
    submission?: submissionUpdateManyWithoutProblemNestedInput
    testcase?: testcaseUpdateManyWithoutProblemNestedInput
  }

  export type problemUncheckedUpdateWithoutExecutable_problem_special_compareToexecutableInput = {
    probid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_run?: NullableStringFieldUpdateOperationsInput | string | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
    clarification?: clarificationUncheckedUpdateManyWithoutProblemNestedInput
    contestproblem?: contestproblemUncheckedUpdateManyWithoutProblemNestedInput
    problem_attachment?: problem_attachmentUncheckedUpdateManyWithoutProblemNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutProblemNestedInput
    submission?: submissionUncheckedUpdateManyWithoutProblemNestedInput
    testcase?: testcaseUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type problemUncheckedUpdateManyWithoutExecutable_problem_special_compareToexecutableInput = {
    probid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    timelimit?: FloatFieldUpdateOperationsInput | number
    memlimit?: NullableIntFieldUpdateOperationsInput | number | null
    outputlimit?: NullableIntFieldUpdateOperationsInput | number | null
    special_run?: NullableStringFieldUpdateOperationsInput | string | null
    special_compare_args?: NullableStringFieldUpdateOperationsInput | string | null
    combined_run_compare?: BoolFieldUpdateOperationsInput | boolean
    problemtext?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    problemtext_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type external_source_warningCreateManyExternal_contest_sourceInput = {
    extwarningid?: number
    last_event_id?: string | null
    time: Decimal | DecimalJsLike | number | string
    entity_type: string
    entity_id: string
    type: string
    hash: string
    content: string
  }

  export type external_source_warningUpdateWithoutExternal_contest_sourceInput = {
    last_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type external_source_warningUncheckedUpdateWithoutExternal_contest_sourceInput = {
    extwarningid?: IntFieldUpdateOperationsInput | number
    last_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type external_source_warningUncheckedUpdateManyWithoutExternal_contest_sourceInput = {
    extwarningid?: IntFieldUpdateOperationsInput | number
    last_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type external_runCreateManyExternal_judgementInput = {
    extrunid?: number
    testcaseid?: number | null
    externalid?: string | null
    cid?: number | null
    result: string
    endtime: Decimal | DecimalJsLike | number | string
    runtime: number
  }

  export type external_runUpdateWithoutExternal_judgementInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    result?: StringFieldUpdateOperationsInput | string
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runtime?: FloatFieldUpdateOperationsInput | number
    testcase?: testcaseUpdateOneWithoutExternal_runNestedInput
    contest?: contestUpdateOneWithoutExternal_runNestedInput
  }

  export type external_runUncheckedUpdateWithoutExternal_judgementInput = {
    extrunid?: IntFieldUpdateOperationsInput | number
    testcaseid?: NullableIntFieldUpdateOperationsInput | number | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    result?: StringFieldUpdateOperationsInput | string
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runtime?: FloatFieldUpdateOperationsInput | number
  }

  export type external_runUncheckedUpdateManyWithoutExternal_judgementInput = {
    extrunid?: IntFieldUpdateOperationsInput | number
    testcaseid?: NullableIntFieldUpdateOperationsInput | number | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    result?: StringFieldUpdateOperationsInput | string
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runtime?: FloatFieldUpdateOperationsInput | number
  }

  export type executable_fileCreateManyImmutable_executableInput = {
    execfileid?: number
    filename: string
    ranknumber: number
    file_content: Buffer
    hash?: string | null
    is_executable?: boolean
  }

  export type executable_fileUpdateWithoutImmutable_executableInput = {
    filename?: StringFieldUpdateOperationsInput | string
    ranknumber?: IntFieldUpdateOperationsInput | number
    file_content?: BytesFieldUpdateOperationsInput | Buffer
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_executable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type executable_fileUncheckedUpdateWithoutImmutable_executableInput = {
    execfileid?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    ranknumber?: IntFieldUpdateOperationsInput | number
    file_content?: BytesFieldUpdateOperationsInput | Buffer
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_executable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type executable_fileUncheckedUpdateManyWithoutImmutable_executableInput = {
    execfileid?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    ranknumber?: IntFieldUpdateOperationsInput | number
    file_content?: BytesFieldUpdateOperationsInput | Buffer
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_executable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type judgingCreateManyInternal_error_judging_erroridTointernal_errorInput = {
    judgingid?: number
    cid?: number | null
    submitid?: number | null
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    rejudgingid?: number | null
    prevjudgingid?: number | null
    judge_completely?: boolean
    uuid: string
    metadata?: Buffer | null
  }

  export type judgingUpdateWithoutInternal_error_judging_erroridTointernal_errorInput = {
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    debug_package?: debug_packageUpdateManyWithoutJudgingNestedInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUpdateManyWithoutJudging_internal_error_judgingidTojudgingNestedInput
    contest?: contestUpdateOneWithoutJudgingNestedInput
    submission?: submissionUpdateOneWithoutJudgingNestedInput
    rejudging?: rejudgingUpdateOneWithoutJudgingNestedInput
    judging?: judgingUpdateOneWithoutOther_judgingNestedInput
    other_judging?: judgingUpdateManyWithoutJudgingNestedInput
    judging_run?: judging_runUpdateManyWithoutJudgingNestedInput
  }

  export type judgingUncheckedUpdateWithoutInternal_error_judging_erroridTointernal_errorInput = {
    judgingid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    prevjudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    debug_package?: debug_packageUncheckedUpdateManyWithoutJudgingNestedInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUncheckedUpdateManyWithoutJudging_internal_error_judgingidTojudgingNestedInput
    other_judging?: judgingUncheckedUpdateManyWithoutJudgingNestedInput
    judging_run?: judging_runUncheckedUpdateManyWithoutJudgingNestedInput
  }

  export type judgingUncheckedUpdateManyWithoutInternal_error_judging_erroridTointernal_errorInput = {
    judgingid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    prevjudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type debug_packageCreateManyJudgehostInput = {
    debug_package_id?: number
    judgingid?: number | null
    filename: string
  }

  export type judgetaskCreateManyJudgehostInput = {
    judgetaskid?: number
    type?: $Enums.judgetask_type
    priority: number
    jobid?: number | null
    submitid?: number | null
    compile_script_id?: number | null
    run_script_id?: number | null
    compare_script_id?: number | null
    testcase_id?: number | null
    compile_config?: string | null
    run_config?: string | null
    compare_config?: string | null
    valid?: boolean
    starttime?: Decimal | DecimalJsLike | number | string | null
    uuid?: string | null
    testcase_hash?: string | null
  }

  export type debug_packageUpdateWithoutJudgehostInput = {
    filename?: StringFieldUpdateOperationsInput | string
    judging?: judgingUpdateOneWithoutDebug_packageNestedInput
  }

  export type debug_packageUncheckedUpdateWithoutJudgehostInput = {
    debug_package_id?: IntFieldUpdateOperationsInput | number
    judgingid?: NullableIntFieldUpdateOperationsInput | number | null
    filename?: StringFieldUpdateOperationsInput | string
  }

  export type debug_packageUncheckedUpdateManyWithoutJudgehostInput = {
    debug_package_id?: IntFieldUpdateOperationsInput | number
    judgingid?: NullableIntFieldUpdateOperationsInput | number | null
    filename?: StringFieldUpdateOperationsInput | string
  }

  export type judgetaskUpdateWithoutJudgehostInput = {
    type?: Enumjudgetask_typeFieldUpdateOperationsInput | $Enums.judgetask_type
    priority?: IntFieldUpdateOperationsInput | number
    jobid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    compile_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    run_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    compare_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    testcase_id?: NullableIntFieldUpdateOperationsInput | number | null
    compile_config?: NullableStringFieldUpdateOperationsInput | string | null
    run_config?: NullableStringFieldUpdateOperationsInput | string | null
    compare_config?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    testcase_hash?: NullableStringFieldUpdateOperationsInput | string | null
    judging_run?: judging_runUpdateManyWithoutJudgetaskNestedInput
  }

  export type judgetaskUncheckedUpdateWithoutJudgehostInput = {
    judgetaskid?: IntFieldUpdateOperationsInput | number
    type?: Enumjudgetask_typeFieldUpdateOperationsInput | $Enums.judgetask_type
    priority?: IntFieldUpdateOperationsInput | number
    jobid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    compile_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    run_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    compare_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    testcase_id?: NullableIntFieldUpdateOperationsInput | number | null
    compile_config?: NullableStringFieldUpdateOperationsInput | string | null
    run_config?: NullableStringFieldUpdateOperationsInput | string | null
    compare_config?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    testcase_hash?: NullableStringFieldUpdateOperationsInput | string | null
    judging_run?: judging_runUncheckedUpdateManyWithoutJudgetaskNestedInput
  }

  export type judgetaskUncheckedUpdateManyWithoutJudgehostInput = {
    judgetaskid?: IntFieldUpdateOperationsInput | number
    type?: Enumjudgetask_typeFieldUpdateOperationsInput | $Enums.judgetask_type
    priority?: IntFieldUpdateOperationsInput | number
    jobid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    compile_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    run_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    compare_script_id?: NullableIntFieldUpdateOperationsInput | number | null
    testcase_id?: NullableIntFieldUpdateOperationsInput | number | null
    compile_config?: NullableStringFieldUpdateOperationsInput | string | null
    run_config?: NullableStringFieldUpdateOperationsInput | string | null
    compare_config?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    testcase_hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type judging_runCreateManyJudgetaskInput = {
    runid?: number
    judgingid?: number | null
    testcaseid?: number | null
    runresult?: string | null
    runtime?: number | null
    endtime?: Decimal | DecimalJsLike | number | string | null
  }

  export type judging_runUpdateWithoutJudgetaskInput = {
    runresult?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableFloatFieldUpdateOperationsInput | number | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    testcase?: testcaseUpdateOneWithoutJudging_runNestedInput
    judging?: judgingUpdateOneWithoutJudging_runNestedInput
    judging_run_output?: judging_run_outputUpdateOneWithoutJudging_runNestedInput
  }

  export type judging_runUncheckedUpdateWithoutJudgetaskInput = {
    runid?: IntFieldUpdateOperationsInput | number
    judgingid?: NullableIntFieldUpdateOperationsInput | number | null
    testcaseid?: NullableIntFieldUpdateOperationsInput | number | null
    runresult?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableFloatFieldUpdateOperationsInput | number | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    judging_run_output?: judging_run_outputUncheckedUpdateOneWithoutJudging_runNestedInput
  }

  export type judging_runUncheckedUpdateManyWithoutJudgetaskInput = {
    runid?: IntFieldUpdateOperationsInput | number
    judgingid?: NullableIntFieldUpdateOperationsInput | number | null
    testcaseid?: NullableIntFieldUpdateOperationsInput | number | null
    runresult?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableFloatFieldUpdateOperationsInput | number | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type debug_packageCreateManyJudgingInput = {
    debug_package_id?: number
    judgehostid?: number | null
    filename: string
  }

  export type internal_errorCreateManyJudging_internal_error_judgingidTojudgingInput = {
    errorid?: number
    cid?: number | null
    description: string
    judgehostlog: string
    time: Decimal | DecimalJsLike | number | string
    disabled: string
    status?: $Enums.internal_error_status
  }

  export type judgingCreateManyJudgingInput = {
    judgingid?: number
    cid?: number | null
    submitid?: number | null
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    rejudgingid?: number | null
    judge_completely?: boolean
    errorid?: number | null
    uuid: string
    metadata?: Buffer | null
  }

  export type judging_runCreateManyJudgingInput = {
    runid?: number
    testcaseid?: number | null
    runresult?: string | null
    runtime?: number | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    judgetaskid?: number | null
  }

  export type debug_packageUpdateWithoutJudgingInput = {
    filename?: StringFieldUpdateOperationsInput | string
    judgehost?: judgehostUpdateOneWithoutDebug_packageNestedInput
  }

  export type debug_packageUncheckedUpdateWithoutJudgingInput = {
    debug_package_id?: IntFieldUpdateOperationsInput | number
    judgehostid?: NullableIntFieldUpdateOperationsInput | number | null
    filename?: StringFieldUpdateOperationsInput | string
  }

  export type debug_packageUncheckedUpdateManyWithoutJudgingInput = {
    debug_package_id?: IntFieldUpdateOperationsInput | number
    judgehostid?: NullableIntFieldUpdateOperationsInput | number | null
    filename?: StringFieldUpdateOperationsInput | string
  }

  export type internal_errorUpdateWithoutJudging_internal_error_judgingidTojudgingInput = {
    description?: StringFieldUpdateOperationsInput | string
    judgehostlog?: StringFieldUpdateOperationsInput | string
    time?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disabled?: StringFieldUpdateOperationsInput | string
    status?: Enuminternal_error_statusFieldUpdateOperationsInput | $Enums.internal_error_status
    contest?: contestUpdateOneWithoutInternal_errorNestedInput
    judging_judging_erroridTointernal_error?: judgingUpdateManyWithoutInternal_error_judging_erroridTointernal_errorNestedInput
  }

  export type internal_errorUncheckedUpdateWithoutJudging_internal_error_judgingidTojudgingInput = {
    errorid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    judgehostlog?: StringFieldUpdateOperationsInput | string
    time?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disabled?: StringFieldUpdateOperationsInput | string
    status?: Enuminternal_error_statusFieldUpdateOperationsInput | $Enums.internal_error_status
    judging_judging_erroridTointernal_error?: judgingUncheckedUpdateManyWithoutInternal_error_judging_erroridTointernal_errorNestedInput
  }

  export type internal_errorUncheckedUpdateManyWithoutJudging_internal_error_judgingidTojudgingInput = {
    errorid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    judgehostlog?: StringFieldUpdateOperationsInput | string
    time?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disabled?: StringFieldUpdateOperationsInput | string
    status?: Enuminternal_error_statusFieldUpdateOperationsInput | $Enums.internal_error_status
  }

  export type judgingUpdateWithoutJudgingInput = {
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    debug_package?: debug_packageUpdateManyWithoutJudgingNestedInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUpdateManyWithoutJudging_internal_error_judgingidTojudgingNestedInput
    internal_error_judging_erroridTointernal_error?: internal_errorUpdateOneWithoutJudging_judging_erroridTointernal_errorNestedInput
    contest?: contestUpdateOneWithoutJudgingNestedInput
    submission?: submissionUpdateOneWithoutJudgingNestedInput
    rejudging?: rejudgingUpdateOneWithoutJudgingNestedInput
    other_judging?: judgingUpdateManyWithoutJudgingNestedInput
    judging_run?: judging_runUpdateManyWithoutJudgingNestedInput
  }

  export type judgingUncheckedUpdateWithoutJudgingInput = {
    judgingid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    errorid?: NullableIntFieldUpdateOperationsInput | number | null
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    debug_package?: debug_packageUncheckedUpdateManyWithoutJudgingNestedInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUncheckedUpdateManyWithoutJudging_internal_error_judgingidTojudgingNestedInput
    other_judging?: judgingUncheckedUpdateManyWithoutJudgingNestedInput
    judging_run?: judging_runUncheckedUpdateManyWithoutJudgingNestedInput
  }

  export type judgingUncheckedUpdateManyWithoutJudgingInput = {
    judgingid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    errorid?: NullableIntFieldUpdateOperationsInput | number | null
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type judging_runUpdateWithoutJudgingInput = {
    runresult?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableFloatFieldUpdateOperationsInput | number | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    judgetask?: judgetaskUpdateOneWithoutJudging_runNestedInput
    testcase?: testcaseUpdateOneWithoutJudging_runNestedInput
    judging_run_output?: judging_run_outputUpdateOneWithoutJudging_runNestedInput
  }

  export type judging_runUncheckedUpdateWithoutJudgingInput = {
    runid?: IntFieldUpdateOperationsInput | number
    testcaseid?: NullableIntFieldUpdateOperationsInput | number | null
    runresult?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableFloatFieldUpdateOperationsInput | number | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    judgetaskid?: NullableIntFieldUpdateOperationsInput | number | null
    judging_run_output?: judging_run_outputUncheckedUpdateOneWithoutJudging_runNestedInput
  }

  export type judging_runUncheckedUpdateManyWithoutJudgingInput = {
    runid?: IntFieldUpdateOperationsInput | number
    testcaseid?: NullableIntFieldUpdateOperationsInput | number | null
    runresult?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableFloatFieldUpdateOperationsInput | number | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    judgetaskid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type submissionCreateManyLanguageInput = {
    submitid?: number
    origsubmitid?: number | null
    cid?: number | null
    teamid?: number | null
    userid?: number | null
    probid?: number | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
  }

  export type submissionUpdateWithoutLanguageInput = {
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUpdateManyWithoutSubmissionNestedInput
    user?: userUpdateOneWithoutSubmissionNestedInput
    contest?: contestUpdateOneWithoutSubmissionNestedInput
    team?: teamUpdateOneWithoutSubmissionNestedInput
    problem?: problemUpdateOneWithoutSubmissionNestedInput
    submission?: submissionUpdateOneWithoutOther_submissionNestedInput
    other_submission?: submissionUpdateManyWithoutSubmissionNestedInput
    rejudging?: rejudgingUpdateOneWithoutSubmissionNestedInput
    contestproblem?: contestproblemUpdateOneWithoutSubmissionNestedInput
    submission_file?: submission_fileUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateWithoutLanguageInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUncheckedUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUncheckedUpdateManyWithoutSubmissionNestedInput
    other_submission?: submissionUncheckedUpdateManyWithoutSubmissionNestedInput
    submission_file?: submission_fileUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateManyWithoutLanguageInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clarificationCreateManyProblemInput = {
    clarid?: number
    externalid?: string | null
    cid?: number | null
    respid?: number | null
    submittime: Decimal | DecimalJsLike | number | string
    sender?: number | null
    recipient?: number | null
    jury_member?: string | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
  }

  export type contestproblemCreateManyProblemInput = {
    cid: number
    shortname: string
    points?: number
    allow_submit?: boolean
    allow_judge?: boolean
    color?: string | null
    lazy_eval_results?: number | null
  }

  export type problem_attachmentCreateManyProblemInput = {
    attachmentid?: number
    name: string
    type: string
  }

  export type scorecacheCreateManyProblemInput = {
    cid: number
    teamid: number
    submissions_restricted?: number
    pending_restricted?: number
    solvetime_restricted?: Decimal | DecimalJsLike | number | string
    is_correct_restricted?: boolean
    submissions_public?: number
    pending_public?: number
    solvetime_public?: Decimal | DecimalJsLike | number | string
    is_correct_public?: boolean
    is_first_to_solve?: boolean
  }

  export type submissionCreateManyProblemInput = {
    submitid?: number
    origsubmitid?: number | null
    cid?: number | null
    teamid?: number | null
    userid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
  }

  export type testcaseCreateManyProblemInput = {
    testcaseid?: number
    md5sum_input?: string | null
    md5sum_output?: string | null
    ranknumber: number
    description?: Buffer | null
    image_type?: string | null
    sample?: boolean
    orig_input_filename?: string | null
    deleted?: boolean
  }

  export type clarificationUpdateWithoutProblemInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    contest?: contestUpdateOneWithoutClarificationNestedInput
    clarification?: clarificationUpdateOneWithoutOther_clarificationNestedInput
    other_clarification?: clarificationUpdateManyWithoutClarificationNestedInput
    team_clarification_senderToteam?: teamUpdateOneWithoutClarification_clarification_senderToteamNestedInput
    team_clarification_recipientToteam?: teamUpdateOneWithoutClarification_clarification_recipientToteamNestedInput
    team_unread?: team_unreadUpdateManyWithoutClarificationNestedInput
  }

  export type clarificationUncheckedUpdateWithoutProblemInput = {
    clarid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    respid?: NullableIntFieldUpdateOperationsInput | number | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sender?: NullableIntFieldUpdateOperationsInput | number | null
    recipient?: NullableIntFieldUpdateOperationsInput | number | null
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    other_clarification?: clarificationUncheckedUpdateManyWithoutClarificationNestedInput
    team_unread?: team_unreadUncheckedUpdateManyWithoutClarificationNestedInput
  }

  export type clarificationUncheckedUpdateManyWithoutProblemInput = {
    clarid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    respid?: NullableIntFieldUpdateOperationsInput | number | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sender?: NullableIntFieldUpdateOperationsInput | number | null
    recipient?: NullableIntFieldUpdateOperationsInput | number | null
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
  }

  export type contestproblemUpdateWithoutProblemInput = {
    shortname?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    lazy_eval_results?: NullableIntFieldUpdateOperationsInput | number | null
    contest?: contestUpdateOneRequiredWithoutContestproblemNestedInput
    submission?: submissionUpdateManyWithoutContestproblemNestedInput
  }

  export type contestproblemUncheckedUpdateWithoutProblemInput = {
    cid?: IntFieldUpdateOperationsInput | number
    shortname?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    lazy_eval_results?: NullableIntFieldUpdateOperationsInput | number | null
    submission?: submissionUncheckedUpdateManyWithoutContestproblemNestedInput
  }

  export type contestproblemUncheckedUpdateManyWithoutProblemInput = {
    cid?: IntFieldUpdateOperationsInput | number
    shortname?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    allow_submit?: BoolFieldUpdateOperationsInput | boolean
    allow_judge?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    lazy_eval_results?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type problem_attachmentUpdateWithoutProblemInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    problem_attachment_content?: problem_attachment_contentUpdateOneWithoutProblem_attachmentNestedInput
  }

  export type problem_attachmentUncheckedUpdateWithoutProblemInput = {
    attachmentid?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    problem_attachment_content?: problem_attachment_contentUncheckedUpdateOneWithoutProblem_attachmentNestedInput
  }

  export type problem_attachmentUncheckedUpdateManyWithoutProblemInput = {
    attachmentid?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type scorecacheUpdateWithoutProblemInput = {
    submissions_restricted?: IntFieldUpdateOperationsInput | number
    pending_restricted?: IntFieldUpdateOperationsInput | number
    solvetime_restricted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_restricted?: BoolFieldUpdateOperationsInput | boolean
    submissions_public?: IntFieldUpdateOperationsInput | number
    pending_public?: IntFieldUpdateOperationsInput | number
    solvetime_public?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_public?: BoolFieldUpdateOperationsInput | boolean
    is_first_to_solve?: BoolFieldUpdateOperationsInput | boolean
    contest?: contestUpdateOneRequiredWithoutScorecacheNestedInput
    team?: teamUpdateOneRequiredWithoutScorecacheNestedInput
  }

  export type scorecacheUncheckedUpdateWithoutProblemInput = {
    cid?: IntFieldUpdateOperationsInput | number
    teamid?: IntFieldUpdateOperationsInput | number
    submissions_restricted?: IntFieldUpdateOperationsInput | number
    pending_restricted?: IntFieldUpdateOperationsInput | number
    solvetime_restricted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_restricted?: BoolFieldUpdateOperationsInput | boolean
    submissions_public?: IntFieldUpdateOperationsInput | number
    pending_public?: IntFieldUpdateOperationsInput | number
    solvetime_public?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_public?: BoolFieldUpdateOperationsInput | boolean
    is_first_to_solve?: BoolFieldUpdateOperationsInput | boolean
  }

  export type scorecacheUncheckedUpdateManyWithoutProblemInput = {
    cid?: IntFieldUpdateOperationsInput | number
    teamid?: IntFieldUpdateOperationsInput | number
    submissions_restricted?: IntFieldUpdateOperationsInput | number
    pending_restricted?: IntFieldUpdateOperationsInput | number
    solvetime_restricted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_restricted?: BoolFieldUpdateOperationsInput | boolean
    submissions_public?: IntFieldUpdateOperationsInput | number
    pending_public?: IntFieldUpdateOperationsInput | number
    solvetime_public?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_public?: BoolFieldUpdateOperationsInput | boolean
    is_first_to_solve?: BoolFieldUpdateOperationsInput | boolean
  }

  export type submissionUpdateWithoutProblemInput = {
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUpdateManyWithoutSubmissionNestedInput
    user?: userUpdateOneWithoutSubmissionNestedInput
    contest?: contestUpdateOneWithoutSubmissionNestedInput
    team?: teamUpdateOneWithoutSubmissionNestedInput
    language?: languageUpdateOneWithoutSubmissionNestedInput
    submission?: submissionUpdateOneWithoutOther_submissionNestedInput
    other_submission?: submissionUpdateManyWithoutSubmissionNestedInput
    rejudging?: rejudgingUpdateOneWithoutSubmissionNestedInput
    contestproblem?: contestproblemUpdateOneWithoutSubmissionNestedInput
    submission_file?: submission_fileUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateWithoutProblemInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUncheckedUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUncheckedUpdateManyWithoutSubmissionNestedInput
    other_submission?: submissionUncheckedUpdateManyWithoutSubmissionNestedInput
    submission_file?: submission_fileUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateManyWithoutProblemInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type testcaseUpdateWithoutProblemInput = {
    md5sum_input?: NullableStringFieldUpdateOperationsInput | string | null
    md5sum_output?: NullableStringFieldUpdateOperationsInput | string | null
    ranknumber?: IntFieldUpdateOperationsInput | number
    description?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image_type?: NullableStringFieldUpdateOperationsInput | string | null
    sample?: BoolFieldUpdateOperationsInput | boolean
    orig_input_filename?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    external_run?: external_runUpdateManyWithoutTestcaseNestedInput
    judging_run?: judging_runUpdateManyWithoutTestcaseNestedInput
    testcase_content?: testcase_contentUpdateManyWithoutTestcaseNestedInput
  }

  export type testcaseUncheckedUpdateWithoutProblemInput = {
    testcaseid?: IntFieldUpdateOperationsInput | number
    md5sum_input?: NullableStringFieldUpdateOperationsInput | string | null
    md5sum_output?: NullableStringFieldUpdateOperationsInput | string | null
    ranknumber?: IntFieldUpdateOperationsInput | number
    description?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image_type?: NullableStringFieldUpdateOperationsInput | string | null
    sample?: BoolFieldUpdateOperationsInput | boolean
    orig_input_filename?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    external_run?: external_runUncheckedUpdateManyWithoutTestcaseNestedInput
    judging_run?: judging_runUncheckedUpdateManyWithoutTestcaseNestedInput
    testcase_content?: testcase_contentUncheckedUpdateManyWithoutTestcaseNestedInput
  }

  export type testcaseUncheckedUpdateManyWithoutProblemInput = {
    testcaseid?: IntFieldUpdateOperationsInput | number
    md5sum_input?: NullableStringFieldUpdateOperationsInput | string | null
    md5sum_output?: NullableStringFieldUpdateOperationsInput | string | null
    ranknumber?: IntFieldUpdateOperationsInput | number
    description?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image_type?: NullableStringFieldUpdateOperationsInput | string | null
    sample?: BoolFieldUpdateOperationsInput | boolean
    orig_input_filename?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type judgingCreateManyRejudgingInput = {
    judgingid?: number
    cid?: number | null
    submitid?: number | null
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    prevjudgingid?: number | null
    judge_completely?: boolean
    errorid?: number | null
    uuid: string
    metadata?: Buffer | null
  }

  export type rejudgingCreateManyRejudgingInput = {
    rejudgingid?: number
    userid_start?: number | null
    userid_finish?: number | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    reason: string
    valid?: boolean
    auto_apply?: boolean
    repeat?: number | null
  }

  export type submissionCreateManyRejudgingInput = {
    submitid?: number
    origsubmitid?: number | null
    cid?: number | null
    teamid?: number | null
    userid?: number | null
    probid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
  }

  export type judgingUpdateWithoutRejudgingInput = {
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    debug_package?: debug_packageUpdateManyWithoutJudgingNestedInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUpdateManyWithoutJudging_internal_error_judgingidTojudgingNestedInput
    internal_error_judging_erroridTointernal_error?: internal_errorUpdateOneWithoutJudging_judging_erroridTointernal_errorNestedInput
    contest?: contestUpdateOneWithoutJudgingNestedInput
    submission?: submissionUpdateOneWithoutJudgingNestedInput
    judging?: judgingUpdateOneWithoutOther_judgingNestedInput
    other_judging?: judgingUpdateManyWithoutJudgingNestedInput
    judging_run?: judging_runUpdateManyWithoutJudgingNestedInput
  }

  export type judgingUncheckedUpdateWithoutRejudgingInput = {
    judgingid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    prevjudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    errorid?: NullableIntFieldUpdateOperationsInput | number | null
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    debug_package?: debug_packageUncheckedUpdateManyWithoutJudgingNestedInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUncheckedUpdateManyWithoutJudging_internal_error_judgingidTojudgingNestedInput
    other_judging?: judgingUncheckedUpdateManyWithoutJudgingNestedInput
    judging_run?: judging_runUncheckedUpdateManyWithoutJudgingNestedInput
  }

  export type judgingUncheckedUpdateManyWithoutRejudgingInput = {
    judgingid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    submitid?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    prevjudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    errorid?: NullableIntFieldUpdateOperationsInput | number | null
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type rejudgingUpdateWithoutRejudgingInput = {
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    auto_apply?: BoolFieldUpdateOperationsInput | boolean
    repeat?: NullableIntFieldUpdateOperationsInput | number | null
    judging?: judgingUpdateManyWithoutRejudgingNestedInput
    other_rejudging?: rejudgingUpdateManyWithoutRejudgingNestedInput
    user_rejudging_userid_startTouser?: userUpdateOneWithoutRejudging_rejudging_userid_startTouserNestedInput
    user_rejudging_userid_finishTouser?: userUpdateOneWithoutRejudging_rejudging_userid_finishTouserNestedInput
    submission?: submissionUpdateManyWithoutRejudgingNestedInput
  }

  export type rejudgingUncheckedUpdateWithoutRejudgingInput = {
    rejudgingid?: IntFieldUpdateOperationsInput | number
    userid_start?: NullableIntFieldUpdateOperationsInput | number | null
    userid_finish?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    auto_apply?: BoolFieldUpdateOperationsInput | boolean
    repeat?: NullableIntFieldUpdateOperationsInput | number | null
    judging?: judgingUncheckedUpdateManyWithoutRejudgingNestedInput
    other_rejudging?: rejudgingUncheckedUpdateManyWithoutRejudgingNestedInput
    submission?: submissionUncheckedUpdateManyWithoutRejudgingNestedInput
  }

  export type rejudgingUncheckedUpdateManyWithoutRejudgingInput = {
    rejudgingid?: IntFieldUpdateOperationsInput | number
    userid_start?: NullableIntFieldUpdateOperationsInput | number | null
    userid_finish?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    auto_apply?: BoolFieldUpdateOperationsInput | boolean
    repeat?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type submissionUpdateWithoutRejudgingInput = {
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUpdateManyWithoutSubmissionNestedInput
    user?: userUpdateOneWithoutSubmissionNestedInput
    contest?: contestUpdateOneWithoutSubmissionNestedInput
    team?: teamUpdateOneWithoutSubmissionNestedInput
    problem?: problemUpdateOneWithoutSubmissionNestedInput
    language?: languageUpdateOneWithoutSubmissionNestedInput
    submission?: submissionUpdateOneWithoutOther_submissionNestedInput
    other_submission?: submissionUpdateManyWithoutSubmissionNestedInput
    contestproblem?: contestproblemUpdateOneWithoutSubmissionNestedInput
    submission_file?: submission_fileUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateWithoutRejudgingInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUncheckedUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUncheckedUpdateManyWithoutSubmissionNestedInput
    other_submission?: submissionUncheckedUpdateManyWithoutSubmissionNestedInput
    submission_file?: submission_fileUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateManyWithoutRejudgingInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userroleCreateManyRoleInput = {
    userid: number
  }

  export type userroleUpdateWithoutRoleInput = {
    user?: userUpdateOneRequiredWithoutUserroleNestedInput
  }

  export type userroleUncheckedUpdateWithoutRoleInput = {
    userid?: IntFieldUpdateOperationsInput | number
  }

  export type userroleUncheckedUpdateManyWithoutRoleInput = {
    userid?: IntFieldUpdateOperationsInput | number
  }

  export type balloonCreateManySubmissionInput = {
    balloonid?: number
    done?: boolean
  }

  export type external_judgementCreateManySubmissionInput = {
    extjudgementid?: number
    externalid?: string | null
    cid?: number | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    valid?: boolean
  }

  export type judgingCreateManySubmissionInput = {
    judgingid?: number
    cid?: number | null
    starttime?: Decimal | DecimalJsLike | number | string | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    result?: string | null
    verified?: boolean
    jury_member?: string | null
    verify_comment?: string | null
    valid?: boolean
    output_compile?: Buffer | null
    seen?: boolean
    rejudgingid?: number | null
    prevjudgingid?: number | null
    judge_completely?: boolean
    errorid?: number | null
    uuid: string
    metadata?: Buffer | null
  }

  export type submissionCreateManySubmissionInput = {
    submitid?: number
    cid?: number | null
    teamid?: number | null
    userid?: number | null
    probid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
  }

  export type submission_fileCreateManySubmissionInput = {
    submitfileid?: number
    sourcecode: Buffer
    filename: string
    ranknumber: number
  }

  export type balloonUpdateWithoutSubmissionInput = {
    done?: BoolFieldUpdateOperationsInput | boolean
  }

  export type balloonUncheckedUpdateWithoutSubmissionInput = {
    balloonid?: IntFieldUpdateOperationsInput | number
    done?: BoolFieldUpdateOperationsInput | boolean
  }

  export type balloonUncheckedUpdateManyWithoutSubmissionInput = {
    balloonid?: IntFieldUpdateOperationsInput | number
    done?: BoolFieldUpdateOperationsInput | boolean
  }

  export type external_judgementUpdateWithoutSubmissionInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    contest?: contestUpdateOneWithoutExternal_judgementNestedInput
    external_run?: external_runUpdateManyWithoutExternal_judgementNestedInput
  }

  export type external_judgementUncheckedUpdateWithoutSubmissionInput = {
    extjudgementid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    external_run?: external_runUncheckedUpdateManyWithoutExternal_judgementNestedInput
  }

  export type external_judgementUncheckedUpdateManyWithoutSubmissionInput = {
    extjudgementid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type judgingUpdateWithoutSubmissionInput = {
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    debug_package?: debug_packageUpdateManyWithoutJudgingNestedInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUpdateManyWithoutJudging_internal_error_judgingidTojudgingNestedInput
    internal_error_judging_erroridTointernal_error?: internal_errorUpdateOneWithoutJudging_judging_erroridTointernal_errorNestedInput
    contest?: contestUpdateOneWithoutJudgingNestedInput
    rejudging?: rejudgingUpdateOneWithoutJudgingNestedInput
    judging?: judgingUpdateOneWithoutOther_judgingNestedInput
    other_judging?: judgingUpdateManyWithoutJudgingNestedInput
    judging_run?: judging_runUpdateManyWithoutJudgingNestedInput
  }

  export type judgingUncheckedUpdateWithoutSubmissionInput = {
    judgingid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    prevjudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    errorid?: NullableIntFieldUpdateOperationsInput | number | null
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    debug_package?: debug_packageUncheckedUpdateManyWithoutJudgingNestedInput
    internal_error_internal_error_judgingidTojudging?: internal_errorUncheckedUpdateManyWithoutJudging_internal_error_judgingidTojudgingNestedInput
    other_judging?: judgingUncheckedUpdateManyWithoutJudgingNestedInput
    judging_run?: judging_runUncheckedUpdateManyWithoutJudgingNestedInput
  }

  export type judgingUncheckedUpdateManyWithoutSubmissionInput = {
    judgingid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    verify_comment?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: BoolFieldUpdateOperationsInput | boolean
    output_compile?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    seen?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    prevjudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judge_completely?: BoolFieldUpdateOperationsInput | boolean
    errorid?: NullableIntFieldUpdateOperationsInput | number | null
    uuid?: StringFieldUpdateOperationsInput | string
    metadata?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type submissionUpdateWithoutSubmissionInput = {
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUpdateManyWithoutSubmissionNestedInput
    user?: userUpdateOneWithoutSubmissionNestedInput
    contest?: contestUpdateOneWithoutSubmissionNestedInput
    team?: teamUpdateOneWithoutSubmissionNestedInput
    problem?: problemUpdateOneWithoutSubmissionNestedInput
    language?: languageUpdateOneWithoutSubmissionNestedInput
    other_submission?: submissionUpdateManyWithoutSubmissionNestedInput
    rejudging?: rejudgingUpdateOneWithoutSubmissionNestedInput
    contestproblem?: contestproblemUpdateOneWithoutSubmissionNestedInput
    submission_file?: submission_fileUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateWithoutSubmissionInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUncheckedUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUncheckedUpdateManyWithoutSubmissionNestedInput
    other_submission?: submissionUncheckedUpdateManyWithoutSubmissionNestedInput
    submission_file?: submission_fileUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateManyWithoutSubmissionInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type submission_fileUpdateWithoutSubmissionInput = {
    sourcecode?: BytesFieldUpdateOperationsInput | Buffer
    filename?: StringFieldUpdateOperationsInput | string
    ranknumber?: IntFieldUpdateOperationsInput | number
  }

  export type submission_fileUncheckedUpdateWithoutSubmissionInput = {
    submitfileid?: IntFieldUpdateOperationsInput | number
    sourcecode?: BytesFieldUpdateOperationsInput | Buffer
    filename?: StringFieldUpdateOperationsInput | string
    ranknumber?: IntFieldUpdateOperationsInput | number
  }

  export type submission_fileUncheckedUpdateManyWithoutSubmissionInput = {
    submitfileid?: IntFieldUpdateOperationsInput | number
    sourcecode?: BytesFieldUpdateOperationsInput | Buffer
    filename?: StringFieldUpdateOperationsInput | string
    ranknumber?: IntFieldUpdateOperationsInput | number
  }

  export type clarificationCreateManyTeam_clarification_senderToteamInput = {
    clarid?: number
    externalid?: string | null
    cid?: number | null
    respid?: number | null
    submittime: Decimal | DecimalJsLike | number | string
    recipient?: number | null
    jury_member?: string | null
    probid?: number | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
  }

  export type clarificationCreateManyTeam_clarification_recipientToteamInput = {
    clarid?: number
    externalid?: string | null
    cid?: number | null
    respid?: number | null
    submittime: Decimal | DecimalJsLike | number | string
    sender?: number | null
    jury_member?: string | null
    probid?: number | null
    category?: string | null
    queue?: string | null
    body: string
    answered?: boolean
  }

  export type contestteamCreateManyTeamInput = {
    cid: number
  }

  export type queuetaskCreateManyTeamInput = {
    queuetaskid?: number
    jobid?: number | null
    priority: number
    teampriority: number
    starttime?: Decimal | DecimalJsLike | number | string | null
  }

  export type rankcacheCreateManyTeamInput = {
    cid: number
    points_restricted?: number
    totaltime_restricted?: number
    points_public?: number
    totaltime_public?: number
  }

  export type scorecacheCreateManyTeamInput = {
    cid: number
    probid: number
    submissions_restricted?: number
    pending_restricted?: number
    solvetime_restricted?: Decimal | DecimalJsLike | number | string
    is_correct_restricted?: boolean
    submissions_public?: number
    pending_public?: number
    solvetime_public?: Decimal | DecimalJsLike | number | string
    is_correct_public?: boolean
    is_first_to_solve?: boolean
  }

  export type submissionCreateManyTeamInput = {
    submitid?: number
    origsubmitid?: number | null
    cid?: number | null
    userid?: number | null
    probid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
  }

  export type team_unreadCreateManyTeamInput = {
    mesgid: number
  }

  export type userCreateManyTeamInput = {
    userid?: number
    externalid?: string | null
    username: string
    name: string
    email?: string | null
    last_login?: Decimal | DecimalJsLike | number | string | null
    last_api_login?: Decimal | DecimalJsLike | number | string | null
    first_login?: Decimal | DecimalJsLike | number | string | null
    last_ip_address?: string | null
    password?: string | null
    ip_address?: string | null
    enabled?: boolean
  }

  export type clarificationUpdateWithoutTeam_clarification_senderToteamInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    contest?: contestUpdateOneWithoutClarificationNestedInput
    clarification?: clarificationUpdateOneWithoutOther_clarificationNestedInput
    other_clarification?: clarificationUpdateManyWithoutClarificationNestedInput
    problem?: problemUpdateOneWithoutClarificationNestedInput
    team_clarification_recipientToteam?: teamUpdateOneWithoutClarification_clarification_recipientToteamNestedInput
    team_unread?: team_unreadUpdateManyWithoutClarificationNestedInput
  }

  export type clarificationUncheckedUpdateWithoutTeam_clarification_senderToteamInput = {
    clarid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    respid?: NullableIntFieldUpdateOperationsInput | number | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recipient?: NullableIntFieldUpdateOperationsInput | number | null
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    other_clarification?: clarificationUncheckedUpdateManyWithoutClarificationNestedInput
    team_unread?: team_unreadUncheckedUpdateManyWithoutClarificationNestedInput
  }

  export type clarificationUncheckedUpdateManyWithoutTeam_clarification_senderToteamInput = {
    clarid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    respid?: NullableIntFieldUpdateOperationsInput | number | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recipient?: NullableIntFieldUpdateOperationsInput | number | null
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
  }

  export type clarificationUpdateWithoutTeam_clarification_recipientToteamInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    contest?: contestUpdateOneWithoutClarificationNestedInput
    clarification?: clarificationUpdateOneWithoutOther_clarificationNestedInput
    other_clarification?: clarificationUpdateManyWithoutClarificationNestedInput
    problem?: problemUpdateOneWithoutClarificationNestedInput
    team_clarification_senderToteam?: teamUpdateOneWithoutClarification_clarification_senderToteamNestedInput
    team_unread?: team_unreadUpdateManyWithoutClarificationNestedInput
  }

  export type clarificationUncheckedUpdateWithoutTeam_clarification_recipientToteamInput = {
    clarid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    respid?: NullableIntFieldUpdateOperationsInput | number | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sender?: NullableIntFieldUpdateOperationsInput | number | null
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
    other_clarification?: clarificationUncheckedUpdateManyWithoutClarificationNestedInput
    team_unread?: team_unreadUncheckedUpdateManyWithoutClarificationNestedInput
  }

  export type clarificationUncheckedUpdateManyWithoutTeam_clarification_recipientToteamInput = {
    clarid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    respid?: NullableIntFieldUpdateOperationsInput | number | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sender?: NullableIntFieldUpdateOperationsInput | number | null
    jury_member?: NullableStringFieldUpdateOperationsInput | string | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    answered?: BoolFieldUpdateOperationsInput | boolean
  }

  export type contestteamUpdateWithoutTeamInput = {
    contest?: contestUpdateOneRequiredWithoutContestteamNestedInput
  }

  export type contestteamUncheckedUpdateWithoutTeamInput = {
    cid?: IntFieldUpdateOperationsInput | number
  }

  export type contestteamUncheckedUpdateManyWithoutTeamInput = {
    cid?: IntFieldUpdateOperationsInput | number
  }

  export type queuetaskUpdateWithoutTeamInput = {
    jobid?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    teampriority?: IntFieldUpdateOperationsInput | number
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type queuetaskUncheckedUpdateWithoutTeamInput = {
    queuetaskid?: IntFieldUpdateOperationsInput | number
    jobid?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    teampriority?: IntFieldUpdateOperationsInput | number
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type queuetaskUncheckedUpdateManyWithoutTeamInput = {
    queuetaskid?: IntFieldUpdateOperationsInput | number
    jobid?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    teampriority?: IntFieldUpdateOperationsInput | number
    starttime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type rankcacheUpdateWithoutTeamInput = {
    points_restricted?: IntFieldUpdateOperationsInput | number
    totaltime_restricted?: IntFieldUpdateOperationsInput | number
    points_public?: IntFieldUpdateOperationsInput | number
    totaltime_public?: IntFieldUpdateOperationsInput | number
    contest?: contestUpdateOneRequiredWithoutRankcacheNestedInput
  }

  export type rankcacheUncheckedUpdateWithoutTeamInput = {
    cid?: IntFieldUpdateOperationsInput | number
    points_restricted?: IntFieldUpdateOperationsInput | number
    totaltime_restricted?: IntFieldUpdateOperationsInput | number
    points_public?: IntFieldUpdateOperationsInput | number
    totaltime_public?: IntFieldUpdateOperationsInput | number
  }

  export type rankcacheUncheckedUpdateManyWithoutTeamInput = {
    cid?: IntFieldUpdateOperationsInput | number
    points_restricted?: IntFieldUpdateOperationsInput | number
    totaltime_restricted?: IntFieldUpdateOperationsInput | number
    points_public?: IntFieldUpdateOperationsInput | number
    totaltime_public?: IntFieldUpdateOperationsInput | number
  }

  export type scorecacheUpdateWithoutTeamInput = {
    submissions_restricted?: IntFieldUpdateOperationsInput | number
    pending_restricted?: IntFieldUpdateOperationsInput | number
    solvetime_restricted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_restricted?: BoolFieldUpdateOperationsInput | boolean
    submissions_public?: IntFieldUpdateOperationsInput | number
    pending_public?: IntFieldUpdateOperationsInput | number
    solvetime_public?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_public?: BoolFieldUpdateOperationsInput | boolean
    is_first_to_solve?: BoolFieldUpdateOperationsInput | boolean
    contest?: contestUpdateOneRequiredWithoutScorecacheNestedInput
    problem?: problemUpdateOneRequiredWithoutScorecacheNestedInput
  }

  export type scorecacheUncheckedUpdateWithoutTeamInput = {
    cid?: IntFieldUpdateOperationsInput | number
    probid?: IntFieldUpdateOperationsInput | number
    submissions_restricted?: IntFieldUpdateOperationsInput | number
    pending_restricted?: IntFieldUpdateOperationsInput | number
    solvetime_restricted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_restricted?: BoolFieldUpdateOperationsInput | boolean
    submissions_public?: IntFieldUpdateOperationsInput | number
    pending_public?: IntFieldUpdateOperationsInput | number
    solvetime_public?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_public?: BoolFieldUpdateOperationsInput | boolean
    is_first_to_solve?: BoolFieldUpdateOperationsInput | boolean
  }

  export type scorecacheUncheckedUpdateManyWithoutTeamInput = {
    cid?: IntFieldUpdateOperationsInput | number
    probid?: IntFieldUpdateOperationsInput | number
    submissions_restricted?: IntFieldUpdateOperationsInput | number
    pending_restricted?: IntFieldUpdateOperationsInput | number
    solvetime_restricted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_restricted?: BoolFieldUpdateOperationsInput | boolean
    submissions_public?: IntFieldUpdateOperationsInput | number
    pending_public?: IntFieldUpdateOperationsInput | number
    solvetime_public?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_correct_public?: BoolFieldUpdateOperationsInput | boolean
    is_first_to_solve?: BoolFieldUpdateOperationsInput | boolean
  }

  export type submissionUpdateWithoutTeamInput = {
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUpdateManyWithoutSubmissionNestedInput
    user?: userUpdateOneWithoutSubmissionNestedInput
    contest?: contestUpdateOneWithoutSubmissionNestedInput
    problem?: problemUpdateOneWithoutSubmissionNestedInput
    language?: languageUpdateOneWithoutSubmissionNestedInput
    submission?: submissionUpdateOneWithoutOther_submissionNestedInput
    other_submission?: submissionUpdateManyWithoutSubmissionNestedInput
    rejudging?: rejudgingUpdateOneWithoutSubmissionNestedInput
    contestproblem?: contestproblemUpdateOneWithoutSubmissionNestedInput
    submission_file?: submission_fileUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateWithoutTeamInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUncheckedUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUncheckedUpdateManyWithoutSubmissionNestedInput
    other_submission?: submissionUncheckedUpdateManyWithoutSubmissionNestedInput
    submission_file?: submission_fileUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateManyWithoutTeamInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type team_unreadUpdateWithoutTeamInput = {
    clarification?: clarificationUpdateOneRequiredWithoutTeam_unreadNestedInput
  }

  export type team_unreadUncheckedUpdateWithoutTeamInput = {
    mesgid?: IntFieldUpdateOperationsInput | number
  }

  export type team_unreadUncheckedUpdateManyWithoutTeamInput = {
    mesgid?: IntFieldUpdateOperationsInput | number
  }

  export type userUpdateWithoutTeamInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_api_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    immutable_executable?: immutable_executableUpdateManyWithoutUserNestedInput
    rejudging_rejudging_userid_startTouser?: rejudgingUpdateManyWithoutUser_rejudging_userid_startTouserNestedInput
    rejudging_rejudging_userid_finishTouser?: rejudgingUpdateManyWithoutUser_rejudging_userid_finishTouserNestedInput
    submission?: submissionUpdateManyWithoutUserNestedInput
    userrole?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutTeamInput = {
    userid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_api_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    immutable_executable?: immutable_executableUncheckedUpdateManyWithoutUserNestedInput
    rejudging_rejudging_userid_startTouser?: rejudgingUncheckedUpdateManyWithoutUser_rejudging_userid_startTouserNestedInput
    rejudging_rejudging_userid_finishTouser?: rejudgingUncheckedUpdateManyWithoutUser_rejudging_userid_finishTouserNestedInput
    submission?: submissionUncheckedUpdateManyWithoutUserNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutTeamInput = {
    userid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_api_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_login?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type teamCreateManyTeam_affiliationInput = {
    teamid?: number
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    categoryid?: number | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
  }

  export type teamUpdateWithoutTeam_affiliationInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    clarification_clarification_recipientToteam?: clarificationUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    contestteam?: contestteamUpdateManyWithoutTeamNestedInput
    queuetask?: queuetaskUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUpdateManyWithoutTeamNestedInput
    submission?: submissionUpdateManyWithoutTeamNestedInput
    team_category?: team_categoryUpdateOneWithoutTeamNestedInput
    team_unread?: team_unreadUpdateManyWithoutTeamNestedInput
    user?: userUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutTeam_affiliationInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    categoryid?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    clarification_clarification_recipientToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutTeamNestedInput
    queuetask?: queuetaskUncheckedUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutTeamNestedInput
    submission?: submissionUncheckedUpdateManyWithoutTeamNestedInput
    team_unread?: team_unreadUncheckedUpdateManyWithoutTeamNestedInput
    user?: userUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateManyWithoutTeam_affiliationInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    categoryid?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
  }

  export type contestteamcategoryCreateManyTeam_categoryInput = {
    cid: number
  }

  export type contestteamcategoryformedalsCreateManyTeam_categoryInput = {
    cid: number
  }

  export type teamCreateManyTeam_categoryInput = {
    teamid?: number
    externalid?: string | null
    icpcid?: string | null
    name: string
    display_name?: string | null
    affilid?: number | null
    enabled?: boolean
    publicdescription?: string | null
    room?: string | null
    internalcomments?: string | null
    judging_last_started?: Decimal | DecimalJsLike | number | string | null
    penalty?: number
  }

  export type contestteamcategoryUpdateWithoutTeam_categoryInput = {
    contest?: contestUpdateOneRequiredWithoutContestteamcategoryNestedInput
  }

  export type contestteamcategoryUncheckedUpdateWithoutTeam_categoryInput = {
    cid?: IntFieldUpdateOperationsInput | number
  }

  export type contestteamcategoryUncheckedUpdateManyWithoutTeam_categoryInput = {
    cid?: IntFieldUpdateOperationsInput | number
  }

  export type contestteamcategoryformedalsUpdateWithoutTeam_categoryInput = {
    contest?: contestUpdateOneRequiredWithoutContestteamcategoryformedalsNestedInput
  }

  export type contestteamcategoryformedalsUncheckedUpdateWithoutTeam_categoryInput = {
    cid?: IntFieldUpdateOperationsInput | number
  }

  export type contestteamcategoryformedalsUncheckedUpdateManyWithoutTeam_categoryInput = {
    cid?: IntFieldUpdateOperationsInput | number
  }

  export type teamUpdateWithoutTeam_categoryInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    clarification_clarification_recipientToteam?: clarificationUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    contestteam?: contestteamUpdateManyWithoutTeamNestedInput
    queuetask?: queuetaskUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUpdateManyWithoutTeamNestedInput
    submission?: submissionUpdateManyWithoutTeamNestedInput
    team_affiliation?: team_affiliationUpdateOneWithoutTeamNestedInput
    team_unread?: team_unreadUpdateManyWithoutTeamNestedInput
    user?: userUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutTeam_categoryInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    affilid?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
    clarification_clarification_senderToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_senderToteamNestedInput
    clarification_clarification_recipientToteam?: clarificationUncheckedUpdateManyWithoutTeam_clarification_recipientToteamNestedInput
    contestteam?: contestteamUncheckedUpdateManyWithoutTeamNestedInput
    queuetask?: queuetaskUncheckedUpdateManyWithoutTeamNestedInput
    rankcache?: rankcacheUncheckedUpdateManyWithoutTeamNestedInput
    scorecache?: scorecacheUncheckedUpdateManyWithoutTeamNestedInput
    submission?: submissionUncheckedUpdateManyWithoutTeamNestedInput
    team_unread?: team_unreadUncheckedUpdateManyWithoutTeamNestedInput
    user?: userUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateManyWithoutTeam_categoryInput = {
    teamid?: IntFieldUpdateOperationsInput | number
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    icpcid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    affilid?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    publicdescription?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    internalcomments?: NullableStringFieldUpdateOperationsInput | string | null
    judging_last_started?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    penalty?: IntFieldUpdateOperationsInput | number
  }

  export type external_runCreateManyTestcaseInput = {
    extrunid?: number
    extjudgementid?: number | null
    externalid?: string | null
    cid?: number | null
    result: string
    endtime: Decimal | DecimalJsLike | number | string
    runtime: number
  }

  export type judging_runCreateManyTestcaseInput = {
    runid?: number
    judgingid?: number | null
    runresult?: string | null
    runtime?: number | null
    endtime?: Decimal | DecimalJsLike | number | string | null
    judgetaskid?: number | null
  }

  export type testcase_contentCreateManyTestcaseInput = {
    input?: Buffer | null
    output?: Buffer | null
    image?: Buffer | null
    image_thumb?: Buffer | null
    tc_contentid?: number
  }

  export type external_runUpdateWithoutTestcaseInput = {
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    result?: StringFieldUpdateOperationsInput | string
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runtime?: FloatFieldUpdateOperationsInput | number
    external_judgement?: external_judgementUpdateOneWithoutExternal_runNestedInput
    contest?: contestUpdateOneWithoutExternal_runNestedInput
  }

  export type external_runUncheckedUpdateWithoutTestcaseInput = {
    extrunid?: IntFieldUpdateOperationsInput | number
    extjudgementid?: NullableIntFieldUpdateOperationsInput | number | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    result?: StringFieldUpdateOperationsInput | string
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runtime?: FloatFieldUpdateOperationsInput | number
  }

  export type external_runUncheckedUpdateManyWithoutTestcaseInput = {
    extrunid?: IntFieldUpdateOperationsInput | number
    extjudgementid?: NullableIntFieldUpdateOperationsInput | number | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    result?: StringFieldUpdateOperationsInput | string
    endtime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runtime?: FloatFieldUpdateOperationsInput | number
  }

  export type judging_runUpdateWithoutTestcaseInput = {
    runresult?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableFloatFieldUpdateOperationsInput | number | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    judgetask?: judgetaskUpdateOneWithoutJudging_runNestedInput
    judging?: judgingUpdateOneWithoutJudging_runNestedInput
    judging_run_output?: judging_run_outputUpdateOneWithoutJudging_runNestedInput
  }

  export type judging_runUncheckedUpdateWithoutTestcaseInput = {
    runid?: IntFieldUpdateOperationsInput | number
    judgingid?: NullableIntFieldUpdateOperationsInput | number | null
    runresult?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableFloatFieldUpdateOperationsInput | number | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    judgetaskid?: NullableIntFieldUpdateOperationsInput | number | null
    judging_run_output?: judging_run_outputUncheckedUpdateOneWithoutJudging_runNestedInput
  }

  export type judging_runUncheckedUpdateManyWithoutTestcaseInput = {
    runid?: IntFieldUpdateOperationsInput | number
    judgingid?: NullableIntFieldUpdateOperationsInput | number | null
    runresult?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableFloatFieldUpdateOperationsInput | number | null
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    judgetaskid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type testcase_contentUpdateWithoutTestcaseInput = {
    input?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image_thumb?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type testcase_contentUncheckedUpdateWithoutTestcaseInput = {
    input?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image_thumb?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    tc_contentid?: IntFieldUpdateOperationsInput | number
  }

  export type testcase_contentUncheckedUpdateManyWithoutTestcaseInput = {
    input?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    output?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    image_thumb?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    tc_contentid?: IntFieldUpdateOperationsInput | number
  }

  export type immutable_executableCreateManyUserInput = {
    immutable_execid?: number
    hash?: string | null
  }

  export type rejudgingCreateManyUser_rejudging_userid_startTouserInput = {
    rejudgingid?: number
    userid_finish?: number | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    reason: string
    valid?: boolean
    auto_apply?: boolean
    repeat?: number | null
    repeat_rejudgingid?: number | null
  }

  export type rejudgingCreateManyUser_rejudging_userid_finishTouserInput = {
    rejudgingid?: number
    userid_start?: number | null
    starttime: Decimal | DecimalJsLike | number | string
    endtime?: Decimal | DecimalJsLike | number | string | null
    reason: string
    valid?: boolean
    auto_apply?: boolean
    repeat?: number | null
    repeat_rejudgingid?: number | null
  }

  export type submissionCreateManyUserInput = {
    submitid?: number
    origsubmitid?: number | null
    cid?: number | null
    teamid?: number | null
    probid?: number | null
    langid?: string | null
    submittime: Decimal | DecimalJsLike | number | string
    valid?: boolean
    rejudgingid?: number | null
    expected_results?: string | null
    externalid?: string | null
    entry_point?: string | null
  }

  export type userroleCreateManyUserInput = {
    roleid: number
  }

  export type immutable_executableUpdateWithoutUserInput = {
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    executable?: executableUpdateOneWithoutImmutable_executableNestedInput
    executable_file?: executable_fileUpdateManyWithoutImmutable_executableNestedInput
  }

  export type immutable_executableUncheckedUpdateWithoutUserInput = {
    immutable_execid?: IntFieldUpdateOperationsInput | number
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    executable?: executableUncheckedUpdateOneWithoutImmutable_executableNestedInput
    executable_file?: executable_fileUncheckedUpdateManyWithoutImmutable_executableNestedInput
  }

  export type immutable_executableUncheckedUpdateManyWithoutUserInput = {
    immutable_execid?: IntFieldUpdateOperationsInput | number
    hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rejudgingUpdateWithoutUser_rejudging_userid_startTouserInput = {
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    auto_apply?: BoolFieldUpdateOperationsInput | boolean
    repeat?: NullableIntFieldUpdateOperationsInput | number | null
    judging?: judgingUpdateManyWithoutRejudgingNestedInput
    rejudging?: rejudgingUpdateOneWithoutOther_rejudgingNestedInput
    other_rejudging?: rejudgingUpdateManyWithoutRejudgingNestedInput
    user_rejudging_userid_finishTouser?: userUpdateOneWithoutRejudging_rejudging_userid_finishTouserNestedInput
    submission?: submissionUpdateManyWithoutRejudgingNestedInput
  }

  export type rejudgingUncheckedUpdateWithoutUser_rejudging_userid_startTouserInput = {
    rejudgingid?: IntFieldUpdateOperationsInput | number
    userid_finish?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    auto_apply?: BoolFieldUpdateOperationsInput | boolean
    repeat?: NullableIntFieldUpdateOperationsInput | number | null
    repeat_rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judging?: judgingUncheckedUpdateManyWithoutRejudgingNestedInput
    other_rejudging?: rejudgingUncheckedUpdateManyWithoutRejudgingNestedInput
    submission?: submissionUncheckedUpdateManyWithoutRejudgingNestedInput
  }

  export type rejudgingUncheckedUpdateManyWithoutUser_rejudging_userid_startTouserInput = {
    rejudgingid?: IntFieldUpdateOperationsInput | number
    userid_finish?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    auto_apply?: BoolFieldUpdateOperationsInput | boolean
    repeat?: NullableIntFieldUpdateOperationsInput | number | null
    repeat_rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rejudgingUpdateWithoutUser_rejudging_userid_finishTouserInput = {
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    auto_apply?: BoolFieldUpdateOperationsInput | boolean
    repeat?: NullableIntFieldUpdateOperationsInput | number | null
    judging?: judgingUpdateManyWithoutRejudgingNestedInput
    rejudging?: rejudgingUpdateOneWithoutOther_rejudgingNestedInput
    other_rejudging?: rejudgingUpdateManyWithoutRejudgingNestedInput
    user_rejudging_userid_startTouser?: userUpdateOneWithoutRejudging_rejudging_userid_startTouserNestedInput
    submission?: submissionUpdateManyWithoutRejudgingNestedInput
  }

  export type rejudgingUncheckedUpdateWithoutUser_rejudging_userid_finishTouserInput = {
    rejudgingid?: IntFieldUpdateOperationsInput | number
    userid_start?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    auto_apply?: BoolFieldUpdateOperationsInput | boolean
    repeat?: NullableIntFieldUpdateOperationsInput | number | null
    repeat_rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    judging?: judgingUncheckedUpdateManyWithoutRejudgingNestedInput
    other_rejudging?: rejudgingUncheckedUpdateManyWithoutRejudgingNestedInput
    submission?: submissionUncheckedUpdateManyWithoutRejudgingNestedInput
  }

  export type rejudgingUncheckedUpdateManyWithoutUser_rejudging_userid_finishTouserInput = {
    rejudgingid?: IntFieldUpdateOperationsInput | number
    userid_start?: NullableIntFieldUpdateOperationsInput | number | null
    starttime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    endtime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    auto_apply?: BoolFieldUpdateOperationsInput | boolean
    repeat?: NullableIntFieldUpdateOperationsInput | number | null
    repeat_rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type submissionUpdateWithoutUserInput = {
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUpdateManyWithoutSubmissionNestedInput
    contest?: contestUpdateOneWithoutSubmissionNestedInput
    team?: teamUpdateOneWithoutSubmissionNestedInput
    problem?: problemUpdateOneWithoutSubmissionNestedInput
    language?: languageUpdateOneWithoutSubmissionNestedInput
    submission?: submissionUpdateOneWithoutOther_submissionNestedInput
    other_submission?: submissionUpdateManyWithoutSubmissionNestedInput
    rejudging?: rejudgingUpdateOneWithoutSubmissionNestedInput
    contestproblem?: contestproblemUpdateOneWithoutSubmissionNestedInput
    submission_file?: submission_fileUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateWithoutUserInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
    balloon?: balloonUncheckedUpdateManyWithoutSubmissionNestedInput
    external_judgement?: external_judgementUncheckedUpdateManyWithoutSubmissionNestedInput
    judging?: judgingUncheckedUpdateManyWithoutSubmissionNestedInput
    other_submission?: submissionUncheckedUpdateManyWithoutSubmissionNestedInput
    submission_file?: submission_fileUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type submissionUncheckedUpdateManyWithoutUserInput = {
    submitid?: IntFieldUpdateOperationsInput | number
    origsubmitid?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: NullableIntFieldUpdateOperationsInput | number | null
    teamid?: NullableIntFieldUpdateOperationsInput | number | null
    probid?: NullableIntFieldUpdateOperationsInput | number | null
    langid?: NullableStringFieldUpdateOperationsInput | string | null
    submittime?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    rejudgingid?: NullableIntFieldUpdateOperationsInput | number | null
    expected_results?: NullableStringFieldUpdateOperationsInput | string | null
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    entry_point?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userroleUpdateWithoutUserInput = {
    role?: roleUpdateOneRequiredWithoutUserroleNestedInput
  }

  export type userroleUncheckedUpdateWithoutUserInput = {
    roleid?: IntFieldUpdateOperationsInput | number
  }

  export type userroleUncheckedUpdateManyWithoutUserInput = {
    roleid?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ClarificationCountOutputTypeDefaultArgs instead
     */
    export type ClarificationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClarificationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContestCountOutputTypeDefaultArgs instead
     */
    export type ContestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContestproblemCountOutputTypeDefaultArgs instead
     */
    export type ContestproblemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContestproblemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExecutableCountOutputTypeDefaultArgs instead
     */
    export type ExecutableCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExecutableCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use External_contest_sourceCountOutputTypeDefaultArgs instead
     */
    export type External_contest_sourceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = External_contest_sourceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use External_judgementCountOutputTypeDefaultArgs instead
     */
    export type External_judgementCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = External_judgementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Immutable_executableCountOutputTypeDefaultArgs instead
     */
    export type Immutable_executableCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Immutable_executableCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Internal_errorCountOutputTypeDefaultArgs instead
     */
    export type Internal_errorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Internal_errorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JudgehostCountOutputTypeDefaultArgs instead
     */
    export type JudgehostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JudgehostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JudgetaskCountOutputTypeDefaultArgs instead
     */
    export type JudgetaskCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JudgetaskCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JudgingCountOutputTypeDefaultArgs instead
     */
    export type JudgingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JudgingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LanguageCountOutputTypeDefaultArgs instead
     */
    export type LanguageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LanguageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProblemCountOutputTypeDefaultArgs instead
     */
    export type ProblemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProblemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RejudgingCountOutputTypeDefaultArgs instead
     */
    export type RejudgingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RejudgingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubmissionCountOutputTypeDefaultArgs instead
     */
    export type SubmissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubmissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamCountOutputTypeDefaultArgs instead
     */
    export type TeamCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Team_affiliationCountOutputTypeDefaultArgs instead
     */
    export type Team_affiliationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Team_affiliationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Team_categoryCountOutputTypeDefaultArgs instead
     */
    export type Team_categoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Team_categoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestcaseCountOutputTypeDefaultArgs instead
     */
    export type TestcaseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestcaseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use auditlogDefaultArgs instead
     */
    export type auditlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = auditlogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use balloonDefaultArgs instead
     */
    export type balloonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = balloonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use clarificationDefaultArgs instead
     */
    export type clarificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = clarificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use configurationDefaultArgs instead
     */
    export type configurationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = configurationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use contestDefaultArgs instead
     */
    export type contestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = contestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use contestproblemDefaultArgs instead
     */
    export type contestproblemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = contestproblemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use contestteamDefaultArgs instead
     */
    export type contestteamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = contestteamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use contestteamcategoryDefaultArgs instead
     */
    export type contestteamcategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = contestteamcategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use contestteamcategoryformedalsDefaultArgs instead
     */
    export type contestteamcategoryformedalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = contestteamcategoryformedalsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use debug_packageDefaultArgs instead
     */
    export type debug_packageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = debug_packageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use doctrine_migration_versionsDefaultArgs instead
     */
    export type doctrine_migration_versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = doctrine_migration_versionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use eventDefaultArgs instead
     */
    export type eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = eventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use executableDefaultArgs instead
     */
    export type executableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = executableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use executable_fileDefaultArgs instead
     */
    export type executable_fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = executable_fileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use external_contest_sourceDefaultArgs instead
     */
    export type external_contest_sourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = external_contest_sourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use external_judgementDefaultArgs instead
     */
    export type external_judgementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = external_judgementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use external_runDefaultArgs instead
     */
    export type external_runArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = external_runDefaultArgs<ExtArgs>
    /**
     * @deprecated Use external_source_warningDefaultArgs instead
     */
    export type external_source_warningArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = external_source_warningDefaultArgs<ExtArgs>
    /**
     * @deprecated Use immutable_executableDefaultArgs instead
     */
    export type immutable_executableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = immutable_executableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use internal_errorDefaultArgs instead
     */
    export type internal_errorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = internal_errorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use judgehostDefaultArgs instead
     */
    export type judgehostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = judgehostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use judgetaskDefaultArgs instead
     */
    export type judgetaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = judgetaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use judgingDefaultArgs instead
     */
    export type judgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = judgingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use judging_runDefaultArgs instead
     */
    export type judging_runArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = judging_runDefaultArgs<ExtArgs>
    /**
     * @deprecated Use judging_run_outputDefaultArgs instead
     */
    export type judging_run_outputArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = judging_run_outputDefaultArgs<ExtArgs>
    /**
     * @deprecated Use languageDefaultArgs instead
     */
    export type languageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = languageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use problemDefaultArgs instead
     */
    export type problemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = problemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use problem_attachmentDefaultArgs instead
     */
    export type problem_attachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = problem_attachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use problem_attachment_contentDefaultArgs instead
     */
    export type problem_attachment_contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = problem_attachment_contentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use queuetaskDefaultArgs instead
     */
    export type queuetaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = queuetaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rankcacheDefaultArgs instead
     */
    export type rankcacheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rankcacheDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rejudgingDefaultArgs instead
     */
    export type rejudgingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rejudgingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use removed_intervalDefaultArgs instead
     */
    export type removed_intervalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = removed_intervalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use roleDefaultArgs instead
     */
    export type roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = roleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use scorecacheDefaultArgs instead
     */
    export type scorecacheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = scorecacheDefaultArgs<ExtArgs>
    /**
     * @deprecated Use sessionsDefaultArgs instead
     */
    export type sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = sessionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use submissionDefaultArgs instead
     */
    export type submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = submissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use submission_fileDefaultArgs instead
     */
    export type submission_fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = submission_fileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use teamDefaultArgs instead
     */
    export type teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = teamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use team_affiliationDefaultArgs instead
     */
    export type team_affiliationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = team_affiliationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use team_categoryDefaultArgs instead
     */
    export type team_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = team_categoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use team_unreadDefaultArgs instead
     */
    export type team_unreadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = team_unreadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use testcaseDefaultArgs instead
     */
    export type testcaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = testcaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use testcase_contentDefaultArgs instead
     */
    export type testcase_contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = testcase_contentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userDefaultArgs instead
     */
    export type userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = userDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userroleDefaultArgs instead
     */
    export type userroleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = userroleDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}